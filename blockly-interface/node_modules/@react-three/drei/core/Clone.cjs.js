"use strict";var e=require("@babel/runtime/helpers/extends"),r=require("three"),t=require("react"),i=require("three-stdlib");function n(e){var r=Object.create(null);return e&&Object.keys(e).forEach((function(t){if("default"!==t){var i=Object.getOwnPropertyDescriptor(e,t);Object.defineProperty(r,t,i.get?i:{enumerable:!0,get:function(){return e[t]}})}})),r.default=e,Object.freeze(r)}var a=n(r),o=n(t);const c=o.forwardRef((({isChild:r=!1,object:t,children:n,deep:s,castShadow:l,receiveShadow:d,inject:u,keys:m,...y},h)=>{const f={keys:m,deep:s,inject:u,castShadow:l,receiveShadow:d};if(t=o.useMemo((()=>{if(!1===r&&!Array.isArray(t)){let e=!1;if(t.traverse((r=>{r.isSkinnedMesh&&(e=!0)})),e)return i.SkeletonUtils.clone(t)}return t}),[t,r]),Array.isArray(t))return o.createElement("group",e({},y,{ref:h}),t.map((r=>o.createElement(c,e({key:r.uuid,object:r},f)))),n);const{children:p,...b}=function(e,{keys:r=["near","far","color","distance","decay","penumbra","angle","intensity","skeleton","visible","castShadow","receiveShadow","morphTargetDictionary","morphTargetInfluences","name","geometry","material","position","rotation","scale","up","userData","bindMode","bindMatrix","bindMatrixInverse","skeleton"],deep:t,inject:i,castShadow:n,receiveShadow:c}){let s={};for(const t of r)s[t]=e[t];return t&&(s.geometry&&"materialsOnly"!==t&&(s.geometry=s.geometry.clone()),s.material&&"geometriesOnly"!==t&&(s.material=s.material.clone())),i&&(s="function"==typeof i?{...s,children:i(e)}:o.isValidElement(i)?{...s,children:i}:{...s,...i}),e instanceof a.Mesh&&(n&&(s.castShadow=!0),c&&(s.receiveShadow=!0)),s}(t,f),v=t.type[0].toLowerCase()+t.type.slice(1);return o.createElement(v,e({},b,y,{ref:h}),t.children.map((r=>"Bone"===r.type?o.createElement("primitive",e({key:r.uuid,object:r},f)):o.createElement(c,e({key:r.uuid,object:r},f,{isChild:!0})))),n,p)}));exports.Clone=c;
