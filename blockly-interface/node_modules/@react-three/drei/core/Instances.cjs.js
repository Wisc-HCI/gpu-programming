"use strict";var e=require("@babel/runtime/helpers/extends"),t=require("three"),r=require("react"),n=require("@react-three/fiber"),a=require("react-merge-refs"),c=require("react-composer"),s=require("../helpers/deprecated.cjs.js");function i(e){var t=Object.create(null);return e&&Object.keys(e).forEach((function(r){if("default"!==r){var n=Object.getOwnPropertyDescriptor(e,r);Object.defineProperty(t,r,n.get?n:{enumerable:!0,get:function(){return e[r]}})}})),t.default=e,Object.freeze(t)}var o=i(t),u=i(r);const l=new o.Matrix4,f=new o.Matrix4,d=[],m=new o.Mesh;class y extends o.Group{constructor(){super(),this.color=new o.Color("white"),this.instance={current:void 0},this.instanceKey={current:void 0}}get geometry(){var e;return null==(e=this.instance.current)?void 0:e.geometry}raycast(e,t){const r=this.instance.current;if(!r)return;if(!r.geometry||!r.material)return;m.geometry=r.geometry;const n=r.matrixWorld,a=r.userData.instances.indexOf(this.instanceKey);if(!(-1===a||a>r.count)){r.getMatrixAt(a,l),f.multiplyMatrices(n,l),m.matrixWorld=f,r.material instanceof o.Material?m.material.side=r.material.side:m.material.side=r.material[0].side,m.raycast(e,d);for(let e=0,r=d.length;e<r;e++){const r=d[e];r.instanceId=a,r.object=this,t.push(r)}d.length=0}}}const h=u.createContext(null),p=new o.Matrix4,g=new o.Matrix4,x=new o.Matrix4,M=new o.Vector3,w=new o.Quaternion,b=new o.Vector3,v=u.forwardRef((({context:t,children:r,...c},s)=>{u.useMemo((()=>n.extend({PositionMesh:y})),[]);const i=u.useRef(),{subscribe:o,getParent:l}=u.useContext(t||h);return u.useLayoutEffect((()=>o(i)),[]),u.createElement("positionMesh",e({instance:l(),instanceKey:i,ref:a([s,i])},c),r)})),E=u.forwardRef((({children:t,range:r,limit:c=1e3,frames:i=1/0,...l},f)=>{const[{context:d,instance:m}]=u.useState((()=>{const t=u.createContext(null);return{context:t,instance:u.forwardRef(((r,n)=>u.createElement(v,e({context:t},r,{ref:n}))))}})),y=u.useRef(null),[E,A]=u.useState([]),[[j,O]]=u.useState((()=>{const e=new Float32Array(16*c);for(let t=0;t<c;t++)x.identity().toArray(e,16*t);return[e,new Float32Array([...new Array(3*c)].map((()=>1)))]}));u.useEffect((()=>{y.current.instanceMatrix.needsUpdate=!0}));let R=0,U=0;n.useFrame((()=>{if(i===1/0||R<i){y.current.updateMatrix(),y.current.updateMatrixWorld(),p.copy(y.current.matrixWorld).invert(),U=Math.min(c,void 0!==r?r:c,E.length),y.current.count=U,s.setUpdateRange(y.current.instanceMatrix,{offset:0,count:16*U}),s.setUpdateRange(y.current.instanceColor,{offset:0,count:3*U});for(let e=0;e<E.length;e++){const t=E[e].current;t.matrixWorld.decompose(M,w,b),g.compose(M,w,b).premultiply(p),g.toArray(j,16*e),y.current.instanceMatrix.needsUpdate=!0,t.color.toArray(O,3*e),y.current.instanceColor.needsUpdate=!0}R++}}));const q=u.useMemo((()=>({getParent:()=>y,subscribe:e=>(A((t=>[...t,e])),()=>A((t=>t.filter((t=>t.current!==e.current)))))})),[]);return u.createElement("instancedMesh",e({userData:{instances:E},matrixAutoUpdate:!1,ref:a([f,y]),args:[null,null,0],raycast:()=>null},l),u.createElement("instancedBufferAttribute",{attach:"instanceMatrix",count:j.length/16,array:j,itemSize:16,usage:o.DynamicDrawUsage}),u.createElement("instancedBufferAttribute",{attach:"instanceColor",count:O.length/3,array:O,itemSize:3,usage:o.DynamicDrawUsage}),"function"==typeof t?u.createElement(d.Provider,{value:q},t(m)):u.createElement(h.Provider,{value:q},t))})),A=u.forwardRef((function({meshes:t,children:r,...n},a){const s=Array.isArray(t);if(!s)for(const e of Object.keys(t))t[e].isMesh||delete t[e];return u.createElement("group",{ref:a},u.createElement(c,{components:(s?t:Object.values(t)).map((({geometry:t,material:r})=>u.createElement(E,e({key:t.uuid,geometry:t,material:r},n))))},(e=>s?r(...e):r(Object.keys(t).filter((e=>t[e].isMesh)).reduce(((t,r,n)=>({...t,[r]:e[n]})),{})))))}));exports.Instance=v,exports.Instances=E,exports.Merged=A;
