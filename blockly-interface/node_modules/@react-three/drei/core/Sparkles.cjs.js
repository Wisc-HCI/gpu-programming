"use strict";var e=require("@babel/runtime/helpers/extends"),t=require("react"),r=require("three"),o=require("@react-three/fiber"),i=require("./shaderMaterial.cjs.js"),n=require("../helpers/constants.cjs.js");function a(e){var t=Object.create(null);return e&&Object.keys(e).forEach((function(r){if("default"!==r){var o=Object.getOwnPropertyDescriptor(e,r);Object.defineProperty(t,r,o.get?o:{enumerable:!0,get:function(){return e[r]}})}})),t.default=e,Object.freeze(t)}var s=a(t),l=a(r);const c=i.shaderMaterial({time:0,pixelRatio:1}," uniform float pixelRatio;\n    uniform float time;\n    attribute float size;  \n    attribute float speed;  \n    attribute float opacity;\n    attribute vec3 noise;\n    attribute vec3 color;\n    varying vec3 vColor;\n    varying float vOpacity;\n    void main() {\n      vec4 modelPosition = modelMatrix * vec4(position, 1.0);\n      modelPosition.y += sin(time * speed + modelPosition.x * noise.x * 100.0) * 0.2;\n      modelPosition.z += cos(time * speed + modelPosition.x * noise.y * 100.0) * 0.2;\n      modelPosition.x += cos(time * speed + modelPosition.x * noise.z * 100.0) * 0.2;\n      vec4 viewPosition = viewMatrix * modelPosition;\n      vec4 projectionPostion = projectionMatrix * viewPosition;\n      gl_Position = projectionPostion;\n      gl_PointSize = size * 25. * pixelRatio;\n      gl_PointSize *= (1.0 / - viewPosition.z);\n      vColor = color;\n      vOpacity = opacity;\n    }",` varying vec3 vColor;\n    varying float vOpacity;\n    void main() {\n      float distanceToCenter = distance(gl_PointCoord, vec2(0.5));\n      float strength = 0.05 / distanceToCenter - 0.1;\n      gl_FragColor = vec4(vColor, strength * vOpacity);\n      #include <tonemapping_fragment>\n      #include <${n.version>=154?"colorspace_fragment":"encodings_fragment"}>\n    }`),u=e=>e&&e.constructor===Float32Array,f=e=>e instanceof l.Vector2||e instanceof l.Vector3||e instanceof l.Vector4,m=e=>Array.isArray(e)?e:f(e)?e.toArray():[e,e,e];function p(e,t,r){return s.useMemo((()=>{if(void 0!==t){if(u(t))return t;if(t instanceof l.Color){const r=Array.from({length:3*e},(()=>{return[(e=t).r,e.g,e.b];var e})).flat();return Float32Array.from(r)}if(f(t)||Array.isArray(t)){const r=Array.from({length:3*e},(()=>m(t))).flat();return Float32Array.from(r)}return Float32Array.from({length:e},(()=>t))}return Float32Array.from({length:e},r)}),[t])}const d=s.forwardRef((({noise:t=1,count:r=100,speed:i=1,opacity:n=1,scale:a=1,size:f,color:d,children:v,...b},y)=>{s.useMemo((()=>o.extend({SparklesImplMaterial:c})),[]);const g=s.useRef(null),h=o.useThree((e=>e.viewport.dpr)),A=m(a),P=s.useMemo((()=>Float32Array.from(Array.from({length:r},(()=>A.map(l.MathUtils.randFloatSpread))).flat())),[r,...A]),x=p(r,f,Math.random),j=p(r,n),M=p(r,i),O=p(3*r,t),z=p(void 0===d?3*r:r,u(d)?d:new l.Color(d),(()=>1));return o.useFrame((e=>{g.current&&g.current.material&&(g.current.material.time=e.clock.elapsedTime)})),s.useImperativeHandle(y,(()=>g.current),[]),s.createElement("points",e({key:`particle-${r}-${JSON.stringify(a)}`},b,{ref:g}),s.createElement("bufferGeometry",null,s.createElement("bufferAttribute",{attach:"attributes-position",args:[P,3]}),s.createElement("bufferAttribute",{attach:"attributes-size",args:[x,1]}),s.createElement("bufferAttribute",{attach:"attributes-opacity",args:[j,1]}),s.createElement("bufferAttribute",{attach:"attributes-speed",args:[M,1]}),s.createElement("bufferAttribute",{attach:"attributes-color",args:[z,3]}),s.createElement("bufferAttribute",{attach:"attributes-noise",args:[O,3]})),v||s.createElement("sparklesImplMaterial",{transparent:!0,pixelRatio:h,depthWrite:!1}))}));exports.Sparkles=d;
