import * as Ln from "react";
import ph, { useReducer as D5, useRef as Xs, useDebugValue as UN, useEffect as hh, useLayoutEffect as H3, useState as O_, useMemo as Qw, createContext as OC, useContext as TM, forwardRef as U0, useCallback as qh, useImperativeHandle as L5, memo as QM, Suspense as P5 } from "react";
/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const a1 = "143", T_ = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, C_ = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, zN = 0, VD = 1, NN = 2, O5 = 3, FN = 0, UC = 1, _M = 2, U_ = 3, vy = 0, cf = 1, Yh = 2, kN = 1, U5 = 2, ff = 0, P0 = 1, wC = 2, GD = 3, WD = 4, IN = 5, L_ = 100, BN = 101, V3 = 102, jD = 103, YD = 104, HN = 200, VN = 201, GN = 202, WN = 203, zC = 204, NC = 205, jN = 206, YN = 207, XN = 208, qN = 209, QN = 210, ZN = 0, JN = 1, KN = 2, bC = 3, $N = 4, eF = 5, tF = 6, nF = 7, ZM = 0, rF = 1, iF = 2, og = 0, aF = 1, sF = 2, oF = 3, G3 = 4, lF = 5, FC = 300, t1 = 301, n1 = 302, CM = 303, RM = 304, hb = 306, Zw = 1e3, jh = 1001, AM = 1002, fo = 1003, EC = 1004, z5 = 1004, MC = 1005, N5 = 1005, Oo = 1006, W3 = 1007, F5 = 1007, s1 = 1008, k5 = 1008, df = 1009, uF = 1010, cF = 1011, j3 = 1012, fF = 1013, L0 = 1014, fy = 1015, X_ = 1016, dF = 1017, hF = 1018, Kx = 1020, pF = 1021, mF = 1022, zp = 1023, vF = 1024, gF = 1025, $x = 1026, r1 = 1027, yF = 1028, xF = 1029, _F = 1030, SF = 1031, wF = 1033, uC = 33776, cC = 33777, fC = 33778, dC = 33779, XD = 35840, qD = 35841, QD = 35842, ZD = 35843, bF = 36196, JD = 37492, KD = 37496, $D = 37808, e3 = 37809, t3 = 37810, n3 = 37811, r3 = 37812, i3 = 37813, a3 = 37814, s3 = 37815, o3 = 37816, l3 = 37817, u3 = 37818, c3 = 37819, f3 = 37820, d3 = 37821, h3 = 36492, EF = 2200, MF = 2201, TF = 2202, DM = 2300, LM = 2301, hC = 2302, z_ = 2400, N_ = 2401, PM = 2402, kC = 2500, Y3 = 2501, I5 = 0, B5 = 1, H5 = 2, wv = 3e3, gi = 3001, o1 = 3200, Jw = 3201, K_ = 0, CF = 1, V5 = "", uy = "srgb", Jx = "srgb-linear", G5 = 0, pC = 7680, W5 = 7681, j5 = 7682, Y5 = 7683, X5 = 34055, q5 = 34056, Q5 = 5386, Z5 = 512, J5 = 513, K5 = 514, $5 = 515, eH = 516, tH = 517, nH = 518, RF = 519, OM = 35044, B_ = 35048, rH = 35040, iH = 35045, aH = 35049, sH = 35041, oH = 35046, lH = 35050, uH = 35042, cH = "100", p3 = "300 es", TC = 1035;
class Cm {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const r = this._listeners;
    r[e] === void 0 && (r[e] = []), r[e].indexOf(t) === -1 && r[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0)
      return !1;
    const r = this._listeners;
    return r[e] !== void 0 && r[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0)
      return;
    const i = this._listeners[e];
    if (i !== void 0) {
      const s = i.indexOf(t);
      s !== -1 && i.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0)
      return;
    const r = this._listeners[e.type];
    if (r !== void 0) {
      e.target = this;
      const i = r.slice(0);
      for (let s = 0, l = i.length; s < l; s++)
        i[s].call(this, e);
      e.target = null;
    }
  }
}
const lh = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let PO = 1234567;
const H_ = Math.PI / 180, UM = 180 / Math.PI;
function Em() {
  const a = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, r = Math.random() * 4294967295 | 0;
  return (lh[a & 255] + lh[a >> 8 & 255] + lh[a >> 16 & 255] + lh[a >> 24 & 255] + "-" + lh[e & 255] + lh[e >> 8 & 255] + "-" + lh[e >> 16 & 15 | 64] + lh[e >> 24 & 255] + "-" + lh[t & 63 | 128] + lh[t >> 8 & 255] + "-" + lh[t >> 16 & 255] + lh[t >> 24 & 255] + lh[r & 255] + lh[r >> 8 & 255] + lh[r >> 16 & 255] + lh[r >> 24 & 255]).toLowerCase();
}
function Zu(a, e, t) {
  return Math.max(e, Math.min(t, a));
}
function X3(a, e) {
  return (a % e + e) % e;
}
function fH(a, e, t, r, i) {
  return r + (a - e) * (i - r) / (t - e);
}
function dH(a, e, t) {
  return a !== e ? (t - a) / (e - a) : 0;
}
function SM(a, e, t) {
  return (1 - t) * a + t * e;
}
function hH(a, e, t, r) {
  return SM(a, e, 1 - Math.exp(-t * r));
}
function pH(a, e = 1) {
  return e - Math.abs(X3(a, e * 2) - e);
}
function mH(a, e, t) {
  return a <= e ? 0 : a >= t ? 1 : (a = (a - e) / (t - e), a * a * (3 - 2 * a));
}
function vH(a, e, t) {
  return a <= e ? 0 : a >= t ? 1 : (a = (a - e) / (t - e), a * a * a * (a * (a * 6 - 15) + 10));
}
function gH(a, e) {
  return a + Math.floor(Math.random() * (e - a + 1));
}
function yH(a, e) {
  return a + Math.random() * (e - a);
}
function xH(a) {
  return a * (0.5 - Math.random());
}
function _H(a) {
  a !== void 0 && (PO = a);
  let e = PO += 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function SH(a) {
  return a * H_;
}
function wH(a) {
  return a * UM;
}
function m3(a) {
  return (a & a - 1) === 0 && a !== 0;
}
function AF(a) {
  return Math.pow(2, Math.ceil(Math.log(a) / Math.LN2));
}
function CC(a) {
  return Math.pow(2, Math.floor(Math.log(a) / Math.LN2));
}
function bH(a, e, t, r, i) {
  const s = Math.cos, l = Math.sin, d = s(t / 2), p = l(t / 2), g = s((e + r) / 2), _ = l((e + r) / 2), w = s((e - r) / 2), T = l((e - r) / 2), R = s((r - e) / 2), D = l((r - e) / 2);
  switch (i) {
    case "XYX":
      a.set(d * _, p * w, p * T, d * g);
      break;
    case "YZY":
      a.set(p * T, d * _, p * w, d * g);
      break;
    case "ZXZ":
      a.set(p * w, p * T, d * _, d * g);
      break;
    case "XZX":
      a.set(d * _, p * D, p * R, d * g);
      break;
    case "YXY":
      a.set(p * R, d * _, p * D, d * g);
      break;
    case "ZYZ":
      a.set(p * D, p * R, d * _, d * g);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i);
  }
}
function EH(a, e) {
  switch (e.constructor) {
    case Float32Array:
      return a;
    case Uint16Array:
      return a / 65535;
    case Uint8Array:
      return a / 255;
    case Int16Array:
      return Math.max(a / 32767, -1);
    case Int8Array:
      return Math.max(a / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function MH(a, e) {
  switch (e.constructor) {
    case Float32Array:
      return a;
    case Uint16Array:
      return Math.round(a * 65535);
    case Uint8Array:
      return Math.round(a * 255);
    case Int16Array:
      return Math.round(a * 32767);
    case Int8Array:
      return Math.round(a * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
var DF = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  DEG2RAD: H_,
  RAD2DEG: UM,
  generateUUID: Em,
  clamp: Zu,
  euclideanModulo: X3,
  mapLinear: fH,
  inverseLerp: dH,
  lerp: SM,
  damp: hH,
  pingpong: pH,
  smoothstep: mH,
  smootherstep: vH,
  randInt: gH,
  randFloat: yH,
  randFloatSpread: xH,
  seededRandom: _H,
  degToRad: SH,
  radToDeg: wH,
  isPowerOfTwo: m3,
  ceilPowerOfTwo: AF,
  floorPowerOfTwo: CC,
  setQuaternionFromProperEuler: bH,
  normalize: MH,
  denormalize: EH
});
class zt {
  constructor(e = 0, t = 0) {
    zt.prototype.isVector2 = !0, this.x = e, this.y = t;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x, r = this.y, i = e.elements;
    return this.x = i[0] * t + i[3] * r + i[6], this.y = i[1] * t + i[4] * r + i[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, r = this.y - e.y;
    return t * t + r * r;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  lerpVectors(e, t, r) {
    return this.x = e.x + (t.x - e.x) * r, this.y = e.y + (t.y - e.y) * r, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this;
  }
  rotateAround(e, t) {
    const r = Math.cos(t), i = Math.sin(t), s = this.x - e.x, l = this.y - e.y;
    return this.x = s * r - l * i + e.x, this.y = s * i + l * r + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Xh {
  constructor() {
    Xh.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ];
  }
  set(e, t, r, i, s, l, d, p, g) {
    const _ = this.elements;
    return _[0] = e, _[1] = i, _[2] = d, _[3] = t, _[4] = s, _[5] = p, _[6] = r, _[7] = l, _[8] = g, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const t = this.elements, r = e.elements;
    return t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = r[3], t[4] = r[4], t[5] = r[5], t[6] = r[6], t[7] = r[7], t[8] = r[8], this;
  }
  extractBasis(e, t, r) {
    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), r.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[4],
      t[8],
      t[1],
      t[5],
      t[9],
      t[2],
      t[6],
      t[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const r = e.elements, i = t.elements, s = this.elements, l = r[0], d = r[3], p = r[6], g = r[1], _ = r[4], w = r[7], T = r[2], R = r[5], D = r[8], O = i[0], U = i[3], H = i[6], I = i[1], G = i[4], B = i[7], Q = i[2], K = i[5], te = i[8];
    return s[0] = l * O + d * I + p * Q, s[3] = l * U + d * G + p * K, s[6] = l * H + d * B + p * te, s[1] = g * O + _ * I + w * Q, s[4] = g * U + _ * G + w * K, s[7] = g * H + _ * B + w * te, s[2] = T * O + R * I + D * Q, s[5] = T * U + R * G + D * K, s[8] = T * H + R * B + D * te, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], r = e[1], i = e[2], s = e[3], l = e[4], d = e[5], p = e[6], g = e[7], _ = e[8];
    return t * l * _ - t * d * g - r * s * _ + r * d * p + i * s * g - i * l * p;
  }
  invert() {
    const e = this.elements, t = e[0], r = e[1], i = e[2], s = e[3], l = e[4], d = e[5], p = e[6], g = e[7], _ = e[8], w = _ * l - d * g, T = d * p - _ * s, R = g * s - l * p, D = t * w + r * T + i * R;
    if (D === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const O = 1 / D;
    return e[0] = w * O, e[1] = (i * g - _ * r) * O, e[2] = (d * r - i * l) * O, e[3] = T * O, e[4] = (_ * t - i * p) * O, e[5] = (i * s - d * t) * O, e[6] = R * O, e[7] = (r * p - g * t) * O, e[8] = (l * t - r * s) * O, this;
  }
  transpose() {
    let e;
    const t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  }
  setUvTransform(e, t, r, i, s, l, d) {
    const p = Math.cos(s), g = Math.sin(s);
    return this.set(
      r * p,
      r * g,
      -r * (p * l + g * d) + l + e,
      -i * g,
      i * p,
      -i * (-g * l + p * d) + d + t,
      0,
      0,
      1
    ), this;
  }
  scale(e, t) {
    const r = this.elements;
    return r[0] *= e, r[3] *= e, r[6] *= e, r[1] *= t, r[4] *= t, r[7] *= t, this;
  }
  rotate(e) {
    const t = Math.cos(e), r = Math.sin(e), i = this.elements, s = i[0], l = i[3], d = i[6], p = i[1], g = i[4], _ = i[7];
    return i[0] = t * s + r * p, i[3] = t * l + r * g, i[6] = t * d + r * _, i[1] = -r * s + t * p, i[4] = -r * l + t * g, i[7] = -r * d + t * _, this;
  }
  translate(e, t) {
    const r = this.elements;
    return r[0] += e * r[2], r[3] += e * r[5], r[6] += e * r[8], r[1] += t * r[2], r[4] += t * r[5], r[7] += t * r[8], this;
  }
  equals(e) {
    const t = this.elements, r = e.elements;
    for (let i = 0; i < 9; i++)
      if (t[i] !== r[i])
        return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let r = 0; r < 9; r++)
      this.elements[r] = e[r + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.elements;
    return e[t] = r[0], e[t + 1] = r[1], e[t + 2] = r[2], e[t + 3] = r[3], e[t + 4] = r[4], e[t + 5] = r[5], e[t + 6] = r[6], e[t + 7] = r[7], e[t + 8] = r[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
function LF(a) {
  for (let e = a.length - 1; e >= 0; --e)
    if (a[e] > 65535)
      return !0;
  return !1;
}
const TH = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function Gw(a, e) {
  return new TH[a](e);
}
function zM(a) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", a);
}
function V_(a) {
  return a < 0.04045 ? a * 0.0773993808 : Math.pow(a * 0.9478672986 + 0.0521327014, 2.4);
}
function mC(a) {
  return a < 31308e-7 ? a * 12.92 : 1.055 * Math.pow(a, 0.41666) - 0.055;
}
const EA = {
  [uy]: { [Jx]: V_ },
  [Jx]: { [uy]: mC }
}, xv = {
  legacyMode: !0,
  get workingColorSpace() {
    return Jx;
  },
  set workingColorSpace(a) {
    console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
  },
  convert: function(a, e, t) {
    if (this.legacyMode || e === t || !e || !t)
      return a;
    if (EA[e] && EA[e][t] !== void 0) {
      const r = EA[e][t];
      return a.r = r(a.r), a.g = r(a.g), a.b = r(a.b), a;
    }
    throw new Error("Unsupported color space conversion.");
  },
  fromWorkingColorSpace: function(a, e) {
    return this.convert(a, this.workingColorSpace, e);
  },
  toWorkingColorSpace: function(a, e) {
    return this.convert(a, e, this.workingColorSpace);
  }
}, PF = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, uf = { r: 0, g: 0, b: 0 }, tg = { h: 0, s: 0, l: 0 }, o2 = { h: 0, s: 0, l: 0 };
function MA(a, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? a + (e - a) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? a + (e - a) * 6 * (2 / 3 - t) : a;
}
function l2(a, e) {
  return e.r = a.r, e.g = a.g, e.b = a.b, e;
}
class Un {
  constructor(e, t, r) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, t === void 0 && r === void 0 ? this.set(e) : this.setRGB(e, t, r);
  }
  set(e) {
    return e && e.isColor ? this.copy(e) : typeof e == "number" ? this.setHex(e) : typeof e == "string" && this.setStyle(e), this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e, t = uy) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, xv.toWorkingColorSpace(this, t), this;
  }
  setRGB(e, t, r, i = Jx) {
    return this.r = e, this.g = t, this.b = r, xv.toWorkingColorSpace(this, i), this;
  }
  setHSL(e, t, r, i = Jx) {
    if (e = X3(e, 1), t = Zu(t, 0, 1), r = Zu(r, 0, 1), t === 0)
      this.r = this.g = this.b = r;
    else {
      const s = r <= 0.5 ? r * (1 + t) : r + t - r * t, l = 2 * r - s;
      this.r = MA(l, s, e + 1 / 3), this.g = MA(l, s, e), this.b = MA(l, s, e - 1 / 3);
    }
    return xv.toWorkingColorSpace(this, i), this;
  }
  setStyle(e, t = uy) {
    function r(s) {
      s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let i;
    if (i = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
      let s;
      const l = i[1], d = i[2];
      switch (l) {
        case "rgb":
        case "rgba":
          if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(d))
            return this.r = Math.min(255, parseInt(s[1], 10)) / 255, this.g = Math.min(255, parseInt(s[2], 10)) / 255, this.b = Math.min(255, parseInt(s[3], 10)) / 255, xv.toWorkingColorSpace(this, t), r(s[4]), this;
          if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(d))
            return this.r = Math.min(100, parseInt(s[1], 10)) / 100, this.g = Math.min(100, parseInt(s[2], 10)) / 100, this.b = Math.min(100, parseInt(s[3], 10)) / 100, xv.toWorkingColorSpace(this, t), r(s[4]), this;
          break;
        case "hsl":
        case "hsla":
          if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(d)) {
            const p = parseFloat(s[1]) / 360, g = parseInt(s[2], 10) / 100, _ = parseInt(s[3], 10) / 100;
            return r(s[4]), this.setHSL(p, g, _, t);
          }
          break;
      }
    } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const s = i[1], l = s.length;
      if (l === 3)
        return this.r = parseInt(s.charAt(0) + s.charAt(0), 16) / 255, this.g = parseInt(s.charAt(1) + s.charAt(1), 16) / 255, this.b = parseInt(s.charAt(2) + s.charAt(2), 16) / 255, xv.toWorkingColorSpace(this, t), this;
      if (l === 6)
        return this.r = parseInt(s.charAt(0) + s.charAt(1), 16) / 255, this.g = parseInt(s.charAt(2) + s.charAt(3), 16) / 255, this.b = parseInt(s.charAt(4) + s.charAt(5), 16) / 255, xv.toWorkingColorSpace(this, t), this;
    }
    return e && e.length > 0 ? this.setColorName(e, t) : this;
  }
  setColorName(e, t = uy) {
    const r = PF[e.toLowerCase()];
    return r !== void 0 ? this.setHex(r, t) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copySRGBToLinear(e) {
    return this.r = V_(e.r), this.g = V_(e.g), this.b = V_(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = mC(e.r), this.g = mC(e.g), this.b = mC(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = uy) {
    return xv.fromWorkingColorSpace(l2(this, uf), e), Zu(uf.r * 255, 0, 255) << 16 ^ Zu(uf.g * 255, 0, 255) << 8 ^ Zu(uf.b * 255, 0, 255) << 0;
  }
  getHexString(e = uy) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = Jx) {
    xv.fromWorkingColorSpace(l2(this, uf), t);
    const r = uf.r, i = uf.g, s = uf.b, l = Math.max(r, i, s), d = Math.min(r, i, s);
    let p, g;
    const _ = (d + l) / 2;
    if (d === l)
      p = 0, g = 0;
    else {
      const w = l - d;
      switch (g = _ <= 0.5 ? w / (l + d) : w / (2 - l - d), l) {
        case r:
          p = (i - s) / w + (i < s ? 6 : 0);
          break;
        case i:
          p = (s - r) / w + 2;
          break;
        case s:
          p = (r - i) / w + 4;
          break;
      }
      p /= 6;
    }
    return e.h = p, e.s = g, e.l = _, e;
  }
  getRGB(e, t = Jx) {
    return xv.fromWorkingColorSpace(l2(this, uf), t), e.r = uf.r, e.g = uf.g, e.b = uf.b, e;
  }
  getStyle(e = uy) {
    return xv.fromWorkingColorSpace(l2(this, uf), e), e !== uy ? `color(${e} ${uf.r} ${uf.g} ${uf.b})` : `rgb(${uf.r * 255 | 0},${uf.g * 255 | 0},${uf.b * 255 | 0})`;
  }
  offsetHSL(e, t, r) {
    return this.getHSL(tg), tg.h += e, tg.s += t, tg.l += r, this.setHSL(tg.h, tg.s, tg.l), this;
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, t) {
    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, t) {
    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
  }
  lerpColors(e, t, r) {
    return this.r = e.r + (t.r - e.r) * r, this.g = e.g + (t.g - e.g) * r, this.b = e.b + (t.b - e.b) * r, this;
  }
  lerpHSL(e, t) {
    this.getHSL(tg), e.getHSL(o2);
    const r = SM(tg.h, o2.h, t), i = SM(tg.s, o2.s, t), s = SM(tg.l, o2.l, t);
    return this.setHSL(r, i, s), this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
  }
  fromBufferAttribute(e, t) {
    return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), e.normalized === !0 && (this.r /= 255, this.g /= 255, this.b /= 255), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
Un.NAMES = PF;
let Sw;
class q3 {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
      return e.src;
    let t;
    if (e instanceof HTMLCanvasElement)
      t = e;
    else {
      Sw === void 0 && (Sw = zM("canvas")), Sw.width = e.width, Sw.height = e.height;
      const r = Sw.getContext("2d");
      e instanceof ImageData ? r.putImageData(e, 0, 0) : r.drawImage(e, 0, 0, e.width, e.height), t = Sw;
    }
    return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", 0.6)) : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
      const t = zM("canvas");
      t.width = e.width, t.height = e.height;
      const r = t.getContext("2d");
      r.drawImage(e, 0, 0, e.width, e.height);
      const i = r.getImageData(0, 0, e.width, e.height), s = i.data;
      for (let l = 0; l < s.length; l++)
        s[l] = V_(s[l] / 255) * 255;
      return r.putImageData(i, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let r = 0; r < t.length; r++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[r] = Math.floor(V_(t[r] / 255) * 255) : t[r] = V_(t[r]);
      return {
        data: t,
        width: e.width,
        height: e.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
  }
}
class F_ {
  constructor(e = null) {
    this.isSource = !0, this.uuid = Em(), this.data = e, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0)
      return e.images[this.uuid];
    const r = {
      uuid: this.uuid,
      url: ""
    }, i = this.data;
    if (i !== null) {
      let s;
      if (Array.isArray(i)) {
        s = [];
        for (let l = 0, d = i.length; l < d; l++)
          i[l].isDataTexture ? s.push(TA(i[l].image)) : s.push(TA(i[l]));
      } else
        s = TA(i);
      r.url = s;
    }
    return t || (e.images[this.uuid] = r), r;
  }
}
function TA(a) {
  return typeof HTMLImageElement < "u" && a instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && a instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && a instanceof ImageBitmap ? q3.getDataURL(a) : a.data ? {
    data: Array.from(a.data),
    width: a.width,
    height: a.height,
    type: a.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let CH = 0;
class su extends Cm {
  constructor(e = su.DEFAULT_IMAGE, t = su.DEFAULT_MAPPING, r = jh, i = jh, s = Oo, l = s1, d = zp, p = df, g = 1, _ = wv) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: CH++ }), this.uuid = Em(), this.name = "", this.source = new F_(e), this.mipmaps = [], this.mapping = t, this.wrapS = r, this.wrapT = i, this.magFilter = s, this.minFilter = l, this.anisotropy = g, this.format = d, this.internalFormat = null, this.type = p, this.offset = new zt(0, 0), this.repeat = new zt(1, 1), this.center = new zt(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Xh(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = _, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1;
  }
  get image() {
    return this.source.data;
  }
  set image(e) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const r = {
      metadata: {
        version: 4.5,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return JSON.stringify(this.userData) !== "{}" && (r.userData = this.userData), t || (e.textures[this.uuid] = r), r;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== FC)
      return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case Zw:
          e.x = e.x - Math.floor(e.x);
          break;
        case jh:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case AM:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case Zw:
          e.y = e.y - Math.floor(e.y);
          break;
        case jh:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case AM:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, this.source.needsUpdate = !0);
  }
}
su.DEFAULT_IMAGE = null;
su.DEFAULT_MAPPING = FC;
class ra {
  constructor(e = 0, t = 0, r = 0, i = 1) {
    ra.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = r, this.w = i;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, r, i) {
    return this.x = e, this.y = t, this.z = r, this.w = i, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const t = this.x, r = this.y, i = this.z, s = this.w, l = e.elements;
    return this.x = l[0] * t + l[4] * r + l[8] * i + l[12] * s, this.y = l[1] * t + l[5] * r + l[9] * i + l[13] * s, this.z = l[2] * t + l[6] * r + l[10] * i + l[14] * s, this.w = l[3] * t + l[7] * r + l[11] * i + l[15] * s, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, r, i, s;
    const p = e.elements, g = p[0], _ = p[4], w = p[8], T = p[1], R = p[5], D = p[9], O = p[2], U = p[6], H = p[10];
    if (Math.abs(_ - T) < 0.01 && Math.abs(w - O) < 0.01 && Math.abs(D - U) < 0.01) {
      if (Math.abs(_ + T) < 0.1 && Math.abs(w + O) < 0.1 && Math.abs(D + U) < 0.1 && Math.abs(g + R + H - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const G = (g + 1) / 2, B = (R + 1) / 2, Q = (H + 1) / 2, K = (_ + T) / 4, te = (w + O) / 4, Y = (D + U) / 4;
      return G > B && G > Q ? G < 0.01 ? (r = 0, i = 0.707106781, s = 0.707106781) : (r = Math.sqrt(G), i = K / r, s = te / r) : B > Q ? B < 0.01 ? (r = 0.707106781, i = 0, s = 0.707106781) : (i = Math.sqrt(B), r = K / i, s = Y / i) : Q < 0.01 ? (r = 0.707106781, i = 0.707106781, s = 0) : (s = Math.sqrt(Q), r = te / s, i = Y / s), this.set(r, i, s, t), this;
    }
    let I = Math.sqrt((U - D) * (U - D) + (w - O) * (w - O) + (T - _) * (T - _));
    return Math.abs(I) < 1e-3 && (I = 1), this.x = (U - D) / I, this.y = (w - O) / I, this.z = (T - _) / I, this.w = Math.acos((g + R + H - 1) / 2), this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this;
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
  }
  lerpVectors(e, t, r) {
    return this.x = e.x + (t.x - e.x) * r, this.y = e.y + (t.y - e.y) * r, this.z = e.z + (t.z - e.z) * r, this.w = e.w + (t.w - e.w) * r, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class po extends Cm {
  constructor(e, t, r = {}) {
    super(), this.isWebGLRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new ra(0, 0, e, t), this.scissorTest = !1, this.viewport = new ra(0, 0, e, t);
    const i = { width: e, height: t, depth: 1 };
    this.texture = new su(i, r.mapping, r.wrapS, r.wrapT, r.magFilter, r.minFilter, r.format, r.type, r.anisotropy, r.encoding), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = r.generateMipmaps !== void 0 ? r.generateMipmaps : !1, this.texture.internalFormat = r.internalFormat !== void 0 ? r.internalFormat : null, this.texture.minFilter = r.minFilter !== void 0 ? r.minFilter : Oo, this.depthBuffer = r.depthBuffer !== void 0 ? r.depthBuffer : !0, this.stencilBuffer = r.stencilBuffer !== void 0 ? r.stencilBuffer : !1, this.depthTexture = r.depthTexture !== void 0 ? r.depthTexture : null, this.samples = r.samples !== void 0 ? r.samples : 0;
  }
  setSize(e, t, r = 1) {
    (this.width !== e || this.height !== t || this.depth !== r) && (this.width = e, this.height = t, this.depth = r, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = r, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.isRenderTargetTexture = !0;
    const t = Object.assign({}, e.texture.image);
    return this.texture.source = new F_(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class JM extends su {
  constructor(e = null, t = 1, r = 1, i = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: t, height: r, depth: i }, this.magFilter = fo, this.minFilter = fo, this.wrapR = jh, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class RH extends po {
  constructor(e, t, r) {
    super(e, t), this.isWebGLArrayRenderTarget = !0, this.depth = r, this.texture = new JM(null, e, t, r), this.texture.isRenderTargetTexture = !0;
  }
}
class IC extends su {
  constructor(e = null, t = 1, r = 1, i = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: e, width: t, height: r, depth: i }, this.magFilter = fo, this.minFilter = fo, this.wrapR = jh, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class AH extends po {
  constructor(e, t, r) {
    super(e, t), this.isWebGL3DRenderTarget = !0, this.depth = r, this.texture = new IC(null, e, t, r), this.texture.isRenderTargetTexture = !0;
  }
}
class DH extends po {
  constructor(e, t, r, i = {}) {
    super(e, t, i), this.isWebGLMultipleRenderTargets = !0;
    const s = this.texture;
    this.texture = [];
    for (let l = 0; l < r; l++)
      this.texture[l] = s.clone(), this.texture[l].isRenderTargetTexture = !0;
  }
  setSize(e, t, r = 1) {
    if (this.width !== e || this.height !== t || this.depth !== r) {
      this.width = e, this.height = t, this.depth = r;
      for (let i = 0, s = this.texture.length; i < s; i++)
        this.texture[i].image.width = e, this.texture[i].image.height = t, this.texture[i].image.depth = r;
      this.dispose();
    }
    return this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this;
  }
  copy(e) {
    this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.texture.length = 0;
    for (let t = 0, r = e.texture.length; t < r; t++)
      this.texture[t] = e.texture[t].clone(), this.texture[t].isRenderTargetTexture = !0;
    return this;
  }
}
class Po {
  constructor(e = 0, t = 0, r = 0, i = 1) {
    this.isQuaternion = !0, this._x = e, this._y = t, this._z = r, this._w = i;
  }
  static slerpFlat(e, t, r, i, s, l, d) {
    let p = r[i + 0], g = r[i + 1], _ = r[i + 2], w = r[i + 3];
    const T = s[l + 0], R = s[l + 1], D = s[l + 2], O = s[l + 3];
    if (d === 0) {
      e[t + 0] = p, e[t + 1] = g, e[t + 2] = _, e[t + 3] = w;
      return;
    }
    if (d === 1) {
      e[t + 0] = T, e[t + 1] = R, e[t + 2] = D, e[t + 3] = O;
      return;
    }
    if (w !== O || p !== T || g !== R || _ !== D) {
      let U = 1 - d;
      const H = p * T + g * R + _ * D + w * O, I = H >= 0 ? 1 : -1, G = 1 - H * H;
      if (G > Number.EPSILON) {
        const Q = Math.sqrt(G), K = Math.atan2(Q, H * I);
        U = Math.sin(U * K) / Q, d = Math.sin(d * K) / Q;
      }
      const B = d * I;
      if (p = p * U + T * B, g = g * U + R * B, _ = _ * U + D * B, w = w * U + O * B, U === 1 - d) {
        const Q = 1 / Math.sqrt(p * p + g * g + _ * _ + w * w);
        p *= Q, g *= Q, _ *= Q, w *= Q;
      }
    }
    e[t] = p, e[t + 1] = g, e[t + 2] = _, e[t + 3] = w;
  }
  static multiplyQuaternionsFlat(e, t, r, i, s, l) {
    const d = r[i], p = r[i + 1], g = r[i + 2], _ = r[i + 3], w = s[l], T = s[l + 1], R = s[l + 2], D = s[l + 3];
    return e[t] = d * D + _ * w + p * R - g * T, e[t + 1] = p * D + _ * T + g * w - d * R, e[t + 2] = g * D + _ * R + d * T - p * w, e[t + 3] = _ * D - d * w - p * T - g * R, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, t, r, i) {
    return this._x = e, this._y = t, this._z = r, this._w = i, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, t) {
    if (!(e && e.isEuler))
      throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
    const r = e._x, i = e._y, s = e._z, l = e._order, d = Math.cos, p = Math.sin, g = d(r / 2), _ = d(i / 2), w = d(s / 2), T = p(r / 2), R = p(i / 2), D = p(s / 2);
    switch (l) {
      case "XYZ":
        this._x = T * _ * w + g * R * D, this._y = g * R * w - T * _ * D, this._z = g * _ * D + T * R * w, this._w = g * _ * w - T * R * D;
        break;
      case "YXZ":
        this._x = T * _ * w + g * R * D, this._y = g * R * w - T * _ * D, this._z = g * _ * D - T * R * w, this._w = g * _ * w + T * R * D;
        break;
      case "ZXY":
        this._x = T * _ * w - g * R * D, this._y = g * R * w + T * _ * D, this._z = g * _ * D + T * R * w, this._w = g * _ * w - T * R * D;
        break;
      case "ZYX":
        this._x = T * _ * w - g * R * D, this._y = g * R * w + T * _ * D, this._z = g * _ * D - T * R * w, this._w = g * _ * w + T * R * D;
        break;
      case "YZX":
        this._x = T * _ * w + g * R * D, this._y = g * R * w + T * _ * D, this._z = g * _ * D - T * R * w, this._w = g * _ * w - T * R * D;
        break;
      case "XZY":
        this._x = T * _ * w - g * R * D, this._y = g * R * w - T * _ * D, this._z = g * _ * D + T * R * w, this._w = g * _ * w + T * R * D;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + l);
    }
    return t !== !1 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const r = t / 2, i = Math.sin(r);
    return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(r), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const t = e.elements, r = t[0], i = t[4], s = t[8], l = t[1], d = t[5], p = t[9], g = t[2], _ = t[6], w = t[10], T = r + d + w;
    if (T > 0) {
      const R = 0.5 / Math.sqrt(T + 1);
      this._w = 0.25 / R, this._x = (_ - p) * R, this._y = (s - g) * R, this._z = (l - i) * R;
    } else if (r > d && r > w) {
      const R = 2 * Math.sqrt(1 + r - d - w);
      this._w = (_ - p) / R, this._x = 0.25 * R, this._y = (i + l) / R, this._z = (s + g) / R;
    } else if (d > w) {
      const R = 2 * Math.sqrt(1 + d - r - w);
      this._w = (s - g) / R, this._x = (i + l) / R, this._y = 0.25 * R, this._z = (p + _) / R;
    } else {
      const R = 2 * Math.sqrt(1 + w - r - d);
      this._w = (l - i) / R, this._x = (s + g) / R, this._y = (p + _) / R, this._z = 0.25 * R;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let r = e.dot(t) + 1;
    return r < Number.EPSILON ? (r = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = r) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = r)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = r), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(Zu(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const r = this.angleTo(e);
    if (r === 0)
      return this;
    const i = Math.min(1, t / r);
    return this.slerp(e, i), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const r = e._x, i = e._y, s = e._z, l = e._w, d = t._x, p = t._y, g = t._z, _ = t._w;
    return this._x = r * _ + l * d + i * g - s * p, this._y = i * _ + l * p + s * d - r * g, this._z = s * _ + l * g + r * p - i * d, this._w = l * _ - r * d - i * p - s * g, this._onChangeCallback(), this;
  }
  slerp(e, t) {
    if (t === 0)
      return this;
    if (t === 1)
      return this.copy(e);
    const r = this._x, i = this._y, s = this._z, l = this._w;
    let d = l * e._w + r * e._x + i * e._y + s * e._z;
    if (d < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, d = -d) : this.copy(e), d >= 1)
      return this._w = l, this._x = r, this._y = i, this._z = s, this;
    const p = 1 - d * d;
    if (p <= Number.EPSILON) {
      const R = 1 - t;
      return this._w = R * l + t * this._w, this._x = R * r + t * this._x, this._y = R * i + t * this._y, this._z = R * s + t * this._z, this.normalize(), this._onChangeCallback(), this;
    }
    const g = Math.sqrt(p), _ = Math.atan2(g, d), w = Math.sin((1 - t) * _) / g, T = Math.sin(t * _) / g;
    return this._w = l * w + this._w * T, this._x = r * w + this._x * T, this._y = i * w + this._y * T, this._z = s * w + this._z * T, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, t, r) {
    return this.copy(e).slerp(t, r);
  }
  random() {
    const e = Math.random(), t = Math.sqrt(1 - e), r = Math.sqrt(e), i = 2 * Math.PI * Math.random(), s = 2 * Math.PI * Math.random();
    return this.set(
      t * Math.cos(i),
      r * Math.sin(s),
      r * Math.cos(s),
      t * Math.sin(i)
    );
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, t = 0) {
    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
  }
  fromBufferAttribute(e, t) {
    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class ge {
  constructor(e = 0, t = 0, r = 0) {
    ge.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = r;
  }
  set(e, t, r) {
    return r === void 0 && (r = this.z), this.x = e, this.y = t, this.z = r, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, t) {
    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(OO.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(OO.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x, r = this.y, i = this.z, s = e.elements;
    return this.x = s[0] * t + s[3] * r + s[6] * i, this.y = s[1] * t + s[4] * r + s[7] * i, this.z = s[2] * t + s[5] * r + s[8] * i, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x, r = this.y, i = this.z, s = e.elements, l = 1 / (s[3] * t + s[7] * r + s[11] * i + s[15]);
    return this.x = (s[0] * t + s[4] * r + s[8] * i + s[12]) * l, this.y = (s[1] * t + s[5] * r + s[9] * i + s[13]) * l, this.z = (s[2] * t + s[6] * r + s[10] * i + s[14]) * l, this;
  }
  applyQuaternion(e) {
    const t = this.x, r = this.y, i = this.z, s = e.x, l = e.y, d = e.z, p = e.w, g = p * t + l * i - d * r, _ = p * r + d * t - s * i, w = p * i + s * r - l * t, T = -s * t - l * r - d * i;
    return this.x = g * p + T * -s + _ * -d - w * -l, this.y = _ * p + T * -l + w * -s - g * -d, this.z = w * p + T * -d + g * -l - _ * -s, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const t = this.x, r = this.y, i = this.z, s = e.elements;
    return this.x = s[0] * t + s[4] * r + s[8] * i, this.y = s[1] * t + s[5] * r + s[9] * i, this.z = s[2] * t + s[6] * r + s[10] * i, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this;
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(Math.max(e, Math.min(t, r)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
  }
  lerpVectors(e, t, r) {
    return this.x = e.x + (t.x - e.x) * r, this.y = e.y + (t.y - e.y) * r, this.z = e.z + (t.z - e.z) * r, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const r = e.x, i = e.y, s = e.z, l = t.x, d = t.y, p = t.z;
    return this.x = i * p - s * d, this.y = s * l - r * p, this.z = r * d - i * l, this;
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0)
      return this.set(0, 0, 0);
    const r = e.dot(this) / t;
    return this.copy(e).multiplyScalar(r);
  }
  projectOnPlane(e) {
    return CA.copy(this).projectOnVector(e), this.sub(CA);
  }
  reflect(e) {
    return this.sub(CA.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0)
      return Math.PI / 2;
    const r = this.dot(e) / t;
    return Math.acos(Zu(r, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, r = this.y - e.y, i = this.z - e.z;
    return t * t + r * r + i * i;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, r) {
    const i = Math.sin(t) * e;
    return this.x = i * Math.sin(r), this.y = Math.cos(t) * e, this.z = i * Math.cos(r), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, r) {
    return this.x = e * Math.sin(t), this.y = r, this.z = e * Math.cos(t), this;
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(), r = this.setFromMatrixColumn(e, 1).length(), i = this.setFromMatrixColumn(e, 2).length();
    return this.x = t, this.y = r, this.z = i, this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2, t = Math.random() * Math.PI * 2, r = Math.sqrt(1 - e ** 2);
    return this.x = r * Math.cos(t), this.y = r * Math.sin(t), this.z = e, this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const CA = /* @__PURE__ */ new ge(), OO = /* @__PURE__ */ new Po();
class cg {
  constructor(e = new ge(1 / 0, 1 / 0, 1 / 0), t = new ge(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    let t = 1 / 0, r = 1 / 0, i = 1 / 0, s = -1 / 0, l = -1 / 0, d = -1 / 0;
    for (let p = 0, g = e.length; p < g; p += 3) {
      const _ = e[p], w = e[p + 1], T = e[p + 2];
      _ < t && (t = _), w < r && (r = w), T < i && (i = T), _ > s && (s = _), w > l && (l = w), T > d && (d = T);
    }
    return this.min.set(t, r, i), this.max.set(s, l, d), this;
  }
  setFromBufferAttribute(e) {
    let t = 1 / 0, r = 1 / 0, i = 1 / 0, s = -1 / 0, l = -1 / 0, d = -1 / 0;
    for (let p = 0, g = e.count; p < g; p++) {
      const _ = e.getX(p), w = e.getY(p), T = e.getZ(p);
      _ < t && (t = _), w < r && (r = w), T < i && (i = T), _ > s && (s = _), w > l && (l = w), T > d && (d = T);
    }
    return this.min.set(t, r, i), this.max.set(s, l, d), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const r = p_.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const r = e.geometry;
    if (r !== void 0)
      if (t && r.attributes != null && r.attributes.position !== void 0) {
        const s = r.attributes.position;
        for (let l = 0, d = s.count; l < d; l++)
          p_.fromBufferAttribute(s, l).applyMatrix4(e.matrixWorld), this.expandByPoint(p_);
      } else
        r.boundingBox === null && r.computeBoundingBox(), RA.copy(r.boundingBox), RA.applyMatrix4(e.matrixWorld), this.union(RA);
    const i = e.children;
    for (let s = 0, l = i.length; s < l; s++)
      this.expandByObject(i[s], t);
    return this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, p_), p_.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let t, r;
    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, r = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, r = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, r += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, r += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, r += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, r += e.normal.z * this.min.z), t <= -e.constant && r >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(JE), u2.subVectors(this.max, JE), ww.subVectors(e.a, JE), bw.subVectors(e.b, JE), Ew.subVectors(e.c, JE), kx.subVectors(bw, ww), Ix.subVectors(Ew, bw), m_.subVectors(ww, Ew);
    let t = [
      0,
      -kx.z,
      kx.y,
      0,
      -Ix.z,
      Ix.y,
      0,
      -m_.z,
      m_.y,
      kx.z,
      0,
      -kx.x,
      Ix.z,
      0,
      -Ix.x,
      m_.z,
      0,
      -m_.x,
      -kx.y,
      kx.x,
      0,
      -Ix.y,
      Ix.x,
      0,
      -m_.y,
      m_.x,
      0
    ];
    return !AA(t, ww, bw, Ew, u2) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !AA(t, ww, bw, Ew, u2)) ? !1 : (c2.crossVectors(kx, Ix), t = [c2.x, c2.y, c2.z], AA(t, ww, bw, Ew, u2));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return p_.copy(e).clamp(this.min, this.max).sub(e).length();
  }
  getBoundingSphere(e) {
    return this.getCenter(e.center), e.radius = this.getSize(p_).length() * 0.5, e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() ? this : (S0[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), S0[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), S0[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), S0[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), S0[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), S0[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), S0[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), S0[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(S0), this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const S0 = [
  /* @__PURE__ */ new ge(),
  /* @__PURE__ */ new ge(),
  /* @__PURE__ */ new ge(),
  /* @__PURE__ */ new ge(),
  /* @__PURE__ */ new ge(),
  /* @__PURE__ */ new ge(),
  /* @__PURE__ */ new ge(),
  /* @__PURE__ */ new ge()
], p_ = /* @__PURE__ */ new ge(), RA = /* @__PURE__ */ new cg(), ww = /* @__PURE__ */ new ge(), bw = /* @__PURE__ */ new ge(), Ew = /* @__PURE__ */ new ge(), kx = /* @__PURE__ */ new ge(), Ix = /* @__PURE__ */ new ge(), m_ = /* @__PURE__ */ new ge(), JE = /* @__PURE__ */ new ge(), u2 = /* @__PURE__ */ new ge(), c2 = /* @__PURE__ */ new ge(), v_ = /* @__PURE__ */ new ge();
function AA(a, e, t, r, i) {
  for (let s = 0, l = a.length - 3; s <= l; s += 3) {
    v_.fromArray(a, s);
    const d = i.x * Math.abs(v_.x) + i.y * Math.abs(v_.y) + i.z * Math.abs(v_.z), p = e.dot(v_), g = t.dot(v_), _ = r.dot(v_);
    if (Math.max(-Math.max(p, g, _), Math.min(p, g, _)) > d)
      return !1;
  }
  return !0;
}
const LH = /* @__PURE__ */ new cg(), UO = /* @__PURE__ */ new ge(), f2 = /* @__PURE__ */ new ge(), DA = /* @__PURE__ */ new ge();
class yy {
  constructor(e = new ge(), t = -1) {
    this.center = e, this.radius = t;
  }
  set(e, t) {
    return this.center.copy(e), this.radius = t, this;
  }
  setFromPoints(e, t) {
    const r = this.center;
    t !== void 0 ? r.copy(t) : LH.setFromPoints(e).getCenter(r);
    let i = 0;
    for (let s = 0, l = e.length; s < l; s++)
      i = Math.max(i, r.distanceToSquared(e[s]));
    return this.radius = Math.sqrt(i), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const r = this.center.distanceToSquared(e);
    return t.copy(e), r > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    DA.subVectors(e, this.center);
    const t = DA.lengthSq();
    if (t > this.radius * this.radius) {
      const r = Math.sqrt(t), i = (r - this.radius) * 0.5;
      this.center.add(DA.multiplyScalar(i / r)), this.radius += i;
    }
    return this;
  }
  union(e) {
    return this.center.equals(e.center) === !0 ? f2.set(0, 0, 1).multiplyScalar(e.radius) : f2.subVectors(e.center, this.center).normalize().multiplyScalar(e.radius), this.expandByPoint(UO.copy(e.center).add(f2)), this.expandByPoint(UO.copy(e.center).sub(f2)), this;
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const w0 = /* @__PURE__ */ new ge(), LA = /* @__PURE__ */ new ge(), d2 = /* @__PURE__ */ new ge(), Bx = /* @__PURE__ */ new ge(), PA = /* @__PURE__ */ new ge(), h2 = /* @__PURE__ */ new ge(), OA = /* @__PURE__ */ new ge();
class KM {
  constructor(e = new ge(), t = new ge(0, 0, -1)) {
    this.origin = e, this.direction = t;
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.direction).multiplyScalar(e).add(this.origin);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, w0)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const r = t.dot(this.direction);
    return r < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(r).add(this.origin);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = w0.subVectors(e, this.origin).dot(this.direction);
    return t < 0 ? this.origin.distanceToSquared(e) : (w0.copy(this.direction).multiplyScalar(t).add(this.origin), w0.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, r, i) {
    LA.copy(e).add(t).multiplyScalar(0.5), d2.copy(t).sub(e).normalize(), Bx.copy(this.origin).sub(LA);
    const s = e.distanceTo(t) * 0.5, l = -this.direction.dot(d2), d = Bx.dot(this.direction), p = -Bx.dot(d2), g = Bx.lengthSq(), _ = Math.abs(1 - l * l);
    let w, T, R, D;
    if (_ > 0)
      if (w = l * p - d, T = l * d - p, D = s * _, w >= 0)
        if (T >= -D)
          if (T <= D) {
            const O = 1 / _;
            w *= O, T *= O, R = w * (w + l * T + 2 * d) + T * (l * w + T + 2 * p) + g;
          } else
            T = s, w = Math.max(0, -(l * T + d)), R = -w * w + T * (T + 2 * p) + g;
        else
          T = -s, w = Math.max(0, -(l * T + d)), R = -w * w + T * (T + 2 * p) + g;
      else
        T <= -D ? (w = Math.max(0, -(-l * s + d)), T = w > 0 ? -s : Math.min(Math.max(-s, -p), s), R = -w * w + T * (T + 2 * p) + g) : T <= D ? (w = 0, T = Math.min(Math.max(-s, -p), s), R = T * (T + 2 * p) + g) : (w = Math.max(0, -(l * s + d)), T = w > 0 ? s : Math.min(Math.max(-s, -p), s), R = -w * w + T * (T + 2 * p) + g);
    else
      T = l > 0 ? -s : s, w = Math.max(0, -(l * T + d)), R = -w * w + T * (T + 2 * p) + g;
    return r && r.copy(this.direction).multiplyScalar(w).add(this.origin), i && i.copy(d2).multiplyScalar(T).add(LA), R;
  }
  intersectSphere(e, t) {
    w0.subVectors(e.center, this.origin);
    const r = w0.dot(this.direction), i = w0.dot(w0) - r * r, s = e.radius * e.radius;
    if (i > s)
      return null;
    const l = Math.sqrt(s - i), d = r - l, p = r + l;
    return d < 0 && p < 0 ? null : d < 0 ? this.at(p, t) : this.at(d, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const r = -(this.origin.dot(e.normal) + e.constant) / t;
    return r >= 0 ? r : null;
  }
  intersectPlane(e, t) {
    const r = this.distanceToPlane(e);
    return r === null ? null : this.at(r, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let r, i, s, l, d, p;
    const g = 1 / this.direction.x, _ = 1 / this.direction.y, w = 1 / this.direction.z, T = this.origin;
    return g >= 0 ? (r = (e.min.x - T.x) * g, i = (e.max.x - T.x) * g) : (r = (e.max.x - T.x) * g, i = (e.min.x - T.x) * g), _ >= 0 ? (s = (e.min.y - T.y) * _, l = (e.max.y - T.y) * _) : (s = (e.max.y - T.y) * _, l = (e.min.y - T.y) * _), r > l || s > i || ((s > r || r !== r) && (r = s), (l < i || i !== i) && (i = l), w >= 0 ? (d = (e.min.z - T.z) * w, p = (e.max.z - T.z) * w) : (d = (e.max.z - T.z) * w, p = (e.min.z - T.z) * w), r > p || d > i) || ((d > r || r !== r) && (r = d), (p < i || i !== i) && (i = p), i < 0) ? null : this.at(r >= 0 ? r : i, t);
  }
  intersectsBox(e) {
    return this.intersectBox(e, w0) !== null;
  }
  intersectTriangle(e, t, r, i, s) {
    PA.subVectors(t, e), h2.subVectors(r, e), OA.crossVectors(PA, h2);
    let l = this.direction.dot(OA), d;
    if (l > 0) {
      if (i)
        return null;
      d = 1;
    } else if (l < 0)
      d = -1, l = -l;
    else
      return null;
    Bx.subVectors(this.origin, e);
    const p = d * this.direction.dot(h2.crossVectors(Bx, h2));
    if (p < 0)
      return null;
    const g = d * this.direction.dot(PA.cross(Bx));
    if (g < 0 || p + g > l)
      return null;
    const _ = -d * Bx.dot(OA);
    return _ < 0 ? null : this.at(_ / l, s);
  }
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Kr {
  constructor() {
    Kr.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
  }
  set(e, t, r, i, s, l, d, p, g, _, w, T, R, D, O, U) {
    const H = this.elements;
    return H[0] = e, H[4] = t, H[8] = r, H[12] = i, H[1] = s, H[5] = l, H[9] = d, H[13] = p, H[2] = g, H[6] = _, H[10] = w, H[14] = T, H[3] = R, H[7] = D, H[11] = O, H[15] = U, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new Kr().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements, r = e.elements;
    return t[0] = r[0], t[1] = r[1], t[2] = r[2], t[3] = r[3], t[4] = r[4], t[5] = r[5], t[6] = r[6], t[7] = r[7], t[8] = r[8], t[9] = r[9], t[10] = r[10], t[11] = r[11], t[12] = r[12], t[13] = r[13], t[14] = r[14], t[15] = r[15], this;
  }
  copyPosition(e) {
    const t = this.elements, r = e.elements;
    return t[12] = r[12], t[13] = r[13], t[14] = r[14], this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[3],
      t[6],
      0,
      t[1],
      t[4],
      t[7],
      0,
      t[2],
      t[5],
      t[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(e, t, r) {
    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), r.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, t, r) {
    return this.set(
      e.x,
      t.x,
      r.x,
      0,
      e.y,
      t.y,
      r.y,
      0,
      e.z,
      t.z,
      r.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const t = this.elements, r = e.elements, i = 1 / Mw.setFromMatrixColumn(e, 0).length(), s = 1 / Mw.setFromMatrixColumn(e, 1).length(), l = 1 / Mw.setFromMatrixColumn(e, 2).length();
    return t[0] = r[0] * i, t[1] = r[1] * i, t[2] = r[2] * i, t[3] = 0, t[4] = r[4] * s, t[5] = r[5] * s, t[6] = r[6] * s, t[7] = 0, t[8] = r[8] * l, t[9] = r[9] * l, t[10] = r[10] * l, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const t = this.elements, r = e.x, i = e.y, s = e.z, l = Math.cos(r), d = Math.sin(r), p = Math.cos(i), g = Math.sin(i), _ = Math.cos(s), w = Math.sin(s);
    if (e.order === "XYZ") {
      const T = l * _, R = l * w, D = d * _, O = d * w;
      t[0] = p * _, t[4] = -p * w, t[8] = g, t[1] = R + D * g, t[5] = T - O * g, t[9] = -d * p, t[2] = O - T * g, t[6] = D + R * g, t[10] = l * p;
    } else if (e.order === "YXZ") {
      const T = p * _, R = p * w, D = g * _, O = g * w;
      t[0] = T + O * d, t[4] = D * d - R, t[8] = l * g, t[1] = l * w, t[5] = l * _, t[9] = -d, t[2] = R * d - D, t[6] = O + T * d, t[10] = l * p;
    } else if (e.order === "ZXY") {
      const T = p * _, R = p * w, D = g * _, O = g * w;
      t[0] = T - O * d, t[4] = -l * w, t[8] = D + R * d, t[1] = R + D * d, t[5] = l * _, t[9] = O - T * d, t[2] = -l * g, t[6] = d, t[10] = l * p;
    } else if (e.order === "ZYX") {
      const T = l * _, R = l * w, D = d * _, O = d * w;
      t[0] = p * _, t[4] = D * g - R, t[8] = T * g + O, t[1] = p * w, t[5] = O * g + T, t[9] = R * g - D, t[2] = -g, t[6] = d * p, t[10] = l * p;
    } else if (e.order === "YZX") {
      const T = l * p, R = l * g, D = d * p, O = d * g;
      t[0] = p * _, t[4] = O - T * w, t[8] = D * w + R, t[1] = w, t[5] = l * _, t[9] = -d * _, t[2] = -g * _, t[6] = R * w + D, t[10] = T - O * w;
    } else if (e.order === "XZY") {
      const T = l * p, R = l * g, D = d * p, O = d * g;
      t[0] = p * _, t[4] = -w, t[8] = g * _, t[1] = T * w + O, t[5] = l * _, t[9] = R * w - D, t[2] = D * w - R, t[6] = d * _, t[10] = O * w + T;
    }
    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(PH, e, OH);
  }
  lookAt(e, t, r) {
    const i = this.elements;
    return _m.subVectors(e, t), _m.lengthSq() === 0 && (_m.z = 1), _m.normalize(), Hx.crossVectors(r, _m), Hx.lengthSq() === 0 && (Math.abs(r.z) === 1 ? _m.x += 1e-4 : _m.z += 1e-4, _m.normalize(), Hx.crossVectors(r, _m)), Hx.normalize(), p2.crossVectors(_m, Hx), i[0] = Hx.x, i[4] = p2.x, i[8] = _m.x, i[1] = Hx.y, i[5] = p2.y, i[9] = _m.y, i[2] = Hx.z, i[6] = p2.z, i[10] = _m.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const r = e.elements, i = t.elements, s = this.elements, l = r[0], d = r[4], p = r[8], g = r[12], _ = r[1], w = r[5], T = r[9], R = r[13], D = r[2], O = r[6], U = r[10], H = r[14], I = r[3], G = r[7], B = r[11], Q = r[15], K = i[0], te = i[4], Y = i[8], re = i[12], se = i[1], ce = i[5], ue = i[9], Me = i[13], me = i[2], De = i[6], Re = i[10], He = i[14], ve = i[3], fe = i[7], he = i[11], ye = i[15];
    return s[0] = l * K + d * se + p * me + g * ve, s[4] = l * te + d * ce + p * De + g * fe, s[8] = l * Y + d * ue + p * Re + g * he, s[12] = l * re + d * Me + p * He + g * ye, s[1] = _ * K + w * se + T * me + R * ve, s[5] = _ * te + w * ce + T * De + R * fe, s[9] = _ * Y + w * ue + T * Re + R * he, s[13] = _ * re + w * Me + T * He + R * ye, s[2] = D * K + O * se + U * me + H * ve, s[6] = D * te + O * ce + U * De + H * fe, s[10] = D * Y + O * ue + U * Re + H * he, s[14] = D * re + O * Me + U * He + H * ye, s[3] = I * K + G * se + B * me + Q * ve, s[7] = I * te + G * ce + B * De + Q * fe, s[11] = I * Y + G * ue + B * Re + Q * he, s[15] = I * re + G * Me + B * He + Q * ye, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], r = e[4], i = e[8], s = e[12], l = e[1], d = e[5], p = e[9], g = e[13], _ = e[2], w = e[6], T = e[10], R = e[14], D = e[3], O = e[7], U = e[11], H = e[15];
    return D * (+s * p * w - i * g * w - s * d * T + r * g * T + i * d * R - r * p * R) + O * (+t * p * R - t * g * T + s * l * T - i * l * R + i * g * _ - s * p * _) + U * (+t * g * w - t * d * R - s * l * w + r * l * R + s * d * _ - r * g * _) + H * (-i * d * _ - t * p * w + t * d * T + i * l * w - r * l * T + r * p * _);
  }
  transpose() {
    const e = this.elements;
    let t;
    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
  }
  setPosition(e, t, r) {
    const i = this.elements;
    return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = t, i[14] = r), this;
  }
  invert() {
    const e = this.elements, t = e[0], r = e[1], i = e[2], s = e[3], l = e[4], d = e[5], p = e[6], g = e[7], _ = e[8], w = e[9], T = e[10], R = e[11], D = e[12], O = e[13], U = e[14], H = e[15], I = w * U * g - O * T * g + O * p * R - d * U * R - w * p * H + d * T * H, G = D * T * g - _ * U * g - D * p * R + l * U * R + _ * p * H - l * T * H, B = _ * O * g - D * w * g + D * d * R - l * O * R - _ * d * H + l * w * H, Q = D * w * p - _ * O * p - D * d * T + l * O * T + _ * d * U - l * w * U, K = t * I + r * G + i * B + s * Q;
    if (K === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const te = 1 / K;
    return e[0] = I * te, e[1] = (O * T * s - w * U * s - O * i * R + r * U * R + w * i * H - r * T * H) * te, e[2] = (d * U * s - O * p * s + O * i * g - r * U * g - d * i * H + r * p * H) * te, e[3] = (w * p * s - d * T * s - w * i * g + r * T * g + d * i * R - r * p * R) * te, e[4] = G * te, e[5] = (_ * U * s - D * T * s + D * i * R - t * U * R - _ * i * H + t * T * H) * te, e[6] = (D * p * s - l * U * s - D * i * g + t * U * g + l * i * H - t * p * H) * te, e[7] = (l * T * s - _ * p * s + _ * i * g - t * T * g - l * i * R + t * p * R) * te, e[8] = B * te, e[9] = (D * w * s - _ * O * s - D * r * R + t * O * R + _ * r * H - t * w * H) * te, e[10] = (l * O * s - D * d * s + D * r * g - t * O * g - l * r * H + t * d * H) * te, e[11] = (_ * d * s - l * w * s - _ * r * g + t * w * g + l * r * R - t * d * R) * te, e[12] = Q * te, e[13] = (_ * O * i - D * w * i + D * r * T - t * O * T - _ * r * U + t * w * U) * te, e[14] = (D * d * i - l * O * i - D * r * p + t * O * p + l * r * U - t * d * U) * te, e[15] = (l * w * i - _ * d * i + _ * r * p - t * w * p - l * r * T + t * d * T) * te, this;
  }
  scale(e) {
    const t = this.elements, r = e.x, i = e.y, s = e.z;
    return t[0] *= r, t[4] *= i, t[8] *= s, t[1] *= r, t[5] *= i, t[9] *= s, t[2] *= r, t[6] *= i, t[10] *= s, t[3] *= r, t[7] *= i, t[11] *= s, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, r, i));
  }
  makeTranslation(e, t, r) {
    return this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      t,
      0,
      0,
      1,
      r,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const t = Math.cos(e), r = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      t,
      -r,
      0,
      0,
      r,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e), r = Math.sin(e);
    return this.set(
      t,
      0,
      r,
      0,
      0,
      1,
      0,
      0,
      -r,
      0,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e), r = Math.sin(e);
    return this.set(
      t,
      -r,
      0,
      0,
      r,
      t,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, t) {
    const r = Math.cos(t), i = Math.sin(t), s = 1 - r, l = e.x, d = e.y, p = e.z, g = s * l, _ = s * d;
    return this.set(
      g * l + r,
      g * d - i * p,
      g * p + i * d,
      0,
      g * d + i * p,
      _ * d + r,
      _ * p - i * l,
      0,
      g * p - i * d,
      _ * p + i * l,
      s * p * p + r,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t, r) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      r,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, t, r, i, s, l) {
    return this.set(
      1,
      r,
      s,
      0,
      e,
      1,
      l,
      0,
      t,
      i,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, t, r) {
    const i = this.elements, s = t._x, l = t._y, d = t._z, p = t._w, g = s + s, _ = l + l, w = d + d, T = s * g, R = s * _, D = s * w, O = l * _, U = l * w, H = d * w, I = p * g, G = p * _, B = p * w, Q = r.x, K = r.y, te = r.z;
    return i[0] = (1 - (O + H)) * Q, i[1] = (R + B) * Q, i[2] = (D - G) * Q, i[3] = 0, i[4] = (R - B) * K, i[5] = (1 - (T + H)) * K, i[6] = (U + I) * K, i[7] = 0, i[8] = (D + G) * te, i[9] = (U - I) * te, i[10] = (1 - (T + O)) * te, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this;
  }
  decompose(e, t, r) {
    const i = this.elements;
    let s = Mw.set(i[0], i[1], i[2]).length();
    const l = Mw.set(i[4], i[5], i[6]).length(), d = Mw.set(i[8], i[9], i[10]).length();
    this.determinant() < 0 && (s = -s), e.x = i[12], e.y = i[13], e.z = i[14], ng.copy(this);
    const g = 1 / s, _ = 1 / l, w = 1 / d;
    return ng.elements[0] *= g, ng.elements[1] *= g, ng.elements[2] *= g, ng.elements[4] *= _, ng.elements[5] *= _, ng.elements[6] *= _, ng.elements[8] *= w, ng.elements[9] *= w, ng.elements[10] *= w, t.setFromRotationMatrix(ng), r.x = s, r.y = l, r.z = d, this;
  }
  makePerspective(e, t, r, i, s, l) {
    const d = this.elements, p = 2 * s / (t - e), g = 2 * s / (r - i), _ = (t + e) / (t - e), w = (r + i) / (r - i), T = -(l + s) / (l - s), R = -2 * l * s / (l - s);
    return d[0] = p, d[4] = 0, d[8] = _, d[12] = 0, d[1] = 0, d[5] = g, d[9] = w, d[13] = 0, d[2] = 0, d[6] = 0, d[10] = T, d[14] = R, d[3] = 0, d[7] = 0, d[11] = -1, d[15] = 0, this;
  }
  makeOrthographic(e, t, r, i, s, l) {
    const d = this.elements, p = 1 / (t - e), g = 1 / (r - i), _ = 1 / (l - s), w = (t + e) * p, T = (r + i) * g, R = (l + s) * _;
    return d[0] = 2 * p, d[4] = 0, d[8] = 0, d[12] = -w, d[1] = 0, d[5] = 2 * g, d[9] = 0, d[13] = -T, d[2] = 0, d[6] = 0, d[10] = -2 * _, d[14] = -R, d[3] = 0, d[7] = 0, d[11] = 0, d[15] = 1, this;
  }
  equals(e) {
    const t = this.elements, r = e.elements;
    for (let i = 0; i < 16; i++)
      if (t[i] !== r[i])
        return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let r = 0; r < 16; r++)
      this.elements[r] = e[r + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.elements;
    return e[t] = r[0], e[t + 1] = r[1], e[t + 2] = r[2], e[t + 3] = r[3], e[t + 4] = r[4], e[t + 5] = r[5], e[t + 6] = r[6], e[t + 7] = r[7], e[t + 8] = r[8], e[t + 9] = r[9], e[t + 10] = r[10], e[t + 11] = r[11], e[t + 12] = r[12], e[t + 13] = r[13], e[t + 14] = r[14], e[t + 15] = r[15], e;
  }
}
const Mw = /* @__PURE__ */ new ge(), ng = /* @__PURE__ */ new Kr(), PH = /* @__PURE__ */ new ge(0, 0, 0), OH = /* @__PURE__ */ new ge(1, 1, 1), Hx = /* @__PURE__ */ new ge(), p2 = /* @__PURE__ */ new ge(), _m = /* @__PURE__ */ new ge(), zO = /* @__PURE__ */ new Kr(), NO = /* @__PURE__ */ new Po();
class $_ {
  constructor(e = 0, t = 0, r = 0, i = $_.DefaultOrder) {
    this.isEuler = !0, this._x = e, this._y = t, this._z = r, this._order = i;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, t, r, i = this._order) {
    return this._x = e, this._y = t, this._z = r, this._order = i, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, t = this._order, r = !0) {
    const i = e.elements, s = i[0], l = i[4], d = i[8], p = i[1], g = i[5], _ = i[9], w = i[2], T = i[6], R = i[10];
    switch (t) {
      case "XYZ":
        this._y = Math.asin(Zu(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._x = Math.atan2(-_, R), this._z = Math.atan2(-l, s)) : (this._x = Math.atan2(T, g), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-Zu(_, -1, 1)), Math.abs(_) < 0.9999999 ? (this._y = Math.atan2(d, R), this._z = Math.atan2(p, g)) : (this._y = Math.atan2(-w, s), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(Zu(T, -1, 1)), Math.abs(T) < 0.9999999 ? (this._y = Math.atan2(-w, R), this._z = Math.atan2(-l, g)) : (this._y = 0, this._z = Math.atan2(p, s));
        break;
      case "ZYX":
        this._y = Math.asin(-Zu(w, -1, 1)), Math.abs(w) < 0.9999999 ? (this._x = Math.atan2(T, R), this._z = Math.atan2(p, s)) : (this._x = 0, this._z = Math.atan2(-l, g));
        break;
      case "YZX":
        this._z = Math.asin(Zu(p, -1, 1)), Math.abs(p) < 0.9999999 ? (this._x = Math.atan2(-_, g), this._y = Math.atan2(-w, s)) : (this._x = 0, this._y = Math.atan2(d, R));
        break;
      case "XZY":
        this._z = Math.asin(-Zu(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(T, g), this._y = Math.atan2(d, s)) : (this._x = Math.atan2(-_, R), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
    }
    return this._order = t, r === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, r) {
    return zO.makeRotationFromQuaternion(e), this.setFromRotationMatrix(zO, t, r);
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return NO.setFromEuler(this), this.setFromQuaternion(NO, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
  toVector3() {
    console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead");
  }
}
$_.DefaultOrder = "XYZ";
$_.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
class G_ {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
let UH = 0;
const FO = /* @__PURE__ */ new ge(), Tw = /* @__PURE__ */ new Po(), b0 = /* @__PURE__ */ new Kr(), m2 = /* @__PURE__ */ new ge(), KE = /* @__PURE__ */ new ge(), zH = /* @__PURE__ */ new ge(), NH = /* @__PURE__ */ new Po(), kO = /* @__PURE__ */ new ge(1, 0, 0), IO = /* @__PURE__ */ new ge(0, 1, 0), BO = /* @__PURE__ */ new ge(0, 0, 1), FH = { type: "added" }, HO = { type: "removed" };
class Xa extends Cm {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: UH++ }), this.uuid = Em(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Xa.DefaultUp.clone();
    const e = new ge(), t = new $_(), r = new Po(), i = new ge(1, 1, 1);
    function s() {
      r.setFromEuler(t, !1);
    }
    function l() {
      t.setFromQuaternion(r, void 0, !1);
    }
    t._onChange(s), r._onChange(l), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: t
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: r
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: i
      },
      modelViewMatrix: {
        value: new Kr()
      },
      normalMatrix: {
        value: new Xh()
      }
    }), this.matrix = new Kr(), this.matrixWorld = new Kr(), this.matrixAutoUpdate = Xa.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new G_(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return Tw.setFromAxisAngle(e, t), this.quaternion.multiply(Tw), this;
  }
  rotateOnWorldAxis(e, t) {
    return Tw.setFromAxisAngle(e, t), this.quaternion.premultiply(Tw), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(kO, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(IO, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(BO, e);
  }
  translateOnAxis(e, t) {
    return FO.copy(e).applyQuaternion(this.quaternion), this.position.add(FO.multiplyScalar(t)), this;
  }
  translateX(e) {
    return this.translateOnAxis(kO, e);
  }
  translateY(e) {
    return this.translateOnAxis(IO, e);
  }
  translateZ(e) {
    return this.translateOnAxis(BO, e);
  }
  localToWorld(e) {
    return e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return e.applyMatrix4(b0.copy(this.matrixWorld).invert());
  }
  lookAt(e, t, r) {
    e.isVector3 ? m2.copy(e) : m2.set(e, t, r);
    const i = this.parent;
    this.updateWorldMatrix(!0, !1), KE.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? b0.lookAt(KE, m2, this.up) : b0.lookAt(m2, KE, this.up), this.quaternion.setFromRotationMatrix(b0), i && (b0.extractRotation(i.matrixWorld), Tw.setFromRotationMatrix(b0), this.quaternion.premultiply(Tw.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++)
        this.add(arguments[t]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(FH)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let r = 0; r < arguments.length; r++)
        this.remove(arguments[r]);
      return this;
    }
    const t = this.children.indexOf(e);
    return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(HO)), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    for (let e = 0; e < this.children.length; e++) {
      const t = this.children[e];
      t.parent = null, t.dispatchEvent(HO);
    }
    return this.children.length = 0, this;
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), b0.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), b0.multiply(e.parent.matrixWorld)), e.applyMatrix4(b0), this.add(e), e.updateWorldMatrix(!1, !0), this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t)
      return this;
    for (let r = 0, i = this.children.length; r < i; r++) {
      const l = this.children[r].getObjectByProperty(e, t);
      if (l !== void 0)
        return l;
    }
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(KE, e, zH), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(KE, NH, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const t = this.children;
    for (let r = 0, i = t.length; r < i; r++)
      t[r].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1)
      return;
    e(this);
    const t = this.children;
    for (let r = 0, i = t.length; r < i; r++)
      t[r].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
    const t = this.children;
    for (let r = 0, i = t.length; r < i; r++)
      t[r].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, t) {
    const r = this.parent;
    if (e === !0 && r !== null && r.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0) {
      const i = this.children;
      for (let s = 0, l = i.length; s < l; s++)
        i[s].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string", r = {};
    t && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, r.metadata = {
      version: 4.5,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const i = {};
    i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.castShadow === !0 && (i.castShadow = !0), this.receiveShadow === !0 && (i.receiveShadow = !0), this.visible === !1 && (i.visible = !1), this.frustumCulled === !1 && (i.frustumCulled = !1), this.renderOrder !== 0 && (i.renderOrder = this.renderOrder), JSON.stringify(this.userData) !== "{}" && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON()));
    function s(d, p) {
      return d[p.uuid] === void 0 && (d[p.uuid] = p.toJSON(e)), p.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (i.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      i.geometry = s(e.geometries, this.geometry);
      const d = this.geometry.parameters;
      if (d !== void 0 && d.shapes !== void 0) {
        const p = d.shapes;
        if (Array.isArray(p))
          for (let g = 0, _ = p.length; g < _; g++) {
            const w = p[g];
            s(e.shapes, w);
          }
        else
          s(e.shapes, p);
      }
    }
    if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(e.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const d = [];
        for (let p = 0, g = this.material.length; p < g; p++)
          d.push(s(e.materials, this.material[p]));
        i.material = d;
      } else
        i.material = s(e.materials, this.material);
    if (this.children.length > 0) {
      i.children = [];
      for (let d = 0; d < this.children.length; d++)
        i.children.push(this.children[d].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      i.animations = [];
      for (let d = 0; d < this.animations.length; d++) {
        const p = this.animations[d];
        i.animations.push(s(e.animations, p));
      }
    }
    if (t) {
      const d = l(e.geometries), p = l(e.materials), g = l(e.textures), _ = l(e.images), w = l(e.shapes), T = l(e.skeletons), R = l(e.animations), D = l(e.nodes);
      d.length > 0 && (r.geometries = d), p.length > 0 && (r.materials = p), g.length > 0 && (r.textures = g), _.length > 0 && (r.images = _), w.length > 0 && (r.shapes = w), T.length > 0 && (r.skeletons = T), R.length > 0 && (r.animations = R), D.length > 0 && (r.nodes = D);
    }
    return r.object = i, r;
    function l(d) {
      const p = [];
      for (const g in d) {
        const _ = d[g];
        delete _.metadata, p.push(_);
      }
      return p;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
      for (let r = 0; r < e.children.length; r++) {
        const i = e.children[r];
        this.add(i.clone());
      }
    return this;
  }
}
Xa.DefaultUp = /* @__PURE__ */ new ge(0, 1, 0);
Xa.DefaultMatrixAutoUpdate = !0;
const rg = /* @__PURE__ */ new ge(), E0 = /* @__PURE__ */ new ge(), UA = /* @__PURE__ */ new ge(), M0 = /* @__PURE__ */ new ge(), Cw = /* @__PURE__ */ new ge(), Rw = /* @__PURE__ */ new ge(), VO = /* @__PURE__ */ new ge(), zA = /* @__PURE__ */ new ge(), NA = /* @__PURE__ */ new ge(), FA = /* @__PURE__ */ new ge();
class wm {
  constructor(e = new ge(), t = new ge(), r = new ge()) {
    this.a = e, this.b = t, this.c = r;
  }
  static getNormal(e, t, r, i) {
    i.subVectors(r, t), rg.subVectors(e, t), i.cross(rg);
    const s = i.lengthSq();
    return s > 0 ? i.multiplyScalar(1 / Math.sqrt(s)) : i.set(0, 0, 0);
  }
  static getBarycoord(e, t, r, i, s) {
    rg.subVectors(i, t), E0.subVectors(r, t), UA.subVectors(e, t);
    const l = rg.dot(rg), d = rg.dot(E0), p = rg.dot(UA), g = E0.dot(E0), _ = E0.dot(UA), w = l * g - d * d;
    if (w === 0)
      return s.set(-2, -1, -1);
    const T = 1 / w, R = (g * p - d * _) * T, D = (l * _ - d * p) * T;
    return s.set(1 - R - D, D, R);
  }
  static containsPoint(e, t, r, i) {
    return this.getBarycoord(e, t, r, i, M0), M0.x >= 0 && M0.y >= 0 && M0.x + M0.y <= 1;
  }
  static getUV(e, t, r, i, s, l, d, p) {
    return this.getBarycoord(e, t, r, i, M0), p.set(0, 0), p.addScaledVector(s, M0.x), p.addScaledVector(l, M0.y), p.addScaledVector(d, M0.z), p;
  }
  static isFrontFacing(e, t, r, i) {
    return rg.subVectors(r, t), E0.subVectors(e, t), rg.cross(E0).dot(i) < 0;
  }
  set(e, t, r) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(r), this;
  }
  setFromPointsAndIndices(e, t, r, i) {
    return this.a.copy(e[t]), this.b.copy(e[r]), this.c.copy(e[i]), this;
  }
  setFromAttributeAndIndices(e, t, r, i) {
    return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, r), this.c.fromBufferAttribute(e, i), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return rg.subVectors(this.c, this.b), E0.subVectors(this.a, this.b), rg.cross(E0).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return wm.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return wm.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getUV(e, t, r, i, s) {
    return wm.getUV(e, this.a, this.b, this.c, t, r, i, s);
  }
  containsPoint(e) {
    return wm.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return wm.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const r = this.a, i = this.b, s = this.c;
    let l, d;
    Cw.subVectors(i, r), Rw.subVectors(s, r), zA.subVectors(e, r);
    const p = Cw.dot(zA), g = Rw.dot(zA);
    if (p <= 0 && g <= 0)
      return t.copy(r);
    NA.subVectors(e, i);
    const _ = Cw.dot(NA), w = Rw.dot(NA);
    if (_ >= 0 && w <= _)
      return t.copy(i);
    const T = p * w - _ * g;
    if (T <= 0 && p >= 0 && _ <= 0)
      return l = p / (p - _), t.copy(r).addScaledVector(Cw, l);
    FA.subVectors(e, s);
    const R = Cw.dot(FA), D = Rw.dot(FA);
    if (D >= 0 && R <= D)
      return t.copy(s);
    const O = R * g - p * D;
    if (O <= 0 && g >= 0 && D <= 0)
      return d = g / (g - D), t.copy(r).addScaledVector(Rw, d);
    const U = _ * D - R * w;
    if (U <= 0 && w - _ >= 0 && R - D >= 0)
      return VO.subVectors(s, i), d = (w - _) / (w - _ + (R - D)), t.copy(i).addScaledVector(VO, d);
    const H = 1 / (U + O + T);
    return l = O * H, d = T * H, t.copy(r).addScaledVector(Cw, l).addScaledVector(Rw, d);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
let kH = 0;
class hf extends Cm {
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: kH++ }), this.uuid = Em(), this.name = "", this.type = "Material", this.blending = P0, this.side = vy, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = zC, this.blendDst = NC, this.blendEquation = L_, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = bC, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = RF, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = pC, this.stencilZFail = pC, this.stencilZPass = pC, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const r = e[t];
        if (r === void 0) {
          console.warn("THREE.Material: '" + t + "' parameter is undefined.");
          continue;
        }
        if (t === "shading") {
          console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = r === kN;
          continue;
        }
        const i = this[t];
        if (i === void 0) {
          console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.");
          continue;
        }
        i && i.isColor ? i.set(r) : i && i.isVector3 && r && r.isVector3 ? i.copy(r) : this[t] = r;
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = {
      textures: {},
      images: {}
    });
    const r = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.color && this.color.isColor && (r.color = this.color.getHex()), this.roughness !== void 0 && (r.roughness = this.roughness), this.metalness !== void 0 && (r.metalness = this.metalness), this.sheen !== void 0 && (r.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (r.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (r.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (r.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (r.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (r.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (r.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (r.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (r.shininess = this.shininess), this.clearcoat !== void 0 && (r.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (r.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (r.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (r.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, r.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.iridescence !== void 0 && (r.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (r.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (r.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (r.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (r.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.map && this.map.isTexture && (r.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (r.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (r.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (r.lightMap = this.lightMap.toJSON(e).uuid, r.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (r.aoMap = this.aoMap.toJSON(e).uuid, r.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (r.bumpMap = this.bumpMap.toJSON(e).uuid, r.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (r.normalMap = this.normalMap.toJSON(e).uuid, r.normalMapType = this.normalMapType, r.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (r.displacementMap = this.displacementMap.toJSON(e).uuid, r.displacementScale = this.displacementScale, r.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (r.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (r.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (r.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (r.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (r.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (r.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (r.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (r.combine = this.combine)), this.envMapIntensity !== void 0 && (r.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (r.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (r.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (r.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (r.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (r.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (r.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (r.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && (r.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (r.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (r.size = this.size), this.shadowSide !== null && (r.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (r.sizeAttenuation = this.sizeAttenuation), this.blending !== P0 && (r.blending = this.blending), this.side !== vy && (r.side = this.side), this.vertexColors && (r.vertexColors = !0), this.opacity < 1 && (r.opacity = this.opacity), this.transparent === !0 && (r.transparent = this.transparent), r.depthFunc = this.depthFunc, r.depthTest = this.depthTest, r.depthWrite = this.depthWrite, r.colorWrite = this.colorWrite, r.stencilWrite = this.stencilWrite, r.stencilWriteMask = this.stencilWriteMask, r.stencilFunc = this.stencilFunc, r.stencilRef = this.stencilRef, r.stencilFuncMask = this.stencilFuncMask, r.stencilFail = this.stencilFail, r.stencilZFail = this.stencilZFail, r.stencilZPass = this.stencilZPass, this.rotation !== void 0 && this.rotation !== 0 && (r.rotation = this.rotation), this.polygonOffset === !0 && (r.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (r.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (r.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (r.linewidth = this.linewidth), this.dashSize !== void 0 && (r.dashSize = this.dashSize), this.gapSize !== void 0 && (r.gapSize = this.gapSize), this.scale !== void 0 && (r.scale = this.scale), this.dithering === !0 && (r.dithering = !0), this.alphaTest > 0 && (r.alphaTest = this.alphaTest), this.alphaToCoverage === !0 && (r.alphaToCoverage = this.alphaToCoverage), this.premultipliedAlpha === !0 && (r.premultipliedAlpha = this.premultipliedAlpha), this.wireframe === !0 && (r.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (r.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (r.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (r.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (r.flatShading = this.flatShading), this.visible === !1 && (r.visible = !1), this.toneMapped === !1 && (r.toneMapped = !1), this.fog === !1 && (r.fog = !1), JSON.stringify(this.userData) !== "{}" && (r.userData = this.userData);
    function i(s) {
      const l = [];
      for (const d in s) {
        const p = s[d];
        delete p.metadata, l.push(p);
      }
      return l;
    }
    if (t) {
      const s = i(e.textures), l = i(e.images);
      s.length > 0 && (r.textures = s), l.length > 0 && (r.images = l);
    }
    return r;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const t = e.clippingPlanes;
    let r = null;
    if (t !== null) {
      const i = t.length;
      r = new Array(i);
      for (let s = 0; s !== i; ++s)
        r[s] = t[s].clone();
    }
    return this.clippingPlanes = r, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
class fg extends hf {
  constructor(e) {
    super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Un(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = ZM, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
const xc = /* @__PURE__ */ new ge(), v2 = /* @__PURE__ */ new zt();
class ls {
  constructor(e, t, r) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = r === !0, this.usage = OM, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this;
  }
  copyAt(e, t, r) {
    e *= this.itemSize, r *= t.itemSize;
    for (let i = 0, s = this.itemSize; i < s; i++)
      this.array[e + i] = t.array[r + i];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  copyColorsArray(e) {
    const t = this.array;
    let r = 0;
    for (let i = 0, s = e.length; i < s; i++) {
      let l = e[i];
      l === void 0 && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), l = new Un()), t[r++] = l.r, t[r++] = l.g, t[r++] = l.b;
    }
    return this;
  }
  copyVector2sArray(e) {
    const t = this.array;
    let r = 0;
    for (let i = 0, s = e.length; i < s; i++) {
      let l = e[i];
      l === void 0 && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), l = new zt()), t[r++] = l.x, t[r++] = l.y;
    }
    return this;
  }
  copyVector3sArray(e) {
    const t = this.array;
    let r = 0;
    for (let i = 0, s = e.length; i < s; i++) {
      let l = e[i];
      l === void 0 && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), l = new ge()), t[r++] = l.x, t[r++] = l.y, t[r++] = l.z;
    }
    return this;
  }
  copyVector4sArray(e) {
    const t = this.array;
    let r = 0;
    for (let i = 0, s = e.length; i < s; i++) {
      let l = e[i];
      l === void 0 && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), l = new ra()), t[r++] = l.x, t[r++] = l.y, t[r++] = l.z, t[r++] = l.w;
    }
    return this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, r = this.count; t < r; t++)
        v2.fromBufferAttribute(this, t), v2.applyMatrix3(e), this.setXY(t, v2.x, v2.y);
    else if (this.itemSize === 3)
      for (let t = 0, r = this.count; t < r; t++)
        xc.fromBufferAttribute(this, t), xc.applyMatrix3(e), this.setXYZ(t, xc.x, xc.y, xc.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, r = this.count; t < r; t++)
      xc.fromBufferAttribute(this, t), xc.applyMatrix4(e), this.setXYZ(t, xc.x, xc.y, xc.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, r = this.count; t < r; t++)
      xc.fromBufferAttribute(this, t), xc.applyNormalMatrix(e), this.setXYZ(t, xc.x, xc.y, xc.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, r = this.count; t < r; t++)
      xc.fromBufferAttribute(this, t), xc.transformDirection(e), this.setXYZ(t, xc.x, xc.y, xc.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getX(e) {
    return this.array[e * this.itemSize];
  }
  setX(e, t) {
    return this.array[e * this.itemSize] = t, this;
  }
  getY(e) {
    return this.array[e * this.itemSize + 1];
  }
  setY(e, t) {
    return this.array[e * this.itemSize + 1] = t, this;
  }
  getZ(e) {
    return this.array[e * this.itemSize + 2];
  }
  setZ(e, t) {
    return this.array[e * this.itemSize + 2] = t, this;
  }
  getW(e) {
    return this.array[e * this.itemSize + 3];
  }
  setW(e, t) {
    return this.array[e * this.itemSize + 3] = t, this;
  }
  setXY(e, t, r) {
    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = r, this;
  }
  setXYZ(e, t, r, i) {
    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = r, this.array[e + 2] = i, this;
  }
  setXYZW(e, t, r, i, s) {
    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = r, this.array[e + 2] = i, this.array[e + 3] = s, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (e.name = this.name), this.usage !== OM && (e.usage = this.usage), (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (e.updateRange = this.updateRange), e;
  }
}
class IH extends ls {
  constructor(e, t, r) {
    super(new Int8Array(e), t, r);
  }
}
class BH extends ls {
  constructor(e, t, r) {
    super(new Uint8Array(e), t, r);
  }
}
class HH extends ls {
  constructor(e, t, r) {
    super(new Uint8ClampedArray(e), t, r);
  }
}
class VH extends ls {
  constructor(e, t, r) {
    super(new Int16Array(e), t, r);
  }
}
class Q3 extends ls {
  constructor(e, t, r) {
    super(new Uint16Array(e), t, r);
  }
}
class GH extends ls {
  constructor(e, t, r) {
    super(new Int32Array(e), t, r);
  }
}
class Z3 extends ls {
  constructor(e, t, r) {
    super(new Uint32Array(e), t, r);
  }
}
class WH extends ls {
  constructor(e, t, r) {
    super(new Uint16Array(e), t, r), this.isFloat16BufferAttribute = !0;
  }
}
class sr extends ls {
  constructor(e, t, r) {
    super(new Float32Array(e), t, r);
  }
}
class jH extends ls {
  constructor(e, t, r) {
    super(new Float64Array(e), t, r);
  }
}
let YH = 0;
const gv = /* @__PURE__ */ new Kr(), kA = /* @__PURE__ */ new Xa(), Aw = /* @__PURE__ */ new ge(), Sm = /* @__PURE__ */ new cg(), $E = /* @__PURE__ */ new cg(), Wf = /* @__PURE__ */ new ge();
class oi extends Cm {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: YH++ }), this.uuid = Em(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (LF(e) ? Z3 : Q3)(e, 1) : this.index = e, this;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return this.attributes[e] = t, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, r = 0) {
    this.groups.push({
      start: e,
      count: t,
      materialIndex: r
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    this.drawRange.start = e, this.drawRange.count = t;
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
    const r = this.attributes.normal;
    if (r !== void 0) {
      const s = new Xh().getNormalMatrix(e);
      r.applyNormalMatrix(s), r.needsUpdate = !0;
    }
    const i = this.attributes.tangent;
    return i !== void 0 && (i.transformDirection(e), i.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return gv.makeRotationFromQuaternion(e), this.applyMatrix4(gv), this;
  }
  rotateX(e) {
    return gv.makeRotationX(e), this.applyMatrix4(gv), this;
  }
  rotateY(e) {
    return gv.makeRotationY(e), this.applyMatrix4(gv), this;
  }
  rotateZ(e) {
    return gv.makeRotationZ(e), this.applyMatrix4(gv), this;
  }
  translate(e, t, r) {
    return gv.makeTranslation(e, t, r), this.applyMatrix4(gv), this;
  }
  scale(e, t, r) {
    return gv.makeScale(e, t, r), this.applyMatrix4(gv), this;
  }
  lookAt(e) {
    return kA.lookAt(e), kA.updateMatrix(), this.applyMatrix4(kA.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(Aw).negate(), this.translate(Aw.x, Aw.y, Aw.z), this;
  }
  setFromPoints(e) {
    const t = [];
    for (let r = 0, i = e.length; r < i; r++) {
      const s = e[r];
      t.push(s.x, s.y, s.z || 0);
    }
    return this.setAttribute("position", new sr(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new cg());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(
        new ge(-1 / 0, -1 / 0, -1 / 0),
        new ge(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), t)
        for (let r = 0, i = t.length; r < i; r++) {
          const s = t[r];
          Sm.setFromBufferAttribute(s), this.morphTargetsRelative ? (Wf.addVectors(this.boundingBox.min, Sm.min), this.boundingBox.expandByPoint(Wf), Wf.addVectors(this.boundingBox.max, Sm.max), this.boundingBox.expandByPoint(Wf)) : (this.boundingBox.expandByPoint(Sm.min), this.boundingBox.expandByPoint(Sm.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new yy());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new ge(), 1 / 0);
      return;
    }
    if (e) {
      const r = this.boundingSphere.center;
      if (Sm.setFromBufferAttribute(e), t)
        for (let s = 0, l = t.length; s < l; s++) {
          const d = t[s];
          $E.setFromBufferAttribute(d), this.morphTargetsRelative ? (Wf.addVectors(Sm.min, $E.min), Sm.expandByPoint(Wf), Wf.addVectors(Sm.max, $E.max), Sm.expandByPoint(Wf)) : (Sm.expandByPoint($E.min), Sm.expandByPoint($E.max));
        }
      Sm.getCenter(r);
      let i = 0;
      for (let s = 0, l = e.count; s < l; s++)
        Wf.fromBufferAttribute(e, s), i = Math.max(i, r.distanceToSquared(Wf));
      if (t)
        for (let s = 0, l = t.length; s < l; s++) {
          const d = t[s], p = this.morphTargetsRelative;
          for (let g = 0, _ = d.count; g < _; g++)
            Wf.fromBufferAttribute(d, g), p && (Aw.fromBufferAttribute(e, g), Wf.add(Aw)), i = Math.max(i, r.distanceToSquared(Wf));
        }
      this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, t = this.attributes;
    if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const r = e.array, i = t.position.array, s = t.normal.array, l = t.uv.array, d = i.length / 3;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new ls(new Float32Array(4 * d), 4));
    const p = this.getAttribute("tangent").array, g = [], _ = [];
    for (let se = 0; se < d; se++)
      g[se] = new ge(), _[se] = new ge();
    const w = new ge(), T = new ge(), R = new ge(), D = new zt(), O = new zt(), U = new zt(), H = new ge(), I = new ge();
    function G(se, ce, ue) {
      w.fromArray(i, se * 3), T.fromArray(i, ce * 3), R.fromArray(i, ue * 3), D.fromArray(l, se * 2), O.fromArray(l, ce * 2), U.fromArray(l, ue * 2), T.sub(w), R.sub(w), O.sub(D), U.sub(D);
      const Me = 1 / (O.x * U.y - U.x * O.y);
      !isFinite(Me) || (H.copy(T).multiplyScalar(U.y).addScaledVector(R, -O.y).multiplyScalar(Me), I.copy(R).multiplyScalar(O.x).addScaledVector(T, -U.x).multiplyScalar(Me), g[se].add(H), g[ce].add(H), g[ue].add(H), _[se].add(I), _[ce].add(I), _[ue].add(I));
    }
    let B = this.groups;
    B.length === 0 && (B = [{
      start: 0,
      count: r.length
    }]);
    for (let se = 0, ce = B.length; se < ce; ++se) {
      const ue = B[se], Me = ue.start, me = ue.count;
      for (let De = Me, Re = Me + me; De < Re; De += 3)
        G(
          r[De + 0],
          r[De + 1],
          r[De + 2]
        );
    }
    const Q = new ge(), K = new ge(), te = new ge(), Y = new ge();
    function re(se) {
      te.fromArray(s, se * 3), Y.copy(te);
      const ce = g[se];
      Q.copy(ce), Q.sub(te.multiplyScalar(te.dot(ce))).normalize(), K.crossVectors(Y, ce);
      const Me = K.dot(_[se]) < 0 ? -1 : 1;
      p[se * 4] = Q.x, p[se * 4 + 1] = Q.y, p[se * 4 + 2] = Q.z, p[se * 4 + 3] = Me;
    }
    for (let se = 0, ce = B.length; se < ce; ++se) {
      const ue = B[se], Me = ue.start, me = ue.count;
      for (let De = Me, Re = Me + me; De < Re; De += 3)
        re(r[De + 0]), re(r[De + 1]), re(r[De + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index, t = this.getAttribute("position");
    if (t !== void 0) {
      let r = this.getAttribute("normal");
      if (r === void 0)
        r = new ls(new Float32Array(t.count * 3), 3), this.setAttribute("normal", r);
      else
        for (let T = 0, R = r.count; T < R; T++)
          r.setXYZ(T, 0, 0, 0);
      const i = new ge(), s = new ge(), l = new ge(), d = new ge(), p = new ge(), g = new ge(), _ = new ge(), w = new ge();
      if (e)
        for (let T = 0, R = e.count; T < R; T += 3) {
          const D = e.getX(T + 0), O = e.getX(T + 1), U = e.getX(T + 2);
          i.fromBufferAttribute(t, D), s.fromBufferAttribute(t, O), l.fromBufferAttribute(t, U), _.subVectors(l, s), w.subVectors(i, s), _.cross(w), d.fromBufferAttribute(r, D), p.fromBufferAttribute(r, O), g.fromBufferAttribute(r, U), d.add(_), p.add(_), g.add(_), r.setXYZ(D, d.x, d.y, d.z), r.setXYZ(O, p.x, p.y, p.z), r.setXYZ(U, g.x, g.y, g.z);
        }
      else
        for (let T = 0, R = t.count; T < R; T += 3)
          i.fromBufferAttribute(t, T + 0), s.fromBufferAttribute(t, T + 1), l.fromBufferAttribute(t, T + 2), _.subVectors(l, s), w.subVectors(i, s), _.cross(w), r.setXYZ(T + 0, _.x, _.y, _.z), r.setXYZ(T + 1, _.x, _.y, _.z), r.setXYZ(T + 2, _.x, _.y, _.z);
      this.normalizeNormals(), r.needsUpdate = !0;
    }
  }
  merge(e, t) {
    if (!(e && e.isBufferGeometry)) {
      console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e);
      return;
    }
    t === void 0 && (t = 0, console.warn(
      "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
    ));
    const r = this.attributes;
    for (const i in r) {
      if (e.attributes[i] === void 0)
        continue;
      const l = r[i].array, d = e.attributes[i], p = d.array, g = d.itemSize * t, _ = Math.min(p.length, l.length - g);
      for (let w = 0, T = g; w < _; w++, T++)
        l[T] = p[w];
    }
    return this;
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, r = e.count; t < r; t++)
      Wf.fromBufferAttribute(e, t), Wf.normalize(), e.setXYZ(t, Wf.x, Wf.y, Wf.z);
  }
  toNonIndexed() {
    function e(d, p) {
      const g = d.array, _ = d.itemSize, w = d.normalized, T = new g.constructor(p.length * _);
      let R = 0, D = 0;
      for (let O = 0, U = p.length; O < U; O++) {
        d.isInterleavedBufferAttribute ? R = p[O] * d.data.stride + d.offset : R = p[O] * _;
        for (let H = 0; H < _; H++)
          T[D++] = g[R++];
      }
      return new ls(T, _, w);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const t = new oi(), r = this.index.array, i = this.attributes;
    for (const d in i) {
      const p = i[d], g = e(p, r);
      t.setAttribute(d, g);
    }
    const s = this.morphAttributes;
    for (const d in s) {
      const p = [], g = s[d];
      for (let _ = 0, w = g.length; _ < w; _++) {
        const T = g[_], R = e(T, r);
        p.push(R);
      }
      t.morphAttributes[d] = p;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const l = this.groups;
    for (let d = 0, p = l.length; d < p; d++) {
      const g = l[d];
      t.addGroup(g.start, g.count, g.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const p = this.parameters;
      for (const g in p)
        p[g] !== void 0 && (e[g] = p[g]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null && (e.data.index = {
      type: t.array.constructor.name,
      array: Array.prototype.slice.call(t.array)
    });
    const r = this.attributes;
    for (const p in r) {
      const g = r[p];
      e.data.attributes[p] = g.toJSON(e.data);
    }
    const i = {};
    let s = !1;
    for (const p in this.morphAttributes) {
      const g = this.morphAttributes[p], _ = [];
      for (let w = 0, T = g.length; w < T; w++) {
        const R = g[w];
        _.push(R.toJSON(e.data));
      }
      _.length > 0 && (i[p] = _, s = !0);
    }
    s && (e.data.morphAttributes = i, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const l = this.groups;
    l.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(l)));
    const d = this.boundingSphere;
    return d !== null && (e.data.boundingSphere = {
      center: d.center.toArray(),
      radius: d.radius
    }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const t = {};
    this.name = e.name;
    const r = e.index;
    r !== null && this.setIndex(r.clone(t));
    const i = e.attributes;
    for (const g in i) {
      const _ = i[g];
      this.setAttribute(g, _.clone(t));
    }
    const s = e.morphAttributes;
    for (const g in s) {
      const _ = [], w = s[g];
      for (let T = 0, R = w.length; T < R; T++)
        _.push(w[T].clone(t));
      this.morphAttributes[g] = _;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const l = e.groups;
    for (let g = 0, _ = l.length; g < _; g++) {
      const w = l[g];
      this.addGroup(w.start, w.count, w.materialIndex);
    }
    const d = e.boundingBox;
    d !== null && (this.boundingBox = d.clone());
    const p = e.boundingSphere;
    return p !== null && (this.boundingSphere = p.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, e.parameters !== void 0 && (this.parameters = Object.assign({}, e.parameters)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const GO = /* @__PURE__ */ new Kr(), Dw = /* @__PURE__ */ new KM(), IA = /* @__PURE__ */ new yy(), Vx = /* @__PURE__ */ new ge(), Gx = /* @__PURE__ */ new ge(), Wx = /* @__PURE__ */ new ge(), BA = /* @__PURE__ */ new ge(), HA = /* @__PURE__ */ new ge(), VA = /* @__PURE__ */ new ge(), g2 = /* @__PURE__ */ new ge(), y2 = /* @__PURE__ */ new ge(), x2 = /* @__PURE__ */ new ge(), _2 = /* @__PURE__ */ new zt(), S2 = /* @__PURE__ */ new zt(), w2 = /* @__PURE__ */ new zt(), GA = /* @__PURE__ */ new ge(), b2 = /* @__PURE__ */ new ge();
class Fn extends Xa {
  constructor(e = new oi(), t = new fg()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this;
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, r = Object.keys(t);
    if (r.length > 0) {
      const i = t[r[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let s = 0, l = i.length; s < l; s++) {
          const d = i[s].name || String(s);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[d] = s;
        }
      }
    }
  }
  raycast(e, t) {
    const r = this.geometry, i = this.material, s = this.matrixWorld;
    if (i === void 0 || (r.boundingSphere === null && r.computeBoundingSphere(), IA.copy(r.boundingSphere), IA.applyMatrix4(s), e.ray.intersectsSphere(IA) === !1) || (GO.copy(s).invert(), Dw.copy(e.ray).applyMatrix4(GO), r.boundingBox !== null && Dw.intersectsBox(r.boundingBox) === !1))
      return;
    let l;
    const d = r.index, p = r.attributes.position, g = r.morphAttributes.position, _ = r.morphTargetsRelative, w = r.attributes.uv, T = r.attributes.uv2, R = r.groups, D = r.drawRange;
    if (d !== null)
      if (Array.isArray(i))
        for (let O = 0, U = R.length; O < U; O++) {
          const H = R[O], I = i[H.materialIndex], G = Math.max(H.start, D.start), B = Math.min(d.count, Math.min(H.start + H.count, D.start + D.count));
          for (let Q = G, K = B; Q < K; Q += 3) {
            const te = d.getX(Q), Y = d.getX(Q + 1), re = d.getX(Q + 2);
            l = E2(this, I, e, Dw, p, g, _, w, T, te, Y, re), l && (l.faceIndex = Math.floor(Q / 3), l.face.materialIndex = H.materialIndex, t.push(l));
          }
        }
      else {
        const O = Math.max(0, D.start), U = Math.min(d.count, D.start + D.count);
        for (let H = O, I = U; H < I; H += 3) {
          const G = d.getX(H), B = d.getX(H + 1), Q = d.getX(H + 2);
          l = E2(this, i, e, Dw, p, g, _, w, T, G, B, Q), l && (l.faceIndex = Math.floor(H / 3), t.push(l));
        }
      }
    else if (p !== void 0)
      if (Array.isArray(i))
        for (let O = 0, U = R.length; O < U; O++) {
          const H = R[O], I = i[H.materialIndex], G = Math.max(H.start, D.start), B = Math.min(p.count, Math.min(H.start + H.count, D.start + D.count));
          for (let Q = G, K = B; Q < K; Q += 3) {
            const te = Q, Y = Q + 1, re = Q + 2;
            l = E2(this, I, e, Dw, p, g, _, w, T, te, Y, re), l && (l.faceIndex = Math.floor(Q / 3), l.face.materialIndex = H.materialIndex, t.push(l));
          }
        }
      else {
        const O = Math.max(0, D.start), U = Math.min(p.count, D.start + D.count);
        for (let H = O, I = U; H < I; H += 3) {
          const G = H, B = H + 1, Q = H + 2;
          l = E2(this, i, e, Dw, p, g, _, w, T, G, B, Q), l && (l.faceIndex = Math.floor(H / 3), t.push(l));
        }
      }
  }
}
function XH(a, e, t, r, i, s, l, d) {
  let p;
  if (e.side === cf ? p = r.intersectTriangle(l, s, i, !0, d) : p = r.intersectTriangle(i, s, l, e.side !== Yh, d), p === null)
    return null;
  b2.copy(d), b2.applyMatrix4(a.matrixWorld);
  const g = t.ray.origin.distanceTo(b2);
  return g < t.near || g > t.far ? null : {
    distance: g,
    point: b2.clone(),
    object: a
  };
}
function E2(a, e, t, r, i, s, l, d, p, g, _, w) {
  Vx.fromBufferAttribute(i, g), Gx.fromBufferAttribute(i, _), Wx.fromBufferAttribute(i, w);
  const T = a.morphTargetInfluences;
  if (s && T) {
    g2.set(0, 0, 0), y2.set(0, 0, 0), x2.set(0, 0, 0);
    for (let D = 0, O = s.length; D < O; D++) {
      const U = T[D], H = s[D];
      U !== 0 && (BA.fromBufferAttribute(H, g), HA.fromBufferAttribute(H, _), VA.fromBufferAttribute(H, w), l ? (g2.addScaledVector(BA, U), y2.addScaledVector(HA, U), x2.addScaledVector(VA, U)) : (g2.addScaledVector(BA.sub(Vx), U), y2.addScaledVector(HA.sub(Gx), U), x2.addScaledVector(VA.sub(Wx), U)));
    }
    Vx.add(g2), Gx.add(y2), Wx.add(x2);
  }
  a.isSkinnedMesh && (a.boneTransform(g, Vx), a.boneTransform(_, Gx), a.boneTransform(w, Wx));
  const R = XH(a, e, t, r, Vx, Gx, Wx, GA);
  if (R) {
    d && (_2.fromBufferAttribute(d, g), S2.fromBufferAttribute(d, _), w2.fromBufferAttribute(d, w), R.uv = wm.getUV(GA, Vx, Gx, Wx, _2, S2, w2, new zt())), p && (_2.fromBufferAttribute(p, g), S2.fromBufferAttribute(p, _), w2.fromBufferAttribute(p, w), R.uv2 = wm.getUV(GA, Vx, Gx, Wx, _2, S2, w2, new zt()));
    const D = {
      a: g,
      b: _,
      c: w,
      normal: new ge(),
      materialIndex: 0
    };
    wm.getNormal(Vx, Gx, Wx, D.normal), R.face = D;
  }
  return R;
}
class fl extends oi {
  constructor(e = 1, t = 1, r = 1, i = 1, s = 1, l = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: t,
      depth: r,
      widthSegments: i,
      heightSegments: s,
      depthSegments: l
    };
    const d = this;
    i = Math.floor(i), s = Math.floor(s), l = Math.floor(l);
    const p = [], g = [], _ = [], w = [];
    let T = 0, R = 0;
    D("z", "y", "x", -1, -1, r, t, e, l, s, 0), D("z", "y", "x", 1, -1, r, t, -e, l, s, 1), D("x", "z", "y", 1, 1, e, r, t, i, l, 2), D("x", "z", "y", 1, -1, e, r, -t, i, l, 3), D("x", "y", "z", 1, -1, e, t, r, i, s, 4), D("x", "y", "z", -1, -1, e, t, -r, i, s, 5), this.setIndex(p), this.setAttribute("position", new sr(g, 3)), this.setAttribute("normal", new sr(_, 3)), this.setAttribute("uv", new sr(w, 2));
    function D(O, U, H, I, G, B, Q, K, te, Y, re) {
      const se = B / te, ce = Q / Y, ue = B / 2, Me = Q / 2, me = K / 2, De = te + 1, Re = Y + 1;
      let He = 0, ve = 0;
      const fe = new ge();
      for (let he = 0; he < Re; he++) {
        const ye = he * ce - Me;
        for (let Ee = 0; Ee < De; Ee++) {
          const Ve = Ee * se - ue;
          fe[O] = Ve * I, fe[U] = ye * G, fe[H] = me, g.push(fe.x, fe.y, fe.z), fe[O] = 0, fe[U] = 0, fe[H] = K > 0 ? 1 : -1, _.push(fe.x, fe.y, fe.z), w.push(Ee / te), w.push(1 - he / Y), He += 1;
        }
      }
      for (let he = 0; he < Y; he++)
        for (let ye = 0; ye < te; ye++) {
          const Ee = T + ye + De * he, Ve = T + ye + De * (he + 1), Je = T + (ye + 1) + De * (he + 1), rt = T + (ye + 1) + De * he;
          p.push(Ee, Ve, rt), p.push(Ve, Je, rt), ve += 6;
        }
      d.addGroup(R, ve, re), R += ve, T += He;
    }
  }
  static fromJSON(e) {
    return new fl(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
function Kw(a) {
  const e = {};
  for (const t in a) {
    e[t] = {};
    for (const r in a[t]) {
      const i = a[t][r];
      i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? e[t][r] = i.clone() : Array.isArray(i) ? e[t][r] = i.slice() : e[t][r] = i;
    }
  }
  return e;
}
function uh(a) {
  const e = {};
  for (let t = 0; t < a.length; t++) {
    const r = Kw(a[t]);
    for (const i in r)
      e[i] = r[i];
  }
  return e;
}
function qH(a) {
  const e = [];
  for (let t = 0; t < a.length; t++)
    e.push(a[t].clone());
  return e;
}
const $M = { clone: Kw, merge: uh };
var QH = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, ZH = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Mu extends hf {
  constructor(e) {
    super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = QH, this.fragmentShader = ZH, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = {
      derivatives: !1,
      fragDepth: !1,
      drawBuffers: !1,
      shaderTextureLOD: !1
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv2: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && (e.attributes !== void 0 && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e));
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = Kw(e.uniforms), this.uniformsGroups = qH(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    t.glslVersion = this.glslVersion, t.uniforms = {};
    for (const i in this.uniforms) {
      const l = this.uniforms[i].value;
      l && l.isTexture ? t.uniforms[i] = {
        type: "t",
        value: l.toJSON(e).uuid
      } : l && l.isColor ? t.uniforms[i] = {
        type: "c",
        value: l.getHex()
      } : l && l.isVector2 ? t.uniforms[i] = {
        type: "v2",
        value: l.toArray()
      } : l && l.isVector3 ? t.uniforms[i] = {
        type: "v3",
        value: l.toArray()
      } : l && l.isVector4 ? t.uniforms[i] = {
        type: "v4",
        value: l.toArray()
      } : l && l.isMatrix3 ? t.uniforms[i] = {
        type: "m3",
        value: l.toArray()
      } : l && l.isMatrix4 ? t.uniforms[i] = {
        type: "m4",
        value: l.toArray()
      } : t.uniforms[i] = {
        value: l
      };
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader;
    const r = {};
    for (const i in this.extensions)
      this.extensions[i] === !0 && (r[i] = !0);
    return Object.keys(r).length > 0 && (t.extensions = r), t;
  }
}
class pb extends Xa {
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Kr(), this.projectionMatrix = new Kr(), this.projectionMatrixInverse = new Kr();
  }
  copy(e, t) {
    return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(-t[8], -t[9], -t[10]).normalize();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class ho extends pb {
  constructor(e = 50, t = 1, r = 0.1, i = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = r, this.far = i, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  setFocalLength(e) {
    const t = 0.5 * this.getFilmHeight() / e;
    this.fov = UM * 2 * Math.atan(t), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(H_ * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  getEffectiveFOV() {
    return UM * 2 * Math.atan(
      Math.tan(H_ * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  setViewOffset(e, t, r, i, s, l) {
    this.aspect = e / t, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = r, this.view.offsetY = i, this.view.width = s, this.view.height = l, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = e * Math.tan(H_ * 0.5 * this.fov) / this.zoom, r = 2 * t, i = this.aspect * r, s = -0.5 * i;
    const l = this.view;
    if (this.view !== null && this.view.enabled) {
      const p = l.fullWidth, g = l.fullHeight;
      s += l.offsetX * i / p, t -= l.offsetY * r / g, i *= l.width / p, r *= l.height / g;
    }
    const d = this.filmOffset;
    d !== 0 && (s += e * d / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + i, t, t - r, e, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
  }
}
const Lw = 90, Pw = 1;
class OF extends Xa {
  constructor(e, t, r) {
    if (super(), this.type = "CubeCamera", r.isWebGLCubeRenderTarget !== !0) {
      console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
      return;
    }
    this.renderTarget = r;
    const i = new ho(Lw, Pw, e, t);
    i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new ge(1, 0, 0)), this.add(i);
    const s = new ho(Lw, Pw, e, t);
    s.layers = this.layers, s.up.set(0, -1, 0), s.lookAt(new ge(-1, 0, 0)), this.add(s);
    const l = new ho(Lw, Pw, e, t);
    l.layers = this.layers, l.up.set(0, 0, 1), l.lookAt(new ge(0, 1, 0)), this.add(l);
    const d = new ho(Lw, Pw, e, t);
    d.layers = this.layers, d.up.set(0, 0, -1), d.lookAt(new ge(0, -1, 0)), this.add(d);
    const p = new ho(Lw, Pw, e, t);
    p.layers = this.layers, p.up.set(0, -1, 0), p.lookAt(new ge(0, 0, 1)), this.add(p);
    const g = new ho(Lw, Pw, e, t);
    g.layers = this.layers, g.up.set(0, -1, 0), g.lookAt(new ge(0, 0, -1)), this.add(g);
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const r = this.renderTarget, [i, s, l, d, p, g] = this.children, _ = e.getRenderTarget(), w = e.toneMapping, T = e.xr.enabled;
    e.toneMapping = og, e.xr.enabled = !1;
    const R = r.texture.generateMipmaps;
    r.texture.generateMipmaps = !1, e.setRenderTarget(r, 0), e.render(t, i), e.setRenderTarget(r, 1), e.render(t, s), e.setRenderTarget(r, 2), e.render(t, l), e.setRenderTarget(r, 3), e.render(t, d), e.setRenderTarget(r, 4), e.render(t, p), r.texture.generateMipmaps = R, e.setRenderTarget(r, 5), e.render(t, g), e.setRenderTarget(_), e.toneMapping = w, e.xr.enabled = T, r.texture.needsPMREMUpdate = !0;
  }
}
class eT extends su {
  constructor(e, t, r, i, s, l, d, p, g, _) {
    e = e !== void 0 ? e : [], t = t !== void 0 ? t : t1, super(e, t, r, i, s, l, d, p, g, _), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class UF extends po {
  constructor(e, t = {}) {
    super(e, e, t), this.isWebGLCubeRenderTarget = !0;
    const r = { width: e, height: e, depth: 1 }, i = [r, r, r, r, r, r];
    this.texture = new eT(i, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Oo;
  }
  fromEquirectangularTexture(e, t) {
    this.texture.type = t.type, this.texture.encoding = t.encoding, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
    const r = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
      fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
    }, i = new fl(5, 5, 5), s = new Mu({
      name: "CubemapFromEquirect",
      uniforms: Kw(r.uniforms),
      vertexShader: r.vertexShader,
      fragmentShader: r.fragmentShader,
      side: cf,
      blending: ff
    });
    s.uniforms.tEquirect.value = t;
    const l = new Fn(i, s), d = t.minFilter;
    return t.minFilter === s1 && (t.minFilter = Oo), new OF(1, 10, this).update(e, l), t.minFilter = d, l.geometry.dispose(), l.material.dispose(), this;
  }
  clear(e, t, r, i) {
    const s = e.getRenderTarget();
    for (let l = 0; l < 6; l++)
      e.setRenderTarget(this, l), e.clear(t, r, i);
    e.setRenderTarget(s);
  }
}
const WA = /* @__PURE__ */ new ge(), JH = /* @__PURE__ */ new ge(), KH = /* @__PURE__ */ new Xh();
class R0 {
  constructor(e = new ge(1, 0, 0), t = 0) {
    this.isPlane = !0, this.normal = e, this.constant = t;
  }
  set(e, t) {
    return this.normal.copy(e), this.constant = t, this;
  }
  setComponents(e, t, r, i) {
    return this.normal.set(e, t, r), this.constant = i, this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
  }
  setFromCoplanarPoints(e, t, r) {
    const i = WA.subVectors(r, t).cross(JH.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(i, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e);
  }
  intersectLine(e, t) {
    const r = e.delta(WA), i = this.normal.dot(r);
    if (i === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const s = -(e.start.dot(this.normal) + this.constant) / i;
    return s < 0 || s > 1 ? null : t.copy(r).multiplyScalar(s).add(e.start);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start), r = this.distanceToPoint(e.end);
    return t < 0 && r > 0 || r < 0 && t > 0;
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const r = t || KH.getNormalMatrix(e), i = this.coplanarPoint(WA).applyMatrix4(e), s = this.normal.applyMatrix3(r).normalize();
    return this.constant = -i.dot(s), this;
  }
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Ow = /* @__PURE__ */ new yy(), M2 = /* @__PURE__ */ new ge();
class BC {
  constructor(e = new R0(), t = new R0(), r = new R0(), i = new R0(), s = new R0(), l = new R0()) {
    this.planes = [e, t, r, i, s, l];
  }
  set(e, t, r, i, s, l) {
    const d = this.planes;
    return d[0].copy(e), d[1].copy(t), d[2].copy(r), d[3].copy(i), d[4].copy(s), d[5].copy(l), this;
  }
  copy(e) {
    const t = this.planes;
    for (let r = 0; r < 6; r++)
      t[r].copy(e.planes[r]);
    return this;
  }
  setFromProjectionMatrix(e) {
    const t = this.planes, r = e.elements, i = r[0], s = r[1], l = r[2], d = r[3], p = r[4], g = r[5], _ = r[6], w = r[7], T = r[8], R = r[9], D = r[10], O = r[11], U = r[12], H = r[13], I = r[14], G = r[15];
    return t[0].setComponents(d - i, w - p, O - T, G - U).normalize(), t[1].setComponents(d + i, w + p, O + T, G + U).normalize(), t[2].setComponents(d + s, w + g, O + R, G + H).normalize(), t[3].setComponents(d - s, w - g, O - R, G - H).normalize(), t[4].setComponents(d - l, w - _, O - D, G - I).normalize(), t[5].setComponents(d + l, w + _, O + D, G + I).normalize(), this;
  }
  intersectsObject(e) {
    const t = e.geometry;
    return t.boundingSphere === null && t.computeBoundingSphere(), Ow.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(Ow);
  }
  intersectsSprite(e) {
    return Ow.center.set(0, 0, 0), Ow.radius = 0.7071067811865476, Ow.applyMatrix4(e.matrixWorld), this.intersectsSphere(Ow);
  }
  intersectsSphere(e) {
    const t = this.planes, r = e.center, i = -e.radius;
    for (let s = 0; s < 6; s++)
      if (t[s].distanceToPoint(r) < i)
        return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let r = 0; r < 6; r++) {
      const i = t[r];
      if (M2.x = i.normal.x > 0 ? e.max.x : e.min.x, M2.y = i.normal.y > 0 ? e.max.y : e.min.y, M2.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(M2) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let r = 0; r < 6; r++)
      if (t[r].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function zF() {
  let a = null, e = !1, t = null, r = null;
  function i(s, l) {
    t(s, l), r = a.requestAnimationFrame(i);
  }
  return {
    start: function() {
      e !== !0 && t !== null && (r = a.requestAnimationFrame(i), e = !0);
    },
    stop: function() {
      a.cancelAnimationFrame(r), e = !1;
    },
    setAnimationLoop: function(s) {
      t = s;
    },
    setContext: function(s) {
      a = s;
    }
  };
}
function $H(a, e) {
  const t = e.isWebGL2, r = /* @__PURE__ */ new WeakMap();
  function i(g, _) {
    const w = g.array, T = g.usage, R = a.createBuffer();
    a.bindBuffer(_, R), a.bufferData(_, w, T), g.onUploadCallback();
    let D;
    if (w instanceof Float32Array)
      D = 5126;
    else if (w instanceof Uint16Array)
      if (g.isFloat16BufferAttribute)
        if (t)
          D = 5131;
        else
          throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
      else
        D = 5123;
    else if (w instanceof Int16Array)
      D = 5122;
    else if (w instanceof Uint32Array)
      D = 5125;
    else if (w instanceof Int32Array)
      D = 5124;
    else if (w instanceof Int8Array)
      D = 5120;
    else if (w instanceof Uint8Array)
      D = 5121;
    else if (w instanceof Uint8ClampedArray)
      D = 5121;
    else
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + w);
    return {
      buffer: R,
      type: D,
      bytesPerElement: w.BYTES_PER_ELEMENT,
      version: g.version
    };
  }
  function s(g, _, w) {
    const T = _.array, R = _.updateRange;
    a.bindBuffer(w, g), R.count === -1 ? a.bufferSubData(w, 0, T) : (t ? a.bufferSubData(
      w,
      R.offset * T.BYTES_PER_ELEMENT,
      T,
      R.offset,
      R.count
    ) : a.bufferSubData(
      w,
      R.offset * T.BYTES_PER_ELEMENT,
      T.subarray(R.offset, R.offset + R.count)
    ), R.count = -1);
  }
  function l(g) {
    return g.isInterleavedBufferAttribute && (g = g.data), r.get(g);
  }
  function d(g) {
    g.isInterleavedBufferAttribute && (g = g.data);
    const _ = r.get(g);
    _ && (a.deleteBuffer(_.buffer), r.delete(g));
  }
  function p(g, _) {
    if (g.isGLBufferAttribute) {
      const T = r.get(g);
      (!T || T.version < g.version) && r.set(g, {
        buffer: g.buffer,
        type: g.type,
        bytesPerElement: g.elementSize,
        version: g.version
      });
      return;
    }
    g.isInterleavedBufferAttribute && (g = g.data);
    const w = r.get(g);
    w === void 0 ? r.set(g, i(g, _)) : w.version < g.version && (s(w.buffer, g, _), w.version = g.version);
  }
  return {
    get: l,
    remove: d,
    update: p
  };
}
class lg extends oi {
  constructor(e = 1, t = 1, r = 1, i = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: e,
      height: t,
      widthSegments: r,
      heightSegments: i
    };
    const s = e / 2, l = t / 2, d = Math.floor(r), p = Math.floor(i), g = d + 1, _ = p + 1, w = e / d, T = t / p, R = [], D = [], O = [], U = [];
    for (let H = 0; H < _; H++) {
      const I = H * T - l;
      for (let G = 0; G < g; G++) {
        const B = G * w - s;
        D.push(B, -I, 0), O.push(0, 0, 1), U.push(G / d), U.push(1 - H / p);
      }
    }
    for (let H = 0; H < p; H++)
      for (let I = 0; I < d; I++) {
        const G = I + g * H, B = I + g * (H + 1), Q = I + 1 + g * (H + 1), K = I + 1 + g * H;
        R.push(G, B, K), R.push(B, Q, K);
      }
    this.setIndex(R), this.setAttribute("position", new sr(D, 3)), this.setAttribute("normal", new sr(O, 3)), this.setAttribute("uv", new sr(U, 2));
  }
  static fromJSON(e) {
    return new lg(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var e6 = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`, t6 = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, n6 = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`, r6 = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, i6 = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, a6 = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, s6 = "vec3 transformed = vec3( position );", o6 = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, l6 = `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#ifdef USE_IRIDESCENCE
	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`, u6 = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, c6 = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, f6 = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`, d6 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, h6 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, p6 = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, m6 = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, v6 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, g6 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, y6 = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, x6 = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`, _6 = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, S6 = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, w6 = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, b6 = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`, E6 = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, M6 = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, T6 = "gl_FragColor = linearToOutputTexel( gl_FragColor );", C6 = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, R6 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, A6 = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, D6 = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, L6 = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, P6 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, O6 = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, U6 = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, z6 = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, N6 = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, F6 = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`, k6 = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`, I6 = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, B6 = `vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointLightInfo( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotLightInfo( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
		#endif
	}
	#pragma unroll_loop_end
#endif`, H6 = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, V6 = `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`, G6 = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, W6 = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`, j6 = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, Y6 = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`, X6 = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`, q6 = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	#ifdef USE_IRIDESCENCE
		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, Q6 = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, Z6 = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, J6 = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`, K6 = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, $6 = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, eV = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`, tV = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`, nV = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, rV = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, iV = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, aV = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, sV = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`, oV = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, lV = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, uV = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`, cV = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`, fV = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`, dV = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`, hV = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, pV = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, mV = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, vV = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, gV = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`, yV = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`, xV = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`, _V = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`, SV = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, wV = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, bV = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`, EV = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, MV = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, TV = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, CV = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, RV = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`, AV = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, DV = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`, LV = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, PV = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`, OV = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, UV = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, zV = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`, NV = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, FV = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, kV = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, IV = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, BV = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, HV = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, VV = `#ifdef USE_TRANSMISSION
	float transmissionAlpha = 1.0;
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;
	#ifdef USE_TRANSMISSIONMAP
		transmissionFactor *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationColor, attenuationDistance );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );
	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );
#endif`, GV = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( attenuationDistance == 0.0 ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`, WV = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`, jV = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`, YV = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`, XV = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`, qV = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`, QV = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`, ZV = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const JV = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, KV = `uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	gl_FragColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		gl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );
	#endif
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, $V = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, eG = `#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, tG = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, nG = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, rG = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, iG = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, aG = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, sG = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, oG = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, lG = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, uG = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, cG = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, fG = `#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, dG = `uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, hG = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, pG = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, mG = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`, vG = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, gG = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, yG = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, xG = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, _G = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, SG = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, wG = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, bG = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, EG = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, MG = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, TG = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, CG = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, RG = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, na = {
  alphamap_fragment: e6,
  alphamap_pars_fragment: t6,
  alphatest_fragment: n6,
  alphatest_pars_fragment: r6,
  aomap_fragment: i6,
  aomap_pars_fragment: a6,
  begin_vertex: s6,
  beginnormal_vertex: o6,
  bsdfs: l6,
  iridescence_fragment: u6,
  bumpmap_pars_fragment: c6,
  clipping_planes_fragment: f6,
  clipping_planes_pars_fragment: d6,
  clipping_planes_pars_vertex: h6,
  clipping_planes_vertex: p6,
  color_fragment: m6,
  color_pars_fragment: v6,
  color_pars_vertex: g6,
  color_vertex: y6,
  common: x6,
  cube_uv_reflection_fragment: _6,
  defaultnormal_vertex: S6,
  displacementmap_pars_vertex: w6,
  displacementmap_vertex: b6,
  emissivemap_fragment: E6,
  emissivemap_pars_fragment: M6,
  encodings_fragment: T6,
  encodings_pars_fragment: C6,
  envmap_fragment: R6,
  envmap_common_pars_fragment: A6,
  envmap_pars_fragment: D6,
  envmap_pars_vertex: L6,
  envmap_physical_pars_fragment: V6,
  envmap_vertex: P6,
  fog_vertex: O6,
  fog_pars_vertex: U6,
  fog_fragment: z6,
  fog_pars_fragment: N6,
  gradientmap_pars_fragment: F6,
  lightmap_fragment: k6,
  lightmap_pars_fragment: I6,
  lights_lambert_vertex: B6,
  lights_pars_begin: H6,
  lights_toon_fragment: G6,
  lights_toon_pars_fragment: W6,
  lights_phong_fragment: j6,
  lights_phong_pars_fragment: Y6,
  lights_physical_fragment: X6,
  lights_physical_pars_fragment: q6,
  lights_fragment_begin: Q6,
  lights_fragment_maps: Z6,
  lights_fragment_end: J6,
  logdepthbuf_fragment: K6,
  logdepthbuf_pars_fragment: $6,
  logdepthbuf_pars_vertex: eV,
  logdepthbuf_vertex: tV,
  map_fragment: nV,
  map_pars_fragment: rV,
  map_particle_fragment: iV,
  map_particle_pars_fragment: aV,
  metalnessmap_fragment: sV,
  metalnessmap_pars_fragment: oV,
  morphcolor_vertex: lV,
  morphnormal_vertex: uV,
  morphtarget_pars_vertex: cV,
  morphtarget_vertex: fV,
  normal_fragment_begin: dV,
  normal_fragment_maps: hV,
  normal_pars_fragment: pV,
  normal_pars_vertex: mV,
  normal_vertex: vV,
  normalmap_pars_fragment: gV,
  clearcoat_normal_fragment_begin: yV,
  clearcoat_normal_fragment_maps: xV,
  clearcoat_pars_fragment: _V,
  iridescence_pars_fragment: SV,
  output_fragment: wV,
  packing: bV,
  premultiplied_alpha_fragment: EV,
  project_vertex: MV,
  dithering_fragment: TV,
  dithering_pars_fragment: CV,
  roughnessmap_fragment: RV,
  roughnessmap_pars_fragment: AV,
  shadowmap_pars_fragment: DV,
  shadowmap_pars_vertex: LV,
  shadowmap_vertex: PV,
  shadowmask_pars_fragment: OV,
  skinbase_vertex: UV,
  skinning_pars_vertex: zV,
  skinning_vertex: NV,
  skinnormal_vertex: FV,
  specularmap_fragment: kV,
  specularmap_pars_fragment: IV,
  tonemapping_fragment: BV,
  tonemapping_pars_fragment: HV,
  transmission_fragment: VV,
  transmission_pars_fragment: GV,
  uv_pars_fragment: WV,
  uv_pars_vertex: jV,
  uv_vertex: YV,
  uv2_pars_fragment: XV,
  uv2_pars_vertex: qV,
  uv2_vertex: QV,
  worldpos_vertex: ZV,
  background_vert: JV,
  background_frag: KV,
  cube_vert: $V,
  cube_frag: eG,
  depth_vert: tG,
  depth_frag: nG,
  distanceRGBA_vert: rG,
  distanceRGBA_frag: iG,
  equirect_vert: aG,
  equirect_frag: sG,
  linedashed_vert: oG,
  linedashed_frag: lG,
  meshbasic_vert: uG,
  meshbasic_frag: cG,
  meshlambert_vert: fG,
  meshlambert_frag: dG,
  meshmatcap_vert: hG,
  meshmatcap_frag: pG,
  meshnormal_vert: mG,
  meshnormal_frag: vG,
  meshphong_vert: gG,
  meshphong_frag: yG,
  meshphysical_vert: xG,
  meshphysical_frag: _G,
  meshtoon_vert: SG,
  meshtoon_frag: wG,
  points_vert: bG,
  points_frag: EG,
  shadow_vert: MG,
  shadow_frag: TG,
  sprite_vert: CG,
  sprite_frag: RG
}, In = {
  common: {
    diffuse: { value: /* @__PURE__ */ new Un(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    uvTransform: { value: /* @__PURE__ */ new Xh() },
    uv2Transform: { value: /* @__PURE__ */ new Xh() },
    alphaMap: { value: null },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null }
  },
  envmap: {
    envMap: { value: null },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    ior: { value: 1.5 },
    refractionRatio: { value: 0.98 }
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 }
  },
  emissivemap: {
    emissiveMap: { value: null }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalScale: { value: /* @__PURE__ */ new zt(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  roughnessmap: {
    roughnessMap: { value: null }
  },
  metalnessmap: {
    metalnessMap: { value: null }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new Un(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotShadowMap: { value: [] },
    spotShadowMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new Un(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new Xh() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new Un(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new zt(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    alphaMap: { value: null },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new Xh() }
  }
}, Wh = {
  basic: {
    uniforms: /* @__PURE__ */ uh([
      In.common,
      In.specularmap,
      In.envmap,
      In.aomap,
      In.lightmap,
      In.fog
    ]),
    vertexShader: na.meshbasic_vert,
    fragmentShader: na.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ uh([
      In.common,
      In.specularmap,
      In.envmap,
      In.aomap,
      In.lightmap,
      In.emissivemap,
      In.fog,
      In.lights,
      {
        emissive: { value: /* @__PURE__ */ new Un(0) }
      }
    ]),
    vertexShader: na.meshlambert_vert,
    fragmentShader: na.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ uh([
      In.common,
      In.specularmap,
      In.envmap,
      In.aomap,
      In.lightmap,
      In.emissivemap,
      In.bumpmap,
      In.normalmap,
      In.displacementmap,
      In.fog,
      In.lights,
      {
        emissive: { value: /* @__PURE__ */ new Un(0) },
        specular: { value: /* @__PURE__ */ new Un(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: na.meshphong_vert,
    fragmentShader: na.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ uh([
      In.common,
      In.envmap,
      In.aomap,
      In.lightmap,
      In.emissivemap,
      In.bumpmap,
      In.normalmap,
      In.displacementmap,
      In.roughnessmap,
      In.metalnessmap,
      In.fog,
      In.lights,
      {
        emissive: { value: /* @__PURE__ */ new Un(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
      }
    ]),
    vertexShader: na.meshphysical_vert,
    fragmentShader: na.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ uh([
      In.common,
      In.aomap,
      In.lightmap,
      In.emissivemap,
      In.bumpmap,
      In.normalmap,
      In.displacementmap,
      In.gradientmap,
      In.fog,
      In.lights,
      {
        emissive: { value: /* @__PURE__ */ new Un(0) }
      }
    ]),
    vertexShader: na.meshtoon_vert,
    fragmentShader: na.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ uh([
      In.common,
      In.bumpmap,
      In.normalmap,
      In.displacementmap,
      In.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: na.meshmatcap_vert,
    fragmentShader: na.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ uh([
      In.points,
      In.fog
    ]),
    vertexShader: na.points_vert,
    fragmentShader: na.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ uh([
      In.common,
      In.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: na.linedashed_vert,
    fragmentShader: na.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ uh([
      In.common,
      In.displacementmap
    ]),
    vertexShader: na.depth_vert,
    fragmentShader: na.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ uh([
      In.common,
      In.bumpmap,
      In.normalmap,
      In.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: na.meshnormal_vert,
    fragmentShader: na.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ uh([
      In.sprite,
      In.fog
    ]),
    vertexShader: na.sprite_vert,
    fragmentShader: na.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new Xh() },
      t2D: { value: null }
    },
    vertexShader: na.background_vert,
    fragmentShader: na.background_frag
  },
  cube: {
    uniforms: /* @__PURE__ */ uh([
      In.envmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: na.cube_vert,
    fragmentShader: na.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: na.equirect_vert,
    fragmentShader: na.equirect_frag
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ uh([
      In.common,
      In.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new ge() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: na.distanceRGBA_vert,
    fragmentShader: na.distanceRGBA_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ uh([
      In.lights,
      In.fog,
      {
        color: { value: /* @__PURE__ */ new Un(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: na.shadow_vert,
    fragmentShader: na.shadow_frag
  }
};
Wh.physical = {
  uniforms: /* @__PURE__ */ uh([
    Wh.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatNormalScale: { value: /* @__PURE__ */ new zt(1, 1) },
      clearcoatNormalMap: { value: null },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new Un(0) },
      sheenColorMap: { value: null },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionSamplerSize: { value: /* @__PURE__ */ new zt() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new Un(0) },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularColor: { value: /* @__PURE__ */ new Un(1, 1, 1) },
      specularColorMap: { value: null }
    }
  ]),
  vertexShader: na.meshphysical_vert,
  fragmentShader: na.meshphysical_frag
};
function AG(a, e, t, r, i, s) {
  const l = new Un(0);
  let d = i === !0 ? 0 : 1, p, g, _ = null, w = 0, T = null;
  function R(O, U) {
    let H = !1, I = U.isScene === !0 ? U.background : null;
    I && I.isTexture && (I = e.get(I));
    const G = a.xr, B = G.getSession && G.getSession();
    B && B.environmentBlendMode === "additive" && (I = null), I === null ? D(l, d) : I && I.isColor && (D(I, 1), H = !0), (a.autoClear || H) && a.clear(a.autoClearColor, a.autoClearDepth, a.autoClearStencil), I && (I.isCubeTexture || I.mapping === hb) ? (g === void 0 && (g = new Fn(
      new fl(1, 1, 1),
      new Mu({
        name: "BackgroundCubeMaterial",
        uniforms: Kw(Wh.cube.uniforms),
        vertexShader: Wh.cube.vertexShader,
        fragmentShader: Wh.cube.fragmentShader,
        side: cf,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), g.geometry.deleteAttribute("normal"), g.geometry.deleteAttribute("uv"), g.onBeforeRender = function(Q, K, te) {
      this.matrixWorld.copyPosition(te.matrixWorld);
    }, Object.defineProperty(g.material, "envMap", {
      get: function() {
        return this.uniforms.envMap.value;
      }
    }), r.update(g)), g.material.uniforms.envMap.value = I, g.material.uniforms.flipEnvMap.value = I.isCubeTexture && I.isRenderTargetTexture === !1 ? -1 : 1, (_ !== I || w !== I.version || T !== a.toneMapping) && (g.material.needsUpdate = !0, _ = I, w = I.version, T = a.toneMapping), g.layers.enableAll(), O.unshift(g, g.geometry, g.material, 0, 0, null)) : I && I.isTexture && (p === void 0 && (p = new Fn(
      new lg(2, 2),
      new Mu({
        name: "BackgroundMaterial",
        uniforms: Kw(Wh.background.uniforms),
        vertexShader: Wh.background.vertexShader,
        fragmentShader: Wh.background.fragmentShader,
        side: vy,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), p.geometry.deleteAttribute("normal"), Object.defineProperty(p.material, "map", {
      get: function() {
        return this.uniforms.t2D.value;
      }
    }), r.update(p)), p.material.uniforms.t2D.value = I, I.matrixAutoUpdate === !0 && I.updateMatrix(), p.material.uniforms.uvTransform.value.copy(I.matrix), (_ !== I || w !== I.version || T !== a.toneMapping) && (p.material.needsUpdate = !0, _ = I, w = I.version, T = a.toneMapping), p.layers.enableAll(), O.unshift(p, p.geometry, p.material, 0, 0, null));
  }
  function D(O, U) {
    t.buffers.color.setClear(O.r, O.g, O.b, U, s);
  }
  return {
    getClearColor: function() {
      return l;
    },
    setClearColor: function(O, U = 1) {
      l.set(O), d = U, D(l, d);
    },
    getClearAlpha: function() {
      return d;
    },
    setClearAlpha: function(O) {
      d = O, D(l, d);
    },
    render: R
  };
}
function DG(a, e, t, r) {
  const i = a.getParameter(34921), s = r.isWebGL2 ? null : e.get("OES_vertex_array_object"), l = r.isWebGL2 || s !== null, d = {}, p = U(null);
  let g = p, _ = !1;
  function w(me, De, Re, He, ve) {
    let fe = !1;
    if (l) {
      const he = O(He, Re, De);
      g !== he && (g = he, R(g.object)), fe = H(me, He, Re, ve), fe && I(me, He, Re, ve);
    } else {
      const he = De.wireframe === !0;
      (g.geometry !== He.id || g.program !== Re.id || g.wireframe !== he) && (g.geometry = He.id, g.program = Re.id, g.wireframe = he, fe = !0);
    }
    ve !== null && t.update(ve, 34963), (fe || _) && (_ = !1, Y(me, De, Re, He), ve !== null && a.bindBuffer(34963, t.get(ve).buffer));
  }
  function T() {
    return r.isWebGL2 ? a.createVertexArray() : s.createVertexArrayOES();
  }
  function R(me) {
    return r.isWebGL2 ? a.bindVertexArray(me) : s.bindVertexArrayOES(me);
  }
  function D(me) {
    return r.isWebGL2 ? a.deleteVertexArray(me) : s.deleteVertexArrayOES(me);
  }
  function O(me, De, Re) {
    const He = Re.wireframe === !0;
    let ve = d[me.id];
    ve === void 0 && (ve = {}, d[me.id] = ve);
    let fe = ve[De.id];
    fe === void 0 && (fe = {}, ve[De.id] = fe);
    let he = fe[He];
    return he === void 0 && (he = U(T()), fe[He] = he), he;
  }
  function U(me) {
    const De = [], Re = [], He = [];
    for (let ve = 0; ve < i; ve++)
      De[ve] = 0, Re[ve] = 0, He[ve] = 0;
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: De,
      enabledAttributes: Re,
      attributeDivisors: He,
      object: me,
      attributes: {},
      index: null
    };
  }
  function H(me, De, Re, He) {
    const ve = g.attributes, fe = De.attributes;
    let he = 0;
    const ye = Re.getAttributes();
    for (const Ee in ye)
      if (ye[Ee].location >= 0) {
        const Je = ve[Ee];
        let rt = fe[Ee];
        if (rt === void 0 && (Ee === "instanceMatrix" && me.instanceMatrix && (rt = me.instanceMatrix), Ee === "instanceColor" && me.instanceColor && (rt = me.instanceColor)), Je === void 0 || Je.attribute !== rt || rt && Je.data !== rt.data)
          return !0;
        he++;
      }
    return g.attributesNum !== he || g.index !== He;
  }
  function I(me, De, Re, He) {
    const ve = {}, fe = De.attributes;
    let he = 0;
    const ye = Re.getAttributes();
    for (const Ee in ye)
      if (ye[Ee].location >= 0) {
        let Je = fe[Ee];
        Je === void 0 && (Ee === "instanceMatrix" && me.instanceMatrix && (Je = me.instanceMatrix), Ee === "instanceColor" && me.instanceColor && (Je = me.instanceColor));
        const rt = {};
        rt.attribute = Je, Je && Je.data && (rt.data = Je.data), ve[Ee] = rt, he++;
      }
    g.attributes = ve, g.attributesNum = he, g.index = He;
  }
  function G() {
    const me = g.newAttributes;
    for (let De = 0, Re = me.length; De < Re; De++)
      me[De] = 0;
  }
  function B(me) {
    Q(me, 0);
  }
  function Q(me, De) {
    const Re = g.newAttributes, He = g.enabledAttributes, ve = g.attributeDivisors;
    Re[me] = 1, He[me] === 0 && (a.enableVertexAttribArray(me), He[me] = 1), ve[me] !== De && ((r.isWebGL2 ? a : e.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](me, De), ve[me] = De);
  }
  function K() {
    const me = g.newAttributes, De = g.enabledAttributes;
    for (let Re = 0, He = De.length; Re < He; Re++)
      De[Re] !== me[Re] && (a.disableVertexAttribArray(Re), De[Re] = 0);
  }
  function te(me, De, Re, He, ve, fe) {
    r.isWebGL2 === !0 && (Re === 5124 || Re === 5125) ? a.vertexAttribIPointer(me, De, Re, ve, fe) : a.vertexAttribPointer(me, De, Re, He, ve, fe);
  }
  function Y(me, De, Re, He) {
    if (r.isWebGL2 === !1 && (me.isInstancedMesh || He.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null)
      return;
    G();
    const ve = He.attributes, fe = Re.getAttributes(), he = De.defaultAttributeValues;
    for (const ye in fe) {
      const Ee = fe[ye];
      if (Ee.location >= 0) {
        let Ve = ve[ye];
        if (Ve === void 0 && (ye === "instanceMatrix" && me.instanceMatrix && (Ve = me.instanceMatrix), ye === "instanceColor" && me.instanceColor && (Ve = me.instanceColor)), Ve !== void 0) {
          const Je = Ve.normalized, rt = Ve.itemSize, Ne = t.get(Ve);
          if (Ne === void 0)
            continue;
          const ct = Ne.buffer, tt = Ne.type, Tt = Ne.bytesPerElement;
          if (Ve.isInterleavedBufferAttribute) {
            const gt = Ve.data, ft = gt.stride, Ie = Ve.offset;
            if (gt.isInstancedInterleavedBuffer) {
              for (let qe = 0; qe < Ee.locationSize; qe++)
                Q(Ee.location + qe, gt.meshPerAttribute);
              me.isInstancedMesh !== !0 && He._maxInstanceCount === void 0 && (He._maxInstanceCount = gt.meshPerAttribute * gt.count);
            } else
              for (let qe = 0; qe < Ee.locationSize; qe++)
                B(Ee.location + qe);
            a.bindBuffer(34962, ct);
            for (let qe = 0; qe < Ee.locationSize; qe++)
              te(
                Ee.location + qe,
                rt / Ee.locationSize,
                tt,
                Je,
                ft * Tt,
                (Ie + rt / Ee.locationSize * qe) * Tt
              );
          } else {
            if (Ve.isInstancedBufferAttribute) {
              for (let gt = 0; gt < Ee.locationSize; gt++)
                Q(Ee.location + gt, Ve.meshPerAttribute);
              me.isInstancedMesh !== !0 && He._maxInstanceCount === void 0 && (He._maxInstanceCount = Ve.meshPerAttribute * Ve.count);
            } else
              for (let gt = 0; gt < Ee.locationSize; gt++)
                B(Ee.location + gt);
            a.bindBuffer(34962, ct);
            for (let gt = 0; gt < Ee.locationSize; gt++)
              te(
                Ee.location + gt,
                rt / Ee.locationSize,
                tt,
                Je,
                rt * Tt,
                rt / Ee.locationSize * gt * Tt
              );
          }
        } else if (he !== void 0) {
          const Je = he[ye];
          if (Je !== void 0)
            switch (Je.length) {
              case 2:
                a.vertexAttrib2fv(Ee.location, Je);
                break;
              case 3:
                a.vertexAttrib3fv(Ee.location, Je);
                break;
              case 4:
                a.vertexAttrib4fv(Ee.location, Je);
                break;
              default:
                a.vertexAttrib1fv(Ee.location, Je);
            }
        }
      }
    }
    K();
  }
  function re() {
    ue();
    for (const me in d) {
      const De = d[me];
      for (const Re in De) {
        const He = De[Re];
        for (const ve in He)
          D(He[ve].object), delete He[ve];
        delete De[Re];
      }
      delete d[me];
    }
  }
  function se(me) {
    if (d[me.id] === void 0)
      return;
    const De = d[me.id];
    for (const Re in De) {
      const He = De[Re];
      for (const ve in He)
        D(He[ve].object), delete He[ve];
      delete De[Re];
    }
    delete d[me.id];
  }
  function ce(me) {
    for (const De in d) {
      const Re = d[De];
      if (Re[me.id] === void 0)
        continue;
      const He = Re[me.id];
      for (const ve in He)
        D(He[ve].object), delete He[ve];
      delete Re[me.id];
    }
  }
  function ue() {
    Me(), _ = !0, g !== p && (g = p, R(g.object));
  }
  function Me() {
    p.geometry = null, p.program = null, p.wireframe = !1;
  }
  return {
    setup: w,
    reset: ue,
    resetDefaultState: Me,
    dispose: re,
    releaseStatesOfGeometry: se,
    releaseStatesOfProgram: ce,
    initAttributes: G,
    enableAttribute: B,
    disableUnusedAttributes: K
  };
}
function LG(a, e, t, r) {
  const i = r.isWebGL2;
  let s;
  function l(g) {
    s = g;
  }
  function d(g, _) {
    a.drawArrays(s, g, _), t.update(_, s, 1);
  }
  function p(g, _, w) {
    if (w === 0)
      return;
    let T, R;
    if (i)
      T = a, R = "drawArraysInstanced";
    else if (T = e.get("ANGLE_instanced_arrays"), R = "drawArraysInstancedANGLE", T === null) {
      console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    T[R](s, g, _, w), t.update(_, s, w);
  }
  this.setMode = l, this.render = d, this.renderInstances = p;
}
function PG(a, e, t) {
  let r;
  function i() {
    if (r !== void 0)
      return r;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const te = e.get("EXT_texture_filter_anisotropic");
      r = a.getParameter(te.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      r = 0;
    return r;
  }
  function s(te) {
    if (te === "highp") {
      if (a.getShaderPrecisionFormat(35633, 36338).precision > 0 && a.getShaderPrecisionFormat(35632, 36338).precision > 0)
        return "highp";
      te = "mediump";
    }
    return te === "mediump" && a.getShaderPrecisionFormat(35633, 36337).precision > 0 && a.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
  }
  const l = typeof WebGL2RenderingContext < "u" && a instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext < "u" && a instanceof WebGL2ComputeRenderingContext;
  let d = t.precision !== void 0 ? t.precision : "highp";
  const p = s(d);
  p !== d && (console.warn("THREE.WebGLRenderer:", d, "not supported, using", p, "instead."), d = p);
  const g = l || e.has("WEBGL_draw_buffers"), _ = t.logarithmicDepthBuffer === !0, w = a.getParameter(34930), T = a.getParameter(35660), R = a.getParameter(3379), D = a.getParameter(34076), O = a.getParameter(34921), U = a.getParameter(36347), H = a.getParameter(36348), I = a.getParameter(36349), G = T > 0, B = l || e.has("OES_texture_float"), Q = G && B, K = l ? a.getParameter(36183) : 0;
  return {
    isWebGL2: l,
    drawBuffers: g,
    getMaxAnisotropy: i,
    getMaxPrecision: s,
    precision: d,
    logarithmicDepthBuffer: _,
    maxTextures: w,
    maxVertexTextures: T,
    maxTextureSize: R,
    maxCubemapSize: D,
    maxAttributes: O,
    maxVertexUniforms: U,
    maxVaryings: H,
    maxFragmentUniforms: I,
    vertexTextures: G,
    floatFragmentTextures: B,
    floatVertexTextures: Q,
    maxSamples: K
  };
}
function OG(a) {
  const e = this;
  let t = null, r = 0, i = !1, s = !1;
  const l = new R0(), d = new Xh(), p = { value: null, needsUpdate: !1 };
  this.uniform = p, this.numPlanes = 0, this.numIntersection = 0, this.init = function(w, T, R) {
    const D = w.length !== 0 || T || r !== 0 || i;
    return i = T, t = _(w, R, 0), r = w.length, D;
  }, this.beginShadows = function() {
    s = !0, _(null);
  }, this.endShadows = function() {
    s = !1, g();
  }, this.setState = function(w, T, R) {
    const D = w.clippingPlanes, O = w.clipIntersection, U = w.clipShadows, H = a.get(w);
    if (!i || D === null || D.length === 0 || s && !U)
      s ? _(null) : g();
    else {
      const I = s ? 0 : r, G = I * 4;
      let B = H.clippingState || null;
      p.value = B, B = _(D, T, G, R);
      for (let Q = 0; Q !== G; ++Q)
        B[Q] = t[Q];
      H.clippingState = B, this.numIntersection = O ? this.numPlanes : 0, this.numPlanes += I;
    }
  };
  function g() {
    p.value !== t && (p.value = t, p.needsUpdate = r > 0), e.numPlanes = r, e.numIntersection = 0;
  }
  function _(w, T, R, D) {
    const O = w !== null ? w.length : 0;
    let U = null;
    if (O !== 0) {
      if (U = p.value, D !== !0 || U === null) {
        const H = R + O * 4, I = T.matrixWorldInverse;
        d.getNormalMatrix(I), (U === null || U.length < H) && (U = new Float32Array(H));
        for (let G = 0, B = R; G !== O; ++G, B += 4)
          l.copy(w[G]).applyMatrix4(I, d), l.normal.toArray(U, B), U[B + 3] = l.constant;
      }
      p.value = U, p.needsUpdate = !0;
    }
    return e.numPlanes = O, e.numIntersection = 0, U;
  }
}
function UG(a) {
  let e = /* @__PURE__ */ new WeakMap();
  function t(l, d) {
    return d === CM ? l.mapping = t1 : d === RM && (l.mapping = n1), l;
  }
  function r(l) {
    if (l && l.isTexture && l.isRenderTargetTexture === !1) {
      const d = l.mapping;
      if (d === CM || d === RM)
        if (e.has(l)) {
          const p = e.get(l).texture;
          return t(p, l.mapping);
        } else {
          const p = l.image;
          if (p && p.height > 0) {
            const g = new UF(p.height / 2);
            return g.fromEquirectangularTexture(a, l), e.set(l, g), l.addEventListener("dispose", i), t(g.texture, l.mapping);
          } else
            return null;
        }
    }
    return l;
  }
  function i(l) {
    const d = l.target;
    d.removeEventListener("dispose", i);
    const p = e.get(d);
    p !== void 0 && (e.delete(d), p.dispose());
  }
  function s() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: r,
    dispose: s
  };
}
class dy extends pb {
  constructor(e = -1, t = 1, r = 1, i = -1, s = 0.1, l = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = r, this.bottom = i, this.near = s, this.far = l, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  setViewOffset(e, t, r, i, s, l) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = r, this.view.offsetY = i, this.view.width = s, this.view.height = l, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), r = (this.right + this.left) / 2, i = (this.top + this.bottom) / 2;
    let s = r - e, l = r + e, d = i + t, p = i - t;
    if (this.view !== null && this.view.enabled) {
      const g = (this.right - this.left) / this.view.fullWidth / this.zoom, _ = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      s += g * this.view.offsetX, l = s + g * this.view.width, d -= _ * this.view.offsetY, p = d - _ * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(s, l, d, p, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
  }
}
const Ww = 4, WO = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], P_ = 20, jA = /* @__PURE__ */ new dy(), jO = /* @__PURE__ */ new Un();
let YA = null;
const R_ = (1 + Math.sqrt(5)) / 2, Uw = 1 / R_, YO = [
  /* @__PURE__ */ new ge(1, 1, 1),
  /* @__PURE__ */ new ge(-1, 1, 1),
  /* @__PURE__ */ new ge(1, 1, -1),
  /* @__PURE__ */ new ge(-1, 1, -1),
  /* @__PURE__ */ new ge(0, R_, Uw),
  /* @__PURE__ */ new ge(0, R_, -Uw),
  /* @__PURE__ */ new ge(Uw, 0, R_),
  /* @__PURE__ */ new ge(-Uw, 0, R_),
  /* @__PURE__ */ new ge(R_, Uw, 0),
  /* @__PURE__ */ new ge(-R_, Uw, 0)
];
class v3 {
  constructor(e) {
    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, t = 0, r = 0.1, i = 100) {
    YA = this._renderer.getRenderTarget(), this._setSize(256);
    const s = this._allocateTargets();
    return s.depthBuffer = !0, this._sceneToCubeUV(e, r, i, s), t > 0 && this._blur(s, 0, 0, t), this._applyPMREM(s), this._cleanup(s), s;
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = QO(), this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = qO(), this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(YA), e.scissorTest = !1, T2(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === t1 || e.mapping === n1 ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), YA = this._renderer.getRenderTarget();
    const r = t || this._allocateTargets();
    return this._textureToCubeUV(e, r), this._applyPMREM(r), this._cleanup(r), r;
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, r = {
      magFilter: Oo,
      minFilter: Oo,
      generateMipmaps: !1,
      type: X_,
      format: zp,
      encoding: wv,
      depthBuffer: !1
    }, i = XO(e, t, r);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = XO(e, t, r);
      const { _lodMax: s } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = zG(s)), this._blurMaterial = NG(s, e, t);
    }
    return i;
  }
  _compileMaterial(e) {
    const t = new Fn(this._lodPlanes[0], e);
    this._renderer.compile(t, jA);
  }
  _sceneToCubeUV(e, t, r, i) {
    const d = new ho(90, 1, t, r), p = [1, -1, 1, 1, 1, 1], g = [1, 1, 1, -1, -1, -1], _ = this._renderer, w = _.autoClear, T = _.toneMapping;
    _.getClearColor(jO), _.toneMapping = og, _.autoClear = !1;
    const R = new fg({
      name: "PMREM.Background",
      side: cf,
      depthWrite: !1,
      depthTest: !1
    }), D = new Fn(new fl(), R);
    let O = !1;
    const U = e.background;
    U ? U.isColor && (R.color.copy(U), e.background = null, O = !0) : (R.color.copy(jO), O = !0);
    for (let H = 0; H < 6; H++) {
      const I = H % 3;
      I === 0 ? (d.up.set(0, p[H], 0), d.lookAt(g[H], 0, 0)) : I === 1 ? (d.up.set(0, 0, p[H]), d.lookAt(0, g[H], 0)) : (d.up.set(0, p[H], 0), d.lookAt(0, 0, g[H]));
      const G = this._cubeSize;
      T2(i, I * G, H > 2 ? G : 0, G, G), _.setRenderTarget(i), O && _.render(D, d), _.render(e, d);
    }
    D.geometry.dispose(), D.material.dispose(), _.toneMapping = T, _.autoClear = w, e.background = U;
  }
  _textureToCubeUV(e, t) {
    const r = this._renderer, i = e.mapping === t1 || e.mapping === n1;
    i ? (this._cubemapMaterial === null && (this._cubemapMaterial = QO()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = qO());
    const s = i ? this._cubemapMaterial : this._equirectMaterial, l = new Fn(this._lodPlanes[0], s), d = s.uniforms;
    d.envMap.value = e;
    const p = this._cubeSize;
    T2(t, 0, 0, 3 * p, 2 * p), r.setRenderTarget(t), r.render(l, jA);
  }
  _applyPMREM(e) {
    const t = this._renderer, r = t.autoClear;
    t.autoClear = !1;
    for (let i = 1; i < this._lodPlanes.length; i++) {
      const s = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]), l = YO[(i - 1) % YO.length];
      this._blur(e, i - 1, i, s, l);
    }
    t.autoClear = r;
  }
  _blur(e, t, r, i, s) {
    const l = this._pingPongRenderTarget;
    this._halfBlur(
      e,
      l,
      t,
      r,
      i,
      "latitudinal",
      s
    ), this._halfBlur(
      l,
      e,
      r,
      r,
      i,
      "longitudinal",
      s
    );
  }
  _halfBlur(e, t, r, i, s, l, d) {
    const p = this._renderer, g = this._blurMaterial;
    l !== "latitudinal" && l !== "longitudinal" && console.error(
      "blur direction must be either latitudinal or longitudinal!"
    );
    const _ = 3, w = new Fn(this._lodPlanes[i], g), T = g.uniforms, R = this._sizeLods[r] - 1, D = isFinite(s) ? Math.PI / (2 * R) : 2 * Math.PI / (2 * P_ - 1), O = s / D, U = isFinite(s) ? 1 + Math.floor(_ * O) : P_;
    U > P_ && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${U} samples when the maximum is set to ${P_}`);
    const H = [];
    let I = 0;
    for (let te = 0; te < P_; ++te) {
      const Y = te / O, re = Math.exp(-Y * Y / 2);
      H.push(re), te === 0 ? I += re : te < U && (I += 2 * re);
    }
    for (let te = 0; te < H.length; te++)
      H[te] = H[te] / I;
    T.envMap.value = e.texture, T.samples.value = U, T.weights.value = H, T.latitudinal.value = l === "latitudinal", d && (T.poleAxis.value = d);
    const { _lodMax: G } = this;
    T.dTheta.value = D, T.mipInt.value = G - r;
    const B = this._sizeLods[i], Q = 3 * B * (i > G - Ww ? i - G + Ww : 0), K = 4 * (this._cubeSize - B);
    T2(t, Q, K, 3 * B, 2 * B), p.setRenderTarget(t), p.render(w, jA);
  }
}
function zG(a) {
  const e = [], t = [], r = [];
  let i = a;
  const s = a - Ww + 1 + WO.length;
  for (let l = 0; l < s; l++) {
    const d = Math.pow(2, i);
    t.push(d);
    let p = 1 / d;
    l > a - Ww ? p = WO[l - a + Ww - 1] : l === 0 && (p = 0), r.push(p);
    const g = 1 / (d - 2), _ = -g, w = 1 + g, T = [_, _, w, _, w, w, _, _, w, w, _, w], R = 6, D = 6, O = 3, U = 2, H = 1, I = new Float32Array(O * D * R), G = new Float32Array(U * D * R), B = new Float32Array(H * D * R);
    for (let K = 0; K < R; K++) {
      const te = K % 3 * 2 / 3 - 1, Y = K > 2 ? 0 : -1, re = [
        te,
        Y,
        0,
        te + 2 / 3,
        Y,
        0,
        te + 2 / 3,
        Y + 1,
        0,
        te,
        Y,
        0,
        te + 2 / 3,
        Y + 1,
        0,
        te,
        Y + 1,
        0
      ];
      I.set(re, O * D * K), G.set(T, U * D * K);
      const se = [K, K, K, K, K, K];
      B.set(se, H * D * K);
    }
    const Q = new oi();
    Q.setAttribute("position", new ls(I, O)), Q.setAttribute("uv", new ls(G, U)), Q.setAttribute("faceIndex", new ls(B, H)), e.push(Q), i > Ww && i--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: r };
}
function XO(a, e, t) {
  const r = new po(a, e, t);
  return r.texture.mapping = hb, r.texture.name = "PMREM.cubeUv", r.scissorTest = !0, r;
}
function T2(a, e, t, r, i) {
  a.viewport.set(e, t, r, i), a.scissor.set(e, t, r, i);
}
function NG(a, e, t) {
  const r = new Float32Array(P_), i = new ge(0, 1, 0);
  return new Mu({
    name: "SphericalGaussianBlur",
    defines: {
      n: P_,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${a}.0`
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: r },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: i }
    },
    vertexShader: J3(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: ff,
    depthTest: !1,
    depthWrite: !1
  });
}
function qO() {
  return new Mu({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null }
    },
    vertexShader: J3(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: ff,
    depthTest: !1,
    depthWrite: !1
  });
}
function QO() {
  return new Mu({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 }
    },
    vertexShader: J3(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: ff,
    depthTest: !1,
    depthWrite: !1
  });
}
function J3() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function FG(a) {
  let e = /* @__PURE__ */ new WeakMap(), t = null;
  function r(d) {
    if (d && d.isTexture) {
      const p = d.mapping, g = p === CM || p === RM, _ = p === t1 || p === n1;
      if (g || _)
        if (d.isRenderTargetTexture && d.needsPMREMUpdate === !0) {
          d.needsPMREMUpdate = !1;
          let w = e.get(d);
          return t === null && (t = new v3(a)), w = g ? t.fromEquirectangular(d, w) : t.fromCubemap(d, w), e.set(d, w), w.texture;
        } else {
          if (e.has(d))
            return e.get(d).texture;
          {
            const w = d.image;
            if (g && w && w.height > 0 || _ && w && i(w)) {
              t === null && (t = new v3(a));
              const T = g ? t.fromEquirectangular(d) : t.fromCubemap(d);
              return e.set(d, T), d.addEventListener("dispose", s), T.texture;
            } else
              return null;
          }
        }
    }
    return d;
  }
  function i(d) {
    let p = 0;
    const g = 6;
    for (let _ = 0; _ < g; _++)
      d[_] !== void 0 && p++;
    return p === g;
  }
  function s(d) {
    const p = d.target;
    p.removeEventListener("dispose", s);
    const g = e.get(p);
    g !== void 0 && (e.delete(p), g.dispose());
  }
  function l() {
    e = /* @__PURE__ */ new WeakMap(), t !== null && (t.dispose(), t = null);
  }
  return {
    get: r,
    dispose: l
  };
}
function kG(a) {
  const e = {};
  function t(r) {
    if (e[r] !== void 0)
      return e[r];
    let i;
    switch (r) {
      case "WEBGL_depth_texture":
        i = a.getExtension("WEBGL_depth_texture") || a.getExtension("MOZ_WEBGL_depth_texture") || a.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        i = a.getExtension("EXT_texture_filter_anisotropic") || a.getExtension("MOZ_EXT_texture_filter_anisotropic") || a.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        i = a.getExtension("WEBGL_compressed_texture_s3tc") || a.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        i = a.getExtension("WEBGL_compressed_texture_pvrtc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        i = a.getExtension(r);
    }
    return e[r] = i, i;
  }
  return {
    has: function(r) {
      return t(r) !== null;
    },
    init: function(r) {
      r.isWebGL2 ? t("EXT_color_buffer_float") : (t("WEBGL_depth_texture"), t("OES_texture_float"), t("OES_texture_half_float"), t("OES_texture_half_float_linear"), t("OES_standard_derivatives"), t("OES_element_index_uint"), t("OES_vertex_array_object"), t("ANGLE_instanced_arrays")), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture");
    },
    get: function(r) {
      const i = t(r);
      return i === null && console.warn("THREE.WebGLRenderer: " + r + " extension not supported."), i;
    }
  };
}
function IG(a, e, t, r) {
  const i = {}, s = /* @__PURE__ */ new WeakMap();
  function l(w) {
    const T = w.target;
    T.index !== null && e.remove(T.index);
    for (const D in T.attributes)
      e.remove(T.attributes[D]);
    T.removeEventListener("dispose", l), delete i[T.id];
    const R = s.get(T);
    R && (e.remove(R), s.delete(T)), r.releaseStatesOfGeometry(T), T.isInstancedBufferGeometry === !0 && delete T._maxInstanceCount, t.memory.geometries--;
  }
  function d(w, T) {
    return i[T.id] === !0 || (T.addEventListener("dispose", l), i[T.id] = !0, t.memory.geometries++), T;
  }
  function p(w) {
    const T = w.attributes;
    for (const D in T)
      e.update(T[D], 34962);
    const R = w.morphAttributes;
    for (const D in R) {
      const O = R[D];
      for (let U = 0, H = O.length; U < H; U++)
        e.update(O[U], 34962);
    }
  }
  function g(w) {
    const T = [], R = w.index, D = w.attributes.position;
    let O = 0;
    if (R !== null) {
      const I = R.array;
      O = R.version;
      for (let G = 0, B = I.length; G < B; G += 3) {
        const Q = I[G + 0], K = I[G + 1], te = I[G + 2];
        T.push(Q, K, K, te, te, Q);
      }
    } else {
      const I = D.array;
      O = D.version;
      for (let G = 0, B = I.length / 3 - 1; G < B; G += 3) {
        const Q = G + 0, K = G + 1, te = G + 2;
        T.push(Q, K, K, te, te, Q);
      }
    }
    const U = new (LF(T) ? Z3 : Q3)(T, 1);
    U.version = O;
    const H = s.get(w);
    H && e.remove(H), s.set(w, U);
  }
  function _(w) {
    const T = s.get(w);
    if (T) {
      const R = w.index;
      R !== null && T.version < R.version && g(w);
    } else
      g(w);
    return s.get(w);
  }
  return {
    get: d,
    update: p,
    getWireframeAttribute: _
  };
}
function BG(a, e, t, r) {
  const i = r.isWebGL2;
  let s;
  function l(T) {
    s = T;
  }
  let d, p;
  function g(T) {
    d = T.type, p = T.bytesPerElement;
  }
  function _(T, R) {
    a.drawElements(s, R, d, T * p), t.update(R, s, 1);
  }
  function w(T, R, D) {
    if (D === 0)
      return;
    let O, U;
    if (i)
      O = a, U = "drawElementsInstanced";
    else if (O = e.get("ANGLE_instanced_arrays"), U = "drawElementsInstancedANGLE", O === null) {
      console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    O[U](s, R, d, T * p, D), t.update(R, s, D);
  }
  this.setMode = l, this.setIndex = g, this.render = _, this.renderInstances = w;
}
function HG(a) {
  const e = {
    geometries: 0,
    textures: 0
  }, t = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function r(s, l, d) {
    switch (t.calls++, l) {
      case 4:
        t.triangles += d * (s / 3);
        break;
      case 1:
        t.lines += d * (s / 2);
        break;
      case 3:
        t.lines += d * (s - 1);
        break;
      case 2:
        t.lines += d * s;
        break;
      case 0:
        t.points += d * s;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", l);
        break;
    }
  }
  function i() {
    t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: i,
    update: r
  };
}
function VG(a, e) {
  return a[0] - e[0];
}
function GG(a, e) {
  return Math.abs(e[1]) - Math.abs(a[1]);
}
function XA(a, e) {
  let t = 1;
  const r = e.isInterleavedBufferAttribute ? e.data.array : e.array;
  r instanceof Int8Array ? t = 127 : r instanceof Uint8Array ? t = 255 : r instanceof Uint16Array ? t = 65535 : r instanceof Int16Array ? t = 32767 : r instanceof Int32Array ? t = 2147483647 : console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", r), a.divideScalar(t);
}
function WG(a, e, t) {
  const r = {}, i = new Float32Array(8), s = /* @__PURE__ */ new WeakMap(), l = new ra(), d = [];
  for (let g = 0; g < 8; g++)
    d[g] = [g, 0];
  function p(g, _, w, T) {
    const R = g.morphTargetInfluences;
    if (e.isWebGL2 === !0) {
      const D = _.morphAttributes.position || _.morphAttributes.normal || _.morphAttributes.color, O = D !== void 0 ? D.length : 0;
      let U = s.get(_);
      if (U === void 0 || U.count !== O) {
        let De = function() {
          Me.dispose(), s.delete(_), _.removeEventListener("dispose", De);
        };
        U !== void 0 && U.texture.dispose();
        const G = _.morphAttributes.position !== void 0, B = _.morphAttributes.normal !== void 0, Q = _.morphAttributes.color !== void 0, K = _.morphAttributes.position || [], te = _.morphAttributes.normal || [], Y = _.morphAttributes.color || [];
        let re = 0;
        G === !0 && (re = 1), B === !0 && (re = 2), Q === !0 && (re = 3);
        let se = _.attributes.position.count * re, ce = 1;
        se > e.maxTextureSize && (ce = Math.ceil(se / e.maxTextureSize), se = e.maxTextureSize);
        const ue = new Float32Array(se * ce * 4 * O), Me = new JM(ue, se, ce, O);
        Me.type = fy, Me.needsUpdate = !0;
        const me = re * 4;
        for (let Re = 0; Re < O; Re++) {
          const He = K[Re], ve = te[Re], fe = Y[Re], he = se * ce * 4 * Re;
          for (let ye = 0; ye < He.count; ye++) {
            const Ee = ye * me;
            G === !0 && (l.fromBufferAttribute(He, ye), He.normalized === !0 && XA(l, He), ue[he + Ee + 0] = l.x, ue[he + Ee + 1] = l.y, ue[he + Ee + 2] = l.z, ue[he + Ee + 3] = 0), B === !0 && (l.fromBufferAttribute(ve, ye), ve.normalized === !0 && XA(l, ve), ue[he + Ee + 4] = l.x, ue[he + Ee + 5] = l.y, ue[he + Ee + 6] = l.z, ue[he + Ee + 7] = 0), Q === !0 && (l.fromBufferAttribute(fe, ye), fe.normalized === !0 && XA(l, fe), ue[he + Ee + 8] = l.x, ue[he + Ee + 9] = l.y, ue[he + Ee + 10] = l.z, ue[he + Ee + 11] = fe.itemSize === 4 ? l.w : 1);
          }
        }
        U = {
          count: O,
          texture: Me,
          size: new zt(se, ce)
        }, s.set(_, U), _.addEventListener("dispose", De);
      }
      let H = 0;
      for (let G = 0; G < R.length; G++)
        H += R[G];
      const I = _.morphTargetsRelative ? 1 : 1 - H;
      T.getUniforms().setValue(a, "morphTargetBaseInfluence", I), T.getUniforms().setValue(a, "morphTargetInfluences", R), T.getUniforms().setValue(a, "morphTargetsTexture", U.texture, t), T.getUniforms().setValue(a, "morphTargetsTextureSize", U.size);
    } else {
      const D = R === void 0 ? 0 : R.length;
      let O = r[_.id];
      if (O === void 0 || O.length !== D) {
        O = [];
        for (let B = 0; B < D; B++)
          O[B] = [B, 0];
        r[_.id] = O;
      }
      for (let B = 0; B < D; B++) {
        const Q = O[B];
        Q[0] = B, Q[1] = R[B];
      }
      O.sort(GG);
      for (let B = 0; B < 8; B++)
        B < D && O[B][1] ? (d[B][0] = O[B][0], d[B][1] = O[B][1]) : (d[B][0] = Number.MAX_SAFE_INTEGER, d[B][1] = 0);
      d.sort(VG);
      const U = _.morphAttributes.position, H = _.morphAttributes.normal;
      let I = 0;
      for (let B = 0; B < 8; B++) {
        const Q = d[B], K = Q[0], te = Q[1];
        K !== Number.MAX_SAFE_INTEGER && te ? (U && _.getAttribute("morphTarget" + B) !== U[K] && _.setAttribute("morphTarget" + B, U[K]), H && _.getAttribute("morphNormal" + B) !== H[K] && _.setAttribute("morphNormal" + B, H[K]), i[B] = te, I += te) : (U && _.hasAttribute("morphTarget" + B) === !0 && _.deleteAttribute("morphTarget" + B), H && _.hasAttribute("morphNormal" + B) === !0 && _.deleteAttribute("morphNormal" + B), i[B] = 0);
      }
      const G = _.morphTargetsRelative ? 1 : 1 - I;
      T.getUniforms().setValue(a, "morphTargetBaseInfluence", G), T.getUniforms().setValue(a, "morphTargetInfluences", i);
    }
  }
  return {
    update: p
  };
}
function jG(a, e, t, r) {
  let i = /* @__PURE__ */ new WeakMap();
  function s(p) {
    const g = r.render.frame, _ = p.geometry, w = e.get(p, _);
    return i.get(w) !== g && (e.update(w), i.set(w, g)), p.isInstancedMesh && (p.hasEventListener("dispose", d) === !1 && p.addEventListener("dispose", d), t.update(p.instanceMatrix, 34962), p.instanceColor !== null && t.update(p.instanceColor, 34962)), w;
  }
  function l() {
    i = /* @__PURE__ */ new WeakMap();
  }
  function d(p) {
    const g = p.target;
    g.removeEventListener("dispose", d), t.remove(g.instanceMatrix), g.instanceColor !== null && t.remove(g.instanceColor);
  }
  return {
    update: s,
    dispose: l
  };
}
const NF = /* @__PURE__ */ new su(), FF = /* @__PURE__ */ new JM(), kF = /* @__PURE__ */ new IC(), IF = /* @__PURE__ */ new eT(), ZO = [], JO = [], KO = new Float32Array(16), $O = new Float32Array(9), eU = new Float32Array(4);
function mb(a, e, t) {
  const r = a[0];
  if (r <= 0 || r > 0)
    return a;
  const i = e * t;
  let s = ZO[i];
  if (s === void 0 && (s = new Float32Array(i), ZO[i] = s), e !== 0) {
    r.toArray(s, 0);
    for (let l = 1, d = 0; l !== e; ++l)
      d += t, a[l].toArray(s, d);
  }
  return s;
}
function Qh(a, e) {
  if (a.length !== e.length)
    return !1;
  for (let t = 0, r = a.length; t < r; t++)
    if (a[t] !== e[t])
      return !1;
  return !0;
}
function Zh(a, e) {
  for (let t = 0, r = e.length; t < r; t++)
    a[t] = e[t];
}
function HC(a, e) {
  let t = JO[e];
  t === void 0 && (t = new Int32Array(e), JO[e] = t);
  for (let r = 0; r !== e; ++r)
    t[r] = a.allocateTextureUnit();
  return t;
}
function YG(a, e) {
  const t = this.cache;
  t[0] !== e && (a.uniform1f(this.addr, e), t[0] = e);
}
function XG(a, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (a.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (Qh(t, e))
      return;
    a.uniform2fv(this.addr, e), Zh(t, e);
  }
}
function qG(a, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (a.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (a.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
  else {
    if (Qh(t, e))
      return;
    a.uniform3fv(this.addr, e), Zh(t, e);
  }
}
function QG(a, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (a.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (Qh(t, e))
      return;
    a.uniform4fv(this.addr, e), Zh(t, e);
  }
}
function ZG(a, e) {
  const t = this.cache, r = e.elements;
  if (r === void 0) {
    if (Qh(t, e))
      return;
    a.uniformMatrix2fv(this.addr, !1, e), Zh(t, e);
  } else {
    if (Qh(t, r))
      return;
    eU.set(r), a.uniformMatrix2fv(this.addr, !1, eU), Zh(t, r);
  }
}
function JG(a, e) {
  const t = this.cache, r = e.elements;
  if (r === void 0) {
    if (Qh(t, e))
      return;
    a.uniformMatrix3fv(this.addr, !1, e), Zh(t, e);
  } else {
    if (Qh(t, r))
      return;
    $O.set(r), a.uniformMatrix3fv(this.addr, !1, $O), Zh(t, r);
  }
}
function KG(a, e) {
  const t = this.cache, r = e.elements;
  if (r === void 0) {
    if (Qh(t, e))
      return;
    a.uniformMatrix4fv(this.addr, !1, e), Zh(t, e);
  } else {
    if (Qh(t, r))
      return;
    KO.set(r), a.uniformMatrix4fv(this.addr, !1, KO), Zh(t, r);
  }
}
function $G(a, e) {
  const t = this.cache;
  t[0] !== e && (a.uniform1i(this.addr, e), t[0] = e);
}
function e8(a, e) {
  const t = this.cache;
  Qh(t, e) || (a.uniform2iv(this.addr, e), Zh(t, e));
}
function t8(a, e) {
  const t = this.cache;
  Qh(t, e) || (a.uniform3iv(this.addr, e), Zh(t, e));
}
function n8(a, e) {
  const t = this.cache;
  Qh(t, e) || (a.uniform4iv(this.addr, e), Zh(t, e));
}
function r8(a, e) {
  const t = this.cache;
  t[0] !== e && (a.uniform1ui(this.addr, e), t[0] = e);
}
function i8(a, e) {
  const t = this.cache;
  Qh(t, e) || (a.uniform2uiv(this.addr, e), Zh(t, e));
}
function a8(a, e) {
  const t = this.cache;
  Qh(t, e) || (a.uniform3uiv(this.addr, e), Zh(t, e));
}
function s8(a, e) {
  const t = this.cache;
  Qh(t, e) || (a.uniform4uiv(this.addr, e), Zh(t, e));
}
function o8(a, e, t) {
  const r = this.cache, i = t.allocateTextureUnit();
  r[0] !== i && (a.uniform1i(this.addr, i), r[0] = i), t.setTexture2D(e || NF, i);
}
function l8(a, e, t) {
  const r = this.cache, i = t.allocateTextureUnit();
  r[0] !== i && (a.uniform1i(this.addr, i), r[0] = i), t.setTexture3D(e || kF, i);
}
function u8(a, e, t) {
  const r = this.cache, i = t.allocateTextureUnit();
  r[0] !== i && (a.uniform1i(this.addr, i), r[0] = i), t.setTextureCube(e || IF, i);
}
function c8(a, e, t) {
  const r = this.cache, i = t.allocateTextureUnit();
  r[0] !== i && (a.uniform1i(this.addr, i), r[0] = i), t.setTexture2DArray(e || FF, i);
}
function f8(a) {
  switch (a) {
    case 5126:
      return YG;
    case 35664:
      return XG;
    case 35665:
      return qG;
    case 35666:
      return QG;
    case 35674:
      return ZG;
    case 35675:
      return JG;
    case 35676:
      return KG;
    case 5124:
    case 35670:
      return $G;
    case 35667:
    case 35671:
      return e8;
    case 35668:
    case 35672:
      return t8;
    case 35669:
    case 35673:
      return n8;
    case 5125:
      return r8;
    case 36294:
      return i8;
    case 36295:
      return a8;
    case 36296:
      return s8;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return o8;
    case 35679:
    case 36299:
    case 36307:
      return l8;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return u8;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return c8;
  }
}
function d8(a, e) {
  a.uniform1fv(this.addr, e);
}
function h8(a, e) {
  const t = mb(e, this.size, 2);
  a.uniform2fv(this.addr, t);
}
function p8(a, e) {
  const t = mb(e, this.size, 3);
  a.uniform3fv(this.addr, t);
}
function m8(a, e) {
  const t = mb(e, this.size, 4);
  a.uniform4fv(this.addr, t);
}
function v8(a, e) {
  const t = mb(e, this.size, 4);
  a.uniformMatrix2fv(this.addr, !1, t);
}
function g8(a, e) {
  const t = mb(e, this.size, 9);
  a.uniformMatrix3fv(this.addr, !1, t);
}
function y8(a, e) {
  const t = mb(e, this.size, 16);
  a.uniformMatrix4fv(this.addr, !1, t);
}
function x8(a, e) {
  a.uniform1iv(this.addr, e);
}
function _8(a, e) {
  a.uniform2iv(this.addr, e);
}
function S8(a, e) {
  a.uniform3iv(this.addr, e);
}
function w8(a, e) {
  a.uniform4iv(this.addr, e);
}
function b8(a, e) {
  a.uniform1uiv(this.addr, e);
}
function E8(a, e) {
  a.uniform2uiv(this.addr, e);
}
function M8(a, e) {
  a.uniform3uiv(this.addr, e);
}
function T8(a, e) {
  a.uniform4uiv(this.addr, e);
}
function C8(a, e, t) {
  const r = e.length, i = HC(t, r);
  a.uniform1iv(this.addr, i);
  for (let s = 0; s !== r; ++s)
    t.setTexture2D(e[s] || NF, i[s]);
}
function R8(a, e, t) {
  const r = e.length, i = HC(t, r);
  a.uniform1iv(this.addr, i);
  for (let s = 0; s !== r; ++s)
    t.setTexture3D(e[s] || kF, i[s]);
}
function A8(a, e, t) {
  const r = e.length, i = HC(t, r);
  a.uniform1iv(this.addr, i);
  for (let s = 0; s !== r; ++s)
    t.setTextureCube(e[s] || IF, i[s]);
}
function D8(a, e, t) {
  const r = e.length, i = HC(t, r);
  a.uniform1iv(this.addr, i);
  for (let s = 0; s !== r; ++s)
    t.setTexture2DArray(e[s] || FF, i[s]);
}
function L8(a) {
  switch (a) {
    case 5126:
      return d8;
    case 35664:
      return h8;
    case 35665:
      return p8;
    case 35666:
      return m8;
    case 35674:
      return v8;
    case 35675:
      return g8;
    case 35676:
      return y8;
    case 5124:
    case 35670:
      return x8;
    case 35667:
    case 35671:
      return _8;
    case 35668:
    case 35672:
      return S8;
    case 35669:
    case 35673:
      return w8;
    case 5125:
      return b8;
    case 36294:
      return E8;
    case 36295:
      return M8;
    case 36296:
      return T8;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return C8;
    case 35679:
    case 36299:
    case 36307:
      return R8;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return A8;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return D8;
  }
}
class P8 {
  constructor(e, t, r) {
    this.id = e, this.addr = r, this.cache = [], this.setValue = f8(t.type);
  }
}
class O8 {
  constructor(e, t, r) {
    this.id = e, this.addr = r, this.cache = [], this.size = t.size, this.setValue = L8(t.type);
  }
}
class U8 {
  constructor(e) {
    this.id = e, this.seq = [], this.map = {};
  }
  setValue(e, t, r) {
    const i = this.seq;
    for (let s = 0, l = i.length; s !== l; ++s) {
      const d = i[s];
      d.setValue(e, t[d.id], r);
    }
  }
}
const qA = /(\w+)(\])?(\[|\.)?/g;
function tU(a, e) {
  a.seq.push(e), a.map[e.id] = e;
}
function z8(a, e, t) {
  const r = a.name, i = r.length;
  for (qA.lastIndex = 0; ; ) {
    const s = qA.exec(r), l = qA.lastIndex;
    let d = s[1];
    const p = s[2] === "]", g = s[3];
    if (p && (d = d | 0), g === void 0 || g === "[" && l + 2 === i) {
      tU(t, g === void 0 ? new P8(d, a, e) : new O8(d, a, e));
      break;
    } else {
      let w = t.map[d];
      w === void 0 && (w = new U8(d), tU(t, w)), t = w;
    }
  }
}
class vC {
  constructor(e, t) {
    this.seq = [], this.map = {};
    const r = e.getProgramParameter(t, 35718);
    for (let i = 0; i < r; ++i) {
      const s = e.getActiveUniform(t, i), l = e.getUniformLocation(t, s.name);
      z8(s, l, this);
    }
  }
  setValue(e, t, r, i) {
    const s = this.map[t];
    s !== void 0 && s.setValue(e, r, i);
  }
  setOptional(e, t, r) {
    const i = t[r];
    i !== void 0 && this.setValue(e, r, i);
  }
  static upload(e, t, r, i) {
    for (let s = 0, l = t.length; s !== l; ++s) {
      const d = t[s], p = r[d.id];
      p.needsUpdate !== !1 && d.setValue(e, p.value, i);
    }
  }
  static seqWithValue(e, t) {
    const r = [];
    for (let i = 0, s = e.length; i !== s; ++i) {
      const l = e[i];
      l.id in t && r.push(l);
    }
    return r;
  }
}
function nU(a, e, t) {
  const r = a.createShader(e);
  return a.shaderSource(r, t), a.compileShader(r), r;
}
let N8 = 0;
function F8(a, e) {
  const t = a.split(`
`), r = [], i = Math.max(e - 6, 0), s = Math.min(e + 6, t.length);
  for (let l = i; l < s; l++) {
    const d = l + 1;
    r.push(`${d === e ? ">" : " "} ${d}: ${t[l]}`);
  }
  return r.join(`
`);
}
function k8(a) {
  switch (a) {
    case wv:
      return ["Linear", "( value )"];
    case gi:
      return ["sRGB", "( value )"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported encoding:", a), ["Linear", "( value )"];
  }
}
function rU(a, e, t) {
  const r = a.getShaderParameter(e, 35713), i = a.getShaderInfoLog(e).trim();
  if (r && i === "")
    return "";
  const s = /ERROR: 0:(\d+)/.exec(i);
  if (s) {
    const l = parseInt(s[1]);
    return t.toUpperCase() + `

` + i + `

` + F8(a.getShaderSource(e), l);
  } else
    return i;
}
function I8(a, e) {
  const t = k8(e);
  return "vec4 " + a + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }";
}
function B8(a, e) {
  let t;
  switch (e) {
    case aF:
      t = "Linear";
      break;
    case sF:
      t = "Reinhard";
      break;
    case oF:
      t = "OptimizedCineon";
      break;
    case G3:
      t = "ACESFilmic";
      break;
    case lF:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear";
  }
  return "vec3 " + a + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
}
function H8(a) {
  return [
    a.extensionDerivatives || !!a.envMapCubeUVHeight || a.bumpMap || a.tangentSpaceNormalMap || a.clearcoatNormalMap || a.flatShading || a.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (a.extensionFragDepth || a.logarithmicDepthBuffer) && a.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    a.extensionDrawBuffers && a.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (a.extensionShaderTextureLOD || a.envMap || a.transmission) && a.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ].filter(vM).join(`
`);
}
function V8(a) {
  const e = [];
  for (const t in a) {
    const r = a[t];
    r !== !1 && e.push("#define " + t + " " + r);
  }
  return e.join(`
`);
}
function G8(a, e) {
  const t = {}, r = a.getProgramParameter(e, 35721);
  for (let i = 0; i < r; i++) {
    const s = a.getActiveAttrib(e, i), l = s.name;
    let d = 1;
    s.type === 35674 && (d = 2), s.type === 35675 && (d = 3), s.type === 35676 && (d = 4), t[l] = {
      type: s.type,
      location: a.getAttribLocation(e, l),
      locationSize: d
    };
  }
  return t;
}
function vM(a) {
  return a !== "";
}
function iU(a, e) {
  return a.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function aU(a, e) {
  return a.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const W8 = /^[ \t]*#include +<([\w\d./]+)>/gm;
function g3(a) {
  return a.replace(W8, j8);
}
function j8(a, e) {
  const t = na[e];
  if (t === void 0)
    throw new Error("Can not resolve #include <" + e + ">");
  return g3(t);
}
const Y8 = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, X8 = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function sU(a) {
  return a.replace(X8, BF).replace(Y8, q8);
}
function q8(a, e, t, r) {
  return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), BF(a, e, t, r);
}
function BF(a, e, t, r) {
  let i = "";
  for (let s = parseInt(e); s < parseInt(t); s++)
    i += r.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
  return i;
}
function oU(a) {
  let e = "precision " + a.precision + ` float;
precision ` + a.precision + " int;";
  return a.precision === "highp" ? e += `
#define HIGH_PRECISION` : a.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : a.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function Q8(a) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return a.shadowMapType === UC ? e = "SHADOWMAP_TYPE_PCF" : a.shadowMapType === _M ? e = "SHADOWMAP_TYPE_PCF_SOFT" : a.shadowMapType === U_ && (e = "SHADOWMAP_TYPE_VSM"), e;
}
function Z8(a) {
  let e = "ENVMAP_TYPE_CUBE";
  if (a.envMap)
    switch (a.envMapMode) {
      case t1:
      case n1:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case hb:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function J8(a) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (a.envMap)
    switch (a.envMapMode) {
      case n1:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function K8(a) {
  let e = "ENVMAP_BLENDING_NONE";
  if (a.envMap)
    switch (a.combine) {
      case ZM:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case rF:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case iF:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function $8(a) {
  const e = a.envMapCubeUVHeight;
  if (e === null)
    return null;
  const t = Math.log2(e) - 2, r = 1 / e;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)), texelHeight: r, maxMip: t };
}
function eW(a, e, t, r) {
  const i = a.getContext(), s = t.defines;
  let l = t.vertexShader, d = t.fragmentShader;
  const p = Q8(t), g = Z8(t), _ = J8(t), w = K8(t), T = $8(t), R = t.isWebGL2 ? "" : H8(t), D = V8(s), O = i.createProgram();
  let U, H, I = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
  t.isRawShaderMaterial ? (U = [
    D
  ].filter(vM).join(`
`), U.length > 0 && (U += `
`), H = [
    R,
    D
  ].filter(vM).join(`
`), H.length > 0 && (H += `
`)) : (U = [
    oU(t),
    "#define SHADER_NAME " + t.shaderName,
    D,
    t.instancing ? "#define USE_INSTANCING" : "",
    t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    t.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.map ? "#define USE_MAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + _ : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
    t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.displacementMap && t.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
    t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
    t.vertexTangents ? "#define USE_TANGENT" : "",
    t.vertexColors ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUvs ? "#define USE_UV" : "",
    t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.skinning ? "#define USE_SKINNING" : "",
    t.morphTargets ? "#define USE_MORPHTARGETS" : "",
    t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + p : "",
    t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    "	attribute mat4 instanceMatrix;",
    "#endif",
    "#ifdef USE_INSTANCING_COLOR",
    "	attribute vec3 instanceColor;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#if defined( USE_COLOR_ALPHA )",
    "	attribute vec4 color;",
    "#elif defined( USE_COLOR )",
    "	attribute vec3 color;",
    "#endif",
    "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
    "	attribute vec3 morphTarget0;",
    "	attribute vec3 morphTarget1;",
    "	attribute vec3 morphTarget2;",
    "	attribute vec3 morphTarget3;",
    "	#ifdef USE_MORPHNORMALS",
    "		attribute vec3 morphNormal0;",
    "		attribute vec3 morphNormal1;",
    "		attribute vec3 morphNormal2;",
    "		attribute vec3 morphNormal3;",
    "	#else",
    "		attribute vec3 morphTarget4;",
    "		attribute vec3 morphTarget5;",
    "		attribute vec3 morphTarget6;",
    "		attribute vec3 morphTarget7;",
    "	#endif",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(vM).join(`
`), H = [
    R,
    oU(t),
    "#define SHADER_NAME " + t.shaderName,
    D,
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.map ? "#define USE_MAP" : "",
    t.matcap ? "#define USE_MATCAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + g : "",
    t.envMap ? "#define " + _ : "",
    t.envMap ? "#define " + w : "",
    T ? "#define CUBEUV_TEXEL_WIDTH " + T.texelWidth : "",
    T ? "#define CUBEUV_TEXEL_HEIGHT " + T.texelHeight : "",
    T ? "#define CUBEUV_MAX_MIP " + T.maxMip + ".0" : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
    t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
    t.clearcoat ? "#define USE_CLEARCOAT" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.iridescence ? "#define USE_IRIDESCENCE" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
    t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.alphaTest ? "#define USE_ALPHATEST" : "",
    t.sheen ? "#define USE_SHEEN" : "",
    t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
    t.vertexTangents ? "#define USE_TANGENT" : "",
    t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUvs ? "#define USE_UV" : "",
    t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
    t.gradientMap ? "#define USE_GRADIENTMAP" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + p : "",
    t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    t.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    t.toneMapping !== og ? "#define TONE_MAPPING" : "",
    t.toneMapping !== og ? na.tonemapping_pars_fragment : "",
    t.toneMapping !== og ? B8("toneMapping", t.toneMapping) : "",
    t.dithering ? "#define DITHERING" : "",
    t.opaque ? "#define OPAQUE" : "",
    na.encodings_pars_fragment,
    I8("linearToOutputTexel", t.outputEncoding),
    t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
    `
`
  ].filter(vM).join(`
`)), l = g3(l), l = iU(l, t), l = aU(l, t), d = g3(d), d = iU(d, t), d = aU(d, t), l = sU(l), d = sU(d), t.isWebGL2 && t.isRawShaderMaterial !== !0 && (I = `#version 300 es
`, U = [
    "precision mediump sampler2DArray;",
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + U, H = [
    "#define varying in",
    t.glslVersion === p3 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
    t.glslVersion === p3 ? "" : "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join(`
`) + `
` + H);
  const G = I + U + l, B = I + H + d, Q = nU(i, 35633, G), K = nU(i, 35632, B);
  if (i.attachShader(O, Q), i.attachShader(O, K), t.index0AttributeName !== void 0 ? i.bindAttribLocation(O, 0, t.index0AttributeName) : t.morphTargets === !0 && i.bindAttribLocation(O, 0, "position"), i.linkProgram(O), a.debug.checkShaderErrors) {
    const re = i.getProgramInfoLog(O).trim(), se = i.getShaderInfoLog(Q).trim(), ce = i.getShaderInfoLog(K).trim();
    let ue = !0, Me = !0;
    if (i.getProgramParameter(O, 35714) === !1) {
      ue = !1;
      const me = rU(i, Q, "vertex"), De = rU(i, K, "fragment");
      console.error(
        "THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(O, 35715) + `

Program Info Log: ` + re + `
` + me + `
` + De
      );
    } else
      re !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", re) : (se === "" || ce === "") && (Me = !1);
    Me && (this.diagnostics = {
      runnable: ue,
      programLog: re,
      vertexShader: {
        log: se,
        prefix: U
      },
      fragmentShader: {
        log: ce,
        prefix: H
      }
    });
  }
  i.deleteShader(Q), i.deleteShader(K);
  let te;
  this.getUniforms = function() {
    return te === void 0 && (te = new vC(i, O)), te;
  };
  let Y;
  return this.getAttributes = function() {
    return Y === void 0 && (Y = G8(i, O)), Y;
  }, this.destroy = function() {
    r.releaseStatesOfProgram(this), i.deleteProgram(O), this.program = void 0;
  }, this.name = t.shaderName, this.id = N8++, this.cacheKey = e, this.usedTimes = 1, this.program = O, this.vertexShader = Q, this.fragmentShader = K, this;
}
let tW = 0;
class nW {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(e) {
    const t = e.vertexShader, r = e.fragmentShader, i = this._getShaderStage(t), s = this._getShaderStage(r), l = this._getShaderCacheForMaterial(e);
    return l.has(i) === !1 && (l.add(i), i.usedTimes++), l.has(s) === !1 && (l.add(s), s.usedTimes++), this;
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const r of t)
      r.usedTimes--, r.usedTimes === 0 && this.shaderCache.delete(r.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    return t.has(e) === !1 && t.set(e, /* @__PURE__ */ new Set()), t.get(e);
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    if (t.has(e) === !1) {
      const r = new rW(e);
      t.set(e, r);
    }
    return t.get(e);
  }
}
class rW {
  constructor(e) {
    this.id = tW++, this.code = e, this.usedTimes = 0;
  }
}
function iW(a, e, t, r, i, s, l) {
  const d = new G_(), p = new nW(), g = [], _ = i.isWebGL2, w = i.logarithmicDepthBuffer, T = i.vertexTextures;
  let R = i.precision;
  const D = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function O(Y, re, se, ce, ue) {
    const Me = ce.fog, me = ue.geometry, De = Y.isMeshStandardMaterial ? ce.environment : null, Re = (Y.isMeshStandardMaterial ? t : e).get(Y.envMap || De), He = !!Re && Re.mapping === hb ? Re.image.height : null, ve = D[Y.type];
    Y.precision !== null && (R = i.getMaxPrecision(Y.precision), R !== Y.precision && console.warn("THREE.WebGLProgram.getParameters:", Y.precision, "not supported, using", R, "instead."));
    const fe = me.morphAttributes.position || me.morphAttributes.normal || me.morphAttributes.color, he = fe !== void 0 ? fe.length : 0;
    let ye = 0;
    me.morphAttributes.position !== void 0 && (ye = 1), me.morphAttributes.normal !== void 0 && (ye = 2), me.morphAttributes.color !== void 0 && (ye = 3);
    let Ee, Ve, Je, rt;
    if (ve) {
      const ft = Wh[ve];
      Ee = ft.vertexShader, Ve = ft.fragmentShader;
    } else
      Ee = Y.vertexShader, Ve = Y.fragmentShader, p.update(Y), Je = p.getVertexShaderID(Y), rt = p.getFragmentShaderID(Y);
    const Ne = a.getRenderTarget(), ct = Y.alphaTest > 0, tt = Y.clearcoat > 0, Tt = Y.iridescence > 0;
    return {
      isWebGL2: _,
      shaderID: ve,
      shaderName: Y.type,
      vertexShader: Ee,
      fragmentShader: Ve,
      defines: Y.defines,
      customVertexShaderID: Je,
      customFragmentShaderID: rt,
      isRawShaderMaterial: Y.isRawShaderMaterial === !0,
      glslVersion: Y.glslVersion,
      precision: R,
      instancing: ue.isInstancedMesh === !0,
      instancingColor: ue.isInstancedMesh === !0 && ue.instanceColor !== null,
      supportsVertexTextures: T,
      outputEncoding: Ne === null ? a.outputEncoding : Ne.isXRRenderTarget === !0 ? Ne.texture.encoding : wv,
      map: !!Y.map,
      matcap: !!Y.matcap,
      envMap: !!Re,
      envMapMode: Re && Re.mapping,
      envMapCubeUVHeight: He,
      lightMap: !!Y.lightMap,
      aoMap: !!Y.aoMap,
      emissiveMap: !!Y.emissiveMap,
      bumpMap: !!Y.bumpMap,
      normalMap: !!Y.normalMap,
      objectSpaceNormalMap: Y.normalMapType === CF,
      tangentSpaceNormalMap: Y.normalMapType === K_,
      decodeVideoTexture: !!Y.map && Y.map.isVideoTexture === !0 && Y.map.encoding === gi,
      clearcoat: tt,
      clearcoatMap: tt && !!Y.clearcoatMap,
      clearcoatRoughnessMap: tt && !!Y.clearcoatRoughnessMap,
      clearcoatNormalMap: tt && !!Y.clearcoatNormalMap,
      iridescence: Tt,
      iridescenceMap: Tt && !!Y.iridescenceMap,
      iridescenceThicknessMap: Tt && !!Y.iridescenceThicknessMap,
      displacementMap: !!Y.displacementMap,
      roughnessMap: !!Y.roughnessMap,
      metalnessMap: !!Y.metalnessMap,
      specularMap: !!Y.specularMap,
      specularIntensityMap: !!Y.specularIntensityMap,
      specularColorMap: !!Y.specularColorMap,
      opaque: Y.transparent === !1 && Y.blending === P0,
      alphaMap: !!Y.alphaMap,
      alphaTest: ct,
      gradientMap: !!Y.gradientMap,
      sheen: Y.sheen > 0,
      sheenColorMap: !!Y.sheenColorMap,
      sheenRoughnessMap: !!Y.sheenRoughnessMap,
      transmission: Y.transmission > 0,
      transmissionMap: !!Y.transmissionMap,
      thicknessMap: !!Y.thicknessMap,
      combine: Y.combine,
      vertexTangents: !!Y.normalMap && !!me.attributes.tangent,
      vertexColors: Y.vertexColors,
      vertexAlphas: Y.vertexColors === !0 && !!me.attributes.color && me.attributes.color.itemSize === 4,
      vertexUvs: !!Y.map || !!Y.bumpMap || !!Y.normalMap || !!Y.specularMap || !!Y.alphaMap || !!Y.emissiveMap || !!Y.roughnessMap || !!Y.metalnessMap || !!Y.clearcoatMap || !!Y.clearcoatRoughnessMap || !!Y.clearcoatNormalMap || !!Y.iridescenceMap || !!Y.iridescenceThicknessMap || !!Y.displacementMap || !!Y.transmissionMap || !!Y.thicknessMap || !!Y.specularIntensityMap || !!Y.specularColorMap || !!Y.sheenColorMap || !!Y.sheenRoughnessMap,
      uvsVertexOnly: !(!!Y.map || !!Y.bumpMap || !!Y.normalMap || !!Y.specularMap || !!Y.alphaMap || !!Y.emissiveMap || !!Y.roughnessMap || !!Y.metalnessMap || !!Y.clearcoatNormalMap || !!Y.iridescenceMap || !!Y.iridescenceThicknessMap || Y.transmission > 0 || !!Y.transmissionMap || !!Y.thicknessMap || !!Y.specularIntensityMap || !!Y.specularColorMap || Y.sheen > 0 || !!Y.sheenColorMap || !!Y.sheenRoughnessMap) && !!Y.displacementMap,
      fog: !!Me,
      useFog: Y.fog === !0,
      fogExp2: Me && Me.isFogExp2,
      flatShading: !!Y.flatShading,
      sizeAttenuation: Y.sizeAttenuation,
      logarithmicDepthBuffer: w,
      skinning: ue.isSkinnedMesh === !0,
      morphTargets: me.morphAttributes.position !== void 0,
      morphNormals: me.morphAttributes.normal !== void 0,
      morphColors: me.morphAttributes.color !== void 0,
      morphTargetsCount: he,
      morphTextureStride: ye,
      numDirLights: re.directional.length,
      numPointLights: re.point.length,
      numSpotLights: re.spot.length,
      numRectAreaLights: re.rectArea.length,
      numHemiLights: re.hemi.length,
      numDirLightShadows: re.directionalShadowMap.length,
      numPointLightShadows: re.pointShadowMap.length,
      numSpotLightShadows: re.spotShadowMap.length,
      numClippingPlanes: l.numPlanes,
      numClipIntersection: l.numIntersection,
      dithering: Y.dithering,
      shadowMapEnabled: a.shadowMap.enabled && se.length > 0,
      shadowMapType: a.shadowMap.type,
      toneMapping: Y.toneMapped ? a.toneMapping : og,
      physicallyCorrectLights: a.physicallyCorrectLights,
      premultipliedAlpha: Y.premultipliedAlpha,
      doubleSided: Y.side === Yh,
      flipSided: Y.side === cf,
      useDepthPacking: !!Y.depthPacking,
      depthPacking: Y.depthPacking || 0,
      index0AttributeName: Y.index0AttributeName,
      extensionDerivatives: Y.extensions && Y.extensions.derivatives,
      extensionFragDepth: Y.extensions && Y.extensions.fragDepth,
      extensionDrawBuffers: Y.extensions && Y.extensions.drawBuffers,
      extensionShaderTextureLOD: Y.extensions && Y.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: _ || r.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: _ || r.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: _ || r.has("EXT_shader_texture_lod"),
      customProgramCacheKey: Y.customProgramCacheKey()
    };
  }
  function U(Y) {
    const re = [];
    if (Y.shaderID ? re.push(Y.shaderID) : (re.push(Y.customVertexShaderID), re.push(Y.customFragmentShaderID)), Y.defines !== void 0)
      for (const se in Y.defines)
        re.push(se), re.push(Y.defines[se]);
    return Y.isRawShaderMaterial === !1 && (H(re, Y), I(re, Y), re.push(a.outputEncoding)), re.push(Y.customProgramCacheKey), re.join();
  }
  function H(Y, re) {
    Y.push(re.precision), Y.push(re.outputEncoding), Y.push(re.envMapMode), Y.push(re.envMapCubeUVHeight), Y.push(re.combine), Y.push(re.vertexUvs), Y.push(re.fogExp2), Y.push(re.sizeAttenuation), Y.push(re.morphTargetsCount), Y.push(re.morphAttributeCount), Y.push(re.numDirLights), Y.push(re.numPointLights), Y.push(re.numSpotLights), Y.push(re.numHemiLights), Y.push(re.numRectAreaLights), Y.push(re.numDirLightShadows), Y.push(re.numPointLightShadows), Y.push(re.numSpotLightShadows), Y.push(re.shadowMapType), Y.push(re.toneMapping), Y.push(re.numClippingPlanes), Y.push(re.numClipIntersection), Y.push(re.depthPacking);
  }
  function I(Y, re) {
    d.disableAll(), re.isWebGL2 && d.enable(0), re.supportsVertexTextures && d.enable(1), re.instancing && d.enable(2), re.instancingColor && d.enable(3), re.map && d.enable(4), re.matcap && d.enable(5), re.envMap && d.enable(6), re.lightMap && d.enable(7), re.aoMap && d.enable(8), re.emissiveMap && d.enable(9), re.bumpMap && d.enable(10), re.normalMap && d.enable(11), re.objectSpaceNormalMap && d.enable(12), re.tangentSpaceNormalMap && d.enable(13), re.clearcoat && d.enable(14), re.clearcoatMap && d.enable(15), re.clearcoatRoughnessMap && d.enable(16), re.clearcoatNormalMap && d.enable(17), re.iridescence && d.enable(18), re.iridescenceMap && d.enable(19), re.iridescenceThicknessMap && d.enable(20), re.displacementMap && d.enable(21), re.specularMap && d.enable(22), re.roughnessMap && d.enable(23), re.metalnessMap && d.enable(24), re.gradientMap && d.enable(25), re.alphaMap && d.enable(26), re.alphaTest && d.enable(27), re.vertexColors && d.enable(28), re.vertexAlphas && d.enable(29), re.vertexUvs && d.enable(30), re.vertexTangents && d.enable(31), re.uvsVertexOnly && d.enable(32), re.fog && d.enable(33), Y.push(d.mask), d.disableAll(), re.useFog && d.enable(0), re.flatShading && d.enable(1), re.logarithmicDepthBuffer && d.enable(2), re.skinning && d.enable(3), re.morphTargets && d.enable(4), re.morphNormals && d.enable(5), re.morphColors && d.enable(6), re.premultipliedAlpha && d.enable(7), re.shadowMapEnabled && d.enable(8), re.physicallyCorrectLights && d.enable(9), re.doubleSided && d.enable(10), re.flipSided && d.enable(11), re.useDepthPacking && d.enable(12), re.dithering && d.enable(13), re.specularIntensityMap && d.enable(14), re.specularColorMap && d.enable(15), re.transmission && d.enable(16), re.transmissionMap && d.enable(17), re.thicknessMap && d.enable(18), re.sheen && d.enable(19), re.sheenColorMap && d.enable(20), re.sheenRoughnessMap && d.enable(21), re.decodeVideoTexture && d.enable(22), re.opaque && d.enable(23), Y.push(d.mask);
  }
  function G(Y) {
    const re = D[Y.type];
    let se;
    if (re) {
      const ce = Wh[re];
      se = $M.clone(ce.uniforms);
    } else
      se = Y.uniforms;
    return se;
  }
  function B(Y, re) {
    let se;
    for (let ce = 0, ue = g.length; ce < ue; ce++) {
      const Me = g[ce];
      if (Me.cacheKey === re) {
        se = Me, ++se.usedTimes;
        break;
      }
    }
    return se === void 0 && (se = new eW(a, re, Y, s), g.push(se)), se;
  }
  function Q(Y) {
    if (--Y.usedTimes === 0) {
      const re = g.indexOf(Y);
      g[re] = g[g.length - 1], g.pop(), Y.destroy();
    }
  }
  function K(Y) {
    p.remove(Y);
  }
  function te() {
    p.dispose();
  }
  return {
    getParameters: O,
    getProgramCacheKey: U,
    getUniforms: G,
    acquireProgram: B,
    releaseProgram: Q,
    releaseShaderCache: K,
    programs: g,
    dispose: te
  };
}
function aW() {
  let a = /* @__PURE__ */ new WeakMap();
  function e(s) {
    let l = a.get(s);
    return l === void 0 && (l = {}, a.set(s, l)), l;
  }
  function t(s) {
    a.delete(s);
  }
  function r(s, l, d) {
    a.get(s)[l] = d;
  }
  function i() {
    a = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    remove: t,
    update: r,
    dispose: i
  };
}
function sW(a, e) {
  return a.groupOrder !== e.groupOrder ? a.groupOrder - e.groupOrder : a.renderOrder !== e.renderOrder ? a.renderOrder - e.renderOrder : a.material.id !== e.material.id ? a.material.id - e.material.id : a.z !== e.z ? a.z - e.z : a.id - e.id;
}
function lU(a, e) {
  return a.groupOrder !== e.groupOrder ? a.groupOrder - e.groupOrder : a.renderOrder !== e.renderOrder ? a.renderOrder - e.renderOrder : a.z !== e.z ? e.z - a.z : a.id - e.id;
}
function uU() {
  const a = [];
  let e = 0;
  const t = [], r = [], i = [];
  function s() {
    e = 0, t.length = 0, r.length = 0, i.length = 0;
  }
  function l(w, T, R, D, O, U) {
    let H = a[e];
    return H === void 0 ? (H = {
      id: w.id,
      object: w,
      geometry: T,
      material: R,
      groupOrder: D,
      renderOrder: w.renderOrder,
      z: O,
      group: U
    }, a[e] = H) : (H.id = w.id, H.object = w, H.geometry = T, H.material = R, H.groupOrder = D, H.renderOrder = w.renderOrder, H.z = O, H.group = U), e++, H;
  }
  function d(w, T, R, D, O, U) {
    const H = l(w, T, R, D, O, U);
    R.transmission > 0 ? r.push(H) : R.transparent === !0 ? i.push(H) : t.push(H);
  }
  function p(w, T, R, D, O, U) {
    const H = l(w, T, R, D, O, U);
    R.transmission > 0 ? r.unshift(H) : R.transparent === !0 ? i.unshift(H) : t.unshift(H);
  }
  function g(w, T) {
    t.length > 1 && t.sort(w || sW), r.length > 1 && r.sort(T || lU), i.length > 1 && i.sort(T || lU);
  }
  function _() {
    for (let w = e, T = a.length; w < T; w++) {
      const R = a[w];
      if (R.id === null)
        break;
      R.id = null, R.object = null, R.geometry = null, R.material = null, R.group = null;
    }
  }
  return {
    opaque: t,
    transmissive: r,
    transparent: i,
    init: s,
    push: d,
    unshift: p,
    finish: _,
    sort: g
  };
}
function oW() {
  let a = /* @__PURE__ */ new WeakMap();
  function e(r, i) {
    let s;
    return a.has(r) === !1 ? (s = new uU(), a.set(r, [s])) : i >= a.get(r).length ? (s = new uU(), a.get(r).push(s)) : s = a.get(r)[i], s;
  }
  function t() {
    a = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    dispose: t
  };
}
function lW() {
  const a = {};
  return {
    get: function(e) {
      if (a[e.id] !== void 0)
        return a[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            direction: new ge(),
            color: new Un()
          };
          break;
        case "SpotLight":
          t = {
            position: new ge(),
            direction: new ge(),
            color: new Un(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          t = {
            position: new ge(),
            color: new Un(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          t = {
            direction: new ge(),
            skyColor: new Un(),
            groundColor: new Un()
          };
          break;
        case "RectAreaLight":
          t = {
            color: new Un(),
            position: new ge(),
            halfWidth: new ge(),
            halfHeight: new ge()
          };
          break;
      }
      return a[e.id] = t, t;
    }
  };
}
function uW() {
  const a = {};
  return {
    get: function(e) {
      if (a[e.id] !== void 0)
        return a[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new zt()
          };
          break;
        case "SpotLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new zt()
          };
          break;
        case "PointLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new zt(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return a[e.id] = t, t;
    }
  };
}
let cW = 0;
function fW(a, e) {
  return (e.castShadow ? 1 : 0) - (a.castShadow ? 1 : 0);
}
function dW(a, e) {
  const t = new lW(), r = uW(), i = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadow: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: []
  };
  for (let _ = 0; _ < 9; _++)
    i.probe.push(new ge());
  const s = new ge(), l = new Kr(), d = new Kr();
  function p(_, w) {
    let T = 0, R = 0, D = 0;
    for (let re = 0; re < 9; re++)
      i.probe[re].set(0, 0, 0);
    let O = 0, U = 0, H = 0, I = 0, G = 0, B = 0, Q = 0, K = 0;
    _.sort(fW);
    const te = w !== !0 ? Math.PI : 1;
    for (let re = 0, se = _.length; re < se; re++) {
      const ce = _[re], ue = ce.color, Me = ce.intensity, me = ce.distance, De = ce.shadow && ce.shadow.map ? ce.shadow.map.texture : null;
      if (ce.isAmbientLight)
        T += ue.r * Me * te, R += ue.g * Me * te, D += ue.b * Me * te;
      else if (ce.isLightProbe)
        for (let Re = 0; Re < 9; Re++)
          i.probe[Re].addScaledVector(ce.sh.coefficients[Re], Me);
      else if (ce.isDirectionalLight) {
        const Re = t.get(ce);
        if (Re.color.copy(ce.color).multiplyScalar(ce.intensity * te), ce.castShadow) {
          const He = ce.shadow, ve = r.get(ce);
          ve.shadowBias = He.bias, ve.shadowNormalBias = He.normalBias, ve.shadowRadius = He.radius, ve.shadowMapSize = He.mapSize, i.directionalShadow[O] = ve, i.directionalShadowMap[O] = De, i.directionalShadowMatrix[O] = ce.shadow.matrix, B++;
        }
        i.directional[O] = Re, O++;
      } else if (ce.isSpotLight) {
        const Re = t.get(ce);
        if (Re.position.setFromMatrixPosition(ce.matrixWorld), Re.color.copy(ue).multiplyScalar(Me * te), Re.distance = me, Re.coneCos = Math.cos(ce.angle), Re.penumbraCos = Math.cos(ce.angle * (1 - ce.penumbra)), Re.decay = ce.decay, ce.castShadow) {
          const He = ce.shadow, ve = r.get(ce);
          ve.shadowBias = He.bias, ve.shadowNormalBias = He.normalBias, ve.shadowRadius = He.radius, ve.shadowMapSize = He.mapSize, i.spotShadow[H] = ve, i.spotShadowMap[H] = De, i.spotShadowMatrix[H] = ce.shadow.matrix, K++;
        }
        i.spot[H] = Re, H++;
      } else if (ce.isRectAreaLight) {
        const Re = t.get(ce);
        Re.color.copy(ue).multiplyScalar(Me), Re.halfWidth.set(ce.width * 0.5, 0, 0), Re.halfHeight.set(0, ce.height * 0.5, 0), i.rectArea[I] = Re, I++;
      } else if (ce.isPointLight) {
        const Re = t.get(ce);
        if (Re.color.copy(ce.color).multiplyScalar(ce.intensity * te), Re.distance = ce.distance, Re.decay = ce.decay, ce.castShadow) {
          const He = ce.shadow, ve = r.get(ce);
          ve.shadowBias = He.bias, ve.shadowNormalBias = He.normalBias, ve.shadowRadius = He.radius, ve.shadowMapSize = He.mapSize, ve.shadowCameraNear = He.camera.near, ve.shadowCameraFar = He.camera.far, i.pointShadow[U] = ve, i.pointShadowMap[U] = De, i.pointShadowMatrix[U] = ce.shadow.matrix, Q++;
        }
        i.point[U] = Re, U++;
      } else if (ce.isHemisphereLight) {
        const Re = t.get(ce);
        Re.skyColor.copy(ce.color).multiplyScalar(Me * te), Re.groundColor.copy(ce.groundColor).multiplyScalar(Me * te), i.hemi[G] = Re, G++;
      }
    }
    I > 0 && (e.isWebGL2 || a.has("OES_texture_float_linear") === !0 ? (i.rectAreaLTC1 = In.LTC_FLOAT_1, i.rectAreaLTC2 = In.LTC_FLOAT_2) : a.has("OES_texture_half_float_linear") === !0 ? (i.rectAreaLTC1 = In.LTC_HALF_1, i.rectAreaLTC2 = In.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), i.ambient[0] = T, i.ambient[1] = R, i.ambient[2] = D;
    const Y = i.hash;
    (Y.directionalLength !== O || Y.pointLength !== U || Y.spotLength !== H || Y.rectAreaLength !== I || Y.hemiLength !== G || Y.numDirectionalShadows !== B || Y.numPointShadows !== Q || Y.numSpotShadows !== K) && (i.directional.length = O, i.spot.length = H, i.rectArea.length = I, i.point.length = U, i.hemi.length = G, i.directionalShadow.length = B, i.directionalShadowMap.length = B, i.pointShadow.length = Q, i.pointShadowMap.length = Q, i.spotShadow.length = K, i.spotShadowMap.length = K, i.directionalShadowMatrix.length = B, i.pointShadowMatrix.length = Q, i.spotShadowMatrix.length = K, Y.directionalLength = O, Y.pointLength = U, Y.spotLength = H, Y.rectAreaLength = I, Y.hemiLength = G, Y.numDirectionalShadows = B, Y.numPointShadows = Q, Y.numSpotShadows = K, i.version = cW++);
  }
  function g(_, w) {
    let T = 0, R = 0, D = 0, O = 0, U = 0;
    const H = w.matrixWorldInverse;
    for (let I = 0, G = _.length; I < G; I++) {
      const B = _[I];
      if (B.isDirectionalLight) {
        const Q = i.directional[T];
        Q.direction.setFromMatrixPosition(B.matrixWorld), s.setFromMatrixPosition(B.target.matrixWorld), Q.direction.sub(s), Q.direction.transformDirection(H), T++;
      } else if (B.isSpotLight) {
        const Q = i.spot[D];
        Q.position.setFromMatrixPosition(B.matrixWorld), Q.position.applyMatrix4(H), Q.direction.setFromMatrixPosition(B.matrixWorld), s.setFromMatrixPosition(B.target.matrixWorld), Q.direction.sub(s), Q.direction.transformDirection(H), D++;
      } else if (B.isRectAreaLight) {
        const Q = i.rectArea[O];
        Q.position.setFromMatrixPosition(B.matrixWorld), Q.position.applyMatrix4(H), d.identity(), l.copy(B.matrixWorld), l.premultiply(H), d.extractRotation(l), Q.halfWidth.set(B.width * 0.5, 0, 0), Q.halfHeight.set(0, B.height * 0.5, 0), Q.halfWidth.applyMatrix4(d), Q.halfHeight.applyMatrix4(d), O++;
      } else if (B.isPointLight) {
        const Q = i.point[R];
        Q.position.setFromMatrixPosition(B.matrixWorld), Q.position.applyMatrix4(H), R++;
      } else if (B.isHemisphereLight) {
        const Q = i.hemi[U];
        Q.direction.setFromMatrixPosition(B.matrixWorld), Q.direction.transformDirection(H), U++;
      }
    }
  }
  return {
    setup: p,
    setupView: g,
    state: i
  };
}
function cU(a, e) {
  const t = new dW(a, e), r = [], i = [];
  function s() {
    r.length = 0, i.length = 0;
  }
  function l(w) {
    r.push(w);
  }
  function d(w) {
    i.push(w);
  }
  function p(w) {
    t.setup(r, w);
  }
  function g(w) {
    t.setupView(r, w);
  }
  return {
    init: s,
    state: {
      lightsArray: r,
      shadowsArray: i,
      lights: t
    },
    setupLights: p,
    setupLightsView: g,
    pushLight: l,
    pushShadow: d
  };
}
function hW(a, e) {
  let t = /* @__PURE__ */ new WeakMap();
  function r(s, l = 0) {
    let d;
    return t.has(s) === !1 ? (d = new cU(a, e), t.set(s, [d])) : l >= t.get(s).length ? (d = new cU(a, e), t.get(s).push(d)) : d = t.get(s)[l], d;
  }
  function i() {
    t = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: r,
    dispose: i
  };
}
class tT extends hf {
  constructor(e) {
    super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = o1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
  }
}
class VC extends hf {
  constructor(e) {
    super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.referencePosition = new ge(), this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
  }
}
const pW = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, mW = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function vW(a, e, t) {
  let r = new BC();
  const i = new zt(), s = new zt(), l = new ra(), d = new tT({ depthPacking: Jw }), p = new VC(), g = {}, _ = t.maxTextureSize, w = { 0: cf, 1: vy, 2: Yh }, T = new Mu({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new zt() },
      radius: { value: 4 }
    },
    vertexShader: pW,
    fragmentShader: mW
  }), R = T.clone();
  R.defines.HORIZONTAL_PASS = 1;
  const D = new oi();
  D.setAttribute(
    "position",
    new ls(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const O = new Fn(D, T), U = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = UC, this.render = function(B, Q, K) {
    if (U.enabled === !1 || U.autoUpdate === !1 && U.needsUpdate === !1 || B.length === 0)
      return;
    const te = a.getRenderTarget(), Y = a.getActiveCubeFace(), re = a.getActiveMipmapLevel(), se = a.state;
    se.setBlending(ff), se.buffers.color.setClear(1, 1, 1, 1), se.buffers.depth.setTest(!0), se.setScissorTest(!1);
    for (let ce = 0, ue = B.length; ce < ue; ce++) {
      const Me = B[ce], me = Me.shadow;
      if (me === void 0) {
        console.warn("THREE.WebGLShadowMap:", Me, "has no shadow.");
        continue;
      }
      if (me.autoUpdate === !1 && me.needsUpdate === !1)
        continue;
      i.copy(me.mapSize);
      const De = me.getFrameExtents();
      if (i.multiply(De), s.copy(me.mapSize), (i.x > _ || i.y > _) && (i.x > _ && (s.x = Math.floor(_ / De.x), i.x = s.x * De.x, me.mapSize.x = s.x), i.y > _ && (s.y = Math.floor(_ / De.y), i.y = s.y * De.y, me.mapSize.y = s.y)), me.map === null) {
        const He = this.type !== U_ ? { minFilter: fo, magFilter: fo } : {};
        me.map = new po(i.x, i.y, He), me.map.texture.name = Me.name + ".shadowMap", me.camera.updateProjectionMatrix();
      }
      a.setRenderTarget(me.map), a.clear();
      const Re = me.getViewportCount();
      for (let He = 0; He < Re; He++) {
        const ve = me.getViewport(He);
        l.set(
          s.x * ve.x,
          s.y * ve.y,
          s.x * ve.z,
          s.y * ve.w
        ), se.viewport(l), me.updateMatrices(Me, He), r = me.getFrustum(), G(Q, K, me.camera, Me, this.type);
      }
      me.isPointLightShadow !== !0 && this.type === U_ && H(me, K), me.needsUpdate = !1;
    }
    U.needsUpdate = !1, a.setRenderTarget(te, Y, re);
  };
  function H(B, Q) {
    const K = e.update(O);
    T.defines.VSM_SAMPLES !== B.blurSamples && (T.defines.VSM_SAMPLES = B.blurSamples, R.defines.VSM_SAMPLES = B.blurSamples, T.needsUpdate = !0, R.needsUpdate = !0), B.mapPass === null && (B.mapPass = new po(i.x, i.y)), T.uniforms.shadow_pass.value = B.map.texture, T.uniforms.resolution.value = B.mapSize, T.uniforms.radius.value = B.radius, a.setRenderTarget(B.mapPass), a.clear(), a.renderBufferDirect(Q, null, K, T, O, null), R.uniforms.shadow_pass.value = B.mapPass.texture, R.uniforms.resolution.value = B.mapSize, R.uniforms.radius.value = B.radius, a.setRenderTarget(B.map), a.clear(), a.renderBufferDirect(Q, null, K, R, O, null);
  }
  function I(B, Q, K, te, Y, re) {
    let se = null;
    const ce = K.isPointLight === !0 ? B.customDistanceMaterial : B.customDepthMaterial;
    if (ce !== void 0 ? se = ce : se = K.isPointLight === !0 ? p : d, a.localClippingEnabled && Q.clipShadows === !0 && Array.isArray(Q.clippingPlanes) && Q.clippingPlanes.length !== 0 || Q.displacementMap && Q.displacementScale !== 0 || Q.alphaMap && Q.alphaTest > 0) {
      const ue = se.uuid, Me = Q.uuid;
      let me = g[ue];
      me === void 0 && (me = {}, g[ue] = me);
      let De = me[Me];
      De === void 0 && (De = se.clone(), me[Me] = De), se = De;
    }
    return se.visible = Q.visible, se.wireframe = Q.wireframe, re === U_ ? se.side = Q.shadowSide !== null ? Q.shadowSide : Q.side : se.side = Q.shadowSide !== null ? Q.shadowSide : w[Q.side], se.alphaMap = Q.alphaMap, se.alphaTest = Q.alphaTest, se.clipShadows = Q.clipShadows, se.clippingPlanes = Q.clippingPlanes, se.clipIntersection = Q.clipIntersection, se.displacementMap = Q.displacementMap, se.displacementScale = Q.displacementScale, se.displacementBias = Q.displacementBias, se.wireframeLinewidth = Q.wireframeLinewidth, se.linewidth = Q.linewidth, K.isPointLight === !0 && se.isMeshDistanceMaterial === !0 && (se.referencePosition.setFromMatrixPosition(K.matrixWorld), se.nearDistance = te, se.farDistance = Y), se;
  }
  function G(B, Q, K, te, Y) {
    if (B.visible === !1)
      return;
    if (B.layers.test(Q.layers) && (B.isMesh || B.isLine || B.isPoints) && (B.castShadow || B.receiveShadow && Y === U_) && (!B.frustumCulled || r.intersectsObject(B))) {
      B.modelViewMatrix.multiplyMatrices(K.matrixWorldInverse, B.matrixWorld);
      const ce = e.update(B), ue = B.material;
      if (Array.isArray(ue)) {
        const Me = ce.groups;
        for (let me = 0, De = Me.length; me < De; me++) {
          const Re = Me[me], He = ue[Re.materialIndex];
          if (He && He.visible) {
            const ve = I(B, He, te, K.near, K.far, Y);
            a.renderBufferDirect(K, null, ce, ve, B, Re);
          }
        }
      } else if (ue.visible) {
        const Me = I(B, ue, te, K.near, K.far, Y);
        a.renderBufferDirect(K, null, ce, Me, B, null);
      }
    }
    const se = B.children;
    for (let ce = 0, ue = se.length; ce < ue; ce++)
      G(se[ce], Q, K, te, Y);
  }
}
function gW(a, e, t) {
  const r = t.isWebGL2;
  function i() {
    let ze = !1;
    const wt = new ra();
    let Pe = null;
    const Gt = new ra(0, 0, 0, 0);
    return {
      setMask: function(At) {
        Pe !== At && !ze && (a.colorMask(At, At, At, At), Pe = At);
      },
      setLocked: function(At) {
        ze = At;
      },
      setClear: function(At, cn, ki, Or, Ii) {
        Ii === !0 && (At *= Or, cn *= Or, ki *= Or), wt.set(At, cn, ki, Or), Gt.equals(wt) === !1 && (a.clearColor(At, cn, ki, Or), Gt.copy(wt));
      },
      reset: function() {
        ze = !1, Pe = null, Gt.set(-1, 0, 0, 0);
      }
    };
  }
  function s() {
    let ze = !1, wt = null, Pe = null, Gt = null;
    return {
      setTest: function(At) {
        At ? ct(2929) : tt(2929);
      },
      setMask: function(At) {
        wt !== At && !ze && (a.depthMask(At), wt = At);
      },
      setFunc: function(At) {
        if (Pe !== At) {
          if (At)
            switch (At) {
              case ZN:
                a.depthFunc(512);
                break;
              case JN:
                a.depthFunc(519);
                break;
              case KN:
                a.depthFunc(513);
                break;
              case bC:
                a.depthFunc(515);
                break;
              case $N:
                a.depthFunc(514);
                break;
              case eF:
                a.depthFunc(518);
                break;
              case tF:
                a.depthFunc(516);
                break;
              case nF:
                a.depthFunc(517);
                break;
              default:
                a.depthFunc(515);
            }
          else
            a.depthFunc(515);
          Pe = At;
        }
      },
      setLocked: function(At) {
        ze = At;
      },
      setClear: function(At) {
        Gt !== At && (a.clearDepth(At), Gt = At);
      },
      reset: function() {
        ze = !1, wt = null, Pe = null, Gt = null;
      }
    };
  }
  function l() {
    let ze = !1, wt = null, Pe = null, Gt = null, At = null, cn = null, ki = null, Or = null, Ii = null;
    return {
      setTest: function(Ir) {
        ze || (Ir ? ct(2960) : tt(2960));
      },
      setMask: function(Ir) {
        wt !== Ir && !ze && (a.stencilMask(Ir), wt = Ir);
      },
      setFunc: function(Ir, Bn, Mi) {
        (Pe !== Ir || Gt !== Bn || At !== Mi) && (a.stencilFunc(Ir, Bn, Mi), Pe = Ir, Gt = Bn, At = Mi);
      },
      setOp: function(Ir, Bn, Mi) {
        (cn !== Ir || ki !== Bn || Or !== Mi) && (a.stencilOp(Ir, Bn, Mi), cn = Ir, ki = Bn, Or = Mi);
      },
      setLocked: function(Ir) {
        ze = Ir;
      },
      setClear: function(Ir) {
        Ii !== Ir && (a.clearStencil(Ir), Ii = Ir);
      },
      reset: function() {
        ze = !1, wt = null, Pe = null, Gt = null, At = null, cn = null, ki = null, Or = null, Ii = null;
      }
    };
  }
  const d = new i(), p = new s(), g = new l(), _ = /* @__PURE__ */ new WeakMap(), w = /* @__PURE__ */ new WeakMap();
  let T = {}, R = {}, D = /* @__PURE__ */ new WeakMap(), O = [], U = null, H = !1, I = null, G = null, B = null, Q = null, K = null, te = null, Y = null, re = !1, se = null, ce = null, ue = null, Me = null, me = null;
  const De = a.getParameter(35661);
  let Re = !1, He = 0;
  const ve = a.getParameter(7938);
  ve.indexOf("WebGL") !== -1 ? (He = parseFloat(/^WebGL (\d)/.exec(ve)[1]), Re = He >= 1) : ve.indexOf("OpenGL ES") !== -1 && (He = parseFloat(/^OpenGL ES (\d)/.exec(ve)[1]), Re = He >= 2);
  let fe = null, he = {};
  const ye = a.getParameter(3088), Ee = a.getParameter(2978), Ve = new ra().fromArray(ye), Je = new ra().fromArray(Ee);
  function rt(ze, wt, Pe) {
    const Gt = new Uint8Array(4), At = a.createTexture();
    a.bindTexture(ze, At), a.texParameteri(ze, 10241, 9728), a.texParameteri(ze, 10240, 9728);
    for (let cn = 0; cn < Pe; cn++)
      a.texImage2D(wt + cn, 0, 6408, 1, 1, 0, 6408, 5121, Gt);
    return At;
  }
  const Ne = {};
  Ne[3553] = rt(3553, 3553, 1), Ne[34067] = rt(34067, 34069, 6), d.setClear(0, 0, 0, 1), p.setClear(1), g.setClear(0), ct(2929), p.setFunc(bC), xt(!1), Vt(VD), ct(2884), dt(ff);
  function ct(ze) {
    T[ze] !== !0 && (a.enable(ze), T[ze] = !0);
  }
  function tt(ze) {
    T[ze] !== !1 && (a.disable(ze), T[ze] = !1);
  }
  function Tt(ze, wt) {
    return R[ze] !== wt ? (a.bindFramebuffer(ze, wt), R[ze] = wt, r && (ze === 36009 && (R[36160] = wt), ze === 36160 && (R[36009] = wt)), !0) : !1;
  }
  function gt(ze, wt) {
    let Pe = O, Gt = !1;
    if (ze)
      if (Pe = D.get(wt), Pe === void 0 && (Pe = [], D.set(wt, Pe)), ze.isWebGLMultipleRenderTargets) {
        const At = ze.texture;
        if (Pe.length !== At.length || Pe[0] !== 36064) {
          for (let cn = 0, ki = At.length; cn < ki; cn++)
            Pe[cn] = 36064 + cn;
          Pe.length = At.length, Gt = !0;
        }
      } else
        Pe[0] !== 36064 && (Pe[0] = 36064, Gt = !0);
    else
      Pe[0] !== 1029 && (Pe[0] = 1029, Gt = !0);
    Gt && (t.isWebGL2 ? a.drawBuffers(Pe) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(Pe));
  }
  function ft(ze) {
    return U !== ze ? (a.useProgram(ze), U = ze, !0) : !1;
  }
  const Ie = {
    [L_]: 32774,
    [BN]: 32778,
    [V3]: 32779
  };
  if (r)
    Ie[jD] = 32775, Ie[YD] = 32776;
  else {
    const ze = e.get("EXT_blend_minmax");
    ze !== null && (Ie[jD] = ze.MIN_EXT, Ie[YD] = ze.MAX_EXT);
  }
  const qe = {
    [HN]: 0,
    [VN]: 1,
    [GN]: 768,
    [zC]: 770,
    [QN]: 776,
    [XN]: 774,
    [jN]: 772,
    [WN]: 769,
    [NC]: 771,
    [qN]: 775,
    [YN]: 773
  };
  function dt(ze, wt, Pe, Gt, At, cn, ki, Or) {
    if (ze === ff) {
      H === !0 && (tt(3042), H = !1);
      return;
    }
    if (H === !1 && (ct(3042), H = !0), ze !== IN) {
      if (ze !== I || Or !== re) {
        if ((G !== L_ || K !== L_) && (a.blendEquation(32774), G = L_, K = L_), Or)
          switch (ze) {
            case P0:
              a.blendFuncSeparate(1, 771, 1, 771);
              break;
            case wC:
              a.blendFunc(1, 1);
              break;
            case GD:
              a.blendFuncSeparate(0, 769, 0, 1);
              break;
            case WD:
              a.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", ze);
              break;
          }
        else
          switch (ze) {
            case P0:
              a.blendFuncSeparate(770, 771, 1, 771);
              break;
            case wC:
              a.blendFunc(770, 1);
              break;
            case GD:
              a.blendFuncSeparate(0, 769, 0, 1);
              break;
            case WD:
              a.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", ze);
              break;
          }
        B = null, Q = null, te = null, Y = null, I = ze, re = Or;
      }
      return;
    }
    At = At || wt, cn = cn || Pe, ki = ki || Gt, (wt !== G || At !== K) && (a.blendEquationSeparate(Ie[wt], Ie[At]), G = wt, K = At), (Pe !== B || Gt !== Q || cn !== te || ki !== Y) && (a.blendFuncSeparate(qe[Pe], qe[Gt], qe[cn], qe[ki]), B = Pe, Q = Gt, te = cn, Y = ki), I = ze, re = null;
  }
  function ht(ze, wt) {
    ze.side === Yh ? tt(2884) : ct(2884);
    let Pe = ze.side === cf;
    wt && (Pe = !Pe), xt(Pe), ze.blending === P0 && ze.transparent === !1 ? dt(ff) : dt(ze.blending, ze.blendEquation, ze.blendSrc, ze.blendDst, ze.blendEquationAlpha, ze.blendSrcAlpha, ze.blendDstAlpha, ze.premultipliedAlpha), p.setFunc(ze.depthFunc), p.setTest(ze.depthTest), p.setMask(ze.depthWrite), d.setMask(ze.colorWrite);
    const Gt = ze.stencilWrite;
    g.setTest(Gt), Gt && (g.setMask(ze.stencilWriteMask), g.setFunc(ze.stencilFunc, ze.stencilRef, ze.stencilFuncMask), g.setOp(ze.stencilFail, ze.stencilZFail, ze.stencilZPass)), Nt(ze.polygonOffset, ze.polygonOffsetFactor, ze.polygonOffsetUnits), ze.alphaToCoverage === !0 ? ct(32926) : tt(32926);
  }
  function xt(ze) {
    se !== ze && (ze ? a.frontFace(2304) : a.frontFace(2305), se = ze);
  }
  function Vt(ze) {
    ze !== zN ? (ct(2884), ze !== ce && (ze === VD ? a.cullFace(1029) : ze === NN ? a.cullFace(1028) : a.cullFace(1032))) : tt(2884), ce = ze;
  }
  function yt(ze) {
    ze !== ue && (Re && a.lineWidth(ze), ue = ze);
  }
  function Nt(ze, wt, Pe) {
    ze ? (ct(32823), (Me !== wt || me !== Pe) && (a.polygonOffset(wt, Pe), Me = wt, me = Pe)) : tt(32823);
  }
  function Zt(ze) {
    ze ? ct(3089) : tt(3089);
  }
  function Rt(ze) {
    ze === void 0 && (ze = 33984 + De - 1), fe !== ze && (a.activeTexture(ze), fe = ze);
  }
  function we(ze, wt) {
    fe === null && Rt();
    let Pe = he[fe];
    Pe === void 0 && (Pe = { type: void 0, texture: void 0 }, he[fe] = Pe), (Pe.type !== ze || Pe.texture !== wt) && (a.bindTexture(ze, wt || Ne[ze]), Pe.type = ze, Pe.texture = wt);
  }
  function oe() {
    const ze = he[fe];
    ze !== void 0 && ze.type !== void 0 && (a.bindTexture(ze.type, null), ze.type = void 0, ze.texture = void 0);
  }
  function Qe() {
    try {
      a.compressedTexImage2D.apply(a, arguments);
    } catch (ze) {
      console.error("THREE.WebGLState:", ze);
    }
  }
  function ut() {
    try {
      a.texSubImage2D.apply(a, arguments);
    } catch (ze) {
      console.error("THREE.WebGLState:", ze);
    }
  }
  function Ft() {
    try {
      a.texSubImage3D.apply(a, arguments);
    } catch (ze) {
      console.error("THREE.WebGLState:", ze);
    }
  }
  function Ot() {
    try {
      a.compressedTexSubImage2D.apply(a, arguments);
    } catch (ze) {
      console.error("THREE.WebGLState:", ze);
    }
  }
  function Wt() {
    try {
      a.texStorage2D.apply(a, arguments);
    } catch (ze) {
      console.error("THREE.WebGLState:", ze);
    }
  }
  function it() {
    try {
      a.texStorage3D.apply(a, arguments);
    } catch (ze) {
      console.error("THREE.WebGLState:", ze);
    }
  }
  function an() {
    try {
      a.texImage2D.apply(a, arguments);
    } catch (ze) {
      console.error("THREE.WebGLState:", ze);
    }
  }
  function Be() {
    try {
      a.texImage3D.apply(a, arguments);
    } catch (ze) {
      console.error("THREE.WebGLState:", ze);
    }
  }
  function pe(ze) {
    Ve.equals(ze) === !1 && (a.scissor(ze.x, ze.y, ze.z, ze.w), Ve.copy(ze));
  }
  function Fe(ze) {
    Je.equals(ze) === !1 && (a.viewport(ze.x, ze.y, ze.z, ze.w), Je.copy(ze));
  }
  function at(ze, wt) {
    let Pe = w.get(wt);
    Pe === void 0 && (Pe = /* @__PURE__ */ new WeakMap(), w.set(wt, Pe));
    let Gt = Pe.get(ze);
    Gt === void 0 && (Gt = a.getUniformBlockIndex(wt, ze.name), Pe.set(ze, Gt));
  }
  function st(ze, wt) {
    const Gt = w.get(wt).get(ze);
    _.get(ze) !== Gt && (a.uniformBlockBinding(wt, Gt, ze.__bindingPointIndex), _.set(ze, Gt));
  }
  function dn() {
    a.disable(3042), a.disable(2884), a.disable(2929), a.disable(32823), a.disable(3089), a.disable(2960), a.disable(32926), a.blendEquation(32774), a.blendFunc(1, 0), a.blendFuncSeparate(1, 0, 1, 0), a.colorMask(!0, !0, !0, !0), a.clearColor(0, 0, 0, 0), a.depthMask(!0), a.depthFunc(513), a.clearDepth(1), a.stencilMask(4294967295), a.stencilFunc(519, 0, 4294967295), a.stencilOp(7680, 7680, 7680), a.clearStencil(0), a.cullFace(1029), a.frontFace(2305), a.polygonOffset(0, 0), a.activeTexture(33984), a.bindFramebuffer(36160, null), r === !0 && (a.bindFramebuffer(36009, null), a.bindFramebuffer(36008, null)), a.useProgram(null), a.lineWidth(1), a.scissor(0, 0, a.canvas.width, a.canvas.height), a.viewport(0, 0, a.canvas.width, a.canvas.height), T = {}, fe = null, he = {}, R = {}, D = /* @__PURE__ */ new WeakMap(), O = [], U = null, H = !1, I = null, G = null, B = null, Q = null, K = null, te = null, Y = null, re = !1, se = null, ce = null, ue = null, Me = null, me = null, Ve.set(0, 0, a.canvas.width, a.canvas.height), Je.set(0, 0, a.canvas.width, a.canvas.height), d.reset(), p.reset(), g.reset();
  }
  return {
    buffers: {
      color: d,
      depth: p,
      stencil: g
    },
    enable: ct,
    disable: tt,
    bindFramebuffer: Tt,
    drawBuffers: gt,
    useProgram: ft,
    setBlending: dt,
    setMaterial: ht,
    setFlipSided: xt,
    setCullFace: Vt,
    setLineWidth: yt,
    setPolygonOffset: Nt,
    setScissorTest: Zt,
    activeTexture: Rt,
    bindTexture: we,
    unbindTexture: oe,
    compressedTexImage2D: Qe,
    texImage2D: an,
    texImage3D: Be,
    updateUBOMapping: at,
    uniformBlockBinding: st,
    texStorage2D: Wt,
    texStorage3D: it,
    texSubImage2D: ut,
    texSubImage3D: Ft,
    compressedTexSubImage2D: Ot,
    scissor: pe,
    viewport: Fe,
    reset: dn
  };
}
function yW(a, e, t, r, i, s, l) {
  const d = i.isWebGL2, p = i.maxTextures, g = i.maxCubemapSize, _ = i.maxTextureSize, w = i.maxSamples, T = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, R = /OculusBrowser/g.test(navigator.userAgent), D = /* @__PURE__ */ new WeakMap();
  let O;
  const U = /* @__PURE__ */ new WeakMap();
  let H = !1;
  try {
    H = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function I(we, oe) {
    return H ? new OffscreenCanvas(we, oe) : zM("canvas");
  }
  function G(we, oe, Qe, ut) {
    let Ft = 1;
    if ((we.width > ut || we.height > ut) && (Ft = ut / Math.max(we.width, we.height)), Ft < 1 || oe === !0)
      if (typeof HTMLImageElement < "u" && we instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && we instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && we instanceof ImageBitmap) {
        const Ot = oe ? CC : Math.floor, Wt = Ot(Ft * we.width), it = Ot(Ft * we.height);
        O === void 0 && (O = I(Wt, it));
        const an = Qe ? I(Wt, it) : O;
        return an.width = Wt, an.height = it, an.getContext("2d").drawImage(we, 0, 0, Wt, it), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + we.width + "x" + we.height + ") to (" + Wt + "x" + it + ")."), an;
      } else
        return "data" in we && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + we.width + "x" + we.height + ")."), we;
    return we;
  }
  function B(we) {
    return m3(we.width) && m3(we.height);
  }
  function Q(we) {
    return d ? !1 : we.wrapS !== jh || we.wrapT !== jh || we.minFilter !== fo && we.minFilter !== Oo;
  }
  function K(we, oe) {
    return we.generateMipmaps && oe && we.minFilter !== fo && we.minFilter !== Oo;
  }
  function te(we) {
    a.generateMipmap(we);
  }
  function Y(we, oe, Qe, ut, Ft = !1) {
    if (d === !1)
      return oe;
    if (we !== null) {
      if (a[we] !== void 0)
        return a[we];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + we + "'");
    }
    let Ot = oe;
    return oe === 6403 && (Qe === 5126 && (Ot = 33326), Qe === 5131 && (Ot = 33325), Qe === 5121 && (Ot = 33321)), oe === 33319 && (Qe === 5126 && (Ot = 33328), Qe === 5131 && (Ot = 33327), Qe === 5121 && (Ot = 33323)), oe === 6408 && (Qe === 5126 && (Ot = 34836), Qe === 5131 && (Ot = 34842), Qe === 5121 && (Ot = ut === gi && Ft === !1 ? 35907 : 32856), Qe === 32819 && (Ot = 32854), Qe === 32820 && (Ot = 32855)), (Ot === 33325 || Ot === 33326 || Ot === 33327 || Ot === 33328 || Ot === 34842 || Ot === 34836) && e.get("EXT_color_buffer_float"), Ot;
  }
  function re(we, oe, Qe) {
    return K(we, Qe) === !0 || we.isFramebufferTexture && we.minFilter !== fo && we.minFilter !== Oo ? Math.log2(Math.max(oe.width, oe.height)) + 1 : we.mipmaps !== void 0 && we.mipmaps.length > 0 ? we.mipmaps.length : we.isCompressedTexture && Array.isArray(we.image) ? oe.mipmaps.length : 1;
  }
  function se(we) {
    return we === fo || we === EC || we === MC ? 9728 : 9729;
  }
  function ce(we) {
    const oe = we.target;
    oe.removeEventListener("dispose", ce), Me(oe), oe.isVideoTexture && D.delete(oe);
  }
  function ue(we) {
    const oe = we.target;
    oe.removeEventListener("dispose", ue), De(oe);
  }
  function Me(we) {
    const oe = r.get(we);
    if (oe.__webglInit === void 0)
      return;
    const Qe = we.source, ut = U.get(Qe);
    if (ut) {
      const Ft = ut[oe.__cacheKey];
      Ft.usedTimes--, Ft.usedTimes === 0 && me(we), Object.keys(ut).length === 0 && U.delete(Qe);
    }
    r.remove(we);
  }
  function me(we) {
    const oe = r.get(we);
    a.deleteTexture(oe.__webglTexture);
    const Qe = we.source, ut = U.get(Qe);
    delete ut[oe.__cacheKey], l.memory.textures--;
  }
  function De(we) {
    const oe = we.texture, Qe = r.get(we), ut = r.get(oe);
    if (ut.__webglTexture !== void 0 && (a.deleteTexture(ut.__webglTexture), l.memory.textures--), we.depthTexture && we.depthTexture.dispose(), we.isWebGLCubeRenderTarget)
      for (let Ft = 0; Ft < 6; Ft++)
        a.deleteFramebuffer(Qe.__webglFramebuffer[Ft]), Qe.__webglDepthbuffer && a.deleteRenderbuffer(Qe.__webglDepthbuffer[Ft]);
    else {
      if (a.deleteFramebuffer(Qe.__webglFramebuffer), Qe.__webglDepthbuffer && a.deleteRenderbuffer(Qe.__webglDepthbuffer), Qe.__webglMultisampledFramebuffer && a.deleteFramebuffer(Qe.__webglMultisampledFramebuffer), Qe.__webglColorRenderbuffer)
        for (let Ft = 0; Ft < Qe.__webglColorRenderbuffer.length; Ft++)
          Qe.__webglColorRenderbuffer[Ft] && a.deleteRenderbuffer(Qe.__webglColorRenderbuffer[Ft]);
      Qe.__webglDepthRenderbuffer && a.deleteRenderbuffer(Qe.__webglDepthRenderbuffer);
    }
    if (we.isWebGLMultipleRenderTargets)
      for (let Ft = 0, Ot = oe.length; Ft < Ot; Ft++) {
        const Wt = r.get(oe[Ft]);
        Wt.__webglTexture && (a.deleteTexture(Wt.__webglTexture), l.memory.textures--), r.remove(oe[Ft]);
      }
    r.remove(oe), r.remove(we);
  }
  let Re = 0;
  function He() {
    Re = 0;
  }
  function ve() {
    const we = Re;
    return we >= p && console.warn("THREE.WebGLTextures: Trying to use " + we + " texture units while this GPU supports only " + p), Re += 1, we;
  }
  function fe(we) {
    const oe = [];
    return oe.push(we.wrapS), oe.push(we.wrapT), oe.push(we.magFilter), oe.push(we.minFilter), oe.push(we.anisotropy), oe.push(we.internalFormat), oe.push(we.format), oe.push(we.type), oe.push(we.generateMipmaps), oe.push(we.premultiplyAlpha), oe.push(we.flipY), oe.push(we.unpackAlignment), oe.push(we.encoding), oe.join();
  }
  function he(we, oe) {
    const Qe = r.get(we);
    if (we.isVideoTexture && Zt(we), we.isRenderTargetTexture === !1 && we.version > 0 && Qe.__version !== we.version) {
      const ut = we.image;
      if (ut === null)
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if (ut.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        tt(Qe, we, oe);
        return;
      }
    }
    t.activeTexture(33984 + oe), t.bindTexture(3553, Qe.__webglTexture);
  }
  function ye(we, oe) {
    const Qe = r.get(we);
    if (we.version > 0 && Qe.__version !== we.version) {
      tt(Qe, we, oe);
      return;
    }
    t.activeTexture(33984 + oe), t.bindTexture(35866, Qe.__webglTexture);
  }
  function Ee(we, oe) {
    const Qe = r.get(we);
    if (we.version > 0 && Qe.__version !== we.version) {
      tt(Qe, we, oe);
      return;
    }
    t.activeTexture(33984 + oe), t.bindTexture(32879, Qe.__webglTexture);
  }
  function Ve(we, oe) {
    const Qe = r.get(we);
    if (we.version > 0 && Qe.__version !== we.version) {
      Tt(Qe, we, oe);
      return;
    }
    t.activeTexture(33984 + oe), t.bindTexture(34067, Qe.__webglTexture);
  }
  const Je = {
    [Zw]: 10497,
    [jh]: 33071,
    [AM]: 33648
  }, rt = {
    [fo]: 9728,
    [EC]: 9984,
    [MC]: 9986,
    [Oo]: 9729,
    [W3]: 9985,
    [s1]: 9987
  };
  function Ne(we, oe, Qe) {
    if (Qe ? (a.texParameteri(we, 10242, Je[oe.wrapS]), a.texParameteri(we, 10243, Je[oe.wrapT]), (we === 32879 || we === 35866) && a.texParameteri(we, 32882, Je[oe.wrapR]), a.texParameteri(we, 10240, rt[oe.magFilter]), a.texParameteri(we, 10241, rt[oe.minFilter])) : (a.texParameteri(we, 10242, 33071), a.texParameteri(we, 10243, 33071), (we === 32879 || we === 35866) && a.texParameteri(we, 32882, 33071), (oe.wrapS !== jh || oe.wrapT !== jh) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), a.texParameteri(we, 10240, se(oe.magFilter)), a.texParameteri(we, 10241, se(oe.minFilter)), oe.minFilter !== fo && oe.minFilter !== Oo && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), e.has("EXT_texture_filter_anisotropic") === !0) {
      const ut = e.get("EXT_texture_filter_anisotropic");
      if (oe.type === fy && e.has("OES_texture_float_linear") === !1 || d === !1 && oe.type === X_ && e.has("OES_texture_half_float_linear") === !1)
        return;
      (oe.anisotropy > 1 || r.get(oe).__currentAnisotropy) && (a.texParameterf(we, ut.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(oe.anisotropy, i.getMaxAnisotropy())), r.get(oe).__currentAnisotropy = oe.anisotropy);
    }
  }
  function ct(we, oe) {
    let Qe = !1;
    we.__webglInit === void 0 && (we.__webglInit = !0, oe.addEventListener("dispose", ce));
    const ut = oe.source;
    let Ft = U.get(ut);
    Ft === void 0 && (Ft = {}, U.set(ut, Ft));
    const Ot = fe(oe);
    if (Ot !== we.__cacheKey) {
      Ft[Ot] === void 0 && (Ft[Ot] = {
        texture: a.createTexture(),
        usedTimes: 0
      }, l.memory.textures++, Qe = !0), Ft[Ot].usedTimes++;
      const Wt = Ft[we.__cacheKey];
      Wt !== void 0 && (Ft[we.__cacheKey].usedTimes--, Wt.usedTimes === 0 && me(oe)), we.__cacheKey = Ot, we.__webglTexture = Ft[Ot].texture;
    }
    return Qe;
  }
  function tt(we, oe, Qe) {
    let ut = 3553;
    oe.isDataArrayTexture && (ut = 35866), oe.isData3DTexture && (ut = 32879);
    const Ft = ct(we, oe), Ot = oe.source;
    if (t.activeTexture(33984 + Qe), t.bindTexture(ut, we.__webglTexture), Ot.version !== Ot.__currentVersion || Ft === !0) {
      a.pixelStorei(37440, oe.flipY), a.pixelStorei(37441, oe.premultiplyAlpha), a.pixelStorei(3317, oe.unpackAlignment), a.pixelStorei(37443, 0);
      const Wt = Q(oe) && B(oe.image) === !1;
      let it = G(oe.image, Wt, !1, _);
      it = Rt(oe, it);
      const an = B(it) || d, Be = s.convert(oe.format, oe.encoding);
      let pe = s.convert(oe.type), Fe = Y(oe.internalFormat, Be, pe, oe.encoding, oe.isVideoTexture);
      Ne(ut, oe, an);
      let at;
      const st = oe.mipmaps, dn = d && oe.isVideoTexture !== !0, ze = Ot.__currentVersion === void 0 || Ft === !0, wt = re(oe, it, an);
      if (oe.isDepthTexture)
        Fe = 6402, d ? oe.type === fy ? Fe = 36012 : oe.type === L0 ? Fe = 33190 : oe.type === Kx ? Fe = 35056 : Fe = 33189 : oe.type === fy && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), oe.format === $x && Fe === 6402 && oe.type !== j3 && oe.type !== L0 && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), oe.type = L0, pe = s.convert(oe.type)), oe.format === r1 && Fe === 6402 && (Fe = 34041, oe.type !== Kx && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), oe.type = Kx, pe = s.convert(oe.type))), ze && (dn ? t.texStorage2D(3553, 1, Fe, it.width, it.height) : t.texImage2D(3553, 0, Fe, it.width, it.height, 0, Be, pe, null));
      else if (oe.isDataTexture)
        if (st.length > 0 && an) {
          dn && ze && t.texStorage2D(3553, wt, Fe, st[0].width, st[0].height);
          for (let Pe = 0, Gt = st.length; Pe < Gt; Pe++)
            at = st[Pe], dn ? t.texSubImage2D(3553, Pe, 0, 0, at.width, at.height, Be, pe, at.data) : t.texImage2D(3553, Pe, Fe, at.width, at.height, 0, Be, pe, at.data);
          oe.generateMipmaps = !1;
        } else
          dn ? (ze && t.texStorage2D(3553, wt, Fe, it.width, it.height), t.texSubImage2D(3553, 0, 0, 0, it.width, it.height, Be, pe, it.data)) : t.texImage2D(3553, 0, Fe, it.width, it.height, 0, Be, pe, it.data);
      else if (oe.isCompressedTexture) {
        dn && ze && t.texStorage2D(3553, wt, Fe, st[0].width, st[0].height);
        for (let Pe = 0, Gt = st.length; Pe < Gt; Pe++)
          at = st[Pe], oe.format !== zp ? Be !== null ? dn ? t.compressedTexSubImage2D(3553, Pe, 0, 0, at.width, at.height, Be, at.data) : t.compressedTexImage2D(3553, Pe, Fe, at.width, at.height, 0, at.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : dn ? t.texSubImage2D(3553, Pe, 0, 0, at.width, at.height, Be, pe, at.data) : t.texImage2D(3553, Pe, Fe, at.width, at.height, 0, Be, pe, at.data);
      } else if (oe.isDataArrayTexture)
        dn ? (ze && t.texStorage3D(35866, wt, Fe, it.width, it.height, it.depth), t.texSubImage3D(35866, 0, 0, 0, 0, it.width, it.height, it.depth, Be, pe, it.data)) : t.texImage3D(35866, 0, Fe, it.width, it.height, it.depth, 0, Be, pe, it.data);
      else if (oe.isData3DTexture)
        dn ? (ze && t.texStorage3D(32879, wt, Fe, it.width, it.height, it.depth), t.texSubImage3D(32879, 0, 0, 0, 0, it.width, it.height, it.depth, Be, pe, it.data)) : t.texImage3D(32879, 0, Fe, it.width, it.height, it.depth, 0, Be, pe, it.data);
      else if (oe.isFramebufferTexture) {
        if (ze)
          if (dn)
            t.texStorage2D(3553, wt, Fe, it.width, it.height);
          else {
            let Pe = it.width, Gt = it.height;
            for (let At = 0; At < wt; At++)
              t.texImage2D(3553, At, Fe, Pe, Gt, 0, Be, pe, null), Pe >>= 1, Gt >>= 1;
          }
      } else if (st.length > 0 && an) {
        dn && ze && t.texStorage2D(3553, wt, Fe, st[0].width, st[0].height);
        for (let Pe = 0, Gt = st.length; Pe < Gt; Pe++)
          at = st[Pe], dn ? t.texSubImage2D(3553, Pe, 0, 0, Be, pe, at) : t.texImage2D(3553, Pe, Fe, Be, pe, at);
        oe.generateMipmaps = !1;
      } else
        dn ? (ze && t.texStorage2D(3553, wt, Fe, it.width, it.height), t.texSubImage2D(3553, 0, 0, 0, Be, pe, it)) : t.texImage2D(3553, 0, Fe, Be, pe, it);
      K(oe, an) && te(ut), Ot.__currentVersion = Ot.version, oe.onUpdate && oe.onUpdate(oe);
    }
    we.__version = oe.version;
  }
  function Tt(we, oe, Qe) {
    if (oe.image.length !== 6)
      return;
    const ut = ct(we, oe), Ft = oe.source;
    if (t.activeTexture(33984 + Qe), t.bindTexture(34067, we.__webglTexture), Ft.version !== Ft.__currentVersion || ut === !0) {
      a.pixelStorei(37440, oe.flipY), a.pixelStorei(37441, oe.premultiplyAlpha), a.pixelStorei(3317, oe.unpackAlignment), a.pixelStorei(37443, 0);
      const Ot = oe.isCompressedTexture || oe.image[0].isCompressedTexture, Wt = oe.image[0] && oe.image[0].isDataTexture, it = [];
      for (let Pe = 0; Pe < 6; Pe++)
        !Ot && !Wt ? it[Pe] = G(oe.image[Pe], !1, !0, g) : it[Pe] = Wt ? oe.image[Pe].image : oe.image[Pe], it[Pe] = Rt(oe, it[Pe]);
      const an = it[0], Be = B(an) || d, pe = s.convert(oe.format, oe.encoding), Fe = s.convert(oe.type), at = Y(oe.internalFormat, pe, Fe, oe.encoding), st = d && oe.isVideoTexture !== !0, dn = Ft.__currentVersion === void 0 || ut === !0;
      let ze = re(oe, an, Be);
      Ne(34067, oe, Be);
      let wt;
      if (Ot) {
        st && dn && t.texStorage2D(34067, ze, at, an.width, an.height);
        for (let Pe = 0; Pe < 6; Pe++) {
          wt = it[Pe].mipmaps;
          for (let Gt = 0; Gt < wt.length; Gt++) {
            const At = wt[Gt];
            oe.format !== zp ? pe !== null ? st ? t.compressedTexSubImage2D(34069 + Pe, Gt, 0, 0, At.width, At.height, pe, At.data) : t.compressedTexImage2D(34069 + Pe, Gt, at, At.width, At.height, 0, At.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : st ? t.texSubImage2D(34069 + Pe, Gt, 0, 0, At.width, At.height, pe, Fe, At.data) : t.texImage2D(34069 + Pe, Gt, at, At.width, At.height, 0, pe, Fe, At.data);
          }
        }
      } else {
        wt = oe.mipmaps, st && dn && (wt.length > 0 && ze++, t.texStorage2D(34067, ze, at, it[0].width, it[0].height));
        for (let Pe = 0; Pe < 6; Pe++)
          if (Wt) {
            st ? t.texSubImage2D(34069 + Pe, 0, 0, 0, it[Pe].width, it[Pe].height, pe, Fe, it[Pe].data) : t.texImage2D(34069 + Pe, 0, at, it[Pe].width, it[Pe].height, 0, pe, Fe, it[Pe].data);
            for (let Gt = 0; Gt < wt.length; Gt++) {
              const cn = wt[Gt].image[Pe].image;
              st ? t.texSubImage2D(34069 + Pe, Gt + 1, 0, 0, cn.width, cn.height, pe, Fe, cn.data) : t.texImage2D(34069 + Pe, Gt + 1, at, cn.width, cn.height, 0, pe, Fe, cn.data);
            }
          } else {
            st ? t.texSubImage2D(34069 + Pe, 0, 0, 0, pe, Fe, it[Pe]) : t.texImage2D(34069 + Pe, 0, at, pe, Fe, it[Pe]);
            for (let Gt = 0; Gt < wt.length; Gt++) {
              const At = wt[Gt];
              st ? t.texSubImage2D(34069 + Pe, Gt + 1, 0, 0, pe, Fe, At.image[Pe]) : t.texImage2D(34069 + Pe, Gt + 1, at, pe, Fe, At.image[Pe]);
            }
          }
      }
      K(oe, Be) && te(34067), Ft.__currentVersion = Ft.version, oe.onUpdate && oe.onUpdate(oe);
    }
    we.__version = oe.version;
  }
  function gt(we, oe, Qe, ut, Ft) {
    const Ot = s.convert(Qe.format, Qe.encoding), Wt = s.convert(Qe.type), it = Y(Qe.internalFormat, Ot, Wt, Qe.encoding);
    r.get(oe).__hasExternalTextures || (Ft === 32879 || Ft === 35866 ? t.texImage3D(Ft, 0, it, oe.width, oe.height, oe.depth, 0, Ot, Wt, null) : t.texImage2D(Ft, 0, it, oe.width, oe.height, 0, Ot, Wt, null)), t.bindFramebuffer(36160, we), Nt(oe) ? T.framebufferTexture2DMultisampleEXT(36160, ut, Ft, r.get(Qe).__webglTexture, 0, yt(oe)) : a.framebufferTexture2D(36160, ut, Ft, r.get(Qe).__webglTexture, 0), t.bindFramebuffer(36160, null);
  }
  function ft(we, oe, Qe) {
    if (a.bindRenderbuffer(36161, we), oe.depthBuffer && !oe.stencilBuffer) {
      let ut = 33189;
      if (Qe || Nt(oe)) {
        const Ft = oe.depthTexture;
        Ft && Ft.isDepthTexture && (Ft.type === fy ? ut = 36012 : Ft.type === L0 && (ut = 33190));
        const Ot = yt(oe);
        Nt(oe) ? T.renderbufferStorageMultisampleEXT(36161, Ot, ut, oe.width, oe.height) : a.renderbufferStorageMultisample(36161, Ot, ut, oe.width, oe.height);
      } else
        a.renderbufferStorage(36161, ut, oe.width, oe.height);
      a.framebufferRenderbuffer(36160, 36096, 36161, we);
    } else if (oe.depthBuffer && oe.stencilBuffer) {
      const ut = yt(oe);
      Qe && Nt(oe) === !1 ? a.renderbufferStorageMultisample(36161, ut, 35056, oe.width, oe.height) : Nt(oe) ? T.renderbufferStorageMultisampleEXT(36161, ut, 35056, oe.width, oe.height) : a.renderbufferStorage(36161, 34041, oe.width, oe.height), a.framebufferRenderbuffer(36160, 33306, 36161, we);
    } else {
      const ut = oe.isWebGLMultipleRenderTargets === !0 ? oe.texture : [oe.texture];
      for (let Ft = 0; Ft < ut.length; Ft++) {
        const Ot = ut[Ft], Wt = s.convert(Ot.format, Ot.encoding), it = s.convert(Ot.type), an = Y(Ot.internalFormat, Wt, it, Ot.encoding), Be = yt(oe);
        Qe && Nt(oe) === !1 ? a.renderbufferStorageMultisample(36161, Be, an, oe.width, oe.height) : Nt(oe) ? T.renderbufferStorageMultisampleEXT(36161, Be, an, oe.width, oe.height) : a.renderbufferStorage(36161, an, oe.width, oe.height);
      }
    }
    a.bindRenderbuffer(36161, null);
  }
  function Ie(we, oe) {
    if (oe && oe.isWebGLCubeRenderTarget)
      throw new Error("Depth Texture with cube render targets is not supported");
    if (t.bindFramebuffer(36160, we), !(oe.depthTexture && oe.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    (!r.get(oe.depthTexture).__webglTexture || oe.depthTexture.image.width !== oe.width || oe.depthTexture.image.height !== oe.height) && (oe.depthTexture.image.width = oe.width, oe.depthTexture.image.height = oe.height, oe.depthTexture.needsUpdate = !0), he(oe.depthTexture, 0);
    const ut = r.get(oe.depthTexture).__webglTexture, Ft = yt(oe);
    if (oe.depthTexture.format === $x)
      Nt(oe) ? T.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, ut, 0, Ft) : a.framebufferTexture2D(36160, 36096, 3553, ut, 0);
    else if (oe.depthTexture.format === r1)
      Nt(oe) ? T.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, ut, 0, Ft) : a.framebufferTexture2D(36160, 33306, 3553, ut, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function qe(we) {
    const oe = r.get(we), Qe = we.isWebGLCubeRenderTarget === !0;
    if (we.depthTexture && !oe.__autoAllocateDepthBuffer) {
      if (Qe)
        throw new Error("target.depthTexture not supported in Cube render targets");
      Ie(oe.__webglFramebuffer, we);
    } else if (Qe) {
      oe.__webglDepthbuffer = [];
      for (let ut = 0; ut < 6; ut++)
        t.bindFramebuffer(36160, oe.__webglFramebuffer[ut]), oe.__webglDepthbuffer[ut] = a.createRenderbuffer(), ft(oe.__webglDepthbuffer[ut], we, !1);
    } else
      t.bindFramebuffer(36160, oe.__webglFramebuffer), oe.__webglDepthbuffer = a.createRenderbuffer(), ft(oe.__webglDepthbuffer, we, !1);
    t.bindFramebuffer(36160, null);
  }
  function dt(we, oe, Qe) {
    const ut = r.get(we);
    oe !== void 0 && gt(ut.__webglFramebuffer, we, we.texture, 36064, 3553), Qe !== void 0 && qe(we);
  }
  function ht(we) {
    const oe = we.texture, Qe = r.get(we), ut = r.get(oe);
    we.addEventListener("dispose", ue), we.isWebGLMultipleRenderTargets !== !0 && (ut.__webglTexture === void 0 && (ut.__webglTexture = a.createTexture()), ut.__version = oe.version, l.memory.textures++);
    const Ft = we.isWebGLCubeRenderTarget === !0, Ot = we.isWebGLMultipleRenderTargets === !0, Wt = B(we) || d;
    if (Ft) {
      Qe.__webglFramebuffer = [];
      for (let it = 0; it < 6; it++)
        Qe.__webglFramebuffer[it] = a.createFramebuffer();
    } else {
      if (Qe.__webglFramebuffer = a.createFramebuffer(), Ot)
        if (i.drawBuffers) {
          const it = we.texture;
          for (let an = 0, Be = it.length; an < Be; an++) {
            const pe = r.get(it[an]);
            pe.__webglTexture === void 0 && (pe.__webglTexture = a.createTexture(), l.memory.textures++);
          }
        } else
          console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
      if (d && we.samples > 0 && Nt(we) === !1) {
        const it = Ot ? oe : [oe];
        Qe.__webglMultisampledFramebuffer = a.createFramebuffer(), Qe.__webglColorRenderbuffer = [], t.bindFramebuffer(36160, Qe.__webglMultisampledFramebuffer);
        for (let an = 0; an < it.length; an++) {
          const Be = it[an];
          Qe.__webglColorRenderbuffer[an] = a.createRenderbuffer(), a.bindRenderbuffer(36161, Qe.__webglColorRenderbuffer[an]);
          const pe = s.convert(Be.format, Be.encoding), Fe = s.convert(Be.type), at = Y(Be.internalFormat, pe, Fe, Be.encoding), st = yt(we);
          a.renderbufferStorageMultisample(36161, st, at, we.width, we.height), a.framebufferRenderbuffer(36160, 36064 + an, 36161, Qe.__webglColorRenderbuffer[an]);
        }
        a.bindRenderbuffer(36161, null), we.depthBuffer && (Qe.__webglDepthRenderbuffer = a.createRenderbuffer(), ft(Qe.__webglDepthRenderbuffer, we, !0)), t.bindFramebuffer(36160, null);
      }
    }
    if (Ft) {
      t.bindTexture(34067, ut.__webglTexture), Ne(34067, oe, Wt);
      for (let it = 0; it < 6; it++)
        gt(Qe.__webglFramebuffer[it], we, oe, 36064, 34069 + it);
      K(oe, Wt) && te(34067), t.unbindTexture();
    } else if (Ot) {
      const it = we.texture;
      for (let an = 0, Be = it.length; an < Be; an++) {
        const pe = it[an], Fe = r.get(pe);
        t.bindTexture(3553, Fe.__webglTexture), Ne(3553, pe, Wt), gt(Qe.__webglFramebuffer, we, pe, 36064 + an, 3553), K(pe, Wt) && te(3553);
      }
      t.unbindTexture();
    } else {
      let it = 3553;
      (we.isWebGL3DRenderTarget || we.isWebGLArrayRenderTarget) && (d ? it = we.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), t.bindTexture(it, ut.__webglTexture), Ne(it, oe, Wt), gt(Qe.__webglFramebuffer, we, oe, 36064, it), K(oe, Wt) && te(it), t.unbindTexture();
    }
    we.depthBuffer && qe(we);
  }
  function xt(we) {
    const oe = B(we) || d, Qe = we.isWebGLMultipleRenderTargets === !0 ? we.texture : [we.texture];
    for (let ut = 0, Ft = Qe.length; ut < Ft; ut++) {
      const Ot = Qe[ut];
      if (K(Ot, oe)) {
        const Wt = we.isWebGLCubeRenderTarget ? 34067 : 3553, it = r.get(Ot).__webglTexture;
        t.bindTexture(Wt, it), te(Wt), t.unbindTexture();
      }
    }
  }
  function Vt(we) {
    if (d && we.samples > 0 && Nt(we) === !1) {
      const oe = we.isWebGLMultipleRenderTargets ? we.texture : [we.texture], Qe = we.width, ut = we.height;
      let Ft = 16384;
      const Ot = [], Wt = we.stencilBuffer ? 33306 : 36096, it = r.get(we), an = we.isWebGLMultipleRenderTargets === !0;
      if (an)
        for (let Be = 0; Be < oe.length; Be++)
          t.bindFramebuffer(36160, it.__webglMultisampledFramebuffer), a.framebufferRenderbuffer(36160, 36064 + Be, 36161, null), t.bindFramebuffer(36160, it.__webglFramebuffer), a.framebufferTexture2D(36009, 36064 + Be, 3553, null, 0);
      t.bindFramebuffer(36008, it.__webglMultisampledFramebuffer), t.bindFramebuffer(36009, it.__webglFramebuffer);
      for (let Be = 0; Be < oe.length; Be++) {
        Ot.push(36064 + Be), we.depthBuffer && Ot.push(Wt);
        const pe = it.__ignoreDepthValues !== void 0 ? it.__ignoreDepthValues : !1;
        if (pe === !1 && (we.depthBuffer && (Ft |= 256), we.stencilBuffer && (Ft |= 1024)), an && a.framebufferRenderbuffer(36008, 36064, 36161, it.__webglColorRenderbuffer[Be]), pe === !0 && (a.invalidateFramebuffer(36008, [Wt]), a.invalidateFramebuffer(36009, [Wt])), an) {
          const Fe = r.get(oe[Be]).__webglTexture;
          a.framebufferTexture2D(36009, 36064, 3553, Fe, 0);
        }
        a.blitFramebuffer(0, 0, Qe, ut, 0, 0, Qe, ut, Ft, 9728), R && a.invalidateFramebuffer(36008, Ot);
      }
      if (t.bindFramebuffer(36008, null), t.bindFramebuffer(36009, null), an)
        for (let Be = 0; Be < oe.length; Be++) {
          t.bindFramebuffer(36160, it.__webglMultisampledFramebuffer), a.framebufferRenderbuffer(36160, 36064 + Be, 36161, it.__webglColorRenderbuffer[Be]);
          const pe = r.get(oe[Be]).__webglTexture;
          t.bindFramebuffer(36160, it.__webglFramebuffer), a.framebufferTexture2D(36009, 36064 + Be, 3553, pe, 0);
        }
      t.bindFramebuffer(36009, it.__webglMultisampledFramebuffer);
    }
  }
  function yt(we) {
    return Math.min(w, we.samples);
  }
  function Nt(we) {
    const oe = r.get(we);
    return d && we.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && oe.__useRenderToTexture !== !1;
  }
  function Zt(we) {
    const oe = l.render.frame;
    D.get(we) !== oe && (D.set(we, oe), we.update());
  }
  function Rt(we, oe) {
    const Qe = we.encoding, ut = we.format, Ft = we.type;
    return we.isCompressedTexture === !0 || we.isVideoTexture === !0 || we.format === TC || Qe !== wv && (Qe === gi ? d === !1 ? e.has("EXT_sRGB") === !0 && ut === zp ? (we.format = TC, we.minFilter = Oo, we.generateMipmaps = !1) : oe = q3.sRGBToLinear(oe) : (ut !== zp || Ft !== df) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", Qe)), oe;
  }
  this.allocateTextureUnit = ve, this.resetTextureUnits = He, this.setTexture2D = he, this.setTexture2DArray = ye, this.setTexture3D = Ee, this.setTextureCube = Ve, this.rebindTextures = dt, this.setupRenderTarget = ht, this.updateRenderTargetMipmap = xt, this.updateMultisampleRenderTarget = Vt, this.setupDepthRenderbuffer = qe, this.setupFrameBufferTexture = gt, this.useMultisampledRTT = Nt;
}
function HF(a, e, t) {
  const r = t.isWebGL2;
  function i(s, l = null) {
    let d;
    if (s === df)
      return 5121;
    if (s === dF)
      return 32819;
    if (s === hF)
      return 32820;
    if (s === uF)
      return 5120;
    if (s === cF)
      return 5122;
    if (s === j3)
      return 5123;
    if (s === fF)
      return 5124;
    if (s === L0)
      return 5125;
    if (s === fy)
      return 5126;
    if (s === X_)
      return r ? 5131 : (d = e.get("OES_texture_half_float"), d !== null ? d.HALF_FLOAT_OES : null);
    if (s === pF)
      return 6406;
    if (s === zp)
      return 6408;
    if (s === vF)
      return 6409;
    if (s === gF)
      return 6410;
    if (s === $x)
      return 6402;
    if (s === r1)
      return 34041;
    if (s === yF)
      return 6403;
    if (s === mF)
      return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"), 6408;
    if (s === TC)
      return d = e.get("EXT_sRGB"), d !== null ? d.SRGB_ALPHA_EXT : null;
    if (s === xF)
      return 36244;
    if (s === _F)
      return 33319;
    if (s === SF)
      return 33320;
    if (s === wF)
      return 36249;
    if (s === uC || s === cC || s === fC || s === dC)
      if (l === gi)
        if (d = e.get("WEBGL_compressed_texture_s3tc_srgb"), d !== null) {
          if (s === uC)
            return d.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (s === cC)
            return d.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (s === fC)
            return d.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (s === dC)
            return d.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (d = e.get("WEBGL_compressed_texture_s3tc"), d !== null) {
        if (s === uC)
          return d.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (s === cC)
          return d.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (s === fC)
          return d.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (s === dC)
          return d.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (s === XD || s === qD || s === QD || s === ZD)
      if (d = e.get("WEBGL_compressed_texture_pvrtc"), d !== null) {
        if (s === XD)
          return d.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (s === qD)
          return d.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (s === QD)
          return d.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (s === ZD)
          return d.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (s === bF)
      return d = e.get("WEBGL_compressed_texture_etc1"), d !== null ? d.COMPRESSED_RGB_ETC1_WEBGL : null;
    if (s === JD || s === KD)
      if (d = e.get("WEBGL_compressed_texture_etc"), d !== null) {
        if (s === JD)
          return l === gi ? d.COMPRESSED_SRGB8_ETC2 : d.COMPRESSED_RGB8_ETC2;
        if (s === KD)
          return l === gi ? d.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : d.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (s === $D || s === e3 || s === t3 || s === n3 || s === r3 || s === i3 || s === a3 || s === s3 || s === o3 || s === l3 || s === u3 || s === c3 || s === f3 || s === d3)
      if (d = e.get("WEBGL_compressed_texture_astc"), d !== null) {
        if (s === $D)
          return l === gi ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : d.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (s === e3)
          return l === gi ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : d.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (s === t3)
          return l === gi ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : d.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (s === n3)
          return l === gi ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : d.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (s === r3)
          return l === gi ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : d.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (s === i3)
          return l === gi ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : d.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (s === a3)
          return l === gi ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : d.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (s === s3)
          return l === gi ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : d.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (s === o3)
          return l === gi ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : d.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (s === l3)
          return l === gi ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : d.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (s === u3)
          return l === gi ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : d.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (s === c3)
          return l === gi ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : d.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (s === f3)
          return l === gi ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : d.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (s === d3)
          return l === gi ? d.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : d.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (s === h3)
      if (d = e.get("EXT_texture_compression_bptc"), d !== null) {
        if (s === h3)
          return l === gi ? d.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : d.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      } else
        return null;
    return s === Kx ? r ? 34042 : (d = e.get("WEBGL_depth_texture"), d !== null ? d.UNSIGNED_INT_24_8_WEBGL : null) : a[s] !== void 0 ? a[s] : null;
  }
  return { convert: i };
}
class VF extends ho {
  constructor(e = []) {
    super(), this.isArrayCamera = !0, this.cameras = e;
  }
}
class jw extends Xa {
  constructor() {
    super(), this.isGroup = !0, this.type = "Group";
  }
}
const xW = { type: "move" };
class QA {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new jw(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new jw(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new ge(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new ge()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new jw(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new ge(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new ge()), this._grip;
  }
  dispatchEvent(e) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
  }
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  update(e, t, r) {
    let i = null, s = null, l = null;
    const d = this._targetRay, p = this._grip, g = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (g && e.hand) {
        l = !0;
        for (const O of e.hand.values()) {
          const U = t.getJointPose(O, r);
          if (g.joints[O.jointName] === void 0) {
            const I = new jw();
            I.matrixAutoUpdate = !1, I.visible = !1, g.joints[O.jointName] = I, g.add(I);
          }
          const H = g.joints[O.jointName];
          U !== null && (H.matrix.fromArray(U.transform.matrix), H.matrix.decompose(H.position, H.rotation, H.scale), H.jointRadius = U.radius), H.visible = U !== null;
        }
        const _ = g.joints["index-finger-tip"], w = g.joints["thumb-tip"], T = _.position.distanceTo(w.position), R = 0.02, D = 5e-3;
        g.inputState.pinching && T > R + D ? (g.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: e.handedness,
          target: this
        })) : !g.inputState.pinching && T <= R - D && (g.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: e.handedness,
          target: this
        }));
      } else
        p !== null && e.gripSpace && (s = t.getPose(e.gripSpace, r), s !== null && (p.matrix.fromArray(s.transform.matrix), p.matrix.decompose(p.position, p.rotation, p.scale), s.linearVelocity ? (p.hasLinearVelocity = !0, p.linearVelocity.copy(s.linearVelocity)) : p.hasLinearVelocity = !1, s.angularVelocity ? (p.hasAngularVelocity = !0, p.angularVelocity.copy(s.angularVelocity)) : p.hasAngularVelocity = !1));
      d !== null && (i = t.getPose(e.targetRaySpace, r), i === null && s !== null && (i = s), i !== null && (d.matrix.fromArray(i.transform.matrix), d.matrix.decompose(d.position, d.rotation, d.scale), i.linearVelocity ? (d.hasLinearVelocity = !0, d.linearVelocity.copy(i.linearVelocity)) : d.hasLinearVelocity = !1, i.angularVelocity ? (d.hasAngularVelocity = !0, d.angularVelocity.copy(i.angularVelocity)) : d.hasAngularVelocity = !1, this.dispatchEvent(xW)));
    }
    return d !== null && (d.visible = i !== null), p !== null && (p.visible = s !== null), g !== null && (g.visible = l !== null), this;
  }
}
class K3 extends su {
  constructor(e, t, r, i, s, l, d, p, g, _) {
    if (_ = _ !== void 0 ? _ : $x, _ !== $x && _ !== r1)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    r === void 0 && _ === $x && (r = L0), r === void 0 && _ === r1 && (r = Kx), super(null, i, s, l, d, p, _, r, g), this.isDepthTexture = !0, this.image = { width: e, height: t }, this.magFilter = d !== void 0 ? d : fo, this.minFilter = p !== void 0 ? p : fo, this.flipY = !1, this.generateMipmaps = !1;
  }
}
class _W extends Cm {
  constructor(e, t) {
    super();
    const r = this;
    let i = null, s = 1, l = null, d = "local-floor", p = null, g = null, _ = null, w = null, T = null, R = null;
    const D = t.getContextAttributes();
    let O = null, U = null;
    const H = [], I = [], G = new ho();
    G.layers.enable(1), G.viewport = new ra();
    const B = new ho();
    B.layers.enable(2), B.viewport = new ra();
    const Q = [G, B], K = new VF();
    K.layers.enable(1), K.layers.enable(2);
    let te = null, Y = null;
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(fe) {
      let he = H[fe];
      return he === void 0 && (he = new QA(), H[fe] = he), he.getTargetRaySpace();
    }, this.getControllerGrip = function(fe) {
      let he = H[fe];
      return he === void 0 && (he = new QA(), H[fe] = he), he.getGripSpace();
    }, this.getHand = function(fe) {
      let he = H[fe];
      return he === void 0 && (he = new QA(), H[fe] = he), he.getHandSpace();
    };
    function re(fe) {
      const he = I.indexOf(fe.inputSource);
      if (he === -1)
        return;
      const ye = H[he];
      ye !== void 0 && ye.dispatchEvent({ type: fe.type, data: fe.inputSource });
    }
    function se() {
      i.removeEventListener("select", re), i.removeEventListener("selectstart", re), i.removeEventListener("selectend", re), i.removeEventListener("squeeze", re), i.removeEventListener("squeezestart", re), i.removeEventListener("squeezeend", re), i.removeEventListener("end", se), i.removeEventListener("inputsourceschange", ce);
      for (let fe = 0; fe < H.length; fe++) {
        const he = I[fe];
        he !== null && (I[fe] = null, H[fe].disconnect(he));
      }
      te = null, Y = null, e.setRenderTarget(O), T = null, w = null, _ = null, i = null, U = null, ve.stop(), r.isPresenting = !1, r.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(fe) {
      s = fe, r.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(fe) {
      d = fe, r.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return p || l;
    }, this.setReferenceSpace = function(fe) {
      p = fe;
    }, this.getBaseLayer = function() {
      return w !== null ? w : T;
    }, this.getBinding = function() {
      return _;
    }, this.getFrame = function() {
      return R;
    }, this.getSession = function() {
      return i;
    }, this.setSession = async function(fe) {
      if (i = fe, i !== null) {
        if (O = e.getRenderTarget(), i.addEventListener("select", re), i.addEventListener("selectstart", re), i.addEventListener("selectend", re), i.addEventListener("squeeze", re), i.addEventListener("squeezestart", re), i.addEventListener("squeezeend", re), i.addEventListener("end", se), i.addEventListener("inputsourceschange", ce), D.xrCompatible !== !0 && await t.makeXRCompatible(), i.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) {
          const he = {
            antialias: i.renderState.layers === void 0 ? D.antialias : !0,
            alpha: D.alpha,
            depth: D.depth,
            stencil: D.stencil,
            framebufferScaleFactor: s
          };
          T = new XRWebGLLayer(i, t, he), i.updateRenderState({ baseLayer: T }), U = new po(
            T.framebufferWidth,
            T.framebufferHeight,
            {
              format: zp,
              type: df,
              encoding: e.outputEncoding
            }
          );
        } else {
          let he = null, ye = null, Ee = null;
          D.depth && (Ee = D.stencil ? 35056 : 33190, he = D.stencil ? r1 : $x, ye = D.stencil ? Kx : L0);
          const Ve = {
            colorFormat: 32856,
            depthFormat: Ee,
            scaleFactor: s
          };
          _ = new XRWebGLBinding(i, t), w = _.createProjectionLayer(Ve), i.updateRenderState({ layers: [w] }), U = new po(
            w.textureWidth,
            w.textureHeight,
            {
              format: zp,
              type: df,
              depthTexture: new K3(w.textureWidth, w.textureHeight, ye, void 0, void 0, void 0, void 0, void 0, void 0, he),
              stencilBuffer: D.stencil,
              encoding: e.outputEncoding,
              samples: D.antialias ? 4 : 0
            }
          );
          const Je = e.properties.get(U);
          Je.__ignoreDepthValues = w.ignoreDepthValues;
        }
        U.isXRRenderTarget = !0, this.setFoveation(1), p = null, l = await i.requestReferenceSpace(d), ve.setContext(i), ve.start(), r.isPresenting = !0, r.dispatchEvent({ type: "sessionstart" });
      }
    };
    function ce(fe) {
      for (let he = 0; he < fe.removed.length; he++) {
        const ye = fe.removed[he], Ee = I.indexOf(ye);
        Ee >= 0 && (I[Ee] = null, H[Ee].dispatchEvent({ type: "disconnected", data: ye }));
      }
      for (let he = 0; he < fe.added.length; he++) {
        const ye = fe.added[he];
        let Ee = I.indexOf(ye);
        if (Ee === -1) {
          for (let Je = 0; Je < H.length; Je++)
            if (Je >= I.length) {
              I.push(ye), Ee = Je;
              break;
            } else if (I[Je] === null) {
              I[Je] = ye, Ee = Je;
              break;
            }
          if (Ee === -1)
            break;
        }
        const Ve = H[Ee];
        Ve && Ve.dispatchEvent({ type: "connected", data: ye });
      }
    }
    const ue = new ge(), Me = new ge();
    function me(fe, he, ye) {
      ue.setFromMatrixPosition(he.matrixWorld), Me.setFromMatrixPosition(ye.matrixWorld);
      const Ee = ue.distanceTo(Me), Ve = he.projectionMatrix.elements, Je = ye.projectionMatrix.elements, rt = Ve[14] / (Ve[10] - 1), Ne = Ve[14] / (Ve[10] + 1), ct = (Ve[9] + 1) / Ve[5], tt = (Ve[9] - 1) / Ve[5], Tt = (Ve[8] - 1) / Ve[0], gt = (Je[8] + 1) / Je[0], ft = rt * Tt, Ie = rt * gt, qe = Ee / (-Tt + gt), dt = qe * -Tt;
      he.matrixWorld.decompose(fe.position, fe.quaternion, fe.scale), fe.translateX(dt), fe.translateZ(qe), fe.matrixWorld.compose(fe.position, fe.quaternion, fe.scale), fe.matrixWorldInverse.copy(fe.matrixWorld).invert();
      const ht = rt + qe, xt = Ne + qe, Vt = ft - dt, yt = Ie + (Ee - dt), Nt = ct * Ne / xt * ht, Zt = tt * Ne / xt * ht;
      fe.projectionMatrix.makePerspective(Vt, yt, Nt, Zt, ht, xt);
    }
    function De(fe, he) {
      he === null ? fe.matrixWorld.copy(fe.matrix) : fe.matrixWorld.multiplyMatrices(he.matrixWorld, fe.matrix), fe.matrixWorldInverse.copy(fe.matrixWorld).invert();
    }
    this.updateCamera = function(fe) {
      if (i === null)
        return;
      K.near = B.near = G.near = fe.near, K.far = B.far = G.far = fe.far, (te !== K.near || Y !== K.far) && (i.updateRenderState({
        depthNear: K.near,
        depthFar: K.far
      }), te = K.near, Y = K.far);
      const he = fe.parent, ye = K.cameras;
      De(K, he);
      for (let Ve = 0; Ve < ye.length; Ve++)
        De(ye[Ve], he);
      K.matrixWorld.decompose(K.position, K.quaternion, K.scale), fe.position.copy(K.position), fe.quaternion.copy(K.quaternion), fe.scale.copy(K.scale), fe.matrix.copy(K.matrix), fe.matrixWorld.copy(K.matrixWorld);
      const Ee = fe.children;
      for (let Ve = 0, Je = Ee.length; Ve < Je; Ve++)
        Ee[Ve].updateMatrixWorld(!0);
      ye.length === 2 ? me(K, G, B) : K.projectionMatrix.copy(G.projectionMatrix);
    }, this.getCamera = function() {
      return K;
    }, this.getFoveation = function() {
      if (w !== null)
        return w.fixedFoveation;
      if (T !== null)
        return T.fixedFoveation;
    }, this.setFoveation = function(fe) {
      w !== null && (w.fixedFoveation = fe), T !== null && T.fixedFoveation !== void 0 && (T.fixedFoveation = fe);
    };
    let Re = null;
    function He(fe, he) {
      if (g = he.getViewerPose(p || l), R = he, g !== null) {
        const ye = g.views;
        T !== null && (e.setRenderTargetFramebuffer(U, T.framebuffer), e.setRenderTarget(U));
        let Ee = !1;
        ye.length !== K.cameras.length && (K.cameras.length = 0, Ee = !0);
        for (let Ve = 0; Ve < ye.length; Ve++) {
          const Je = ye[Ve];
          let rt = null;
          if (T !== null)
            rt = T.getViewport(Je);
          else {
            const ct = _.getViewSubImage(w, Je);
            rt = ct.viewport, Ve === 0 && (e.setRenderTargetTextures(
              U,
              ct.colorTexture,
              w.ignoreDepthValues ? void 0 : ct.depthStencilTexture
            ), e.setRenderTarget(U));
          }
          let Ne = Q[Ve];
          Ne === void 0 && (Ne = new ho(), Ne.layers.enable(Ve), Ne.viewport = new ra(), Q[Ve] = Ne), Ne.matrix.fromArray(Je.transform.matrix), Ne.projectionMatrix.fromArray(Je.projectionMatrix), Ne.viewport.set(rt.x, rt.y, rt.width, rt.height), Ve === 0 && K.matrix.copy(Ne.matrix), Ee === !0 && K.cameras.push(Ne);
        }
      }
      for (let ye = 0; ye < H.length; ye++) {
        const Ee = I[ye], Ve = H[ye];
        Ee !== null && Ve !== void 0 && Ve.update(Ee, he, p || l);
      }
      Re && Re(fe, he), R = null;
    }
    const ve = new zF();
    ve.setAnimationLoop(He), this.setAnimationLoop = function(fe) {
      Re = fe;
    }, this.dispose = function() {
    };
  }
}
function SW(a, e) {
  function t(O, U) {
    O.fogColor.value.copy(U.color), U.isFog ? (O.fogNear.value = U.near, O.fogFar.value = U.far) : U.isFogExp2 && (O.fogDensity.value = U.density);
  }
  function r(O, U, H, I, G) {
    U.isMeshBasicMaterial || U.isMeshLambertMaterial ? i(O, U) : U.isMeshToonMaterial ? (i(O, U), _(O, U)) : U.isMeshPhongMaterial ? (i(O, U), g(O, U)) : U.isMeshStandardMaterial ? (i(O, U), w(O, U), U.isMeshPhysicalMaterial && T(O, U, G)) : U.isMeshMatcapMaterial ? (i(O, U), R(O, U)) : U.isMeshDepthMaterial ? i(O, U) : U.isMeshDistanceMaterial ? (i(O, U), D(O, U)) : U.isMeshNormalMaterial ? i(O, U) : U.isLineBasicMaterial ? (s(O, U), U.isLineDashedMaterial && l(O, U)) : U.isPointsMaterial ? d(O, U, H, I) : U.isSpriteMaterial ? p(O, U) : U.isShadowMaterial ? (O.color.value.copy(U.color), O.opacity.value = U.opacity) : U.isShaderMaterial && (U.uniformsNeedUpdate = !1);
  }
  function i(O, U) {
    O.opacity.value = U.opacity, U.color && O.diffuse.value.copy(U.color), U.emissive && O.emissive.value.copy(U.emissive).multiplyScalar(U.emissiveIntensity), U.map && (O.map.value = U.map), U.alphaMap && (O.alphaMap.value = U.alphaMap), U.bumpMap && (O.bumpMap.value = U.bumpMap, O.bumpScale.value = U.bumpScale, U.side === cf && (O.bumpScale.value *= -1)), U.displacementMap && (O.displacementMap.value = U.displacementMap, O.displacementScale.value = U.displacementScale, O.displacementBias.value = U.displacementBias), U.emissiveMap && (O.emissiveMap.value = U.emissiveMap), U.normalMap && (O.normalMap.value = U.normalMap, O.normalScale.value.copy(U.normalScale), U.side === cf && O.normalScale.value.negate()), U.specularMap && (O.specularMap.value = U.specularMap), U.alphaTest > 0 && (O.alphaTest.value = U.alphaTest);
    const H = e.get(U).envMap;
    if (H && (O.envMap.value = H, O.flipEnvMap.value = H.isCubeTexture && H.isRenderTargetTexture === !1 ? -1 : 1, O.reflectivity.value = U.reflectivity, O.ior.value = U.ior, O.refractionRatio.value = U.refractionRatio), U.lightMap) {
      O.lightMap.value = U.lightMap;
      const B = a.physicallyCorrectLights !== !0 ? Math.PI : 1;
      O.lightMapIntensity.value = U.lightMapIntensity * B;
    }
    U.aoMap && (O.aoMap.value = U.aoMap, O.aoMapIntensity.value = U.aoMapIntensity);
    let I;
    U.map ? I = U.map : U.specularMap ? I = U.specularMap : U.displacementMap ? I = U.displacementMap : U.normalMap ? I = U.normalMap : U.bumpMap ? I = U.bumpMap : U.roughnessMap ? I = U.roughnessMap : U.metalnessMap ? I = U.metalnessMap : U.alphaMap ? I = U.alphaMap : U.emissiveMap ? I = U.emissiveMap : U.clearcoatMap ? I = U.clearcoatMap : U.clearcoatNormalMap ? I = U.clearcoatNormalMap : U.clearcoatRoughnessMap ? I = U.clearcoatRoughnessMap : U.iridescenceMap ? I = U.iridescenceMap : U.iridescenceThicknessMap ? I = U.iridescenceThicknessMap : U.specularIntensityMap ? I = U.specularIntensityMap : U.specularColorMap ? I = U.specularColorMap : U.transmissionMap ? I = U.transmissionMap : U.thicknessMap ? I = U.thicknessMap : U.sheenColorMap ? I = U.sheenColorMap : U.sheenRoughnessMap && (I = U.sheenRoughnessMap), I !== void 0 && (I.isWebGLRenderTarget && (I = I.texture), I.matrixAutoUpdate === !0 && I.updateMatrix(), O.uvTransform.value.copy(I.matrix));
    let G;
    U.aoMap ? G = U.aoMap : U.lightMap && (G = U.lightMap), G !== void 0 && (G.isWebGLRenderTarget && (G = G.texture), G.matrixAutoUpdate === !0 && G.updateMatrix(), O.uv2Transform.value.copy(G.matrix));
  }
  function s(O, U) {
    O.diffuse.value.copy(U.color), O.opacity.value = U.opacity;
  }
  function l(O, U) {
    O.dashSize.value = U.dashSize, O.totalSize.value = U.dashSize + U.gapSize, O.scale.value = U.scale;
  }
  function d(O, U, H, I) {
    O.diffuse.value.copy(U.color), O.opacity.value = U.opacity, O.size.value = U.size * H, O.scale.value = I * 0.5, U.map && (O.map.value = U.map), U.alphaMap && (O.alphaMap.value = U.alphaMap), U.alphaTest > 0 && (O.alphaTest.value = U.alphaTest);
    let G;
    U.map ? G = U.map : U.alphaMap && (G = U.alphaMap), G !== void 0 && (G.matrixAutoUpdate === !0 && G.updateMatrix(), O.uvTransform.value.copy(G.matrix));
  }
  function p(O, U) {
    O.diffuse.value.copy(U.color), O.opacity.value = U.opacity, O.rotation.value = U.rotation, U.map && (O.map.value = U.map), U.alphaMap && (O.alphaMap.value = U.alphaMap), U.alphaTest > 0 && (O.alphaTest.value = U.alphaTest);
    let H;
    U.map ? H = U.map : U.alphaMap && (H = U.alphaMap), H !== void 0 && (H.matrixAutoUpdate === !0 && H.updateMatrix(), O.uvTransform.value.copy(H.matrix));
  }
  function g(O, U) {
    O.specular.value.copy(U.specular), O.shininess.value = Math.max(U.shininess, 1e-4);
  }
  function _(O, U) {
    U.gradientMap && (O.gradientMap.value = U.gradientMap);
  }
  function w(O, U) {
    O.roughness.value = U.roughness, O.metalness.value = U.metalness, U.roughnessMap && (O.roughnessMap.value = U.roughnessMap), U.metalnessMap && (O.metalnessMap.value = U.metalnessMap), e.get(U).envMap && (O.envMapIntensity.value = U.envMapIntensity);
  }
  function T(O, U, H) {
    O.ior.value = U.ior, U.sheen > 0 && (O.sheenColor.value.copy(U.sheenColor).multiplyScalar(U.sheen), O.sheenRoughness.value = U.sheenRoughness, U.sheenColorMap && (O.sheenColorMap.value = U.sheenColorMap), U.sheenRoughnessMap && (O.sheenRoughnessMap.value = U.sheenRoughnessMap)), U.clearcoat > 0 && (O.clearcoat.value = U.clearcoat, O.clearcoatRoughness.value = U.clearcoatRoughness, U.clearcoatMap && (O.clearcoatMap.value = U.clearcoatMap), U.clearcoatRoughnessMap && (O.clearcoatRoughnessMap.value = U.clearcoatRoughnessMap), U.clearcoatNormalMap && (O.clearcoatNormalScale.value.copy(U.clearcoatNormalScale), O.clearcoatNormalMap.value = U.clearcoatNormalMap, U.side === cf && O.clearcoatNormalScale.value.negate())), U.iridescence > 0 && (O.iridescence.value = U.iridescence, O.iridescenceIOR.value = U.iridescenceIOR, O.iridescenceThicknessMinimum.value = U.iridescenceThicknessRange[0], O.iridescenceThicknessMaximum.value = U.iridescenceThicknessRange[1], U.iridescenceMap && (O.iridescenceMap.value = U.iridescenceMap), U.iridescenceThicknessMap && (O.iridescenceThicknessMap.value = U.iridescenceThicknessMap)), U.transmission > 0 && (O.transmission.value = U.transmission, O.transmissionSamplerMap.value = H.texture, O.transmissionSamplerSize.value.set(H.width, H.height), U.transmissionMap && (O.transmissionMap.value = U.transmissionMap), O.thickness.value = U.thickness, U.thicknessMap && (O.thicknessMap.value = U.thicknessMap), O.attenuationDistance.value = U.attenuationDistance, O.attenuationColor.value.copy(U.attenuationColor)), O.specularIntensity.value = U.specularIntensity, O.specularColor.value.copy(U.specularColor), U.specularIntensityMap && (O.specularIntensityMap.value = U.specularIntensityMap), U.specularColorMap && (O.specularColorMap.value = U.specularColorMap);
  }
  function R(O, U) {
    U.matcap && (O.matcap.value = U.matcap);
  }
  function D(O, U) {
    O.referencePosition.value.copy(U.referencePosition), O.nearDistance.value = U.nearDistance, O.farDistance.value = U.farDistance;
  }
  return {
    refreshFogUniforms: t,
    refreshMaterialUniforms: r
  };
}
function wW(a, e, t, r) {
  let i = {}, s = {}, l = [];
  const d = t.isWebGL2 ? a.getParameter(35375) : 0;
  function p(I, G) {
    const B = G.program;
    r.uniformBlockBinding(I, B);
  }
  function g(I, G) {
    let B = i[I.id];
    B === void 0 && (D(I), B = _(I), i[I.id] = B, I.addEventListener("dispose", U));
    const Q = G.program;
    r.updateUBOMapping(I, Q);
    const K = e.render.frame;
    s[I.id] !== K && (T(I), s[I.id] = K);
  }
  function _(I) {
    const G = w();
    I.__bindingPointIndex = G;
    const B = a.createBuffer(), Q = I.__size, K = I.usage;
    return a.bindBuffer(35345, B), a.bufferData(35345, Q, K), a.bindBuffer(35345, null), a.bindBufferBase(35345, G, B), B;
  }
  function w() {
    for (let I = 0; I < d; I++)
      if (l.indexOf(I) === -1)
        return l.push(I), I;
    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  function T(I) {
    const G = i[I.id], B = I.uniforms, Q = I.__cache;
    a.bindBuffer(35345, G);
    for (let K = 0, te = B.length; K < te; K++) {
      const Y = B[K];
      if (R(Y, K, Q) === !0) {
        const re = Y.value, se = Y.__offset;
        typeof re == "number" ? (Y.__data[0] = re, a.bufferSubData(35345, se, Y.__data)) : (Y.value.isMatrix3 ? (Y.__data[0] = Y.value.elements[0], Y.__data[1] = Y.value.elements[1], Y.__data[2] = Y.value.elements[2], Y.__data[3] = Y.value.elements[0], Y.__data[4] = Y.value.elements[3], Y.__data[5] = Y.value.elements[4], Y.__data[6] = Y.value.elements[5], Y.__data[7] = Y.value.elements[0], Y.__data[8] = Y.value.elements[6], Y.__data[9] = Y.value.elements[7], Y.__data[10] = Y.value.elements[8], Y.__data[11] = Y.value.elements[0]) : re.toArray(Y.__data), a.bufferSubData(35345, se, Y.__data));
      }
    }
    a.bindBuffer(35345, null);
  }
  function R(I, G, B) {
    const Q = I.value;
    if (B[G] === void 0)
      return typeof Q == "number" ? B[G] = Q : B[G] = Q.clone(), !0;
    if (typeof Q == "number") {
      if (B[G] !== Q)
        return B[G] = Q, !0;
    } else {
      const K = B[G];
      if (K.equals(Q) === !1)
        return K.copy(Q), !0;
    }
    return !1;
  }
  function D(I) {
    const G = I.uniforms;
    let B = 0;
    const Q = 16;
    let K = 0;
    for (let te = 0, Y = G.length; te < Y; te++) {
      const re = G[te], se = O(re);
      if (re.__data = new Float32Array(se.storage / Float32Array.BYTES_PER_ELEMENT), re.__offset = B, te > 0) {
        K = B % Q;
        const ce = Q - K;
        K !== 0 && ce - se.boundary < 0 && (B += Q - K, re.__offset = B);
      }
      B += se.storage;
    }
    return K = B % Q, K > 0 && (B += Q - K), I.__size = B, I.__cache = {}, this;
  }
  function O(I) {
    const G = I.value, B = {
      boundary: 0,
      storage: 0
    };
    return typeof G == "number" ? (B.boundary = 4, B.storage = 4) : G.isVector2 ? (B.boundary = 8, B.storage = 8) : G.isVector3 || G.isColor ? (B.boundary = 16, B.storage = 12) : G.isVector4 ? (B.boundary = 16, B.storage = 16) : G.isMatrix3 ? (B.boundary = 48, B.storage = 48) : G.isMatrix4 ? (B.boundary = 64, B.storage = 64) : G.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", G), B;
  }
  function U(I) {
    const G = I.target;
    G.removeEventListener("dispose", U);
    const B = l.indexOf(G.__bindingPointIndex);
    l.splice(B, 1), a.deleteBuffer(i[G.id]), delete i[G.id], delete s[G.id];
  }
  function H() {
    for (const I in i)
      a.deleteBuffer(i[I]);
    l = [], i = {}, s = {};
  }
  return {
    bind: p,
    update: g,
    dispose: H
  };
}
function bW() {
  const a = zM("canvas");
  return a.style.display = "block", a;
}
function $3(a = {}) {
  this.isWebGLRenderer = !0;
  const e = a.canvas !== void 0 ? a.canvas : bW(), t = a.context !== void 0 ? a.context : null, r = a.depth !== void 0 ? a.depth : !0, i = a.stencil !== void 0 ? a.stencil : !0, s = a.antialias !== void 0 ? a.antialias : !1, l = a.premultipliedAlpha !== void 0 ? a.premultipliedAlpha : !0, d = a.preserveDrawingBuffer !== void 0 ? a.preserveDrawingBuffer : !1, p = a.powerPreference !== void 0 ? a.powerPreference : "default", g = a.failIfMajorPerformanceCaveat !== void 0 ? a.failIfMajorPerformanceCaveat : !1;
  let _;
  t !== null ? _ = t.getContextAttributes().alpha : _ = a.alpha !== void 0 ? a.alpha : !1;
  let w = null, T = null;
  const R = [], D = [];
  this.domElement = e, this.debug = {
    checkShaderErrors: !0
  }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = wv, this.physicallyCorrectLights = !1, this.toneMapping = og, this.toneMappingExposure = 1, Object.defineProperties(this, {
    gammaFactor: {
      get: function() {
        return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."), 2;
      },
      set: function() {
        console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
      }
    }
  });
  const O = this;
  let U = !1, H = 0, I = 0, G = null, B = -1, Q = null;
  const K = new ra(), te = new ra();
  let Y = null, re = e.width, se = e.height, ce = 1, ue = null, Me = null;
  const me = new ra(0, 0, re, se), De = new ra(0, 0, re, se);
  let Re = !1;
  const He = new BC();
  let ve = !1, fe = !1, he = null;
  const ye = new Kr(), Ee = new zt(), Ve = new ge(), Je = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
  function rt() {
    return G === null ? ce : 1;
  }
  let Ne = t;
  function ct(Te, ot) {
    for (let de = 0; de < Te.length; de++) {
      const Le = Te[de], Ye = e.getContext(Le, ot);
      if (Ye !== null)
        return Ye;
    }
    return null;
  }
  try {
    const Te = {
      alpha: !0,
      depth: r,
      stencil: i,
      antialias: s,
      premultipliedAlpha: l,
      preserveDrawingBuffer: d,
      powerPreference: p,
      failIfMajorPerformanceCaveat: g
    };
    if ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${a1}`), e.addEventListener("webglcontextlost", at, !1), e.addEventListener("webglcontextrestored", st, !1), e.addEventListener("webglcontextcreationerror", dn, !1), Ne === null) {
      const ot = ["webgl2", "webgl", "experimental-webgl"];
      if (O.isWebGL1Renderer === !0 && ot.shift(), Ne = ct(ot, Te), Ne === null)
        throw ct(ot) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
    }
    Ne.getShaderPrecisionFormat === void 0 && (Ne.getShaderPrecisionFormat = function() {
      return { rangeMin: 1, rangeMax: 1, precision: 1 };
    });
  } catch (Te) {
    throw console.error("THREE.WebGLRenderer: " + Te.message), Te;
  }
  let tt, Tt, gt, ft, Ie, qe, dt, ht, xt, Vt, yt, Nt, Zt, Rt, we, oe, Qe, ut, Ft, Ot, Wt, it, an, Be;
  function pe() {
    tt = new kG(Ne), Tt = new PG(Ne, tt, a), tt.init(Tt), it = new HF(Ne, tt, Tt), gt = new gW(Ne, tt, Tt), ft = new HG(), Ie = new aW(), qe = new yW(Ne, tt, gt, Ie, Tt, it, ft), dt = new UG(O), ht = new FG(O), xt = new $H(Ne, Tt), an = new DG(Ne, tt, xt, Tt), Vt = new IG(Ne, xt, ft, an), yt = new jG(Ne, Vt, xt, ft), Ft = new WG(Ne, Tt, qe), oe = new OG(Ie), Nt = new iW(O, dt, ht, tt, Tt, an, oe), Zt = new SW(O, Ie), Rt = new oW(), we = new hW(tt, Tt), ut = new AG(O, dt, gt, yt, _, l), Qe = new vW(O, yt, Tt), Be = new wW(Ne, ft, Tt, gt), Ot = new LG(Ne, tt, ft, Tt), Wt = new BG(Ne, tt, ft, Tt), ft.programs = Nt.programs, O.capabilities = Tt, O.extensions = tt, O.properties = Ie, O.renderLists = Rt, O.shadowMap = Qe, O.state = gt, O.info = ft;
  }
  pe();
  const Fe = new _W(O, Ne);
  this.xr = Fe, this.getContext = function() {
    return Ne;
  }, this.getContextAttributes = function() {
    return Ne.getContextAttributes();
  }, this.forceContextLoss = function() {
    const Te = tt.get("WEBGL_lose_context");
    Te && Te.loseContext();
  }, this.forceContextRestore = function() {
    const Te = tt.get("WEBGL_lose_context");
    Te && Te.restoreContext();
  }, this.getPixelRatio = function() {
    return ce;
  }, this.setPixelRatio = function(Te) {
    Te !== void 0 && (ce = Te, this.setSize(re, se, !1));
  }, this.getSize = function(Te) {
    return Te.set(re, se);
  }, this.setSize = function(Te, ot, de) {
    if (Fe.isPresenting) {
      console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
      return;
    }
    re = Te, se = ot, e.width = Math.floor(Te * ce), e.height = Math.floor(ot * ce), de !== !1 && (e.style.width = Te + "px", e.style.height = ot + "px"), this.setViewport(0, 0, Te, ot);
  }, this.getDrawingBufferSize = function(Te) {
    return Te.set(re * ce, se * ce).floor();
  }, this.setDrawingBufferSize = function(Te, ot, de) {
    re = Te, se = ot, ce = de, e.width = Math.floor(Te * de), e.height = Math.floor(ot * de), this.setViewport(0, 0, Te, ot);
  }, this.getCurrentViewport = function(Te) {
    return Te.copy(K);
  }, this.getViewport = function(Te) {
    return Te.copy(me);
  }, this.setViewport = function(Te, ot, de, Le) {
    Te.isVector4 ? me.set(Te.x, Te.y, Te.z, Te.w) : me.set(Te, ot, de, Le), gt.viewport(K.copy(me).multiplyScalar(ce).floor());
  }, this.getScissor = function(Te) {
    return Te.copy(De);
  }, this.setScissor = function(Te, ot, de, Le) {
    Te.isVector4 ? De.set(Te.x, Te.y, Te.z, Te.w) : De.set(Te, ot, de, Le), gt.scissor(te.copy(De).multiplyScalar(ce).floor());
  }, this.getScissorTest = function() {
    return Re;
  }, this.setScissorTest = function(Te) {
    gt.setScissorTest(Re = Te);
  }, this.setOpaqueSort = function(Te) {
    ue = Te;
  }, this.setTransparentSort = function(Te) {
    Me = Te;
  }, this.getClearColor = function(Te) {
    return Te.copy(ut.getClearColor());
  }, this.setClearColor = function() {
    ut.setClearColor.apply(ut, arguments);
  }, this.getClearAlpha = function() {
    return ut.getClearAlpha();
  }, this.setClearAlpha = function() {
    ut.setClearAlpha.apply(ut, arguments);
  }, this.clear = function(Te = !0, ot = !0, de = !0) {
    let Le = 0;
    Te && (Le |= 16384), ot && (Le |= 256), de && (Le |= 1024), Ne.clear(Le);
  }, this.clearColor = function() {
    this.clear(!0, !1, !1);
  }, this.clearDepth = function() {
    this.clear(!1, !0, !1);
  }, this.clearStencil = function() {
    this.clear(!1, !1, !0);
  }, this.dispose = function() {
    e.removeEventListener("webglcontextlost", at, !1), e.removeEventListener("webglcontextrestored", st, !1), e.removeEventListener("webglcontextcreationerror", dn, !1), Rt.dispose(), we.dispose(), Ie.dispose(), dt.dispose(), ht.dispose(), yt.dispose(), an.dispose(), Be.dispose(), Nt.dispose(), Fe.dispose(), Fe.removeEventListener("sessionstart", cn), Fe.removeEventListener("sessionend", ki), he && (he.dispose(), he = null), Or.stop();
  };
  function at(Te) {
    Te.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), U = !0;
  }
  function st() {
    console.log("THREE.WebGLRenderer: Context Restored."), U = !1;
    const Te = ft.autoReset, ot = Qe.enabled, de = Qe.autoUpdate, Le = Qe.needsUpdate, Ye = Qe.type;
    pe(), ft.autoReset = Te, Qe.enabled = ot, Qe.autoUpdate = de, Qe.needsUpdate = Le, Qe.type = Ye;
  }
  function dn(Te) {
    console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", Te.statusMessage);
  }
  function ze(Te) {
    const ot = Te.target;
    ot.removeEventListener("dispose", ze), wt(ot);
  }
  function wt(Te) {
    Pe(Te), Ie.remove(Te);
  }
  function Pe(Te) {
    const ot = Ie.get(Te).programs;
    ot !== void 0 && (ot.forEach(function(de) {
      Nt.releaseProgram(de);
    }), Te.isShaderMaterial && Nt.releaseShaderCache(Te));
  }
  this.renderBufferDirect = function(Te, ot, de, Le, Ye, $t) {
    ot === null && (ot = Je);
    const mn = Ye.isMesh && Ye.matrixWorld.determinant() < 0, Rn = xi(Te, ot, de, Le, Ye);
    gt.setMaterial(Le, mn);
    let gn = de.index;
    const yn = de.attributes.position;
    if (gn === null) {
      if (yn === void 0 || yn.count === 0)
        return;
    } else if (gn.count === 0)
      return;
    let Jn = 1;
    Le.wireframe === !0 && (gn = Vt.getWireframeAttribute(de), Jn = 2), an.setup(Ye, Le, Rn, de, gn);
    let rr, wr = Ot;
    gn !== null && (rr = xt.get(gn), wr = Wt, wr.setIndex(rr));
    const Yi = gn !== null ? gn.count : yn.count, La = de.drawRange.start * Jn, qs = de.drawRange.count * Jn, en = $t !== null ? $t.start * Jn : 0, Xr = $t !== null ? $t.count * Jn : 1 / 0, us = Math.max(La, en), qn = Math.min(Yi, La + qs, en + Xr) - 1, qa = Math.max(0, qn - us + 1);
    if (qa !== 0) {
      if (Ye.isMesh)
        Le.wireframe === !0 ? (gt.setLineWidth(Le.wireframeLinewidth * rt()), wr.setMode(1)) : wr.setMode(4);
      else if (Ye.isLine) {
        let mo = Le.linewidth;
        mo === void 0 && (mo = 1), gt.setLineWidth(mo * rt()), Ye.isLineSegments ? wr.setMode(1) : Ye.isLineLoop ? wr.setMode(2) : wr.setMode(3);
      } else
        Ye.isPoints ? wr.setMode(0) : Ye.isSprite && wr.setMode(4);
      if (Ye.isInstancedMesh)
        wr.renderInstances(us, qa, Ye.count);
      else if (de.isInstancedBufferGeometry) {
        const mo = Math.min(de.instanceCount, de._maxInstanceCount);
        wr.renderInstances(us, qa, mo);
      } else
        wr.render(us, qa);
    }
  }, this.compile = function(Te, ot) {
    T = we.get(Te), T.init(), D.push(T), Te.traverseVisible(function(de) {
      de.isLight && de.layers.test(ot.layers) && (T.pushLight(de), de.castShadow && T.pushShadow(de));
    }), T.setupLights(O.physicallyCorrectLights), Te.traverse(function(de) {
      const Le = de.material;
      if (Le)
        if (Array.isArray(Le))
          for (let Ye = 0; Ye < Le.length; Ye++) {
            const $t = Le[Ye];
            ii($t, Te, de);
          }
        else
          ii(Le, Te, de);
    }), D.pop(), T = null;
  };
  let Gt = null;
  function At(Te) {
    Gt && Gt(Te);
  }
  function cn() {
    Or.stop();
  }
  function ki() {
    Or.start();
  }
  const Or = new zF();
  Or.setAnimationLoop(At), typeof self < "u" && Or.setContext(self), this.setAnimationLoop = function(Te) {
    Gt = Te, Fe.setAnimationLoop(Te), Te === null ? Or.stop() : Or.start();
  }, Fe.addEventListener("sessionstart", cn), Fe.addEventListener("sessionend", ki), this.render = function(Te, ot) {
    if (ot !== void 0 && ot.isCamera !== !0) {
      console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      return;
    }
    if (U === !0)
      return;
    Te.autoUpdate === !0 && Te.updateMatrixWorld(), ot.parent === null && ot.updateMatrixWorld(), Fe.enabled === !0 && Fe.isPresenting === !0 && (Fe.cameraAutoUpdate === !0 && Fe.updateCamera(ot), ot = Fe.getCamera()), Te.isScene === !0 && Te.onBeforeRender(O, Te, ot, G), T = we.get(Te, D.length), T.init(), D.push(T), ye.multiplyMatrices(ot.projectionMatrix, ot.matrixWorldInverse), He.setFromProjectionMatrix(ye), fe = this.localClippingEnabled, ve = oe.init(this.clippingPlanes, fe, ot), w = Rt.get(Te, R.length), w.init(), R.push(w), Ii(Te, ot, 0, O.sortObjects), w.finish(), O.sortObjects === !0 && w.sort(ue, Me), ve === !0 && oe.beginShadows();
    const de = T.state.shadowsArray;
    if (Qe.render(de, Te, ot), ve === !0 && oe.endShadows(), this.info.autoReset === !0 && this.info.reset(), ut.render(w, Te), T.setupLights(O.physicallyCorrectLights), ot.isArrayCamera) {
      const Le = ot.cameras;
      for (let Ye = 0, $t = Le.length; Ye < $t; Ye++) {
        const mn = Le[Ye];
        Ir(w, Te, mn, mn.viewport);
      }
    } else
      Ir(w, Te, ot);
    G !== null && (qe.updateMultisampleRenderTarget(G), qe.updateRenderTargetMipmap(G)), Te.isScene === !0 && Te.onAfterRender(O, Te, ot), an.resetDefaultState(), B = -1, Q = null, D.pop(), D.length > 0 ? T = D[D.length - 1] : T = null, R.pop(), R.length > 0 ? w = R[R.length - 1] : w = null;
  };
  function Ii(Te, ot, de, Le) {
    if (Te.visible === !1)
      return;
    if (Te.layers.test(ot.layers)) {
      if (Te.isGroup)
        de = Te.renderOrder;
      else if (Te.isLOD)
        Te.autoUpdate === !0 && Te.update(ot);
      else if (Te.isLight)
        T.pushLight(Te), Te.castShadow && T.pushShadow(Te);
      else if (Te.isSprite) {
        if (!Te.frustumCulled || He.intersectsSprite(Te)) {
          Le && Ve.setFromMatrixPosition(Te.matrixWorld).applyMatrix4(ye);
          const mn = yt.update(Te), Rn = Te.material;
          Rn.visible && w.push(Te, mn, Rn, de, Ve.z, null);
        }
      } else if ((Te.isMesh || Te.isLine || Te.isPoints) && (Te.isSkinnedMesh && Te.skeleton.frame !== ft.render.frame && (Te.skeleton.update(), Te.skeleton.frame = ft.render.frame), !Te.frustumCulled || He.intersectsObject(Te))) {
        Le && Ve.setFromMatrixPosition(Te.matrixWorld).applyMatrix4(ye);
        const mn = yt.update(Te), Rn = Te.material;
        if (Array.isArray(Rn)) {
          const gn = mn.groups;
          for (let yn = 0, Jn = gn.length; yn < Jn; yn++) {
            const rr = gn[yn], wr = Rn[rr.materialIndex];
            wr && wr.visible && w.push(Te, mn, wr, de, Ve.z, rr);
          }
        } else
          Rn.visible && w.push(Te, mn, Rn, de, Ve.z, null);
      }
    }
    const $t = Te.children;
    for (let mn = 0, Rn = $t.length; mn < Rn; mn++)
      Ii($t[mn], ot, de, Le);
  }
  function Ir(Te, ot, de, Le) {
    const Ye = Te.opaque, $t = Te.transmissive, mn = Te.transparent;
    T.setupLightsView(de), $t.length > 0 && Bn(Ye, ot, de), Le && gt.viewport(K.copy(Le)), Ye.length > 0 && Mi(Ye, ot, de), $t.length > 0 && Mi($t, ot, de), mn.length > 0 && Mi(mn, ot, de), gt.buffers.depth.setTest(!0), gt.buffers.depth.setMask(!0), gt.buffers.color.setMask(!0), gt.setPolygonOffset(!1);
  }
  function Bn(Te, ot, de) {
    const Le = Tt.isWebGL2;
    he === null && (he = new po(1, 1, {
      generateMipmaps: !0,
      type: tt.has("EXT_color_buffer_half_float") ? X_ : df,
      minFilter: s1,
      samples: Le && s === !0 ? 4 : 0
    })), O.getDrawingBufferSize(Ee), Le ? he.setSize(Ee.x, Ee.y) : he.setSize(CC(Ee.x), CC(Ee.y));
    const Ye = O.getRenderTarget();
    O.setRenderTarget(he), O.clear();
    const $t = O.toneMapping;
    O.toneMapping = og, Mi(Te, ot, de), O.toneMapping = $t, qe.updateMultisampleRenderTarget(he), qe.updateRenderTargetMipmap(he), O.setRenderTarget(Ye);
  }
  function Mi(Te, ot, de) {
    const Le = ot.isScene === !0 ? ot.overrideMaterial : null;
    for (let Ye = 0, $t = Te.length; Ye < $t; Ye++) {
      const mn = Te[Ye], Rn = mn.object, gn = mn.geometry, yn = Le === null ? mn.material : Le, Jn = mn.group;
      Rn.layers.test(de.layers) && yi(Rn, ot, de, gn, yn, Jn);
    }
  }
  function yi(Te, ot, de, Le, Ye, $t) {
    Te.onBeforeRender(O, ot, de, Le, Ye, $t), Te.modelViewMatrix.multiplyMatrices(de.matrixWorldInverse, Te.matrixWorld), Te.normalMatrix.getNormalMatrix(Te.modelViewMatrix), Ye.onBeforeRender(O, ot, de, Le, Te, $t), Ye.transparent === !0 && Ye.side === Yh ? (Ye.side = cf, Ye.needsUpdate = !0, O.renderBufferDirect(de, ot, Le, Ye, Te, $t), Ye.side = vy, Ye.needsUpdate = !0, O.renderBufferDirect(de, ot, Le, Ye, Te, $t), Ye.side = Yh) : O.renderBufferDirect(de, ot, Le, Ye, Te, $t), Te.onAfterRender(O, ot, de, Le, Ye, $t);
  }
  function ii(Te, ot, de) {
    ot.isScene !== !0 && (ot = Je);
    const Le = Ie.get(Te), Ye = T.state.lights, $t = T.state.shadowsArray, mn = Ye.state.version, Rn = Nt.getParameters(Te, Ye.state, $t, ot, de), gn = Nt.getProgramCacheKey(Rn);
    let yn = Le.programs;
    Le.environment = Te.isMeshStandardMaterial ? ot.environment : null, Le.fog = ot.fog, Le.envMap = (Te.isMeshStandardMaterial ? ht : dt).get(Te.envMap || Le.environment), yn === void 0 && (Te.addEventListener("dispose", ze), yn = /* @__PURE__ */ new Map(), Le.programs = yn);
    let Jn = yn.get(gn);
    if (Jn !== void 0) {
      if (Le.currentProgram === Jn && Le.lightsStateVersion === mn)
        return Bi(Te, Rn), Jn;
    } else
      Rn.uniforms = Nt.getUniforms(Te), Te.onBuild(de, Rn, O), Te.onBeforeCompile(Rn, O), Jn = Nt.acquireProgram(Rn, gn), yn.set(gn, Jn), Le.uniforms = Rn.uniforms;
    const rr = Le.uniforms;
    (!Te.isShaderMaterial && !Te.isRawShaderMaterial || Te.clipping === !0) && (rr.clippingPlanes = oe.uniform), Bi(Te, Rn), Le.needsLights = ai(Te), Le.lightsStateVersion = mn, Le.needsLights && (rr.ambientLightColor.value = Ye.state.ambient, rr.lightProbe.value = Ye.state.probe, rr.directionalLights.value = Ye.state.directional, rr.directionalLightShadows.value = Ye.state.directionalShadow, rr.spotLights.value = Ye.state.spot, rr.spotLightShadows.value = Ye.state.spotShadow, rr.rectAreaLights.value = Ye.state.rectArea, rr.ltc_1.value = Ye.state.rectAreaLTC1, rr.ltc_2.value = Ye.state.rectAreaLTC2, rr.pointLights.value = Ye.state.point, rr.pointLightShadows.value = Ye.state.pointShadow, rr.hemisphereLights.value = Ye.state.hemi, rr.directionalShadowMap.value = Ye.state.directionalShadowMap, rr.directionalShadowMatrix.value = Ye.state.directionalShadowMatrix, rr.spotShadowMap.value = Ye.state.spotShadowMap, rr.spotShadowMatrix.value = Ye.state.spotShadowMatrix, rr.pointShadowMap.value = Ye.state.pointShadowMap, rr.pointShadowMatrix.value = Ye.state.pointShadowMatrix);
    const wr = Jn.getUniforms(), Yi = vC.seqWithValue(wr.seq, rr);
    return Le.currentProgram = Jn, Le.uniformsList = Yi, Jn;
  }
  function Bi(Te, ot) {
    const de = Ie.get(Te);
    de.outputEncoding = ot.outputEncoding, de.instancing = ot.instancing, de.skinning = ot.skinning, de.morphTargets = ot.morphTargets, de.morphNormals = ot.morphNormals, de.morphColors = ot.morphColors, de.morphTargetsCount = ot.morphTargetsCount, de.numClippingPlanes = ot.numClippingPlanes, de.numIntersection = ot.numClipIntersection, de.vertexAlphas = ot.vertexAlphas, de.vertexTangents = ot.vertexTangents, de.toneMapping = ot.toneMapping;
  }
  function xi(Te, ot, de, Le, Ye) {
    ot.isScene !== !0 && (ot = Je), qe.resetTextureUnits();
    const $t = ot.fog, mn = Le.isMeshStandardMaterial ? ot.environment : null, Rn = G === null ? O.outputEncoding : G.isXRRenderTarget === !0 ? G.texture.encoding : wv, gn = (Le.isMeshStandardMaterial ? ht : dt).get(Le.envMap || mn), yn = Le.vertexColors === !0 && !!de.attributes.color && de.attributes.color.itemSize === 4, Jn = !!Le.normalMap && !!de.attributes.tangent, rr = !!de.morphAttributes.position, wr = !!de.morphAttributes.normal, Yi = !!de.morphAttributes.color, La = Le.toneMapped ? O.toneMapping : og, qs = de.morphAttributes.position || de.morphAttributes.normal || de.morphAttributes.color, en = qs !== void 0 ? qs.length : 0, Xr = Ie.get(Le), us = T.state.lights;
    if (ve === !0 && (fe === !0 || Te !== Q)) {
      const Si = Te === Q && Le.id === B;
      oe.setState(Le, Te, Si);
    }
    let qn = !1;
    Le.version === Xr.__version ? (Xr.needsLights && Xr.lightsStateVersion !== us.state.version || Xr.outputEncoding !== Rn || Ye.isInstancedMesh && Xr.instancing === !1 || !Ye.isInstancedMesh && Xr.instancing === !0 || Ye.isSkinnedMesh && Xr.skinning === !1 || !Ye.isSkinnedMesh && Xr.skinning === !0 || Xr.envMap !== gn || Le.fog === !0 && Xr.fog !== $t || Xr.numClippingPlanes !== void 0 && (Xr.numClippingPlanes !== oe.numPlanes || Xr.numIntersection !== oe.numIntersection) || Xr.vertexAlphas !== yn || Xr.vertexTangents !== Jn || Xr.morphTargets !== rr || Xr.morphNormals !== wr || Xr.morphColors !== Yi || Xr.toneMapping !== La || Tt.isWebGL2 === !0 && Xr.morphTargetsCount !== en) && (qn = !0) : (qn = !0, Xr.__version = Le.version);
    let qa = Xr.currentProgram;
    qn === !0 && (qa = ii(Le, ot, Ye));
    let mo = !1, Ls = !1, cs = !1;
    const mr = qa.getUniforms(), di = Xr.uniforms;
    if (gt.useProgram(qa.program) && (mo = !0, Ls = !0, cs = !0), Le.id !== B && (B = Le.id, Ls = !0), mo || Q !== Te) {
      if (mr.setValue(Ne, "projectionMatrix", Te.projectionMatrix), Tt.logarithmicDepthBuffer && mr.setValue(
        Ne,
        "logDepthBufFC",
        2 / (Math.log(Te.far + 1) / Math.LN2)
      ), Q !== Te && (Q = Te, Ls = !0, cs = !0), Le.isShaderMaterial || Le.isMeshPhongMaterial || Le.isMeshToonMaterial || Le.isMeshStandardMaterial || Le.envMap) {
        const Si = mr.map.cameraPosition;
        Si !== void 0 && Si.setValue(
          Ne,
          Ve.setFromMatrixPosition(Te.matrixWorld)
        );
      }
      (Le.isMeshPhongMaterial || Le.isMeshToonMaterial || Le.isMeshLambertMaterial || Le.isMeshBasicMaterial || Le.isMeshStandardMaterial || Le.isShaderMaterial) && mr.setValue(Ne, "isOrthographic", Te.isOrthographicCamera === !0), (Le.isMeshPhongMaterial || Le.isMeshToonMaterial || Le.isMeshLambertMaterial || Le.isMeshBasicMaterial || Le.isMeshStandardMaterial || Le.isShaderMaterial || Le.isShadowMaterial || Ye.isSkinnedMesh) && mr.setValue(Ne, "viewMatrix", Te.matrixWorldInverse);
    }
    if (Ye.isSkinnedMesh) {
      mr.setOptional(Ne, Ye, "bindMatrix"), mr.setOptional(Ne, Ye, "bindMatrixInverse");
      const Si = Ye.skeleton;
      Si && (Tt.floatVertexTextures ? (Si.boneTexture === null && Si.computeBoneTexture(), mr.setValue(Ne, "boneTexture", Si.boneTexture, qe), mr.setValue(Ne, "boneTextureSize", Si.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."));
    }
    const Ea = de.morphAttributes;
    if ((Ea.position !== void 0 || Ea.normal !== void 0 || Ea.color !== void 0 && Tt.isWebGL2 === !0) && Ft.update(Ye, de, Le, qa), (Ls || Xr.receiveShadow !== Ye.receiveShadow) && (Xr.receiveShadow = Ye.receiveShadow, mr.setValue(Ne, "receiveShadow", Ye.receiveShadow)), Ls && (mr.setValue(Ne, "toneMappingExposure", O.toneMappingExposure), Xr.needsLights && $r(di, cs), $t && Le.fog === !0 && Zt.refreshFogUniforms(di, $t), Zt.refreshMaterialUniforms(di, Le, ce, se, he), vC.upload(Ne, Xr.uniformsList, di, qe)), Le.isShaderMaterial && Le.uniformsNeedUpdate === !0 && (vC.upload(Ne, Xr.uniformsList, di, qe), Le.uniformsNeedUpdate = !1), Le.isSpriteMaterial && mr.setValue(Ne, "center", Ye.center), mr.setValue(Ne, "modelViewMatrix", Ye.modelViewMatrix), mr.setValue(Ne, "normalMatrix", Ye.normalMatrix), mr.setValue(Ne, "modelMatrix", Ye.matrixWorld), Le.isShaderMaterial || Le.isRawShaderMaterial) {
      const Si = Le.uniformsGroups;
      for (let Ti = 0, Uo = Si.length; Ti < Uo; Ti++)
        if (Tt.isWebGL2) {
          const zo = Si[Ti];
          Be.update(zo, qa), Be.bind(zo, qa);
        } else
          console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");
    }
    return qa;
  }
  function $r(Te, ot) {
    Te.ambientLightColor.needsUpdate = ot, Te.lightProbe.needsUpdate = ot, Te.directionalLights.needsUpdate = ot, Te.directionalLightShadows.needsUpdate = ot, Te.pointLights.needsUpdate = ot, Te.pointLightShadows.needsUpdate = ot, Te.spotLights.needsUpdate = ot, Te.spotLightShadows.needsUpdate = ot, Te.rectAreaLights.needsUpdate = ot, Te.hemisphereLights.needsUpdate = ot;
  }
  function ai(Te) {
    return Te.isMeshLambertMaterial || Te.isMeshToonMaterial || Te.isMeshPhongMaterial || Te.isMeshStandardMaterial || Te.isShadowMaterial || Te.isShaderMaterial && Te.lights === !0;
  }
  this.getActiveCubeFace = function() {
    return H;
  }, this.getActiveMipmapLevel = function() {
    return I;
  }, this.getRenderTarget = function() {
    return G;
  }, this.setRenderTargetTextures = function(Te, ot, de) {
    Ie.get(Te.texture).__webglTexture = ot, Ie.get(Te.depthTexture).__webglTexture = de;
    const Le = Ie.get(Te);
    Le.__hasExternalTextures = !0, Le.__hasExternalTextures && (Le.__autoAllocateDepthBuffer = de === void 0, Le.__autoAllocateDepthBuffer || tt.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), Le.__useRenderToTexture = !1));
  }, this.setRenderTargetFramebuffer = function(Te, ot) {
    const de = Ie.get(Te);
    de.__webglFramebuffer = ot, de.__useDefaultFramebuffer = ot === void 0;
  }, this.setRenderTarget = function(Te, ot = 0, de = 0) {
    G = Te, H = ot, I = de;
    let Le = !0;
    if (Te) {
      const gn = Ie.get(Te);
      gn.__useDefaultFramebuffer !== void 0 ? (gt.bindFramebuffer(36160, null), Le = !1) : gn.__webglFramebuffer === void 0 ? qe.setupRenderTarget(Te) : gn.__hasExternalTextures && qe.rebindTextures(Te, Ie.get(Te.texture).__webglTexture, Ie.get(Te.depthTexture).__webglTexture);
    }
    let Ye = null, $t = !1, mn = !1;
    if (Te) {
      const gn = Te.texture;
      (gn.isData3DTexture || gn.isDataArrayTexture) && (mn = !0);
      const yn = Ie.get(Te).__webglFramebuffer;
      Te.isWebGLCubeRenderTarget ? (Ye = yn[ot], $t = !0) : Tt.isWebGL2 && Te.samples > 0 && qe.useMultisampledRTT(Te) === !1 ? Ye = Ie.get(Te).__webglMultisampledFramebuffer : Ye = yn, K.copy(Te.viewport), te.copy(Te.scissor), Y = Te.scissorTest;
    } else
      K.copy(me).multiplyScalar(ce).floor(), te.copy(De).multiplyScalar(ce).floor(), Y = Re;
    if (gt.bindFramebuffer(36160, Ye) && Tt.drawBuffers && Le && gt.drawBuffers(Te, Ye), gt.viewport(K), gt.scissor(te), gt.setScissorTest(Y), $t) {
      const gn = Ie.get(Te.texture);
      Ne.framebufferTexture2D(36160, 36064, 34069 + ot, gn.__webglTexture, de);
    } else if (mn) {
      const gn = Ie.get(Te.texture), yn = ot || 0;
      Ne.framebufferTextureLayer(36160, 36064, gn.__webglTexture, de || 0, yn);
    }
    B = -1;
  }, this.readRenderTargetPixels = function(Te, ot, de, Le, Ye, $t, mn) {
    if (!(Te && Te.isWebGLRenderTarget)) {
      console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      return;
    }
    let Rn = Ie.get(Te).__webglFramebuffer;
    if (Te.isWebGLCubeRenderTarget && mn !== void 0 && (Rn = Rn[mn]), Rn) {
      gt.bindFramebuffer(36160, Rn);
      try {
        const gn = Te.texture, yn = gn.format, Jn = gn.type;
        if (yn !== zp && it.convert(yn) !== Ne.getParameter(35739)) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
          return;
        }
        const rr = Jn === X_ && (tt.has("EXT_color_buffer_half_float") || Tt.isWebGL2 && tt.has("EXT_color_buffer_float"));
        if (Jn !== df && it.convert(Jn) !== Ne.getParameter(35738) && !(Jn === fy && (Tt.isWebGL2 || tt.has("OES_texture_float") || tt.has("WEBGL_color_buffer_float"))) && !rr) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          return;
        }
        ot >= 0 && ot <= Te.width - Le && de >= 0 && de <= Te.height - Ye && Ne.readPixels(ot, de, Le, Ye, it.convert(yn), it.convert(Jn), $t);
      } finally {
        const gn = G !== null ? Ie.get(G).__webglFramebuffer : null;
        gt.bindFramebuffer(36160, gn);
      }
    }
  }, this.copyFramebufferToTexture = function(Te, ot, de = 0) {
    const Le = Math.pow(2, -de), Ye = Math.floor(ot.image.width * Le), $t = Math.floor(ot.image.height * Le);
    qe.setTexture2D(ot, 0), Ne.copyTexSubImage2D(3553, de, 0, 0, Te.x, Te.y, Ye, $t), gt.unbindTexture();
  }, this.copyTextureToTexture = function(Te, ot, de, Le = 0) {
    const Ye = ot.image.width, $t = ot.image.height, mn = it.convert(de.format), Rn = it.convert(de.type);
    qe.setTexture2D(de, 0), Ne.pixelStorei(37440, de.flipY), Ne.pixelStorei(37441, de.premultiplyAlpha), Ne.pixelStorei(3317, de.unpackAlignment), ot.isDataTexture ? Ne.texSubImage2D(3553, Le, Te.x, Te.y, Ye, $t, mn, Rn, ot.image.data) : ot.isCompressedTexture ? Ne.compressedTexSubImage2D(3553, Le, Te.x, Te.y, ot.mipmaps[0].width, ot.mipmaps[0].height, mn, ot.mipmaps[0].data) : Ne.texSubImage2D(3553, Le, Te.x, Te.y, mn, Rn, ot.image), Le === 0 && de.generateMipmaps && Ne.generateMipmap(3553), gt.unbindTexture();
  }, this.copyTextureToTexture3D = function(Te, ot, de, Le, Ye = 0) {
    if (O.isWebGL1Renderer) {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
      return;
    }
    const $t = Te.max.x - Te.min.x + 1, mn = Te.max.y - Te.min.y + 1, Rn = Te.max.z - Te.min.z + 1, gn = it.convert(Le.format), yn = it.convert(Le.type);
    let Jn;
    if (Le.isData3DTexture)
      qe.setTexture3D(Le, 0), Jn = 32879;
    else if (Le.isDataArrayTexture)
      qe.setTexture2DArray(Le, 0), Jn = 35866;
    else {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
      return;
    }
    Ne.pixelStorei(37440, Le.flipY), Ne.pixelStorei(37441, Le.premultiplyAlpha), Ne.pixelStorei(3317, Le.unpackAlignment);
    const rr = Ne.getParameter(3314), wr = Ne.getParameter(32878), Yi = Ne.getParameter(3316), La = Ne.getParameter(3315), qs = Ne.getParameter(32877), en = de.isCompressedTexture ? de.mipmaps[0] : de.image;
    Ne.pixelStorei(3314, en.width), Ne.pixelStorei(32878, en.height), Ne.pixelStorei(3316, Te.min.x), Ne.pixelStorei(3315, Te.min.y), Ne.pixelStorei(32877, Te.min.z), de.isDataTexture || de.isData3DTexture ? Ne.texSubImage3D(Jn, Ye, ot.x, ot.y, ot.z, $t, mn, Rn, gn, yn, en.data) : de.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), Ne.compressedTexSubImage3D(Jn, Ye, ot.x, ot.y, ot.z, $t, mn, Rn, gn, en.data)) : Ne.texSubImage3D(Jn, Ye, ot.x, ot.y, ot.z, $t, mn, Rn, gn, yn, en), Ne.pixelStorei(3314, rr), Ne.pixelStorei(32878, wr), Ne.pixelStorei(3316, Yi), Ne.pixelStorei(3315, La), Ne.pixelStorei(32877, qs), Ye === 0 && Le.generateMipmaps && Ne.generateMipmap(Jn), gt.unbindTexture();
  }, this.initTexture = function(Te) {
    Te.isCubeTexture ? qe.setTextureCube(Te, 0) : Te.isData3DTexture ? qe.setTexture3D(Te, 0) : Te.isDataArrayTexture ? qe.setTexture2DArray(Te, 0) : qe.setTexture2D(Te, 0), gt.unbindTexture();
  }, this.resetState = function() {
    H = 0, I = 0, G = null, gt.reset(), an.reset();
  }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
}
class GF extends $3 {
}
GF.prototype.isWebGL1Renderer = !0;
class GC {
  constructor(e, t = 25e-5) {
    this.isFogExp2 = !0, this.name = "", this.color = new Un(e), this.density = t;
  }
  clone() {
    return new GC(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      color: this.color.getHex(),
      density: this.density
    };
  }
}
class WC {
  constructor(e, t = 1, r = 1e3) {
    this.isFog = !0, this.name = "", this.color = new Un(e), this.near = t, this.far = r;
  }
  clone() {
    return new WC(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
}
class NM extends Xa {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, t) {
    return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.fog !== null && (t.object.fog = this.fog.toJSON()), t;
  }
}
class jC {
  constructor(e, t) {
    this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = OM, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = Em();
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  copy(e) {
    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
  }
  copyAt(e, t, r) {
    e *= this.stride, r *= t.stride;
    for (let i = 0, s = this.stride; i < s; i++)
      this.array[e + i] = t.array[r + i];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Em()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), r = new this.constructor(t, this.stride);
    return r.setUsage(this.usage), r;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  toJSON(e) {
    return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Em()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
}
const Gh = /* @__PURE__ */ new ge();
class bm {
  constructor(e, t, r, i = !1) {
    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = r, this.normalized = i === !0;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, r = this.data.count; t < r; t++)
      Gh.fromBufferAttribute(this, t), Gh.applyMatrix4(e), this.setXYZ(t, Gh.x, Gh.y, Gh.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, r = this.count; t < r; t++)
      Gh.fromBufferAttribute(this, t), Gh.applyNormalMatrix(e), this.setXYZ(t, Gh.x, Gh.y, Gh.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, r = this.count; t < r; t++)
      Gh.fromBufferAttribute(this, t), Gh.transformDirection(e), this.setXYZ(t, Gh.x, Gh.y, Gh.z);
    return this;
  }
  setX(e, t) {
    return this.data.array[e * this.data.stride + this.offset] = t, this;
  }
  setY(e, t) {
    return this.data.array[e * this.data.stride + this.offset + 1] = t, this;
  }
  setZ(e, t) {
    return this.data.array[e * this.data.stride + this.offset + 2] = t, this;
  }
  setW(e, t) {
    return this.data.array[e * this.data.stride + this.offset + 3] = t, this;
  }
  getX(e) {
    return this.data.array[e * this.data.stride + this.offset];
  }
  getY(e) {
    return this.data.array[e * this.data.stride + this.offset + 1];
  }
  getZ(e) {
    return this.data.array[e * this.data.stride + this.offset + 2];
  }
  getW(e) {
    return this.data.array[e * this.data.stride + this.offset + 3];
  }
  setXY(e, t, r) {
    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = r, this;
  }
  setXYZ(e, t, r, i) {
    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = r, this.data.array[e + 2] = i, this;
  }
  setXYZW(e, t, r, i, s) {
    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = r, this.data.array[e + 2] = i, this.data.array[e + 3] = s, this;
  }
  clone(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will deinterleave buffer data.");
      const t = [];
      for (let r = 0; r < this.count; r++) {
        const i = r * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++)
          t.push(this.data.array[i + s]);
      }
      return new ls(new this.array.constructor(t), this.itemSize, this.normalized);
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new bm(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  toJSON(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will deinterleave buffer data.");
      const t = [];
      for (let r = 0; r < this.count; r++) {
        const i = r * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++)
          t.push(this.data.array[i + s]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized
      };
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
  }
}
class eL extends hf {
  constructor(e) {
    super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new Un(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
let zw;
const eM = /* @__PURE__ */ new ge(), Nw = /* @__PURE__ */ new ge(), Fw = /* @__PURE__ */ new ge(), kw = /* @__PURE__ */ new zt(), tM = /* @__PURE__ */ new zt(), WF = /* @__PURE__ */ new Kr(), C2 = /* @__PURE__ */ new ge(), nM = /* @__PURE__ */ new ge(), R2 = /* @__PURE__ */ new ge(), fU = /* @__PURE__ */ new zt(), ZA = /* @__PURE__ */ new zt(), dU = /* @__PURE__ */ new zt();
class jF extends Xa {
  constructor(e) {
    if (super(), this.isSprite = !0, this.type = "Sprite", zw === void 0) {
      zw = new oi();
      const t = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]), r = new jC(t, 5);
      zw.setIndex([0, 1, 2, 0, 2, 3]), zw.setAttribute("position", new bm(r, 3, 0, !1)), zw.setAttribute("uv", new bm(r, 2, 3, !1));
    }
    this.geometry = zw, this.material = e !== void 0 ? e : new eL(), this.center = new zt(0.5, 0.5);
  }
  raycast(e, t) {
    e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Nw.setFromMatrixScale(this.matrixWorld), WF.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), Fw.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && Nw.multiplyScalar(-Fw.z);
    const r = this.material.rotation;
    let i, s;
    r !== 0 && (s = Math.cos(r), i = Math.sin(r));
    const l = this.center;
    A2(C2.set(-0.5, -0.5, 0), Fw, l, Nw, i, s), A2(nM.set(0.5, -0.5, 0), Fw, l, Nw, i, s), A2(R2.set(0.5, 0.5, 0), Fw, l, Nw, i, s), fU.set(0, 0), ZA.set(1, 0), dU.set(1, 1);
    let d = e.ray.intersectTriangle(C2, nM, R2, !1, eM);
    if (d === null && (A2(nM.set(-0.5, 0.5, 0), Fw, l, Nw, i, s), ZA.set(0, 1), d = e.ray.intersectTriangle(C2, R2, nM, !1, eM), d === null))
      return;
    const p = e.ray.origin.distanceTo(eM);
    p < e.near || p > e.far || t.push({
      distance: p,
      point: eM.clone(),
      uv: wm.getUV(eM, C2, nM, R2, fU, ZA, dU, new zt()),
      face: null,
      object: this
    });
  }
  copy(e, t) {
    return super.copy(e, t), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this;
  }
}
function A2(a, e, t, r, i, s) {
  kw.subVectors(a, t).addScalar(0.5).multiply(r), i !== void 0 ? (tM.x = s * kw.x - i * kw.y, tM.y = i * kw.x + s * kw.y) : tM.copy(kw), a.copy(e), a.x += tM.x, a.y += tM.y, a.applyMatrix4(WF);
}
const D2 = /* @__PURE__ */ new ge(), hU = /* @__PURE__ */ new ge();
class YF extends Xa {
  constructor() {
    super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
      levels: {
        enumerable: !0,
        value: []
      },
      isLOD: {
        value: !0
      }
    }), this.autoUpdate = !0;
  }
  copy(e) {
    super.copy(e, !1);
    const t = e.levels;
    for (let r = 0, i = t.length; r < i; r++) {
      const s = t[r];
      this.addLevel(s.object.clone(), s.distance);
    }
    return this.autoUpdate = e.autoUpdate, this;
  }
  addLevel(e, t = 0) {
    t = Math.abs(t);
    const r = this.levels;
    let i;
    for (i = 0; i < r.length && !(t < r[i].distance); i++)
      ;
    return r.splice(i, 0, { distance: t, object: e }), this.add(e), this;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let r, i;
      for (r = 1, i = t.length; r < i && !(e < t[r].distance); r++)
        ;
      return t[r - 1].object;
    }
    return null;
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      D2.setFromMatrixPosition(this.matrixWorld);
      const i = e.ray.origin.distanceTo(D2);
      this.getObjectForDistance(i).raycast(e, t);
    }
  }
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      D2.setFromMatrixPosition(e.matrixWorld), hU.setFromMatrixPosition(this.matrixWorld);
      const r = D2.distanceTo(hU) / e.zoom;
      t[0].object.visible = !0;
      let i, s;
      for (i = 1, s = t.length; i < s && r >= t[i].distance; i++)
        t[i - 1].object.visible = !1, t[i].object.visible = !0;
      for (this._currentLevel = i - 1; i < s; i++)
        t[i].object.visible = !1;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    this.autoUpdate === !1 && (t.object.autoUpdate = !1), t.object.levels = [];
    const r = this.levels;
    for (let i = 0, s = r.length; i < s; i++) {
      const l = r[i];
      t.object.levels.push({
        object: l.object.uuid,
        distance: l.distance
      });
    }
    return t;
  }
}
const pU = /* @__PURE__ */ new ge(), mU = /* @__PURE__ */ new ra(), vU = /* @__PURE__ */ new ra(), EW = /* @__PURE__ */ new ge(), gU = /* @__PURE__ */ new Kr();
class XF extends Fn {
  constructor(e, t) {
    super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Kr(), this.bindMatrixInverse = new Kr();
  }
  copy(e, t) {
    return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, this;
  }
  bind(e, t) {
    this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new ra(), t = this.geometry.attributes.skinWeight;
    for (let r = 0, i = t.count; r < i; r++) {
      e.fromBufferAttribute(t, r);
      const s = 1 / e.manhattanLength();
      s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0), t.setXYZW(r, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  }
  boneTransform(e, t) {
    const r = this.skeleton, i = this.geometry;
    mU.fromBufferAttribute(i.attributes.skinIndex, e), vU.fromBufferAttribute(i.attributes.skinWeight, e), pU.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
    for (let s = 0; s < 4; s++) {
      const l = vU.getComponent(s);
      if (l !== 0) {
        const d = mU.getComponent(s);
        gU.multiplyMatrices(r.bones[d].matrixWorld, r.boneInverses[d]), t.addScaledVector(EW.copy(pU).applyMatrix4(gU), l);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
}
class tL extends Xa {
  constructor() {
    super(), this.isBone = !0, this.type = "Bone";
  }
}
class qw extends su {
  constructor(e = null, t = 1, r = 1, i, s, l, d, p, g = fo, _ = fo, w, T) {
    super(null, l, d, p, g, _, i, s, w, T), this.isDataTexture = !0, this.image = { data: e, width: t, height: r }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
const yU = /* @__PURE__ */ new Kr(), MW = /* @__PURE__ */ new Kr();
class YC {
  constructor(e = [], t = []) {
    this.uuid = Em(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init();
  }
  init() {
    const e = this.bones, t = this.boneInverses;
    if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0)
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
      for (let r = 0, i = this.bones.length; r < i; r++)
        this.boneInverses.push(new Kr());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const r = new Kr();
      this.bones[e] && r.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(r);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const r = this.bones[e];
      r && r.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const r = this.bones[e];
      r && (r.parent && r.parent.isBone ? (r.matrix.copy(r.parent.matrixWorld).invert(), r.matrix.multiply(r.matrixWorld)) : r.matrix.copy(r.matrixWorld), r.matrix.decompose(r.position, r.quaternion, r.scale));
    }
  }
  update() {
    const e = this.bones, t = this.boneInverses, r = this.boneMatrices, i = this.boneTexture;
    for (let s = 0, l = e.length; s < l; s++) {
      const d = e[s] ? e[s].matrixWorld : MW;
      yU.multiplyMatrices(d, t[s]), yU.toArray(r, s * 16);
    }
    i !== null && (i.needsUpdate = !0);
  }
  clone() {
    return new YC(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    e = AF(e), e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const r = new qw(t, e, e, zp, fy);
    return r.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = r, this.boneTextureSize = e, this;
  }
  getBoneByName(e) {
    for (let t = 0, r = this.bones.length; t < r; t++) {
      const i = this.bones[t];
      if (i.name === e)
        return i;
    }
  }
  dispose() {
    this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let r = 0, i = e.bones.length; r < i; r++) {
      const s = e.bones[r];
      let l = t[s];
      l === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s), l = new tL()), this.bones.push(l), this.boneInverses.push(new Kr().fromArray(e.boneInverses[r]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.5,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    e.uuid = this.uuid;
    const t = this.bones, r = this.boneInverses;
    for (let i = 0, s = t.length; i < s; i++) {
      const l = t[i];
      e.bones.push(l.uuid);
      const d = r[i];
      e.boneInverses.push(d.toArray());
    }
    return e;
  }
}
class q_ extends ls {
  constructor(e, t, r, i = 1) {
    typeof r == "number" && (i = r, r = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(e, t, r), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = i;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
  }
}
const xU = /* @__PURE__ */ new Kr(), _U = /* @__PURE__ */ new Kr(), L2 = [], rM = /* @__PURE__ */ new Fn();
class qF extends Fn {
  constructor(e, t, r) {
    super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new q_(new Float32Array(r * 16), 16), this.instanceColor = null, this.count = r, this.frustumCulled = !1;
  }
  copy(e, t) {
    return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, this;
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  raycast(e, t) {
    const r = this.matrixWorld, i = this.count;
    if (rM.geometry = this.geometry, rM.material = this.material, rM.material !== void 0)
      for (let s = 0; s < i; s++) {
        this.getMatrixAt(s, xU), _U.multiplyMatrices(r, xU), rM.matrixWorld = _U, rM.raycast(e, L2);
        for (let l = 0, d = L2.length; l < d; l++) {
          const p = L2[l];
          p.instanceId = s, p.object = this, t.push(p);
        }
        L2.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null && (this.instanceColor = new q_(new Float32Array(this.instanceMatrix.count * 3), 3)), t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  updateMorphTargets() {
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class mh extends hf {
  constructor(e) {
    super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new Un(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
  }
}
const SU = /* @__PURE__ */ new ge(), wU = /* @__PURE__ */ new ge(), bU = /* @__PURE__ */ new Kr(), JA = /* @__PURE__ */ new KM(), P2 = /* @__PURE__ */ new yy();
class fh extends Xa {
  constructor(e = new oi(), t = new mh()) {
    super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this;
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, r = [0];
      for (let i = 1, s = t.count; i < s; i++)
        SU.fromBufferAttribute(t, i - 1), wU.fromBufferAttribute(t, i), r[i] = r[i - 1], r[i] += SU.distanceTo(wU);
      e.setAttribute("lineDistance", new sr(r, 1));
    } else
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  raycast(e, t) {
    const r = this.geometry, i = this.matrixWorld, s = e.params.Line.threshold, l = r.drawRange;
    if (r.boundingSphere === null && r.computeBoundingSphere(), P2.copy(r.boundingSphere), P2.applyMatrix4(i), P2.radius += s, e.ray.intersectsSphere(P2) === !1)
      return;
    bU.copy(i).invert(), JA.copy(e.ray).applyMatrix4(bU);
    const d = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), p = d * d, g = new ge(), _ = new ge(), w = new ge(), T = new ge(), R = this.isLineSegments ? 2 : 1, D = r.index, U = r.attributes.position;
    if (D !== null) {
      const H = Math.max(0, l.start), I = Math.min(D.count, l.start + l.count);
      for (let G = H, B = I - 1; G < B; G += R) {
        const Q = D.getX(G), K = D.getX(G + 1);
        if (g.fromBufferAttribute(U, Q), _.fromBufferAttribute(U, K), JA.distanceSqToSegment(g, _, T, w) > p)
          continue;
        T.applyMatrix4(this.matrixWorld);
        const Y = e.ray.origin.distanceTo(T);
        Y < e.near || Y > e.far || t.push({
          distance: Y,
          point: w.clone().applyMatrix4(this.matrixWorld),
          index: G,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    } else {
      const H = Math.max(0, l.start), I = Math.min(U.count, l.start + l.count);
      for (let G = H, B = I - 1; G < B; G += R) {
        if (g.fromBufferAttribute(U, G), _.fromBufferAttribute(U, G + 1), JA.distanceSqToSegment(g, _, T, w) > p)
          continue;
        T.applyMatrix4(this.matrixWorld);
        const K = e.ray.origin.distanceTo(T);
        K < e.near || K > e.far || t.push({
          distance: K,
          point: w.clone().applyMatrix4(this.matrixWorld),
          index: G,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, r = Object.keys(t);
    if (r.length > 0) {
      const i = t[r[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let s = 0, l = i.length; s < l; s++) {
          const d = i[s].name || String(s);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[d] = s;
        }
      }
    }
  }
}
const EU = /* @__PURE__ */ new ge(), MU = /* @__PURE__ */ new ge();
class xy extends fh {
  constructor(e, t) {
    super(e, t), this.isLineSegments = !0, this.type = "LineSegments";
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, r = [];
      for (let i = 0, s = t.count; i < s; i += 2)
        EU.fromBufferAttribute(t, i), MU.fromBufferAttribute(t, i + 1), r[i] = i === 0 ? 0 : r[i - 1], r[i + 1] = r[i] + EU.distanceTo(MU);
      e.setAttribute("lineDistance", new sr(r, 1));
    } else
      console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
}
class QF extends fh {
  constructor(e, t) {
    super(e, t), this.isLineLoop = !0, this.type = "LineLoop";
  }
}
class XC extends hf {
  constructor(e) {
    super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new Un(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
const TU = /* @__PURE__ */ new Kr(), y3 = /* @__PURE__ */ new KM(), O2 = /* @__PURE__ */ new yy(), U2 = /* @__PURE__ */ new ge();
class ZF extends Xa {
  constructor(e = new oi(), t = new XC()) {
    super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this;
  }
  raycast(e, t) {
    const r = this.geometry, i = this.matrixWorld, s = e.params.Points.threshold, l = r.drawRange;
    if (r.boundingSphere === null && r.computeBoundingSphere(), O2.copy(r.boundingSphere), O2.applyMatrix4(i), O2.radius += s, e.ray.intersectsSphere(O2) === !1)
      return;
    TU.copy(i).invert(), y3.copy(e.ray).applyMatrix4(TU);
    const d = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), p = d * d, g = r.index, w = r.attributes.position;
    if (g !== null) {
      const T = Math.max(0, l.start), R = Math.min(g.count, l.start + l.count);
      for (let D = T, O = R; D < O; D++) {
        const U = g.getX(D);
        U2.fromBufferAttribute(w, U), CU(U2, U, p, i, e, t, this);
      }
    } else {
      const T = Math.max(0, l.start), R = Math.min(w.count, l.start + l.count);
      for (let D = T, O = R; D < O; D++)
        U2.fromBufferAttribute(w, D), CU(U2, D, p, i, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, r = Object.keys(t);
    if (r.length > 0) {
      const i = t[r[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let s = 0, l = i.length; s < l; s++) {
          const d = i[s].name || String(s);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[d] = s;
        }
      }
    }
  }
}
function CU(a, e, t, r, i, s, l) {
  const d = y3.distanceSqToPoint(a);
  if (d < t) {
    const p = new ge();
    y3.closestPointToPoint(a, p), p.applyMatrix4(r);
    const g = i.ray.origin.distanceTo(p);
    if (g < i.near || g > i.far)
      return;
    s.push({
      distance: g,
      distanceToRay: Math.sqrt(d),
      point: p,
      index: e,
      face: null,
      object: l
    });
  }
}
class TW extends su {
  constructor(e, t, r, i, s, l, d, p, g) {
    super(e, t, r, i, s, l, d, p, g), this.isVideoTexture = !0, this.minFilter = l !== void 0 ? l : Oo, this.magFilter = s !== void 0 ? s : Oo, this.generateMipmaps = !1;
    const _ = this;
    function w() {
      _.needsUpdate = !0, e.requestVideoFrameCallback(w);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(w);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  }
}
class CW extends su {
  constructor(e, t, r) {
    super({ width: e, height: t }), this.isFramebufferTexture = !0, this.format = r, this.magFilter = fo, this.minFilter = fo, this.generateMipmaps = !1, this.needsUpdate = !0;
  }
}
class JF extends su {
  constructor(e, t, r, i, s, l, d, p, g, _, w, T) {
    super(null, l, d, p, g, _, i, s, w, T), this.isCompressedTexture = !0, this.image = { width: t, height: r }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1;
  }
}
class RW extends su {
  constructor(e, t, r, i, s, l, d, p, g) {
    super(e, t, r, i, s, l, d, p, g), this.isCanvasTexture = !0, this.needsUpdate = !0;
  }
}
class dg {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  getPointAt(e, t) {
    const r = this.getUtoTmapping(e);
    return this.getPoint(r, t);
  }
  getPoints(e = 5) {
    const t = [];
    for (let r = 0; r <= e; r++)
      t.push(this.getPoint(r / e));
    return t;
  }
  getSpacedPoints(e = 5) {
    const t = [];
    for (let r = 0; r <= e; r++)
      t.push(this.getPointAt(r / e));
    return t;
  }
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let r, i = this.getPoint(0), s = 0;
    t.push(0);
    for (let l = 1; l <= e; l++)
      r = this.getPoint(l / e), s += r.distanceTo(i), t.push(s), i = r;
    return this.cacheArcLengths = t, t;
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  getUtoTmapping(e, t) {
    const r = this.getLengths();
    let i = 0;
    const s = r.length;
    let l;
    t ? l = t : l = e * r[s - 1];
    let d = 0, p = s - 1, g;
    for (; d <= p; )
      if (i = Math.floor(d + (p - d) / 2), g = r[i] - l, g < 0)
        d = i + 1;
      else if (g > 0)
        p = i - 1;
      else {
        p = i;
        break;
      }
    if (i = p, r[i] === l)
      return i / (s - 1);
    const _ = r[i], T = r[i + 1] - _, R = (l - _) / T;
    return (i + R) / (s - 1);
  }
  getTangent(e, t) {
    let i = e - 1e-4, s = e + 1e-4;
    i < 0 && (i = 0), s > 1 && (s = 1);
    const l = this.getPoint(i), d = this.getPoint(s), p = t || (l.isVector2 ? new zt() : new ge());
    return p.copy(d).sub(l).normalize(), p;
  }
  getTangentAt(e, t) {
    const r = this.getUtoTmapping(e);
    return this.getTangent(r, t);
  }
  computeFrenetFrames(e, t) {
    const r = new ge(), i = [], s = [], l = [], d = new ge(), p = new Kr();
    for (let R = 0; R <= e; R++) {
      const D = R / e;
      i[R] = this.getTangentAt(D, new ge());
    }
    s[0] = new ge(), l[0] = new ge();
    let g = Number.MAX_VALUE;
    const _ = Math.abs(i[0].x), w = Math.abs(i[0].y), T = Math.abs(i[0].z);
    _ <= g && (g = _, r.set(1, 0, 0)), w <= g && (g = w, r.set(0, 1, 0)), T <= g && r.set(0, 0, 1), d.crossVectors(i[0], r).normalize(), s[0].crossVectors(i[0], d), l[0].crossVectors(i[0], s[0]);
    for (let R = 1; R <= e; R++) {
      if (s[R] = s[R - 1].clone(), l[R] = l[R - 1].clone(), d.crossVectors(i[R - 1], i[R]), d.length() > Number.EPSILON) {
        d.normalize();
        const D = Math.acos(Zu(i[R - 1].dot(i[R]), -1, 1));
        s[R].applyMatrix4(p.makeRotationAxis(d, D));
      }
      l[R].crossVectors(i[R], s[R]);
    }
    if (t === !0) {
      let R = Math.acos(Zu(s[0].dot(s[e]), -1, 1));
      R /= e, i[0].dot(d.crossVectors(s[0], s[e])) > 0 && (R = -R);
      for (let D = 1; D <= e; D++)
        s[D].applyMatrix4(p.makeRotationAxis(i[D], R * D)), l[D].crossVectors(i[D], s[D]);
    }
    return {
      tangents: i,
      normals: s,
      binormals: l
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.5,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class qC extends dg {
  constructor(e = 0, t = 0, r = 1, i = 1, s = 0, l = Math.PI * 2, d = !1, p = 0) {
    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = r, this.yRadius = i, this.aStartAngle = s, this.aEndAngle = l, this.aClockwise = d, this.aRotation = p;
  }
  getPoint(e, t) {
    const r = t || new zt(), i = Math.PI * 2;
    let s = this.aEndAngle - this.aStartAngle;
    const l = Math.abs(s) < Number.EPSILON;
    for (; s < 0; )
      s += i;
    for (; s > i; )
      s -= i;
    s < Number.EPSILON && (l ? s = 0 : s = i), this.aClockwise === !0 && !l && (s === i ? s = -i : s = s - i);
    const d = this.aStartAngle + e * s;
    let p = this.aX + this.xRadius * Math.cos(d), g = this.aY + this.yRadius * Math.sin(d);
    if (this.aRotation !== 0) {
      const _ = Math.cos(this.aRotation), w = Math.sin(this.aRotation), T = p - this.aX, R = g - this.aY;
      p = T * _ - R * w + this.aX, g = T * w + R * _ + this.aY;
    }
    return r.set(p, g);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
class KF extends qC {
  constructor(e, t, r, i, s, l) {
    super(e, t, r, r, i, s, l), this.isArcCurve = !0, this.type = "ArcCurve";
  }
}
function nL() {
  let a = 0, e = 0, t = 0, r = 0;
  function i(s, l, d, p) {
    a = s, e = d, t = -3 * s + 3 * l - 2 * d - p, r = 2 * s - 2 * l + d + p;
  }
  return {
    initCatmullRom: function(s, l, d, p, g) {
      i(l, d, g * (d - s), g * (p - l));
    },
    initNonuniformCatmullRom: function(s, l, d, p, g, _, w) {
      let T = (l - s) / g - (d - s) / (g + _) + (d - l) / _, R = (d - l) / _ - (p - l) / (_ + w) + (p - d) / w;
      T *= _, R *= _, i(l, d, T, R);
    },
    calc: function(s) {
      const l = s * s, d = l * s;
      return a + e * s + t * l + r * d;
    }
  };
}
const z2 = /* @__PURE__ */ new ge(), KA = /* @__PURE__ */ new nL(), $A = /* @__PURE__ */ new nL(), eD = /* @__PURE__ */ new nL();
class $F extends dg {
  constructor(e = [], t = !1, r = "centripetal", i = 0.5) {
    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = r, this.tension = i;
  }
  getPoint(e, t = new ge()) {
    const r = t, i = this.points, s = i.length, l = (s - (this.closed ? 0 : 1)) * e;
    let d = Math.floor(l), p = l - d;
    this.closed ? d += d > 0 ? 0 : (Math.floor(Math.abs(d) / s) + 1) * s : p === 0 && d === s - 1 && (d = s - 2, p = 1);
    let g, _;
    this.closed || d > 0 ? g = i[(d - 1) % s] : (z2.subVectors(i[0], i[1]).add(i[0]), g = z2);
    const w = i[d % s], T = i[(d + 1) % s];
    if (this.closed || d + 2 < s ? _ = i[(d + 2) % s] : (z2.subVectors(i[s - 1], i[s - 2]).add(i[s - 1]), _ = z2), this.curveType === "centripetal" || this.curveType === "chordal") {
      const R = this.curveType === "chordal" ? 0.5 : 0.25;
      let D = Math.pow(g.distanceToSquared(w), R), O = Math.pow(w.distanceToSquared(T), R), U = Math.pow(T.distanceToSquared(_), R);
      O < 1e-4 && (O = 1), D < 1e-4 && (D = O), U < 1e-4 && (U = O), KA.initNonuniformCatmullRom(g.x, w.x, T.x, _.x, D, O, U), $A.initNonuniformCatmullRom(g.y, w.y, T.y, _.y, D, O, U), eD.initNonuniformCatmullRom(g.z, w.z, T.z, _.z, D, O, U);
    } else
      this.curveType === "catmullrom" && (KA.initCatmullRom(g.x, w.x, T.x, _.x, this.tension), $A.initCatmullRom(g.y, w.y, T.y, _.y, this.tension), eD.initCatmullRom(g.z, w.z, T.z, _.z, this.tension));
    return r.set(
      KA.calc(p),
      $A.calc(p),
      eD.calc(p)
    ), r;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, r = this.points.length; t < r; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(new ge().fromArray(i));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
function RU(a, e, t, r, i) {
  const s = (r - e) * 0.5, l = (i - t) * 0.5, d = a * a, p = a * d;
  return (2 * t - 2 * r + s + l) * p + (-3 * t + 3 * r - 2 * s - l) * d + s * a + t;
}
function AW(a, e) {
  const t = 1 - a;
  return t * t * e;
}
function DW(a, e) {
  return 2 * (1 - a) * a * e;
}
function LW(a, e) {
  return a * a * e;
}
function wM(a, e, t, r) {
  return AW(a, e) + DW(a, t) + LW(a, r);
}
function PW(a, e) {
  const t = 1 - a;
  return t * t * t * e;
}
function OW(a, e) {
  const t = 1 - a;
  return 3 * t * t * a * e;
}
function UW(a, e) {
  return 3 * (1 - a) * a * a * e;
}
function zW(a, e) {
  return a * a * a * e;
}
function bM(a, e, t, r, i) {
  return PW(a, e) + OW(a, t) + UW(a, r) + zW(a, i);
}
class rL extends dg {
  constructor(e = new zt(), t = new zt(), r = new zt(), i = new zt()) {
    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = r, this.v3 = i;
  }
  getPoint(e, t = new zt()) {
    const r = t, i = this.v0, s = this.v1, l = this.v2, d = this.v3;
    return r.set(
      bM(e, i.x, s.x, l.x, d.x),
      bM(e, i.y, s.y, l.y, d.y)
    ), r;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class ek extends dg {
  constructor(e = new ge(), t = new ge(), r = new ge(), i = new ge()) {
    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = r, this.v3 = i;
  }
  getPoint(e, t = new ge()) {
    const r = t, i = this.v0, s = this.v1, l = this.v2, d = this.v3;
    return r.set(
      bM(e, i.x, s.x, l.x, d.x),
      bM(e, i.y, s.y, l.y, d.y),
      bM(e, i.z, s.z, l.z, d.z)
    ), r;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class QC extends dg {
  constructor(e = new zt(), t = new zt()) {
    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new zt()) {
    const r = t;
    return e === 1 ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)), r;
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t) {
    const r = t || new zt();
    return r.copy(this.v2).sub(this.v1).normalize(), r;
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class tk extends dg {
  constructor(e = new ge(), t = new ge()) {
    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new ge()) {
    const r = t;
    return e === 1 ? r.copy(this.v2) : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)), r;
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class iL extends dg {
  constructor(e = new zt(), t = new zt(), r = new zt()) {
    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = r;
  }
  getPoint(e, t = new zt()) {
    const r = t, i = this.v0, s = this.v1, l = this.v2;
    return r.set(
      wM(e, i.x, s.x, l.x),
      wM(e, i.y, s.y, l.y)
    ), r;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class aL extends dg {
  constructor(e = new ge(), t = new ge(), r = new ge()) {
    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = r;
  }
  getPoint(e, t = new ge()) {
    const r = t, i = this.v0, s = this.v1, l = this.v2;
    return r.set(
      wM(e, i.x, s.x, l.x),
      wM(e, i.y, s.y, l.y),
      wM(e, i.z, s.z, l.z)
    ), r;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class sL extends dg {
  constructor(e = []) {
    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
  }
  getPoint(e, t = new zt()) {
    const r = t, i = this.points, s = (i.length - 1) * e, l = Math.floor(s), d = s - l, p = i[l === 0 ? l : l - 1], g = i[l], _ = i[l > i.length - 2 ? i.length - 1 : l + 1], w = i[l > i.length - 3 ? i.length - 1 : l + 2];
    return r.set(
      RU(d, p.x, g.x, _.x, w.x),
      RU(d, p.y, g.y, _.y, w.y)
    ), r;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, r = this.points.length; t < r; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(new zt().fromArray(i));
    }
    return this;
  }
}
var oL = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve: KF,
  CatmullRomCurve3: $F,
  CubicBezierCurve: rL,
  CubicBezierCurve3: ek,
  EllipseCurve: qC,
  LineCurve: QC,
  LineCurve3: tk,
  QuadraticBezierCurve: iL,
  QuadraticBezierCurve3: aL,
  SplineCurve: sL
});
class nk extends dg {
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
    e.equals(t) || this.curves.push(new QC(t, e));
  }
  getPoint(e, t) {
    const r = e * this.getLength(), i = this.getCurveLengths();
    let s = 0;
    for (; s < i.length; ) {
      if (i[s] >= r) {
        const l = i[s] - r, d = this.curves[s], p = d.getLength(), g = p === 0 ? 0 : 1 - l / p;
        return d.getPointAt(g, t);
      }
      s++;
    }
    return null;
  }
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let r = 0, i = this.curves.length; r < i; r++)
      t += this.curves[r].getLength(), e.push(t);
    return this.cacheLengths = e, e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let r = 0; r <= e; r++)
      t.push(this.getPoint(r / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let r;
    for (let i = 0, s = this.curves; i < s.length; i++) {
      const l = s[i], d = l.isEllipseCurve ? e * 2 : l.isLineCurve || l.isLineCurve3 ? 1 : l.isSplineCurve ? e * l.points.length : e, p = l.getPoints(d);
      for (let g = 0; g < p.length; g++) {
        const _ = p[g];
        r && r.equals(_) || (t.push(_), r = _);
      }
    }
    return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
  }
  copy(e) {
    super.copy(e), this.curves = [];
    for (let t = 0, r = e.curves.length; t < r; t++) {
      const i = e.curves[t];
      this.curves.push(i.clone());
    }
    return this.autoClose = e.autoClose, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.autoClose = this.autoClose, e.curves = [];
    for (let t = 0, r = this.curves.length; t < r; t++) {
      const i = this.curves[t];
      e.curves.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
    for (let t = 0, r = e.curves.length; t < r; t++) {
      const i = e.curves[t];
      this.curves.push(new oL[i.type]().fromJSON(i));
    }
    return this;
  }
}
class FM extends nk {
  constructor(e) {
    super(), this.type = "Path", this.currentPoint = new zt(), e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, r = e.length; t < r; t++)
      this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const r = new QC(this.currentPoint.clone(), new zt(e, t));
    return this.curves.push(r), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, r, i) {
    const s = new iL(
      this.currentPoint.clone(),
      new zt(e, t),
      new zt(r, i)
    );
    return this.curves.push(s), this.currentPoint.set(r, i), this;
  }
  bezierCurveTo(e, t, r, i, s, l) {
    const d = new rL(
      this.currentPoint.clone(),
      new zt(e, t),
      new zt(r, i),
      new zt(s, l)
    );
    return this.curves.push(d), this.currentPoint.set(s, l), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e), r = new sL(t);
    return this.curves.push(r), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, r, i, s, l) {
    const d = this.currentPoint.x, p = this.currentPoint.y;
    return this.absarc(
      e + d,
      t + p,
      r,
      i,
      s,
      l
    ), this;
  }
  absarc(e, t, r, i, s, l) {
    return this.absellipse(e, t, r, r, i, s, l), this;
  }
  ellipse(e, t, r, i, s, l, d, p) {
    const g = this.currentPoint.x, _ = this.currentPoint.y;
    return this.absellipse(e + g, t + _, r, i, s, l, d, p), this;
  }
  absellipse(e, t, r, i, s, l, d, p) {
    const g = new qC(e, t, r, i, s, l, d, p);
    if (this.curves.length > 0) {
      const w = g.getPoint(0);
      w.equals(this.currentPoint) || this.lineTo(w.x, w.y);
    }
    this.curves.push(g);
    const _ = g.getPoint(1);
    return this.currentPoint.copy(_), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.currentPoint = this.currentPoint.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class Q_ extends oi {
  constructor(e = [new zt(0, -0.5), new zt(0.5, 0), new zt(0, 0.5)], t = 12, r = 0, i = Math.PI * 2) {
    super(), this.type = "LatheGeometry", this.parameters = {
      points: e,
      segments: t,
      phiStart: r,
      phiLength: i
    }, t = Math.floor(t), i = Zu(i, 0, Math.PI * 2);
    const s = [], l = [], d = [], p = [], g = [], _ = 1 / t, w = new ge(), T = new zt(), R = new ge(), D = new ge(), O = new ge();
    let U = 0, H = 0;
    for (let I = 0; I <= e.length - 1; I++)
      switch (I) {
        case 0:
          U = e[I + 1].x - e[I].x, H = e[I + 1].y - e[I].y, R.x = H * 1, R.y = -U, R.z = H * 0, O.copy(R), R.normalize(), p.push(R.x, R.y, R.z);
          break;
        case e.length - 1:
          p.push(O.x, O.y, O.z);
          break;
        default:
          U = e[I + 1].x - e[I].x, H = e[I + 1].y - e[I].y, R.x = H * 1, R.y = -U, R.z = H * 0, D.copy(R), R.x += O.x, R.y += O.y, R.z += O.z, R.normalize(), p.push(R.x, R.y, R.z), O.copy(D);
      }
    for (let I = 0; I <= t; I++) {
      const G = r + I * _ * i, B = Math.sin(G), Q = Math.cos(G);
      for (let K = 0; K <= e.length - 1; K++) {
        w.x = e[K].x * B, w.y = e[K].y, w.z = e[K].x * Q, l.push(w.x, w.y, w.z), T.x = I / t, T.y = K / (e.length - 1), d.push(T.x, T.y);
        const te = p[3 * K + 0] * B, Y = p[3 * K + 1], re = p[3 * K + 0] * Q;
        g.push(te, Y, re);
      }
    }
    for (let I = 0; I < t; I++)
      for (let G = 0; G < e.length - 1; G++) {
        const B = G + I * e.length, Q = B, K = B + e.length, te = B + e.length + 1, Y = B + 1;
        s.push(Q, K, Y), s.push(te, Y, K);
      }
    this.setIndex(s), this.setAttribute("position", new sr(l, 3)), this.setAttribute("uv", new sr(d, 2)), this.setAttribute("normal", new sr(g, 3));
  }
  static fromJSON(e) {
    return new Q_(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class $w extends Q_ {
  constructor(e = 1, t = 1, r = 4, i = 8) {
    const s = new FM();
    s.absarc(0, -t / 2, e, Math.PI * 1.5, 0), s.absarc(0, t / 2, e, 0, Math.PI * 0.5), super(s.getPoints(r), i), this.type = "CapsuleGeometry", this.parameters = {
      radius: e,
      height: t,
      capSegments: r,
      radialSegments: i
    };
  }
  static fromJSON(e) {
    return new $w(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class eb extends oi {
  constructor(e = 1, t = 8, r = 0, i = Math.PI * 2) {
    super(), this.type = "CircleGeometry", this.parameters = {
      radius: e,
      segments: t,
      thetaStart: r,
      thetaLength: i
    }, t = Math.max(3, t);
    const s = [], l = [], d = [], p = [], g = new ge(), _ = new zt();
    l.push(0, 0, 0), d.push(0, 0, 1), p.push(0.5, 0.5);
    for (let w = 0, T = 3; w <= t; w++, T += 3) {
      const R = r + w / t * i;
      g.x = e * Math.cos(R), g.y = e * Math.sin(R), l.push(g.x, g.y, g.z), d.push(0, 0, 1), _.x = (l[T] / e + 1) / 2, _.y = (l[T + 1] / e + 1) / 2, p.push(_.x, _.y);
    }
    for (let w = 1; w <= t; w++)
      s.push(w, w + 1, 0);
    this.setIndex(s), this.setAttribute("position", new sr(l, 3)), this.setAttribute("normal", new sr(d, 3)), this.setAttribute("uv", new sr(p, 2));
  }
  static fromJSON(e) {
    return new eb(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class Ko extends oi {
  constructor(e = 1, t = 1, r = 1, i = 8, s = 1, l = !1, d = 0, p = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: e,
      radiusBottom: t,
      height: r,
      radialSegments: i,
      heightSegments: s,
      openEnded: l,
      thetaStart: d,
      thetaLength: p
    };
    const g = this;
    i = Math.floor(i), s = Math.floor(s);
    const _ = [], w = [], T = [], R = [];
    let D = 0;
    const O = [], U = r / 2;
    let H = 0;
    I(), l === !1 && (e > 0 && G(!0), t > 0 && G(!1)), this.setIndex(_), this.setAttribute("position", new sr(w, 3)), this.setAttribute("normal", new sr(T, 3)), this.setAttribute("uv", new sr(R, 2));
    function I() {
      const B = new ge(), Q = new ge();
      let K = 0;
      const te = (t - e) / r;
      for (let Y = 0; Y <= s; Y++) {
        const re = [], se = Y / s, ce = se * (t - e) + e;
        for (let ue = 0; ue <= i; ue++) {
          const Me = ue / i, me = Me * p + d, De = Math.sin(me), Re = Math.cos(me);
          Q.x = ce * De, Q.y = -se * r + U, Q.z = ce * Re, w.push(Q.x, Q.y, Q.z), B.set(De, te, Re).normalize(), T.push(B.x, B.y, B.z), R.push(Me, 1 - se), re.push(D++);
        }
        O.push(re);
      }
      for (let Y = 0; Y < i; Y++)
        for (let re = 0; re < s; re++) {
          const se = O[re][Y], ce = O[re + 1][Y], ue = O[re + 1][Y + 1], Me = O[re][Y + 1];
          _.push(se, ce, Me), _.push(ce, ue, Me), K += 6;
        }
      g.addGroup(H, K, 0), H += K;
    }
    function G(B) {
      const Q = D, K = new zt(), te = new ge();
      let Y = 0;
      const re = B === !0 ? e : t, se = B === !0 ? 1 : -1;
      for (let ue = 1; ue <= i; ue++)
        w.push(0, U * se, 0), T.push(0, se, 0), R.push(0.5, 0.5), D++;
      const ce = D;
      for (let ue = 0; ue <= i; ue++) {
        const me = ue / i * p + d, De = Math.cos(me), Re = Math.sin(me);
        te.x = re * Re, te.y = U * se, te.z = re * De, w.push(te.x, te.y, te.z), T.push(0, se, 0), K.x = De * 0.5 + 0.5, K.y = Re * 0.5 * se + 0.5, R.push(K.x, K.y), D++;
      }
      for (let ue = 0; ue < i; ue++) {
        const Me = Q + ue, me = ce + ue;
        B === !0 ? _.push(me, me + 1, Me) : _.push(me + 1, me, Me), Y += 3;
      }
      g.addGroup(H, Y, B === !0 ? 1 : 2), H += Y;
    }
  }
  static fromJSON(e) {
    return new Ko(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class tb extends Ko {
  constructor(e = 1, t = 1, r = 8, i = 1, s = !1, l = 0, d = Math.PI * 2) {
    super(0, e, t, r, i, s, l, d), this.type = "ConeGeometry", this.parameters = {
      radius: e,
      height: t,
      radialSegments: r,
      heightSegments: i,
      openEnded: s,
      thetaStart: l,
      thetaLength: d
    };
  }
  static fromJSON(e) {
    return new tb(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class gy extends oi {
  constructor(e = [], t = [], r = 1, i = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = {
      vertices: e,
      indices: t,
      radius: r,
      detail: i
    };
    const s = [], l = [];
    d(i), g(r), _(), this.setAttribute("position", new sr(s, 3)), this.setAttribute("normal", new sr(s.slice(), 3)), this.setAttribute("uv", new sr(l, 2)), i === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function d(I) {
      const G = new ge(), B = new ge(), Q = new ge();
      for (let K = 0; K < t.length; K += 3)
        R(t[K + 0], G), R(t[K + 1], B), R(t[K + 2], Q), p(G, B, Q, I);
    }
    function p(I, G, B, Q) {
      const K = Q + 1, te = [];
      for (let Y = 0; Y <= K; Y++) {
        te[Y] = [];
        const re = I.clone().lerp(B, Y / K), se = G.clone().lerp(B, Y / K), ce = K - Y;
        for (let ue = 0; ue <= ce; ue++)
          ue === 0 && Y === K ? te[Y][ue] = re : te[Y][ue] = re.clone().lerp(se, ue / ce);
      }
      for (let Y = 0; Y < K; Y++)
        for (let re = 0; re < 2 * (K - Y) - 1; re++) {
          const se = Math.floor(re / 2);
          re % 2 === 0 ? (T(te[Y][se + 1]), T(te[Y + 1][se]), T(te[Y][se])) : (T(te[Y][se + 1]), T(te[Y + 1][se + 1]), T(te[Y + 1][se]));
        }
    }
    function g(I) {
      const G = new ge();
      for (let B = 0; B < s.length; B += 3)
        G.x = s[B + 0], G.y = s[B + 1], G.z = s[B + 2], G.normalize().multiplyScalar(I), s[B + 0] = G.x, s[B + 1] = G.y, s[B + 2] = G.z;
    }
    function _() {
      const I = new ge();
      for (let G = 0; G < s.length; G += 3) {
        I.x = s[G + 0], I.y = s[G + 1], I.z = s[G + 2];
        const B = U(I) / 2 / Math.PI + 0.5, Q = H(I) / Math.PI + 0.5;
        l.push(B, 1 - Q);
      }
      D(), w();
    }
    function w() {
      for (let I = 0; I < l.length; I += 6) {
        const G = l[I + 0], B = l[I + 2], Q = l[I + 4], K = Math.max(G, B, Q), te = Math.min(G, B, Q);
        K > 0.9 && te < 0.1 && (G < 0.2 && (l[I + 0] += 1), B < 0.2 && (l[I + 2] += 1), Q < 0.2 && (l[I + 4] += 1));
      }
    }
    function T(I) {
      s.push(I.x, I.y, I.z);
    }
    function R(I, G) {
      const B = I * 3;
      G.x = e[B + 0], G.y = e[B + 1], G.z = e[B + 2];
    }
    function D() {
      const I = new ge(), G = new ge(), B = new ge(), Q = new ge(), K = new zt(), te = new zt(), Y = new zt();
      for (let re = 0, se = 0; re < s.length; re += 9, se += 6) {
        I.set(s[re + 0], s[re + 1], s[re + 2]), G.set(s[re + 3], s[re + 4], s[re + 5]), B.set(s[re + 6], s[re + 7], s[re + 8]), K.set(l[se + 0], l[se + 1]), te.set(l[se + 2], l[se + 3]), Y.set(l[se + 4], l[se + 5]), Q.copy(I).add(G).add(B).divideScalar(3);
        const ce = U(Q);
        O(K, se + 0, I, ce), O(te, se + 2, G, ce), O(Y, se + 4, B, ce);
      }
    }
    function O(I, G, B, Q) {
      Q < 0 && I.x === 1 && (l[G] = I.x - 1), B.x === 0 && B.z === 0 && (l[G] = Q / 2 / Math.PI + 0.5);
    }
    function U(I) {
      return Math.atan2(I.z, -I.x);
    }
    function H(I) {
      return Math.atan2(-I.y, Math.sqrt(I.x * I.x + I.z * I.z));
    }
  }
  static fromJSON(e) {
    return new gy(e.vertices, e.indices, e.radius, e.details);
  }
}
class nb extends gy {
  constructor(e = 1, t = 0) {
    const r = (1 + Math.sqrt(5)) / 2, i = 1 / r, s = [
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      0,
      -i,
      -r,
      0,
      -i,
      r,
      0,
      i,
      -r,
      0,
      i,
      r,
      -i,
      -r,
      0,
      -i,
      r,
      0,
      i,
      -r,
      0,
      i,
      r,
      0,
      -r,
      0,
      -i,
      r,
      0,
      -i,
      -r,
      0,
      i,
      r,
      0,
      i
    ], l = [
      3,
      11,
      7,
      3,
      7,
      15,
      3,
      15,
      13,
      7,
      19,
      17,
      7,
      17,
      6,
      7,
      6,
      15,
      17,
      4,
      8,
      17,
      8,
      10,
      17,
      10,
      6,
      8,
      0,
      16,
      8,
      16,
      2,
      8,
      2,
      10,
      0,
      12,
      1,
      0,
      1,
      18,
      0,
      18,
      16,
      6,
      10,
      2,
      6,
      2,
      13,
      6,
      13,
      15,
      2,
      16,
      18,
      2,
      18,
      3,
      2,
      3,
      13,
      18,
      1,
      9,
      18,
      9,
      11,
      18,
      11,
      3,
      4,
      14,
      12,
      4,
      12,
      0,
      4,
      0,
      8,
      11,
      9,
      5,
      11,
      5,
      19,
      11,
      19,
      7,
      19,
      5,
      14,
      19,
      14,
      4,
      19,
      4,
      17,
      1,
      12,
      14,
      1,
      14,
      5,
      1,
      5,
      9
    ];
    super(s, l, e, t), this.type = "DodecahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new nb(e.radius, e.detail);
  }
}
const N2 = /* @__PURE__ */ new ge(), F2 = /* @__PURE__ */ new ge(), tD = /* @__PURE__ */ new ge(), k2 = /* @__PURE__ */ new wm();
class rk extends oi {
  constructor(e = null, t = 1) {
    if (super(), this.type = "EdgesGeometry", this.parameters = {
      geometry: e,
      thresholdAngle: t
    }, e !== null) {
      const i = Math.pow(10, 4), s = Math.cos(H_ * t), l = e.getIndex(), d = e.getAttribute("position"), p = l ? l.count : d.count, g = [0, 0, 0], _ = ["a", "b", "c"], w = new Array(3), T = {}, R = [];
      for (let D = 0; D < p; D += 3) {
        l ? (g[0] = l.getX(D), g[1] = l.getX(D + 1), g[2] = l.getX(D + 2)) : (g[0] = D, g[1] = D + 1, g[2] = D + 2);
        const { a: O, b: U, c: H } = k2;
        if (O.fromBufferAttribute(d, g[0]), U.fromBufferAttribute(d, g[1]), H.fromBufferAttribute(d, g[2]), k2.getNormal(tD), w[0] = `${Math.round(O.x * i)},${Math.round(O.y * i)},${Math.round(O.z * i)}`, w[1] = `${Math.round(U.x * i)},${Math.round(U.y * i)},${Math.round(U.z * i)}`, w[2] = `${Math.round(H.x * i)},${Math.round(H.y * i)},${Math.round(H.z * i)}`, !(w[0] === w[1] || w[1] === w[2] || w[2] === w[0]))
          for (let I = 0; I < 3; I++) {
            const G = (I + 1) % 3, B = w[I], Q = w[G], K = k2[_[I]], te = k2[_[G]], Y = `${B}_${Q}`, re = `${Q}_${B}`;
            re in T && T[re] ? (tD.dot(T[re].normal) <= s && (R.push(K.x, K.y, K.z), R.push(te.x, te.y, te.z)), T[re] = null) : Y in T || (T[Y] = {
              index0: g[I],
              index1: g[G],
              normal: tD.clone()
            });
          }
      }
      for (const D in T)
        if (T[D]) {
          const { index0: O, index1: U } = T[D];
          N2.fromBufferAttribute(d, O), F2.fromBufferAttribute(d, U), R.push(N2.x, N2.y, N2.z), R.push(F2.x, F2.y, F2.z);
        }
      this.setAttribute("position", new sr(R, 3));
    }
  }
}
class W_ extends FM {
  constructor(e) {
    super(e), this.uuid = Em(), this.type = "Shape", this.holes = [];
  }
  getPointsHoles(e) {
    const t = [];
    for (let r = 0, i = this.holes.length; r < i; r++)
      t[r] = this.holes[r].getPoints(e);
    return t;
  }
  extractPoints(e) {
    return {
      shape: this.getPoints(e),
      holes: this.getPointsHoles(e)
    };
  }
  copy(e) {
    super.copy(e), this.holes = [];
    for (let t = 0, r = e.holes.length; t < r; t++) {
      const i = e.holes[t];
      this.holes.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.uuid = this.uuid, e.holes = [];
    for (let t = 0, r = this.holes.length; t < r; t++) {
      const i = this.holes[t];
      e.holes.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
    for (let t = 0, r = e.holes.length; t < r; t++) {
      const i = e.holes[t];
      this.holes.push(new FM().fromJSON(i));
    }
    return this;
  }
}
const NW = {
  triangulate: function(a, e, t = 2) {
    const r = e && e.length, i = r ? e[0] * t : a.length;
    let s = ik(a, 0, i, t, !0);
    const l = [];
    if (!s || s.next === s.prev)
      return l;
    let d, p, g, _, w, T, R;
    if (r && (s = HW(a, e, s, t)), a.length > 80 * t) {
      d = g = a[0], p = _ = a[1];
      for (let D = t; D < i; D += t)
        w = a[D], T = a[D + 1], w < d && (d = w), T < p && (p = T), w > g && (g = w), T > _ && (_ = T);
      R = Math.max(g - d, _ - p), R = R !== 0 ? 1 / R : 0;
    }
    return kM(s, l, t, d, p, R), l;
  }
};
function ik(a, e, t, r, i) {
  let s, l;
  if (i === KW(a, e, t, r) > 0)
    for (s = e; s < t; s += r)
      l = AU(s, a[s], a[s + 1], l);
  else
    for (s = t - r; s >= e; s -= r)
      l = AU(s, a[s], a[s + 1], l);
  return l && ZC(l, l.next) && (BM(l), l = l.next), l;
}
function i1(a, e) {
  if (!a)
    return a;
  e || (e = a);
  let t = a, r;
  do
    if (r = !1, !t.steiner && (ZC(t, t.next) || au(t.prev, t, t.next) === 0)) {
      if (BM(t), t = e = t.prev, t === t.next)
        break;
      r = !0;
    } else
      t = t.next;
  while (r || t !== e);
  return e;
}
function kM(a, e, t, r, i, s, l) {
  if (!a)
    return;
  !l && s && YW(a, r, i, s);
  let d = a, p, g;
  for (; a.prev !== a.next; ) {
    if (p = a.prev, g = a.next, s ? kW(a, r, i, s) : FW(a)) {
      e.push(p.i / t), e.push(a.i / t), e.push(g.i / t), BM(a), a = g.next, d = g.next;
      continue;
    }
    if (a = g, a === d) {
      l ? l === 1 ? (a = IW(i1(a), e, t), kM(a, e, t, r, i, s, 2)) : l === 2 && BW(a, e, t, r, i, s) : kM(i1(a), e, t, r, i, s, 1);
      break;
    }
  }
}
function FW(a) {
  const e = a.prev, t = a, r = a.next;
  if (au(e, t, r) >= 0)
    return !1;
  let i = a.next.next;
  for (; i !== a.prev; ) {
    if (Yw(e.x, e.y, t.x, t.y, r.x, r.y, i.x, i.y) && au(i.prev, i, i.next) >= 0)
      return !1;
    i = i.next;
  }
  return !0;
}
function kW(a, e, t, r) {
  const i = a.prev, s = a, l = a.next;
  if (au(i, s, l) >= 0)
    return !1;
  const d = i.x < s.x ? i.x < l.x ? i.x : l.x : s.x < l.x ? s.x : l.x, p = i.y < s.y ? i.y < l.y ? i.y : l.y : s.y < l.y ? s.y : l.y, g = i.x > s.x ? i.x > l.x ? i.x : l.x : s.x > l.x ? s.x : l.x, _ = i.y > s.y ? i.y > l.y ? i.y : l.y : s.y > l.y ? s.y : l.y, w = x3(d, p, e, t, r), T = x3(g, _, e, t, r);
  let R = a.prevZ, D = a.nextZ;
  for (; R && R.z >= w && D && D.z <= T; ) {
    if (R !== a.prev && R !== a.next && Yw(i.x, i.y, s.x, s.y, l.x, l.y, R.x, R.y) && au(R.prev, R, R.next) >= 0 || (R = R.prevZ, D !== a.prev && D !== a.next && Yw(i.x, i.y, s.x, s.y, l.x, l.y, D.x, D.y) && au(D.prev, D, D.next) >= 0))
      return !1;
    D = D.nextZ;
  }
  for (; R && R.z >= w; ) {
    if (R !== a.prev && R !== a.next && Yw(i.x, i.y, s.x, s.y, l.x, l.y, R.x, R.y) && au(R.prev, R, R.next) >= 0)
      return !1;
    R = R.prevZ;
  }
  for (; D && D.z <= T; ) {
    if (D !== a.prev && D !== a.next && Yw(i.x, i.y, s.x, s.y, l.x, l.y, D.x, D.y) && au(D.prev, D, D.next) >= 0)
      return !1;
    D = D.nextZ;
  }
  return !0;
}
function IW(a, e, t) {
  let r = a;
  do {
    const i = r.prev, s = r.next.next;
    !ZC(i, s) && ak(i, r, r.next, s) && IM(i, s) && IM(s, i) && (e.push(i.i / t), e.push(r.i / t), e.push(s.i / t), BM(r), BM(r.next), r = a = s), r = r.next;
  } while (r !== a);
  return i1(r);
}
function BW(a, e, t, r, i, s) {
  let l = a;
  do {
    let d = l.next.next;
    for (; d !== l.prev; ) {
      if (l.i !== d.i && QW(l, d)) {
        let p = sk(l, d);
        l = i1(l, l.next), p = i1(p, p.next), kM(l, e, t, r, i, s), kM(p, e, t, r, i, s);
        return;
      }
      d = d.next;
    }
    l = l.next;
  } while (l !== a);
}
function HW(a, e, t, r) {
  const i = [];
  let s, l, d, p, g;
  for (s = 0, l = e.length; s < l; s++)
    d = e[s] * r, p = s < l - 1 ? e[s + 1] * r : a.length, g = ik(a, d, p, r, !1), g === g.next && (g.steiner = !0), i.push(qW(g));
  for (i.sort(VW), s = 0; s < i.length; s++)
    GW(i[s], t), t = i1(t, t.next);
  return t;
}
function VW(a, e) {
  return a.x - e.x;
}
function GW(a, e) {
  if (e = WW(a, e), e) {
    const t = sk(e, a);
    i1(e, e.next), i1(t, t.next);
  }
}
function WW(a, e) {
  let t = e;
  const r = a.x, i = a.y;
  let s = -1 / 0, l;
  do {
    if (i <= t.y && i >= t.next.y && t.next.y !== t.y) {
      const T = t.x + (i - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
      if (T <= r && T > s) {
        if (s = T, T === r) {
          if (i === t.y)
            return t;
          if (i === t.next.y)
            return t.next;
        }
        l = t.x < t.next.x ? t : t.next;
      }
    }
    t = t.next;
  } while (t !== e);
  if (!l)
    return null;
  if (r === s)
    return l;
  const d = l, p = l.x, g = l.y;
  let _ = 1 / 0, w;
  t = l;
  do
    r >= t.x && t.x >= p && r !== t.x && Yw(i < g ? r : s, i, p, g, i < g ? s : r, i, t.x, t.y) && (w = Math.abs(i - t.y) / (r - t.x), IM(t, a) && (w < _ || w === _ && (t.x > l.x || t.x === l.x && jW(l, t))) && (l = t, _ = w)), t = t.next;
  while (t !== d);
  return l;
}
function jW(a, e) {
  return au(a.prev, a, e.prev) < 0 && au(e.next, a, a.next) < 0;
}
function YW(a, e, t, r) {
  let i = a;
  do
    i.z === null && (i.z = x3(i.x, i.y, e, t, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;
  while (i !== a);
  i.prevZ.nextZ = null, i.prevZ = null, XW(i);
}
function XW(a) {
  let e, t, r, i, s, l, d, p, g = 1;
  do {
    for (t = a, a = null, s = null, l = 0; t; ) {
      for (l++, r = t, d = 0, e = 0; e < g && (d++, r = r.nextZ, !!r); e++)
        ;
      for (p = g; d > 0 || p > 0 && r; )
        d !== 0 && (p === 0 || !r || t.z <= r.z) ? (i = t, t = t.nextZ, d--) : (i = r, r = r.nextZ, p--), s ? s.nextZ = i : a = i, i.prevZ = s, s = i;
      t = r;
    }
    s.nextZ = null, g *= 2;
  } while (l > 1);
  return a;
}
function x3(a, e, t, r, i) {
  return a = 32767 * (a - t) * i, e = 32767 * (e - r) * i, a = (a | a << 8) & 16711935, a = (a | a << 4) & 252645135, a = (a | a << 2) & 858993459, a = (a | a << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, a | e << 1;
}
function qW(a) {
  let e = a, t = a;
  do
    (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
  while (e !== a);
  return t;
}
function Yw(a, e, t, r, i, s, l, d) {
  return (i - l) * (e - d) - (a - l) * (s - d) >= 0 && (a - l) * (r - d) - (t - l) * (e - d) >= 0 && (t - l) * (s - d) - (i - l) * (r - d) >= 0;
}
function QW(a, e) {
  return a.next.i !== e.i && a.prev.i !== e.i && !ZW(a, e) && (IM(a, e) && IM(e, a) && JW(a, e) && (au(a.prev, a, e.prev) || au(a, e.prev, e)) || ZC(a, e) && au(a.prev, a, a.next) > 0 && au(e.prev, e, e.next) > 0);
}
function au(a, e, t) {
  return (e.y - a.y) * (t.x - e.x) - (e.x - a.x) * (t.y - e.y);
}
function ZC(a, e) {
  return a.x === e.x && a.y === e.y;
}
function ak(a, e, t, r) {
  const i = B2(au(a, e, t)), s = B2(au(a, e, r)), l = B2(au(t, r, a)), d = B2(au(t, r, e));
  return !!(i !== s && l !== d || i === 0 && I2(a, t, e) || s === 0 && I2(a, r, e) || l === 0 && I2(t, a, r) || d === 0 && I2(t, e, r));
}
function I2(a, e, t) {
  return e.x <= Math.max(a.x, t.x) && e.x >= Math.min(a.x, t.x) && e.y <= Math.max(a.y, t.y) && e.y >= Math.min(a.y, t.y);
}
function B2(a) {
  return a > 0 ? 1 : a < 0 ? -1 : 0;
}
function ZW(a, e) {
  let t = a;
  do {
    if (t.i !== a.i && t.next.i !== a.i && t.i !== e.i && t.next.i !== e.i && ak(t, t.next, a, e))
      return !0;
    t = t.next;
  } while (t !== a);
  return !1;
}
function IM(a, e) {
  return au(a.prev, a, a.next) < 0 ? au(a, e, a.next) >= 0 && au(a, a.prev, e) >= 0 : au(a, e, a.prev) < 0 || au(a, a.next, e) < 0;
}
function JW(a, e) {
  let t = a, r = !1;
  const i = (a.x + e.x) / 2, s = (a.y + e.y) / 2;
  do
    t.y > s != t.next.y > s && t.next.y !== t.y && i < (t.next.x - t.x) * (s - t.y) / (t.next.y - t.y) + t.x && (r = !r), t = t.next;
  while (t !== a);
  return r;
}
function sk(a, e) {
  const t = new _3(a.i, a.x, a.y), r = new _3(e.i, e.x, e.y), i = a.next, s = e.prev;
  return a.next = e, e.prev = a, t.next = i, i.prev = t, r.next = t, t.prev = r, s.next = r, r.prev = s, r;
}
function AU(a, e, t, r) {
  const i = new _3(a, e, t);
  return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i;
}
function BM(a) {
  a.next.prev = a.prev, a.prev.next = a.next, a.prevZ && (a.prevZ.nextZ = a.nextZ), a.nextZ && (a.nextZ.prevZ = a.prevZ);
}
function _3(a, e, t) {
  this.i = a, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
function KW(a, e, t, r) {
  let i = 0;
  for (let s = e, l = t - r; s < t; s += r)
    i += (a[l] - a[s]) * (a[s + 1] + a[l + 1]), l = s;
  return i;
}
class hy {
  static area(e) {
    const t = e.length;
    let r = 0;
    for (let i = t - 1, s = 0; s < t; i = s++)
      r += e[i].x * e[s].y - e[s].x * e[i].y;
    return r * 0.5;
  }
  static isClockWise(e) {
    return hy.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const r = [], i = [], s = [];
    DU(e), LU(r, e);
    let l = e.length;
    t.forEach(DU);
    for (let p = 0; p < t.length; p++)
      i.push(l), l += t[p].length, LU(r, t[p]);
    const d = NW.triangulate(r, i);
    for (let p = 0; p < d.length; p += 3)
      s.push(d.slice(p, p + 3));
    return s;
  }
}
function DU(a) {
  const e = a.length;
  e > 2 && a[e - 1].equals(a[0]) && a.pop();
}
function LU(a, e) {
  for (let t = 0; t < e.length; t++)
    a.push(e[t].x), a.push(e[t].y);
}
class rb extends oi {
  constructor(e = new W_([new zt(0.5, 0.5), new zt(-0.5, 0.5), new zt(-0.5, -0.5), new zt(0.5, -0.5)]), t = {}) {
    super(), this.type = "ExtrudeGeometry", this.parameters = {
      shapes: e,
      options: t
    }, e = Array.isArray(e) ? e : [e];
    const r = this, i = [], s = [];
    for (let d = 0, p = e.length; d < p; d++) {
      const g = e[d];
      l(g);
    }
    this.setAttribute("position", new sr(i, 3)), this.setAttribute("uv", new sr(s, 2)), this.computeVertexNormals();
    function l(d) {
      const p = [], g = t.curveSegments !== void 0 ? t.curveSegments : 12, _ = t.steps !== void 0 ? t.steps : 1, w = t.depth !== void 0 ? t.depth : 1;
      let T = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0, R = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2, D = t.bevelSize !== void 0 ? t.bevelSize : R - 0.1, O = t.bevelOffset !== void 0 ? t.bevelOffset : 0, U = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const H = t.extrudePath, I = t.UVGenerator !== void 0 ? t.UVGenerator : $W;
      let G, B = !1, Q, K, te, Y;
      H && (G = H.getSpacedPoints(_), B = !0, T = !1, Q = H.computeFrenetFrames(_, !1), K = new ge(), te = new ge(), Y = new ge()), T || (U = 0, R = 0, D = 0, O = 0);
      const re = d.extractPoints(g);
      let se = re.shape;
      const ce = re.holes;
      if (!hy.isClockWise(se)) {
        se = se.reverse();
        for (let Ie = 0, qe = ce.length; Ie < qe; Ie++) {
          const dt = ce[Ie];
          hy.isClockWise(dt) && (ce[Ie] = dt.reverse());
        }
      }
      const Me = hy.triangulateShape(se, ce), me = se;
      for (let Ie = 0, qe = ce.length; Ie < qe; Ie++) {
        const dt = ce[Ie];
        se = se.concat(dt);
      }
      function De(Ie, qe, dt) {
        return qe || console.error("THREE.ExtrudeGeometry: vec does not exist"), qe.clone().multiplyScalar(dt).add(Ie);
      }
      const Re = se.length, He = Me.length;
      function ve(Ie, qe, dt) {
        let ht, xt, Vt;
        const yt = Ie.x - qe.x, Nt = Ie.y - qe.y, Zt = dt.x - Ie.x, Rt = dt.y - Ie.y, we = yt * yt + Nt * Nt, oe = yt * Rt - Nt * Zt;
        if (Math.abs(oe) > Number.EPSILON) {
          const Qe = Math.sqrt(we), ut = Math.sqrt(Zt * Zt + Rt * Rt), Ft = qe.x - Nt / Qe, Ot = qe.y + yt / Qe, Wt = dt.x - Rt / ut, it = dt.y + Zt / ut, an = ((Wt - Ft) * Rt - (it - Ot) * Zt) / (yt * Rt - Nt * Zt);
          ht = Ft + yt * an - Ie.x, xt = Ot + Nt * an - Ie.y;
          const Be = ht * ht + xt * xt;
          if (Be <= 2)
            return new zt(ht, xt);
          Vt = Math.sqrt(Be / 2);
        } else {
          let Qe = !1;
          yt > Number.EPSILON ? Zt > Number.EPSILON && (Qe = !0) : yt < -Number.EPSILON ? Zt < -Number.EPSILON && (Qe = !0) : Math.sign(Nt) === Math.sign(Rt) && (Qe = !0), Qe ? (ht = -Nt, xt = yt, Vt = Math.sqrt(we)) : (ht = yt, xt = Nt, Vt = Math.sqrt(we / 2));
        }
        return new zt(ht / Vt, xt / Vt);
      }
      const fe = [];
      for (let Ie = 0, qe = me.length, dt = qe - 1, ht = Ie + 1; Ie < qe; Ie++, dt++, ht++)
        dt === qe && (dt = 0), ht === qe && (ht = 0), fe[Ie] = ve(me[Ie], me[dt], me[ht]);
      const he = [];
      let ye, Ee = fe.concat();
      for (let Ie = 0, qe = ce.length; Ie < qe; Ie++) {
        const dt = ce[Ie];
        ye = [];
        for (let ht = 0, xt = dt.length, Vt = xt - 1, yt = ht + 1; ht < xt; ht++, Vt++, yt++)
          Vt === xt && (Vt = 0), yt === xt && (yt = 0), ye[ht] = ve(dt[ht], dt[Vt], dt[yt]);
        he.push(ye), Ee = Ee.concat(ye);
      }
      for (let Ie = 0; Ie < U; Ie++) {
        const qe = Ie / U, dt = R * Math.cos(qe * Math.PI / 2), ht = D * Math.sin(qe * Math.PI / 2) + O;
        for (let xt = 0, Vt = me.length; xt < Vt; xt++) {
          const yt = De(me[xt], fe[xt], ht);
          ct(yt.x, yt.y, -dt);
        }
        for (let xt = 0, Vt = ce.length; xt < Vt; xt++) {
          const yt = ce[xt];
          ye = he[xt];
          for (let Nt = 0, Zt = yt.length; Nt < Zt; Nt++) {
            const Rt = De(yt[Nt], ye[Nt], ht);
            ct(Rt.x, Rt.y, -dt);
          }
        }
      }
      const Ve = D + O;
      for (let Ie = 0; Ie < Re; Ie++) {
        const qe = T ? De(se[Ie], Ee[Ie], Ve) : se[Ie];
        B ? (te.copy(Q.normals[0]).multiplyScalar(qe.x), K.copy(Q.binormals[0]).multiplyScalar(qe.y), Y.copy(G[0]).add(te).add(K), ct(Y.x, Y.y, Y.z)) : ct(qe.x, qe.y, 0);
      }
      for (let Ie = 1; Ie <= _; Ie++)
        for (let qe = 0; qe < Re; qe++) {
          const dt = T ? De(se[qe], Ee[qe], Ve) : se[qe];
          B ? (te.copy(Q.normals[Ie]).multiplyScalar(dt.x), K.copy(Q.binormals[Ie]).multiplyScalar(dt.y), Y.copy(G[Ie]).add(te).add(K), ct(Y.x, Y.y, Y.z)) : ct(dt.x, dt.y, w / _ * Ie);
        }
      for (let Ie = U - 1; Ie >= 0; Ie--) {
        const qe = Ie / U, dt = R * Math.cos(qe * Math.PI / 2), ht = D * Math.sin(qe * Math.PI / 2) + O;
        for (let xt = 0, Vt = me.length; xt < Vt; xt++) {
          const yt = De(me[xt], fe[xt], ht);
          ct(yt.x, yt.y, w + dt);
        }
        for (let xt = 0, Vt = ce.length; xt < Vt; xt++) {
          const yt = ce[xt];
          ye = he[xt];
          for (let Nt = 0, Zt = yt.length; Nt < Zt; Nt++) {
            const Rt = De(yt[Nt], ye[Nt], ht);
            B ? ct(Rt.x, Rt.y + G[_ - 1].y, G[_ - 1].x + dt) : ct(Rt.x, Rt.y, w + dt);
          }
        }
      }
      Je(), rt();
      function Je() {
        const Ie = i.length / 3;
        if (T) {
          let qe = 0, dt = Re * qe;
          for (let ht = 0; ht < He; ht++) {
            const xt = Me[ht];
            tt(xt[2] + dt, xt[1] + dt, xt[0] + dt);
          }
          qe = _ + U * 2, dt = Re * qe;
          for (let ht = 0; ht < He; ht++) {
            const xt = Me[ht];
            tt(xt[0] + dt, xt[1] + dt, xt[2] + dt);
          }
        } else {
          for (let qe = 0; qe < He; qe++) {
            const dt = Me[qe];
            tt(dt[2], dt[1], dt[0]);
          }
          for (let qe = 0; qe < He; qe++) {
            const dt = Me[qe];
            tt(dt[0] + Re * _, dt[1] + Re * _, dt[2] + Re * _);
          }
        }
        r.addGroup(Ie, i.length / 3 - Ie, 0);
      }
      function rt() {
        const Ie = i.length / 3;
        let qe = 0;
        Ne(me, qe), qe += me.length;
        for (let dt = 0, ht = ce.length; dt < ht; dt++) {
          const xt = ce[dt];
          Ne(xt, qe), qe += xt.length;
        }
        r.addGroup(Ie, i.length / 3 - Ie, 1);
      }
      function Ne(Ie, qe) {
        let dt = Ie.length;
        for (; --dt >= 0; ) {
          const ht = dt;
          let xt = dt - 1;
          xt < 0 && (xt = Ie.length - 1);
          for (let Vt = 0, yt = _ + U * 2; Vt < yt; Vt++) {
            const Nt = Re * Vt, Zt = Re * (Vt + 1), Rt = qe + ht + Nt, we = qe + xt + Nt, oe = qe + xt + Zt, Qe = qe + ht + Zt;
            Tt(Rt, we, oe, Qe);
          }
        }
      }
      function ct(Ie, qe, dt) {
        p.push(Ie), p.push(qe), p.push(dt);
      }
      function tt(Ie, qe, dt) {
        gt(Ie), gt(qe), gt(dt);
        const ht = i.length / 3, xt = I.generateTopUV(r, i, ht - 3, ht - 2, ht - 1);
        ft(xt[0]), ft(xt[1]), ft(xt[2]);
      }
      function Tt(Ie, qe, dt, ht) {
        gt(Ie), gt(qe), gt(ht), gt(qe), gt(dt), gt(ht);
        const xt = i.length / 3, Vt = I.generateSideWallUV(r, i, xt - 6, xt - 3, xt - 2, xt - 1);
        ft(Vt[0]), ft(Vt[1]), ft(Vt[3]), ft(Vt[1]), ft(Vt[2]), ft(Vt[3]);
      }
      function gt(Ie) {
        i.push(p[Ie * 3 + 0]), i.push(p[Ie * 3 + 1]), i.push(p[Ie * 3 + 2]);
      }
      function ft(Ie) {
        s.push(Ie.x), s.push(Ie.y);
      }
    }
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes, r = this.parameters.options;
    return e7(t, r, e);
  }
  static fromJSON(e, t) {
    const r = [];
    for (let s = 0, l = e.shapes.length; s < l; s++) {
      const d = t[e.shapes[s]];
      r.push(d);
    }
    const i = e.options.extrudePath;
    return i !== void 0 && (e.options.extrudePath = new oL[i.type]().fromJSON(i)), new rb(r, e.options);
  }
}
const $W = {
  generateTopUV: function(a, e, t, r, i) {
    const s = e[t * 3], l = e[t * 3 + 1], d = e[r * 3], p = e[r * 3 + 1], g = e[i * 3], _ = e[i * 3 + 1];
    return [
      new zt(s, l),
      new zt(d, p),
      new zt(g, _)
    ];
  },
  generateSideWallUV: function(a, e, t, r, i, s) {
    const l = e[t * 3], d = e[t * 3 + 1], p = e[t * 3 + 2], g = e[r * 3], _ = e[r * 3 + 1], w = e[r * 3 + 2], T = e[i * 3], R = e[i * 3 + 1], D = e[i * 3 + 2], O = e[s * 3], U = e[s * 3 + 1], H = e[s * 3 + 2];
    return Math.abs(d - _) < Math.abs(l - g) ? [
      new zt(l, 1 - p),
      new zt(g, 1 - w),
      new zt(T, 1 - D),
      new zt(O, 1 - H)
    ] : [
      new zt(d, 1 - p),
      new zt(_, 1 - w),
      new zt(R, 1 - D),
      new zt(U, 1 - H)
    ];
  }
};
function e7(a, e, t) {
  if (t.shapes = [], Array.isArray(a))
    for (let r = 0, i = a.length; r < i; r++) {
      const s = a[r];
      t.shapes.push(s.uuid);
    }
  else
    t.shapes.push(a.uuid);
  return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t;
}
class ib extends gy {
  constructor(e = 1, t = 0) {
    const r = (1 + Math.sqrt(5)) / 2, i = [
      -1,
      r,
      0,
      1,
      r,
      0,
      -1,
      -r,
      0,
      1,
      -r,
      0,
      0,
      -1,
      r,
      0,
      1,
      r,
      0,
      -1,
      -r,
      0,
      1,
      -r,
      r,
      0,
      -1,
      r,
      0,
      1,
      -r,
      0,
      -1,
      -r,
      0,
      1
    ], s = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    super(i, s, e, t), this.type = "IcosahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new ib(e.radius, e.detail);
  }
}
class sg extends gy {
  constructor(e = 1, t = 0) {
    const r = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ], i = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(r, i, e, t), this.type = "OctahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new sg(e.radius, e.detail);
  }
}
class ab extends oi {
  constructor(e = 0.5, t = 1, r = 8, i = 1, s = 0, l = Math.PI * 2) {
    super(), this.type = "RingGeometry", this.parameters = {
      innerRadius: e,
      outerRadius: t,
      thetaSegments: r,
      phiSegments: i,
      thetaStart: s,
      thetaLength: l
    }, r = Math.max(3, r), i = Math.max(1, i);
    const d = [], p = [], g = [], _ = [];
    let w = e;
    const T = (t - e) / i, R = new ge(), D = new zt();
    for (let O = 0; O <= i; O++) {
      for (let U = 0; U <= r; U++) {
        const H = s + U / r * l;
        R.x = w * Math.cos(H), R.y = w * Math.sin(H), p.push(R.x, R.y, R.z), g.push(0, 0, 1), D.x = (R.x / t + 1) / 2, D.y = (R.y / t + 1) / 2, _.push(D.x, D.y);
      }
      w += T;
    }
    for (let O = 0; O < i; O++) {
      const U = O * (r + 1);
      for (let H = 0; H < r; H++) {
        const I = H + U, G = I, B = I + r + 1, Q = I + r + 2, K = I + 1;
        d.push(G, B, K), d.push(B, Q, K);
      }
    }
    this.setIndex(d), this.setAttribute("position", new sr(p, 3)), this.setAttribute("normal", new sr(g, 3)), this.setAttribute("uv", new sr(_, 2));
  }
  static fromJSON(e) {
    return new ab(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength);
  }
}
class sb extends oi {
  constructor(e = new W_([new zt(0, 0.5), new zt(-0.5, -0.5), new zt(0.5, -0.5)]), t = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = {
      shapes: e,
      curveSegments: t
    };
    const r = [], i = [], s = [], l = [];
    let d = 0, p = 0;
    if (Array.isArray(e) === !1)
      g(e);
    else
      for (let _ = 0; _ < e.length; _++)
        g(e[_]), this.addGroup(d, p, _), d += p, p = 0;
    this.setIndex(r), this.setAttribute("position", new sr(i, 3)), this.setAttribute("normal", new sr(s, 3)), this.setAttribute("uv", new sr(l, 2));
    function g(_) {
      const w = i.length / 3, T = _.extractPoints(t);
      let R = T.shape;
      const D = T.holes;
      hy.isClockWise(R) === !1 && (R = R.reverse());
      for (let U = 0, H = D.length; U < H; U++) {
        const I = D[U];
        hy.isClockWise(I) === !0 && (D[U] = I.reverse());
      }
      const O = hy.triangulateShape(R, D);
      for (let U = 0, H = D.length; U < H; U++) {
        const I = D[U];
        R = R.concat(I);
      }
      for (let U = 0, H = R.length; U < H; U++) {
        const I = R[U];
        i.push(I.x, I.y, 0), s.push(0, 0, 1), l.push(I.x, I.y);
      }
      for (let U = 0, H = O.length; U < H; U++) {
        const I = O[U], G = I[0] + w, B = I[1] + w, Q = I[2] + w;
        r.push(G, B, Q), p += 3;
      }
    }
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes;
    return t7(t, e);
  }
  static fromJSON(e, t) {
    const r = [];
    for (let i = 0, s = e.shapes.length; i < s; i++) {
      const l = t[e.shapes[i]];
      r.push(l);
    }
    return new sb(r, e.curveSegments);
  }
}
function t7(a, e) {
  if (e.shapes = [], Array.isArray(a))
    for (let t = 0, r = a.length; t < r; t++) {
      const i = a[t];
      e.shapes.push(i.uuid);
    }
  else
    e.shapes.push(a.uuid);
  return e;
}
class ug extends oi {
  constructor(e = 1, t = 32, r = 16, i = 0, s = Math.PI * 2, l = 0, d = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: t,
      heightSegments: r,
      phiStart: i,
      phiLength: s,
      thetaStart: l,
      thetaLength: d
    }, t = Math.max(3, Math.floor(t)), r = Math.max(2, Math.floor(r));
    const p = Math.min(l + d, Math.PI);
    let g = 0;
    const _ = [], w = new ge(), T = new ge(), R = [], D = [], O = [], U = [];
    for (let H = 0; H <= r; H++) {
      const I = [], G = H / r;
      let B = 0;
      H == 0 && l == 0 ? B = 0.5 / t : H == r && p == Math.PI && (B = -0.5 / t);
      for (let Q = 0; Q <= t; Q++) {
        const K = Q / t;
        w.x = -e * Math.cos(i + K * s) * Math.sin(l + G * d), w.y = e * Math.cos(l + G * d), w.z = e * Math.sin(i + K * s) * Math.sin(l + G * d), D.push(w.x, w.y, w.z), T.copy(w).normalize(), O.push(T.x, T.y, T.z), U.push(K + B, 1 - G), I.push(g++);
      }
      _.push(I);
    }
    for (let H = 0; H < r; H++)
      for (let I = 0; I < t; I++) {
        const G = _[H][I + 1], B = _[H][I], Q = _[H + 1][I], K = _[H + 1][I + 1];
        (H !== 0 || l > 0) && R.push(G, B, K), (H !== r - 1 || p < Math.PI) && R.push(B, Q, K);
      }
    this.setIndex(R), this.setAttribute("position", new sr(D, 3)), this.setAttribute("normal", new sr(O, 3)), this.setAttribute("uv", new sr(U, 2));
  }
  static fromJSON(e) {
    return new ug(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class ob extends gy {
  constructor(e = 1, t = 0) {
    const r = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ], i = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(r, i, e, t), this.type = "TetrahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new ob(e.radius, e.detail);
  }
}
class ag extends oi {
  constructor(e = 1, t = 0.4, r = 8, i = 6, s = Math.PI * 2) {
    super(), this.type = "TorusGeometry", this.parameters = {
      radius: e,
      tube: t,
      radialSegments: r,
      tubularSegments: i,
      arc: s
    }, r = Math.floor(r), i = Math.floor(i);
    const l = [], d = [], p = [], g = [], _ = new ge(), w = new ge(), T = new ge();
    for (let R = 0; R <= r; R++)
      for (let D = 0; D <= i; D++) {
        const O = D / i * s, U = R / r * Math.PI * 2;
        w.x = (e + t * Math.cos(U)) * Math.cos(O), w.y = (e + t * Math.cos(U)) * Math.sin(O), w.z = t * Math.sin(U), d.push(w.x, w.y, w.z), _.x = e * Math.cos(O), _.y = e * Math.sin(O), T.subVectors(w, _).normalize(), p.push(T.x, T.y, T.z), g.push(D / i), g.push(R / r);
      }
    for (let R = 1; R <= r; R++)
      for (let D = 1; D <= i; D++) {
        const O = (i + 1) * R + D - 1, U = (i + 1) * (R - 1) + D - 1, H = (i + 1) * (R - 1) + D, I = (i + 1) * R + D;
        l.push(O, U, I), l.push(U, H, I);
      }
    this.setIndex(l), this.setAttribute("position", new sr(d, 3)), this.setAttribute("normal", new sr(p, 3)), this.setAttribute("uv", new sr(g, 2));
  }
  static fromJSON(e) {
    return new ag(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class lb extends oi {
  constructor(e = 1, t = 0.4, r = 64, i = 8, s = 2, l = 3) {
    super(), this.type = "TorusKnotGeometry", this.parameters = {
      radius: e,
      tube: t,
      tubularSegments: r,
      radialSegments: i,
      p: s,
      q: l
    }, r = Math.floor(r), i = Math.floor(i);
    const d = [], p = [], g = [], _ = [], w = new ge(), T = new ge(), R = new ge(), D = new ge(), O = new ge(), U = new ge(), H = new ge();
    for (let G = 0; G <= r; ++G) {
      const B = G / r * s * Math.PI * 2;
      I(B, s, l, e, R), I(B + 0.01, s, l, e, D), U.subVectors(D, R), H.addVectors(D, R), O.crossVectors(U, H), H.crossVectors(O, U), O.normalize(), H.normalize();
      for (let Q = 0; Q <= i; ++Q) {
        const K = Q / i * Math.PI * 2, te = -t * Math.cos(K), Y = t * Math.sin(K);
        w.x = R.x + (te * H.x + Y * O.x), w.y = R.y + (te * H.y + Y * O.y), w.z = R.z + (te * H.z + Y * O.z), p.push(w.x, w.y, w.z), T.subVectors(w, R).normalize(), g.push(T.x, T.y, T.z), _.push(G / r), _.push(Q / i);
      }
    }
    for (let G = 1; G <= r; G++)
      for (let B = 1; B <= i; B++) {
        const Q = (i + 1) * (G - 1) + (B - 1), K = (i + 1) * G + (B - 1), te = (i + 1) * G + B, Y = (i + 1) * (G - 1) + B;
        d.push(Q, K, Y), d.push(K, te, Y);
      }
    this.setIndex(d), this.setAttribute("position", new sr(p, 3)), this.setAttribute("normal", new sr(g, 3)), this.setAttribute("uv", new sr(_, 2));
    function I(G, B, Q, K, te) {
      const Y = Math.cos(G), re = Math.sin(G), se = Q / B * G, ce = Math.cos(se);
      te.x = K * (2 + ce) * 0.5 * Y, te.y = K * (2 + ce) * re * 0.5, te.z = K * Math.sin(se) * 0.5;
    }
  }
  static fromJSON(e) {
    return new lb(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
  }
}
class ub extends oi {
  constructor(e = new aL(new ge(-1, -1, 0), new ge(-1, 1, 0), new ge(1, 1, 0)), t = 64, r = 1, i = 8, s = !1) {
    super(), this.type = "TubeGeometry", this.parameters = {
      path: e,
      tubularSegments: t,
      radius: r,
      radialSegments: i,
      closed: s
    };
    const l = e.computeFrenetFrames(t, s);
    this.tangents = l.tangents, this.normals = l.normals, this.binormals = l.binormals;
    const d = new ge(), p = new ge(), g = new zt();
    let _ = new ge();
    const w = [], T = [], R = [], D = [];
    O(), this.setIndex(D), this.setAttribute("position", new sr(w, 3)), this.setAttribute("normal", new sr(T, 3)), this.setAttribute("uv", new sr(R, 2));
    function O() {
      for (let G = 0; G < t; G++)
        U(G);
      U(s === !1 ? t : 0), I(), H();
    }
    function U(G) {
      _ = e.getPointAt(G / t, _);
      const B = l.normals[G], Q = l.binormals[G];
      for (let K = 0; K <= i; K++) {
        const te = K / i * Math.PI * 2, Y = Math.sin(te), re = -Math.cos(te);
        p.x = re * B.x + Y * Q.x, p.y = re * B.y + Y * Q.y, p.z = re * B.z + Y * Q.z, p.normalize(), T.push(p.x, p.y, p.z), d.x = _.x + r * p.x, d.y = _.y + r * p.y, d.z = _.z + r * p.z, w.push(d.x, d.y, d.z);
      }
    }
    function H() {
      for (let G = 1; G <= t; G++)
        for (let B = 1; B <= i; B++) {
          const Q = (i + 1) * (G - 1) + (B - 1), K = (i + 1) * G + (B - 1), te = (i + 1) * G + B, Y = (i + 1) * (G - 1) + B;
          D.push(Q, K, Y), D.push(K, te, Y);
        }
    }
    function I() {
      for (let G = 0; G <= t; G++)
        for (let B = 0; B <= i; B++)
          g.x = G / t, g.y = B / i, R.push(g.x, g.y);
    }
  }
  toJSON() {
    const e = super.toJSON();
    return e.path = this.parameters.path.toJSON(), e;
  }
  static fromJSON(e) {
    return new ub(
      new oL[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class lL extends oi {
  constructor(e = null) {
    if (super(), this.type = "WireframeGeometry", this.parameters = {
      geometry: e
    }, e !== null) {
      const t = [], r = /* @__PURE__ */ new Set(), i = new ge(), s = new ge();
      if (e.index !== null) {
        const l = e.attributes.position, d = e.index;
        let p = e.groups;
        p.length === 0 && (p = [{ start: 0, count: d.count, materialIndex: 0 }]);
        for (let g = 0, _ = p.length; g < _; ++g) {
          const w = p[g], T = w.start, R = w.count;
          for (let D = T, O = T + R; D < O; D += 3)
            for (let U = 0; U < 3; U++) {
              const H = d.getX(D + U), I = d.getX(D + (U + 1) % 3);
              i.fromBufferAttribute(l, H), s.fromBufferAttribute(l, I), PU(i, s, r) === !0 && (t.push(i.x, i.y, i.z), t.push(s.x, s.y, s.z));
            }
        }
      } else {
        const l = e.attributes.position;
        for (let d = 0, p = l.count / 3; d < p; d++)
          for (let g = 0; g < 3; g++) {
            const _ = 3 * d + g, w = 3 * d + (g + 1) % 3;
            i.fromBufferAttribute(l, _), s.fromBufferAttribute(l, w), PU(i, s, r) === !0 && (t.push(i.x, i.y, i.z), t.push(s.x, s.y, s.z));
          }
      }
      this.setAttribute("position", new sr(t, 3));
    }
  }
}
function PU(a, e, t) {
  const r = `${a.x},${a.y},${a.z}-${e.x},${e.y},${e.z}`, i = `${e.x},${e.y},${e.z}-${a.x},${a.y},${a.z}`;
  return t.has(r) === !0 || t.has(i) === !0 ? !1 : (t.add(r), t.add(i), !0);
}
var OU = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BoxGeometry: fl,
  BoxBufferGeometry: fl,
  CapsuleGeometry: $w,
  CapsuleBufferGeometry: $w,
  CircleGeometry: eb,
  CircleBufferGeometry: eb,
  ConeGeometry: tb,
  ConeBufferGeometry: tb,
  CylinderGeometry: Ko,
  CylinderBufferGeometry: Ko,
  DodecahedronGeometry: nb,
  DodecahedronBufferGeometry: nb,
  EdgesGeometry: rk,
  ExtrudeGeometry: rb,
  ExtrudeBufferGeometry: rb,
  IcosahedronGeometry: ib,
  IcosahedronBufferGeometry: ib,
  LatheGeometry: Q_,
  LatheBufferGeometry: Q_,
  OctahedronGeometry: sg,
  OctahedronBufferGeometry: sg,
  PlaneGeometry: lg,
  PlaneBufferGeometry: lg,
  PolyhedronGeometry: gy,
  PolyhedronBufferGeometry: gy,
  RingGeometry: ab,
  RingBufferGeometry: ab,
  ShapeGeometry: sb,
  ShapeBufferGeometry: sb,
  SphereGeometry: ug,
  SphereBufferGeometry: ug,
  TetrahedronGeometry: ob,
  TetrahedronBufferGeometry: ob,
  TorusGeometry: ag,
  TorusBufferGeometry: ag,
  TorusKnotGeometry: lb,
  TorusKnotBufferGeometry: lb,
  TubeGeometry: ub,
  TubeBufferGeometry: ub,
  WireframeGeometry: lL
});
class ok extends hf {
  constructor(e) {
    super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new Un(0), this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this;
  }
}
class lk extends Mu {
  constructor(e) {
    super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial";
  }
}
class HM extends hf {
  constructor(e) {
    super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Un(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Un(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = K_, this.normalScale = new zt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class uk extends HM {
  constructor(e) {
    super(), this.isMeshPhysicalMaterial = !0, this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new zt(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
      get: function() {
        return Zu(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function(t) {
        this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
      }
    }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Un(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new Un(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Un(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._iridescence = 0, this._transmission = 0, this.setValues(e);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
  }
  copy(e) {
    return super.copy(e), this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
  }
}
class ck extends hf {
  constructor(e) {
    super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new Un(16777215), this.specular = new Un(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Un(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = K_, this.normalScale = new zt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = ZM, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class fk extends hf {
  constructor(e) {
    super(), this.isMeshToonMaterial = !0, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new Un(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Un(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = K_, this.normalScale = new zt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
class uL extends hf {
  constructor(e) {
    super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = K_, this.normalScale = new zt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
  }
}
class dk extends hf {
  constructor(e) {
    super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new Un(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Un(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = ZM, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
class hk extends hf {
  constructor(e) {
    super(), this.isMeshMatcapMaterial = !0, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new Un(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = K_, this.normalScale = new zt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class pk extends mh {
  constructor(e) {
    super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
  }
}
function _v(a, e, t) {
  return cL(a) ? new a.constructor(a.subarray(e, t !== void 0 ? t : a.length)) : a.slice(e, t);
}
function k_(a, e, t) {
  return !a || !t && a.constructor === e ? a : typeof e.BYTES_PER_ELEMENT == "number" ? new e(a) : Array.prototype.slice.call(a);
}
function cL(a) {
  return ArrayBuffer.isView(a) && !(a instanceof DataView);
}
function mk(a) {
  function e(i, s) {
    return a[i] - a[s];
  }
  const t = a.length, r = new Array(t);
  for (let i = 0; i !== t; ++i)
    r[i] = i;
  return r.sort(e), r;
}
function S3(a, e, t) {
  const r = a.length, i = new a.constructor(r);
  for (let s = 0, l = 0; l !== r; ++s) {
    const d = t[s] * e;
    for (let p = 0; p !== e; ++p)
      i[l++] = a[d + p];
  }
  return i;
}
function fL(a, e, t, r) {
  let i = 1, s = a[0];
  for (; s !== void 0 && s[r] === void 0; )
    s = a[i++];
  if (s === void 0)
    return;
  let l = s[r];
  if (l !== void 0)
    if (Array.isArray(l))
      do
        l = s[r], l !== void 0 && (e.push(s.time), t.push.apply(t, l)), s = a[i++];
      while (s !== void 0);
    else if (l.toArray !== void 0)
      do
        l = s[r], l !== void 0 && (e.push(s.time), l.toArray(t, t.length)), s = a[i++];
      while (s !== void 0);
    else
      do
        l = s[r], l !== void 0 && (e.push(s.time), t.push(l)), s = a[i++];
      while (s !== void 0);
}
function n7(a, e, t, r, i = 30) {
  const s = a.clone();
  s.name = e;
  const l = [];
  for (let p = 0; p < s.tracks.length; ++p) {
    const g = s.tracks[p], _ = g.getValueSize(), w = [], T = [];
    for (let R = 0; R < g.times.length; ++R) {
      const D = g.times[R] * i;
      if (!(D < t || D >= r)) {
        w.push(g.times[R]);
        for (let O = 0; O < _; ++O)
          T.push(g.values[R * _ + O]);
      }
    }
    w.length !== 0 && (g.times = k_(w, g.times.constructor), g.values = k_(T, g.values.constructor), l.push(g));
  }
  s.tracks = l;
  let d = 1 / 0;
  for (let p = 0; p < s.tracks.length; ++p)
    d > s.tracks[p].times[0] && (d = s.tracks[p].times[0]);
  for (let p = 0; p < s.tracks.length; ++p)
    s.tracks[p].shift(-1 * d);
  return s.resetDuration(), s;
}
function r7(a, e = 0, t = a, r = 30) {
  r <= 0 && (r = 30);
  const i = t.tracks.length, s = e / r;
  for (let l = 0; l < i; ++l) {
    const d = t.tracks[l], p = d.ValueTypeName;
    if (p === "bool" || p === "string")
      continue;
    const g = a.tracks.find(function(H) {
      return H.name === d.name && H.ValueTypeName === p;
    });
    if (g === void 0)
      continue;
    let _ = 0;
    const w = d.getValueSize();
    d.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (_ = w / 3);
    let T = 0;
    const R = g.getValueSize();
    g.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (T = R / 3);
    const D = d.times.length - 1;
    let O;
    if (s <= d.times[0]) {
      const H = _, I = w - _;
      O = _v(d.values, H, I);
    } else if (s >= d.times[D]) {
      const H = D * w + _, I = H + w - _;
      O = _v(d.values, H, I);
    } else {
      const H = d.createInterpolant(), I = _, G = w - _;
      H.evaluate(s), O = _v(H.resultBuffer, I, G);
    }
    p === "quaternion" && new Po().fromArray(O).normalize().conjugate().toArray(O);
    const U = g.times.length;
    for (let H = 0; H < U; ++H) {
      const I = H * R + T;
      if (p === "quaternion")
        Po.multiplyQuaternionsFlat(
          g.values,
          I,
          O,
          0,
          g.values,
          I
        );
      else {
        const G = R - T * 2;
        for (let B = 0; B < G; ++B)
          g.values[I + B] -= O[B];
      }
    }
  }
  return a.blendMode = Y3, a;
}
var i7 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  arraySlice: _v,
  convertArray: k_,
  isTypedArray: cL,
  getKeyframeOrder: mk,
  sortedArray: S3,
  flattenJSON: fL,
  subclip: n7,
  makeClipAdditive: r7
});
class nT {
  constructor(e, t, r, i) {
    this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = i !== void 0 ? i : new t.constructor(r), this.sampleValues = t, this.valueSize = r, this.settings = null, this.DefaultSettings_ = {};
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let r = this._cachedIndex, i = t[r], s = t[r - 1];
    e: {
      t: {
        let l;
        n: {
          r:
            if (!(e < i)) {
              for (let d = r + 2; ; ) {
                if (i === void 0) {
                  if (e < s)
                    break r;
                  return r = t.length, this._cachedIndex = r, this.copySampleValue_(r - 1);
                }
                if (r === d)
                  break;
                if (s = i, i = t[++r], e < i)
                  break t;
              }
              l = t.length;
              break n;
            }
          if (!(e >= s)) {
            const d = t[1];
            e < d && (r = 2, s = d);
            for (let p = r - 2; ; ) {
              if (s === void 0)
                return this._cachedIndex = 0, this.copySampleValue_(0);
              if (r === p)
                break;
              if (i = s, s = t[--r - 1], e >= s)
                break t;
            }
            l = r, r = 0;
            break n;
          }
          break e;
        }
        for (; r < l; ) {
          const d = r + l >>> 1;
          e < t[d] ? l = d : r = d + 1;
        }
        if (i = t[r], s = t[r - 1], s === void 0)
          return this._cachedIndex = 0, this.copySampleValue_(0);
        if (i === void 0)
          return r = t.length, this._cachedIndex = r, this.copySampleValue_(r - 1);
      }
      this._cachedIndex = r, this.intervalChanged_(r, s, i);
    }
    return this.interpolate_(r, s, e, i);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, r = this.sampleValues, i = this.valueSize, s = e * i;
    for (let l = 0; l !== i; ++l)
      t[l] = r[s + l];
    return t;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
}
class vk extends nT {
  constructor(e, t, r, i) {
    super(e, t, r, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
      endingStart: z_,
      endingEnd: z_
    };
  }
  intervalChanged_(e, t, r) {
    const i = this.parameterPositions;
    let s = e - 2, l = e + 1, d = i[s], p = i[l];
    if (d === void 0)
      switch (this.getSettings_().endingStart) {
        case N_:
          s = e, d = 2 * t - r;
          break;
        case PM:
          s = i.length - 2, d = t + i[s] - i[s + 1];
          break;
        default:
          s = e, d = r;
      }
    if (p === void 0)
      switch (this.getSettings_().endingEnd) {
        case N_:
          l = e, p = 2 * r - t;
          break;
        case PM:
          l = 1, p = r + i[1] - i[0];
          break;
        default:
          l = e - 1, p = t;
      }
    const g = (r - t) * 0.5, _ = this.valueSize;
    this._weightPrev = g / (t - d), this._weightNext = g / (p - r), this._offsetPrev = s * _, this._offsetNext = l * _;
  }
  interpolate_(e, t, r, i) {
    const s = this.resultBuffer, l = this.sampleValues, d = this.valueSize, p = e * d, g = p - d, _ = this._offsetPrev, w = this._offsetNext, T = this._weightPrev, R = this._weightNext, D = (r - t) / (i - t), O = D * D, U = O * D, H = -T * U + 2 * T * O - T * D, I = (1 + T) * U + (-1.5 - 2 * T) * O + (-0.5 + T) * D + 1, G = (-1 - R) * U + (1.5 + R) * O + 0.5 * D, B = R * U - R * O;
    for (let Q = 0; Q !== d; ++Q)
      s[Q] = H * l[_ + Q] + I * l[g + Q] + G * l[p + Q] + B * l[w + Q];
    return s;
  }
}
class dL extends nT {
  constructor(e, t, r, i) {
    super(e, t, r, i);
  }
  interpolate_(e, t, r, i) {
    const s = this.resultBuffer, l = this.sampleValues, d = this.valueSize, p = e * d, g = p - d, _ = (r - t) / (i - t), w = 1 - _;
    for (let T = 0; T !== d; ++T)
      s[T] = l[g + T] * w + l[p + T] * _;
    return s;
  }
}
class gk extends nT {
  constructor(e, t, r, i) {
    super(e, t, r, i);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class hg {
  constructor(e, t, r, i) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    this.name = e, this.times = k_(t, this.TimeBufferType), this.values = k_(r, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation);
  }
  static toJSON(e) {
    const t = e.constructor;
    let r;
    if (t.toJSON !== this.toJSON)
      r = t.toJSON(e);
    else {
      r = {
        name: e.name,
        times: k_(e.times, Array),
        values: k_(e.values, Array)
      };
      const i = e.getInterpolation();
      i !== e.DefaultInterpolation && (r.interpolation = i);
    }
    return r.type = e.ValueTypeName, r;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new gk(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new dL(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new vk(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case DM:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case LM:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case hC:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const r = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else
          throw new Error(r);
      return console.warn("THREE.KeyframeTrack:", r), this;
    }
    return this.createInterpolant = t, this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return DM;
      case this.InterpolantFactoryMethodLinear:
        return LM;
      case this.InterpolantFactoryMethodSmooth:
        return hC;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let r = 0, i = t.length; r !== i; ++r)
        t[r] += e;
    }
    return this;
  }
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let r = 0, i = t.length; r !== i; ++r)
        t[r] *= e;
    }
    return this;
  }
  trim(e, t) {
    const r = this.times, i = r.length;
    let s = 0, l = i - 1;
    for (; s !== i && r[s] < e; )
      ++s;
    for (; l !== -1 && r[l] > t; )
      --l;
    if (++l, s !== 0 || l !== i) {
      s >= l && (l = Math.max(l, 1), s = l - 1);
      const d = this.getValueSize();
      this.times = _v(r, s, l), this.values = _v(this.values, s * d, l * d);
    }
    return this;
  }
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
    const r = this.times, i = this.values, s = r.length;
    s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
    let l = null;
    for (let d = 0; d !== s; d++) {
      const p = r[d];
      if (typeof p == "number" && isNaN(p)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, d, p), e = !1;
        break;
      }
      if (l !== null && l > p) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, d, p, l), e = !1;
        break;
      }
      l = p;
    }
    if (i !== void 0 && cL(i))
      for (let d = 0, p = i.length; d !== p; ++d) {
        const g = i[d];
        if (isNaN(g)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, d, g), e = !1;
          break;
        }
      }
    return e;
  }
  optimize() {
    const e = _v(this.times), t = _v(this.values), r = this.getValueSize(), i = this.getInterpolation() === hC, s = e.length - 1;
    let l = 1;
    for (let d = 1; d < s; ++d) {
      let p = !1;
      const g = e[d], _ = e[d + 1];
      if (g !== _ && (d !== 1 || g !== e[0]))
        if (i)
          p = !0;
        else {
          const w = d * r, T = w - r, R = w + r;
          for (let D = 0; D !== r; ++D) {
            const O = t[w + D];
            if (O !== t[T + D] || O !== t[R + D]) {
              p = !0;
              break;
            }
          }
        }
      if (p) {
        if (d !== l) {
          e[l] = e[d];
          const w = d * r, T = l * r;
          for (let R = 0; R !== r; ++R)
            t[T + R] = t[w + R];
        }
        ++l;
      }
    }
    if (s > 0) {
      e[l] = e[s];
      for (let d = s * r, p = l * r, g = 0; g !== r; ++g)
        t[p + g] = t[d + g];
      ++l;
    }
    return l !== e.length ? (this.times = _v(e, 0, l), this.values = _v(t, 0, l * r)) : (this.times = e, this.values = t), this;
  }
  clone() {
    const e = _v(this.times, 0), t = _v(this.values, 0), r = this.constructor, i = new r(this.name, e, t);
    return i.createInterpolant = this.createInterpolant, i;
  }
}
hg.prototype.TimeBufferType = Float32Array;
hg.prototype.ValueBufferType = Float32Array;
hg.prototype.DefaultInterpolation = LM;
class eS extends hg {
}
eS.prototype.ValueTypeName = "bool";
eS.prototype.ValueBufferType = Array;
eS.prototype.DefaultInterpolation = DM;
eS.prototype.InterpolantFactoryMethodLinear = void 0;
eS.prototype.InterpolantFactoryMethodSmooth = void 0;
class hL extends hg {
}
hL.prototype.ValueTypeName = "color";
class VM extends hg {
}
VM.prototype.ValueTypeName = "number";
class yk extends nT {
  constructor(e, t, r, i) {
    super(e, t, r, i);
  }
  interpolate_(e, t, r, i) {
    const s = this.resultBuffer, l = this.sampleValues, d = this.valueSize, p = (r - t) / (i - t);
    let g = e * d;
    for (let _ = g + d; g !== _; g += 4)
      Po.slerpFlat(s, 0, l, g - d, l, g, p);
    return s;
  }
}
class vb extends hg {
  InterpolantFactoryMethodLinear(e) {
    return new yk(this.times, this.values, this.getValueSize(), e);
  }
}
vb.prototype.ValueTypeName = "quaternion";
vb.prototype.DefaultInterpolation = LM;
vb.prototype.InterpolantFactoryMethodSmooth = void 0;
class tS extends hg {
}
tS.prototype.ValueTypeName = "string";
tS.prototype.ValueBufferType = Array;
tS.prototype.DefaultInterpolation = DM;
tS.prototype.InterpolantFactoryMethodLinear = void 0;
tS.prototype.InterpolantFactoryMethodSmooth = void 0;
class GM extends hg {
}
GM.prototype.ValueTypeName = "vector";
class WM {
  constructor(e, t = -1, r, i = kC) {
    this.name = e, this.tracks = r, this.duration = t, this.blendMode = i, this.uuid = Em(), this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [], r = e.tracks, i = 1 / (e.fps || 1);
    for (let l = 0, d = r.length; l !== d; ++l)
      t.push(s7(r[l]).scale(i));
    const s = new this(e.name, e.duration, t, e.blendMode);
    return s.uuid = e.uuid, s;
  }
  static toJSON(e) {
    const t = [], r = e.tracks, i = {
      name: e.name,
      duration: e.duration,
      tracks: t,
      uuid: e.uuid,
      blendMode: e.blendMode
    };
    for (let s = 0, l = r.length; s !== l; ++s)
      t.push(hg.toJSON(r[s]));
    return i;
  }
  static CreateFromMorphTargetSequence(e, t, r, i) {
    const s = t.length, l = [];
    for (let d = 0; d < s; d++) {
      let p = [], g = [];
      p.push(
        (d + s - 1) % s,
        d,
        (d + 1) % s
      ), g.push(0, 1, 0);
      const _ = mk(p);
      p = S3(p, 1, _), g = S3(g, 1, _), !i && p[0] === 0 && (p.push(s), g.push(g[0])), l.push(
        new VM(
          ".morphTargetInfluences[" + t[d].name + "]",
          p,
          g
        ).scale(1 / r)
      );
    }
    return new this(e, -1, l);
  }
  static findByName(e, t) {
    let r = e;
    if (!Array.isArray(e)) {
      const i = e;
      r = i.geometry && i.geometry.animations || i.animations;
    }
    for (let i = 0; i < r.length; i++)
      if (r[i].name === t)
        return r[i];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, r) {
    const i = {}, s = /^([\w-]*?)([\d]+)$/;
    for (let d = 0, p = e.length; d < p; d++) {
      const g = e[d], _ = g.name.match(s);
      if (_ && _.length > 1) {
        const w = _[1];
        let T = i[w];
        T || (i[w] = T = []), T.push(g);
      }
    }
    const l = [];
    for (const d in i)
      l.push(this.CreateFromMorphTargetSequence(d, i[d], t, r));
    return l;
  }
  static parseAnimation(e, t) {
    if (!e)
      return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    const r = function(w, T, R, D, O) {
      if (R.length !== 0) {
        const U = [], H = [];
        fL(R, U, H, D), U.length !== 0 && O.push(new w(T, U, H));
      }
    }, i = [], s = e.name || "default", l = e.fps || 30, d = e.blendMode;
    let p = e.length || -1;
    const g = e.hierarchy || [];
    for (let w = 0; w < g.length; w++) {
      const T = g[w].keys;
      if (!(!T || T.length === 0))
        if (T[0].morphTargets) {
          const R = {};
          let D;
          for (D = 0; D < T.length; D++)
            if (T[D].morphTargets)
              for (let O = 0; O < T[D].morphTargets.length; O++)
                R[T[D].morphTargets[O]] = -1;
          for (const O in R) {
            const U = [], H = [];
            for (let I = 0; I !== T[D].morphTargets.length; ++I) {
              const G = T[D];
              U.push(G.time), H.push(G.morphTarget === O ? 1 : 0);
            }
            i.push(new VM(".morphTargetInfluence[" + O + "]", U, H));
          }
          p = R.length * l;
        } else {
          const R = ".bones[" + t[w].name + "]";
          r(
            GM,
            R + ".position",
            T,
            "pos",
            i
          ), r(
            vb,
            R + ".quaternion",
            T,
            "rot",
            i
          ), r(
            GM,
            R + ".scale",
            T,
            "scl",
            i
          );
        }
    }
    return i.length === 0 ? null : new this(s, p, i, d);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let r = 0, i = e.length; r !== i; ++r) {
      const s = this.tracks[r];
      t = Math.max(t, s.times[s.times.length - 1]);
    }
    return this.duration = t, this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++)
      e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function a7(a) {
  switch (a.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return VM;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return GM;
    case "color":
      return hL;
    case "quaternion":
      return vb;
    case "bool":
    case "boolean":
      return eS;
    case "string":
      return tS;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + a);
}
function s7(a) {
  if (a.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = a7(a.type);
  if (a.times === void 0) {
    const t = [], r = [];
    fL(a.keys, t, r, "value"), a.times = t, a.values = r;
  }
  return e.parse !== void 0 ? e.parse(a) : new e(a.name, a.times, a.values, a.interpolation);
}
const Z_ = {
  enabled: !1,
  files: {},
  add: function(a, e) {
    this.enabled !== !1 && (this.files[a] = e);
  },
  get: function(a) {
    if (this.enabled !== !1)
      return this.files[a];
  },
  remove: function(a) {
    delete this.files[a];
  },
  clear: function() {
    this.files = {};
  }
};
class pL {
  constructor(e, t, r) {
    const i = this;
    let s = !1, l = 0, d = 0, p;
    const g = [];
    this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = r, this.itemStart = function(_) {
      d++, s === !1 && i.onStart !== void 0 && i.onStart(_, l, d), s = !0;
    }, this.itemEnd = function(_) {
      l++, i.onProgress !== void 0 && i.onProgress(_, l, d), l === d && (s = !1, i.onLoad !== void 0 && i.onLoad());
    }, this.itemError = function(_) {
      i.onError !== void 0 && i.onError(_);
    }, this.resolveURL = function(_) {
      return p ? p(_) : _;
    }, this.setURLModifier = function(_) {
      return p = _, this;
    }, this.addHandler = function(_, w) {
      return g.push(_, w), this;
    }, this.removeHandler = function(_) {
      const w = g.indexOf(_);
      return w !== -1 && g.splice(w, 2), this;
    }, this.getHandler = function(_) {
      for (let w = 0, T = g.length; w < T; w += 2) {
        const R = g[w], D = g[w + 1];
        if (R.global && (R.lastIndex = 0), R.test(_))
          return D;
      }
      return null;
    };
  }
}
const xk = /* @__PURE__ */ new pL();
class Rm {
  constructor(e) {
    this.manager = e !== void 0 ? e : xk, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  load() {
  }
  loadAsync(e, t) {
    const r = this;
    return new Promise(function(i, s) {
      r.load(e, i, t, s);
    });
  }
  parse() {
  }
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  setWithCredentials(e) {
    return this.withCredentials = e, this;
  }
  setPath(e) {
    return this.path = e, this;
  }
  setResourcePath(e) {
    return this.resourcePath = e, this;
  }
  setRequestHeader(e) {
    return this.requestHeader = e, this;
  }
}
const T0 = {};
class o7 extends Error {
  constructor(e, t) {
    super(e), this.response = t;
  }
}
class O0 extends Rm {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const s = Z_.get(e);
    if (s !== void 0)
      return this.manager.itemStart(e), setTimeout(() => {
        t && t(s), this.manager.itemEnd(e);
      }, 0), s;
    if (T0[e] !== void 0) {
      T0[e].push({
        onLoad: t,
        onProgress: r,
        onError: i
      });
      return;
    }
    T0[e] = [], T0[e].push({
      onLoad: t,
      onProgress: r,
      onError: i
    });
    const l = new Request(e, {
      headers: new Headers(this.requestHeader),
      credentials: this.withCredentials ? "include" : "same-origin"
    }), d = this.mimeType, p = this.responseType;
    fetch(l).then((g) => {
      if (g.status === 200 || g.status === 0) {
        if (g.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || g.body === void 0 || g.body.getReader === void 0)
          return g;
        const _ = T0[e], w = g.body.getReader(), T = g.headers.get("Content-Length"), R = T ? parseInt(T) : 0, D = R !== 0;
        let O = 0;
        const U = new ReadableStream({
          start(H) {
            I();
            function I() {
              w.read().then(({ done: G, value: B }) => {
                if (G)
                  H.close();
                else {
                  O += B.byteLength;
                  const Q = new ProgressEvent("progress", { lengthComputable: D, loaded: O, total: R });
                  for (let K = 0, te = _.length; K < te; K++) {
                    const Y = _[K];
                    Y.onProgress && Y.onProgress(Q);
                  }
                  H.enqueue(B), I();
                }
              });
            }
          }
        });
        return new Response(U);
      } else
        throw new o7(`fetch for "${g.url}" responded with ${g.status}: ${g.statusText}`, g);
    }).then((g) => {
      switch (p) {
        case "arraybuffer":
          return g.arrayBuffer();
        case "blob":
          return g.blob();
        case "document":
          return g.text().then((_) => new DOMParser().parseFromString(_, d));
        case "json":
          return g.json();
        default:
          if (d === void 0)
            return g.text();
          {
            const w = /charset="?([^;"\s]*)"?/i.exec(d), T = w && w[1] ? w[1].toLowerCase() : void 0, R = new TextDecoder(T);
            return g.arrayBuffer().then((D) => R.decode(D));
          }
      }
    }).then((g) => {
      Z_.add(e, g);
      const _ = T0[e];
      delete T0[e];
      for (let w = 0, T = _.length; w < T; w++) {
        const R = _[w];
        R.onLoad && R.onLoad(g);
      }
    }).catch((g) => {
      const _ = T0[e];
      if (_ === void 0)
        throw this.manager.itemError(e), g;
      delete T0[e];
      for (let w = 0, T = _.length; w < T; w++) {
        const R = _[w];
        R.onError && R.onError(g);
      }
      this.manager.itemError(e);
    }).finally(() => {
      this.manager.itemEnd(e);
    }), this.manager.itemStart(e);
  }
  setResponseType(e) {
    return this.responseType = e, this;
  }
  setMimeType(e) {
    return this.mimeType = e, this;
  }
}
class l7 extends Rm {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const s = this, l = new O0(this.manager);
    l.setPath(this.path), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function(d) {
      try {
        t(s.parse(JSON.parse(d)));
      } catch (p) {
        i ? i(p) : console.error(p), s.manager.itemError(e);
      }
    }, r, i);
  }
  parse(e) {
    const t = [];
    for (let r = 0; r < e.length; r++) {
      const i = WM.parse(e[r]);
      t.push(i);
    }
    return t;
  }
}
class u7 extends Rm {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const s = this, l = [], d = new JF(), p = new O0(this.manager);
    p.setPath(this.path), p.setResponseType("arraybuffer"), p.setRequestHeader(this.requestHeader), p.setWithCredentials(s.withCredentials);
    let g = 0;
    function _(w) {
      p.load(e[w], function(T) {
        const R = s.parse(T, !0);
        l[w] = {
          width: R.width,
          height: R.height,
          format: R.format,
          mipmaps: R.mipmaps
        }, g += 1, g === 6 && (R.mipmapCount === 1 && (d.minFilter = Oo), d.image = l, d.format = R.format, d.needsUpdate = !0, t && t(d));
      }, r, i);
    }
    if (Array.isArray(e))
      for (let w = 0, T = e.length; w < T; ++w)
        _(w);
    else
      p.load(e, function(w) {
        const T = s.parse(w, !0);
        if (T.isCubemap) {
          const R = T.mipmaps.length / T.mipmapCount;
          for (let D = 0; D < R; D++) {
            l[D] = { mipmaps: [] };
            for (let O = 0; O < T.mipmapCount; O++)
              l[D].mipmaps.push(T.mipmaps[D * T.mipmapCount + O]), l[D].format = T.format, l[D].width = T.width, l[D].height = T.height;
          }
          d.image = l;
        } else
          d.image.width = T.width, d.image.height = T.height, d.mipmaps = T.mipmaps;
        T.mipmapCount === 1 && (d.minFilter = Oo), d.format = T.format, d.needsUpdate = !0, t && t(d);
      }, r, i);
    return d;
  }
}
class jM extends Rm {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const s = this, l = Z_.get(e);
    if (l !== void 0)
      return s.manager.itemStart(e), setTimeout(function() {
        t && t(l), s.manager.itemEnd(e);
      }, 0), l;
    const d = zM("img");
    function p() {
      _(), Z_.add(e, this), t && t(this), s.manager.itemEnd(e);
    }
    function g(w) {
      _(), i && i(w), s.manager.itemError(e), s.manager.itemEnd(e);
    }
    function _() {
      d.removeEventListener("load", p, !1), d.removeEventListener("error", g, !1);
    }
    return d.addEventListener("load", p, !1), d.addEventListener("error", g, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (d.crossOrigin = this.crossOrigin), s.manager.itemStart(e), d.src = e, d;
  }
}
class c7 extends Rm {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const s = new eT(), l = new jM(this.manager);
    l.setCrossOrigin(this.crossOrigin), l.setPath(this.path);
    let d = 0;
    function p(g) {
      l.load(e[g], function(_) {
        s.images[g] = _, d++, d === 6 && (s.needsUpdate = !0, t && t(s));
      }, void 0, i);
    }
    for (let g = 0; g < e.length; ++g)
      p(g);
    return s;
  }
}
class f7 extends Rm {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const s = this, l = new qw(), d = new O0(this.manager);
    return d.setResponseType("arraybuffer"), d.setRequestHeader(this.requestHeader), d.setPath(this.path), d.setWithCredentials(s.withCredentials), d.load(e, function(p) {
      const g = s.parse(p);
      !g || (g.image !== void 0 ? l.image = g.image : g.data !== void 0 && (l.image.width = g.width, l.image.height = g.height, l.image.data = g.data), l.wrapS = g.wrapS !== void 0 ? g.wrapS : jh, l.wrapT = g.wrapT !== void 0 ? g.wrapT : jh, l.magFilter = g.magFilter !== void 0 ? g.magFilter : Oo, l.minFilter = g.minFilter !== void 0 ? g.minFilter : Oo, l.anisotropy = g.anisotropy !== void 0 ? g.anisotropy : 1, g.encoding !== void 0 && (l.encoding = g.encoding), g.flipY !== void 0 && (l.flipY = g.flipY), g.format !== void 0 && (l.format = g.format), g.type !== void 0 && (l.type = g.type), g.mipmaps !== void 0 && (l.mipmaps = g.mipmaps, l.minFilter = s1), g.mipmapCount === 1 && (l.minFilter = Oo), g.generateMipmaps !== void 0 && (l.generateMipmaps = g.generateMipmaps), l.needsUpdate = !0, t && t(l, g));
    }, r, i), l;
  }
}
class d7 extends Rm {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const s = new su(), l = new jM(this.manager);
    return l.setCrossOrigin(this.crossOrigin), l.setPath(this.path), l.load(e, function(d) {
      s.image = d, s.needsUpdate = !0, t !== void 0 && t(s);
    }, r, i), s;
  }
}
class l1 extends Xa {
  constructor(e, t = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new Un(e), this.intensity = t;
  }
  dispose() {
  }
  copy(e, t) {
    return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t;
  }
}
class _k extends l1 {
  constructor(e, t, r) {
    super(e, r), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(Xa.DefaultUp), this.updateMatrix(), this.groundColor = new Un(t);
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const UU = /* @__PURE__ */ new Kr(), zU = /* @__PURE__ */ new ge(), NU = /* @__PURE__ */ new ge();
class mL {
  constructor(e) {
    this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new zt(512, 512), this.map = null, this.mapPass = null, this.matrix = new Kr(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new BC(), this._frameExtents = new zt(1, 1), this._viewportCount = 1, this._viewports = [
      new ra(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera, r = this.matrix;
    zU.setFromMatrixPosition(e.matrixWorld), t.position.copy(zU), NU.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(NU), t.updateMatrixWorld(), UU.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(UU), r.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), r.multiply(t.projectionMatrix), r.multiply(t.matrixWorldInverse);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
  }
}
class h7 extends mL {
  constructor() {
    super(new ho(50, 1, 0.5, 500)), this.isSpotLightShadow = !0, this.focus = 1;
  }
  updateMatrices(e) {
    const t = this.camera, r = UM * 2 * e.angle * this.focus, i = this.mapSize.width / this.mapSize.height, s = e.distance || t.far;
    (r !== t.fov || i !== t.aspect || s !== t.far) && (t.fov = r, t.aspect = i, t.far = s, t.updateProjectionMatrix()), super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), this.focus = e.focus, this;
  }
}
class Sk extends l1 {
  constructor(e, t, r = 0, i = Math.PI / 3, s = 0, l = 1) {
    super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(Xa.DefaultUp), this.updateMatrix(), this.target = new Xa(), this.distance = r, this.angle = i, this.penumbra = s, this.decay = l, this.shadow = new h7();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
const FU = /* @__PURE__ */ new Kr(), iM = /* @__PURE__ */ new ge(), nD = /* @__PURE__ */ new ge();
class p7 extends mL {
  constructor() {
    super(new ho(90, 1, 0.5, 500)), this.isPointLightShadow = !0, this._frameExtents = new zt(4, 2), this._viewportCount = 6, this._viewports = [
      new ra(2, 1, 1, 1),
      new ra(0, 1, 1, 1),
      new ra(3, 1, 1, 1),
      new ra(1, 1, 1, 1),
      new ra(3, 0, 1, 1),
      new ra(1, 0, 1, 1)
    ], this._cubeDirections = [
      new ge(1, 0, 0),
      new ge(-1, 0, 0),
      new ge(0, 0, 1),
      new ge(0, 0, -1),
      new ge(0, 1, 0),
      new ge(0, -1, 0)
    ], this._cubeUps = [
      new ge(0, 1, 0),
      new ge(0, 1, 0),
      new ge(0, 1, 0),
      new ge(0, 1, 0),
      new ge(0, 0, 1),
      new ge(0, 0, -1)
    ];
  }
  updateMatrices(e, t = 0) {
    const r = this.camera, i = this.matrix, s = e.distance || r.far;
    s !== r.far && (r.far = s, r.updateProjectionMatrix()), iM.setFromMatrixPosition(e.matrixWorld), r.position.copy(iM), nD.copy(r.position), nD.add(this._cubeDirections[t]), r.up.copy(this._cubeUps[t]), r.lookAt(nD), r.updateMatrixWorld(), i.makeTranslation(-iM.x, -iM.y, -iM.z), FU.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse), this._frustum.setFromProjectionMatrix(FU);
  }
}
class wk extends l1 {
  constructor(e, t, r = 0, i = 1) {
    super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = r, this.decay = i, this.shadow = new p7();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
  }
}
class m7 extends mL {
  constructor() {
    super(new dy(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
}
class bk extends l1 {
  constructor(e, t) {
    super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(Xa.DefaultUp), this.updateMatrix(), this.target = new Xa(), this.shadow = new m7();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
class Ek extends l1 {
  constructor(e, t) {
    super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
}
class Mk extends l1 {
  constructor(e, t, r = 10, i = 10) {
    super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = r, this.height = i;
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return super.copy(e), this.width = e.width, this.height = e.height, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.width = this.width, t.object.height = this.height, t;
  }
}
class Tk {
  constructor() {
    this.isSphericalHarmonics3 = !0, this.coefficients = [];
    for (let e = 0; e < 9; e++)
      this.coefficients.push(new ge());
  }
  set(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++)
      this.coefficients[e].set(0, 0, 0);
    return this;
  }
  getAt(e, t) {
    const r = e.x, i = e.y, s = e.z, l = this.coefficients;
    return t.copy(l[0]).multiplyScalar(0.282095), t.addScaledVector(l[1], 0.488603 * i), t.addScaledVector(l[2], 0.488603 * s), t.addScaledVector(l[3], 0.488603 * r), t.addScaledVector(l[4], 1.092548 * (r * i)), t.addScaledVector(l[5], 1.092548 * (i * s)), t.addScaledVector(l[6], 0.315392 * (3 * s * s - 1)), t.addScaledVector(l[7], 1.092548 * (r * s)), t.addScaledVector(l[8], 0.546274 * (r * r - i * i)), t;
  }
  getIrradianceAt(e, t) {
    const r = e.x, i = e.y, s = e.z, l = this.coefficients;
    return t.copy(l[0]).multiplyScalar(0.886227), t.addScaledVector(l[1], 2 * 0.511664 * i), t.addScaledVector(l[2], 2 * 0.511664 * s), t.addScaledVector(l[3], 2 * 0.511664 * r), t.addScaledVector(l[4], 2 * 0.429043 * r * i), t.addScaledVector(l[5], 2 * 0.429043 * i * s), t.addScaledVector(l[6], 0.743125 * s * s - 0.247708), t.addScaledVector(l[7], 2 * 0.429043 * r * s), t.addScaledVector(l[8], 0.429043 * (r * r - i * i)), t;
  }
  add(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let r = 0; r < 9; r++)
      this.coefficients[r].addScaledVector(e.coefficients[r], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let r = 0; r < 9; r++)
      this.coefficients[r].lerp(e.coefficients[r], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t]))
        return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const r = this.coefficients;
    for (let i = 0; i < 9; i++)
      r[i].fromArray(e, t + i * 3);
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.coefficients;
    for (let i = 0; i < 9; i++)
      r[i].toArray(e, t + i * 3);
    return e;
  }
  static getBasisAt(e, t) {
    const r = e.x, i = e.y, s = e.z;
    t[0] = 0.282095, t[1] = 0.488603 * i, t[2] = 0.488603 * s, t[3] = 0.488603 * r, t[4] = 1.092548 * r * i, t[5] = 1.092548 * i * s, t[6] = 0.315392 * (3 * s * s - 1), t[7] = 1.092548 * r * s, t[8] = 0.546274 * (r * r - i * i);
  }
}
class JC extends l1 {
  constructor(e = new Tk(), t = 1) {
    super(void 0, t), this.isLightProbe = !0, this.sh = e;
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return this.intensity = e.intensity, this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.sh = this.sh.toArray(), t;
  }
}
class KC extends Rm {
  constructor(e) {
    super(e), this.textures = {};
  }
  load(e, t, r, i) {
    const s = this, l = new O0(s.manager);
    l.setPath(s.path), l.setRequestHeader(s.requestHeader), l.setWithCredentials(s.withCredentials), l.load(e, function(d) {
      try {
        t(s.parse(JSON.parse(d)));
      } catch (p) {
        i ? i(p) : console.error(p), s.manager.itemError(e);
      }
    }, r, i);
  }
  parse(e) {
    const t = this.textures;
    function r(s) {
      return t[s] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", s), t[s];
    }
    const i = KC.createMaterialFromType(e.type);
    if (e.uuid !== void 0 && (i.uuid = e.uuid), e.name !== void 0 && (i.name = e.name), e.color !== void 0 && i.color !== void 0 && i.color.setHex(e.color), e.roughness !== void 0 && (i.roughness = e.roughness), e.metalness !== void 0 && (i.metalness = e.metalness), e.sheen !== void 0 && (i.sheen = e.sheen), e.sheenColor !== void 0 && (i.sheenColor = new Un().setHex(e.sheenColor)), e.sheenRoughness !== void 0 && (i.sheenRoughness = e.sheenRoughness), e.emissive !== void 0 && i.emissive !== void 0 && i.emissive.setHex(e.emissive), e.specular !== void 0 && i.specular !== void 0 && i.specular.setHex(e.specular), e.specularIntensity !== void 0 && (i.specularIntensity = e.specularIntensity), e.specularColor !== void 0 && i.specularColor !== void 0 && i.specularColor.setHex(e.specularColor), e.shininess !== void 0 && (i.shininess = e.shininess), e.clearcoat !== void 0 && (i.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = e.clearcoatRoughness), e.iridescence !== void 0 && (i.iridescence = e.iridescence), e.iridescenceIOR !== void 0 && (i.iridescenceIOR = e.iridescenceIOR), e.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = e.iridescenceThicknessRange), e.transmission !== void 0 && (i.transmission = e.transmission), e.thickness !== void 0 && (i.thickness = e.thickness), e.attenuationDistance !== void 0 && (i.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && i.attenuationColor !== void 0 && i.attenuationColor.setHex(e.attenuationColor), e.fog !== void 0 && (i.fog = e.fog), e.flatShading !== void 0 && (i.flatShading = e.flatShading), e.blending !== void 0 && (i.blending = e.blending), e.combine !== void 0 && (i.combine = e.combine), e.side !== void 0 && (i.side = e.side), e.shadowSide !== void 0 && (i.shadowSide = e.shadowSide), e.opacity !== void 0 && (i.opacity = e.opacity), e.transparent !== void 0 && (i.transparent = e.transparent), e.alphaTest !== void 0 && (i.alphaTest = e.alphaTest), e.depthTest !== void 0 && (i.depthTest = e.depthTest), e.depthWrite !== void 0 && (i.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (i.colorWrite = e.colorWrite), e.stencilWrite !== void 0 && (i.stencilWrite = e.stencilWrite), e.stencilWriteMask !== void 0 && (i.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (i.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (i.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (i.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (i.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (i.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (i.stencilZPass = e.stencilZPass), e.wireframe !== void 0 && (i.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (i.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (i.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (i.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (i.rotation = e.rotation), e.linewidth !== 1 && (i.linewidth = e.linewidth), e.dashSize !== void 0 && (i.dashSize = e.dashSize), e.gapSize !== void 0 && (i.gapSize = e.gapSize), e.scale !== void 0 && (i.scale = e.scale), e.polygonOffset !== void 0 && (i.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (i.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (i.polygonOffsetUnits = e.polygonOffsetUnits), e.dithering !== void 0 && (i.dithering = e.dithering), e.alphaToCoverage !== void 0 && (i.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (i.premultipliedAlpha = e.premultipliedAlpha), e.visible !== void 0 && (i.visible = e.visible), e.toneMapped !== void 0 && (i.toneMapped = e.toneMapped), e.userData !== void 0 && (i.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? i.vertexColors = e.vertexColors > 0 : i.vertexColors = e.vertexColors), e.uniforms !== void 0)
      for (const s in e.uniforms) {
        const l = e.uniforms[s];
        switch (i.uniforms[s] = {}, l.type) {
          case "t":
            i.uniforms[s].value = r(l.value);
            break;
          case "c":
            i.uniforms[s].value = new Un().setHex(l.value);
            break;
          case "v2":
            i.uniforms[s].value = new zt().fromArray(l.value);
            break;
          case "v3":
            i.uniforms[s].value = new ge().fromArray(l.value);
            break;
          case "v4":
            i.uniforms[s].value = new ra().fromArray(l.value);
            break;
          case "m3":
            i.uniforms[s].value = new Xh().fromArray(l.value);
            break;
          case "m4":
            i.uniforms[s].value = new Kr().fromArray(l.value);
            break;
          default:
            i.uniforms[s].value = l.value;
        }
      }
    if (e.defines !== void 0 && (i.defines = e.defines), e.vertexShader !== void 0 && (i.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (i.fragmentShader = e.fragmentShader), e.extensions !== void 0)
      for (const s in e.extensions)
        i.extensions[s] = e.extensions[s];
    if (e.shading !== void 0 && (i.flatShading = e.shading === 1), e.size !== void 0 && (i.size = e.size), e.sizeAttenuation !== void 0 && (i.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (i.map = r(e.map)), e.matcap !== void 0 && (i.matcap = r(e.matcap)), e.alphaMap !== void 0 && (i.alphaMap = r(e.alphaMap)), e.bumpMap !== void 0 && (i.bumpMap = r(e.bumpMap)), e.bumpScale !== void 0 && (i.bumpScale = e.bumpScale), e.normalMap !== void 0 && (i.normalMap = r(e.normalMap)), e.normalMapType !== void 0 && (i.normalMapType = e.normalMapType), e.normalScale !== void 0) {
      let s = e.normalScale;
      Array.isArray(s) === !1 && (s = [s, s]), i.normalScale = new zt().fromArray(s);
    }
    return e.displacementMap !== void 0 && (i.displacementMap = r(e.displacementMap)), e.displacementScale !== void 0 && (i.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (i.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (i.roughnessMap = r(e.roughnessMap)), e.metalnessMap !== void 0 && (i.metalnessMap = r(e.metalnessMap)), e.emissiveMap !== void 0 && (i.emissiveMap = r(e.emissiveMap)), e.emissiveIntensity !== void 0 && (i.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (i.specularMap = r(e.specularMap)), e.specularIntensityMap !== void 0 && (i.specularIntensityMap = r(e.specularIntensityMap)), e.specularColorMap !== void 0 && (i.specularColorMap = r(e.specularColorMap)), e.envMap !== void 0 && (i.envMap = r(e.envMap)), e.envMapIntensity !== void 0 && (i.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (i.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (i.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (i.lightMap = r(e.lightMap)), e.lightMapIntensity !== void 0 && (i.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (i.aoMap = r(e.aoMap)), e.aoMapIntensity !== void 0 && (i.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (i.gradientMap = r(e.gradientMap)), e.clearcoatMap !== void 0 && (i.clearcoatMap = r(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (i.clearcoatRoughnessMap = r(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (i.clearcoatNormalMap = r(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (i.clearcoatNormalScale = new zt().fromArray(e.clearcoatNormalScale)), e.iridescenceMap !== void 0 && (i.iridescenceMap = r(e.iridescenceMap)), e.iridescenceThicknessMap !== void 0 && (i.iridescenceThicknessMap = r(e.iridescenceThicknessMap)), e.transmissionMap !== void 0 && (i.transmissionMap = r(e.transmissionMap)), e.thicknessMap !== void 0 && (i.thicknessMap = r(e.thicknessMap)), e.sheenColorMap !== void 0 && (i.sheenColorMap = r(e.sheenColorMap)), e.sheenRoughnessMap !== void 0 && (i.sheenRoughnessMap = r(e.sheenRoughnessMap)), i;
  }
  setTextures(e) {
    return this.textures = e, this;
  }
  static createMaterialFromType(e) {
    const t = {
      ShadowMaterial: ok,
      SpriteMaterial: eL,
      RawShaderMaterial: lk,
      ShaderMaterial: Mu,
      PointsMaterial: XC,
      MeshPhysicalMaterial: uk,
      MeshStandardMaterial: HM,
      MeshPhongMaterial: ck,
      MeshToonMaterial: fk,
      MeshNormalMaterial: uL,
      MeshLambertMaterial: dk,
      MeshDepthMaterial: tT,
      MeshDistanceMaterial: VC,
      MeshBasicMaterial: fg,
      MeshMatcapMaterial: hk,
      LineDashedMaterial: pk,
      LineBasicMaterial: mh,
      Material: hf
    };
    return new t[e]();
  }
}
class w3 {
  static decodeText(e) {
    if (typeof TextDecoder < "u")
      return new TextDecoder().decode(e);
    let t = "";
    for (let r = 0, i = e.length; r < i; r++)
      t += String.fromCharCode(e[r]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
  }
}
class $C extends oi {
  constructor() {
    super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
  }
  copy(e) {
    return super.copy(e), this.instanceCount = e.instanceCount, this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = super.toJSON(this);
    return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e;
  }
}
class Ck extends Rm {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const s = this, l = new O0(s.manager);
    l.setPath(s.path), l.setRequestHeader(s.requestHeader), l.setWithCredentials(s.withCredentials), l.load(e, function(d) {
      try {
        t(s.parse(JSON.parse(d)));
      } catch (p) {
        i ? i(p) : console.error(p), s.manager.itemError(e);
      }
    }, r, i);
  }
  parse(e) {
    const t = {}, r = {};
    function i(R, D) {
      if (t[D] !== void 0)
        return t[D];
      const U = R.interleavedBuffers[D], H = s(R, U.buffer), I = Gw(U.type, H), G = new jC(I, U.stride);
      return G.uuid = U.uuid, t[D] = G, G;
    }
    function s(R, D) {
      if (r[D] !== void 0)
        return r[D];
      const U = R.arrayBuffers[D], H = new Uint32Array(U).buffer;
      return r[D] = H, H;
    }
    const l = e.isInstancedBufferGeometry ? new $C() : new oi(), d = e.data.index;
    if (d !== void 0) {
      const R = Gw(d.type, d.array);
      l.setIndex(new ls(R, 1));
    }
    const p = e.data.attributes;
    for (const R in p) {
      const D = p[R];
      let O;
      if (D.isInterleavedBufferAttribute) {
        const U = i(e.data, D.data);
        O = new bm(U, D.itemSize, D.offset, D.normalized);
      } else {
        const U = Gw(D.type, D.array), H = D.isInstancedBufferAttribute ? q_ : ls;
        O = new H(U, D.itemSize, D.normalized);
      }
      D.name !== void 0 && (O.name = D.name), D.usage !== void 0 && O.setUsage(D.usage), D.updateRange !== void 0 && (O.updateRange.offset = D.updateRange.offset, O.updateRange.count = D.updateRange.count), l.setAttribute(R, O);
    }
    const g = e.data.morphAttributes;
    if (g)
      for (const R in g) {
        const D = g[R], O = [];
        for (let U = 0, H = D.length; U < H; U++) {
          const I = D[U];
          let G;
          if (I.isInterleavedBufferAttribute) {
            const B = i(e.data, I.data);
            G = new bm(B, I.itemSize, I.offset, I.normalized);
          } else {
            const B = Gw(I.type, I.array);
            G = new ls(B, I.itemSize, I.normalized);
          }
          I.name !== void 0 && (G.name = I.name), O.push(G);
        }
        l.morphAttributes[R] = O;
      }
    e.data.morphTargetsRelative && (l.morphTargetsRelative = !0);
    const w = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (w !== void 0)
      for (let R = 0, D = w.length; R !== D; ++R) {
        const O = w[R];
        l.addGroup(O.start, O.count, O.materialIndex);
      }
    const T = e.data.boundingSphere;
    if (T !== void 0) {
      const R = new ge();
      T.center !== void 0 && R.fromArray(T.center), l.boundingSphere = new yy(R, T.radius);
    }
    return e.name && (l.name = e.name), e.userData && (l.userData = e.userData), l;
  }
}
class v7 extends Rm {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const s = this, l = this.path === "" ? w3.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || l;
    const d = new O0(this.manager);
    d.setPath(this.path), d.setRequestHeader(this.requestHeader), d.setWithCredentials(this.withCredentials), d.load(e, function(p) {
      let g = null;
      try {
        g = JSON.parse(p);
      } catch (w) {
        i !== void 0 && i(w), console.error("THREE:ObjectLoader: Can't parse " + e + ".", w.message);
        return;
      }
      const _ = g.metadata;
      if (_ === void 0 || _.type === void 0 || _.type.toLowerCase() === "geometry") {
        console.error("THREE.ObjectLoader: Can't load " + e);
        return;
      }
      s.parse(g, t);
    }, r, i);
  }
  async loadAsync(e, t) {
    const r = this, i = this.path === "" ? w3.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || i;
    const s = new O0(this.manager);
    s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials);
    const l = await s.loadAsync(e, t), d = JSON.parse(l), p = d.metadata;
    if (p === void 0 || p.type === void 0 || p.type.toLowerCase() === "geometry")
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await r.parseAsync(d);
  }
  parse(e, t) {
    const r = this.parseAnimations(e.animations), i = this.parseShapes(e.shapes), s = this.parseGeometries(e.geometries, i), l = this.parseImages(e.images, function() {
      t !== void 0 && t(g);
    }), d = this.parseTextures(e.textures, l), p = this.parseMaterials(e.materials, d), g = this.parseObject(e.object, s, p, d, r), _ = this.parseSkeletons(e.skeletons, g);
    if (this.bindSkeletons(g, _), t !== void 0) {
      let w = !1;
      for (const T in l)
        if (l[T].data instanceof HTMLImageElement) {
          w = !0;
          break;
        }
      w === !1 && t(g);
    }
    return g;
  }
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations), r = this.parseShapes(e.shapes), i = this.parseGeometries(e.geometries, r), s = await this.parseImagesAsync(e.images), l = this.parseTextures(e.textures, s), d = this.parseMaterials(e.materials, l), p = this.parseObject(e.object, i, d, l, t), g = this.parseSkeletons(e.skeletons, p);
    return this.bindSkeletons(p, g), p;
  }
  parseShapes(e) {
    const t = {};
    if (e !== void 0)
      for (let r = 0, i = e.length; r < i; r++) {
        const s = new W_().fromJSON(e[r]);
        t[s.uuid] = s;
      }
    return t;
  }
  parseSkeletons(e, t) {
    const r = {}, i = {};
    if (t.traverse(function(s) {
      s.isBone && (i[s.uuid] = s);
    }), e !== void 0)
      for (let s = 0, l = e.length; s < l; s++) {
        const d = new YC().fromJSON(e[s], i);
        r[d.uuid] = d;
      }
    return r;
  }
  parseGeometries(e, t) {
    const r = {};
    if (e !== void 0) {
      const i = new Ck();
      for (let s = 0, l = e.length; s < l; s++) {
        let d;
        const p = e[s];
        switch (p.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            d = i.parse(p);
            break;
          case "Geometry":
            console.error("THREE.ObjectLoader: The legacy Geometry type is no longer supported.");
            break;
          default:
            p.type in OU ? d = OU[p.type].fromJSON(p, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${p.type}"`);
        }
        d.uuid = p.uuid, p.name !== void 0 && (d.name = p.name), d.isBufferGeometry === !0 && p.userData !== void 0 && (d.userData = p.userData), r[p.uuid] = d;
      }
    }
    return r;
  }
  parseMaterials(e, t) {
    const r = {}, i = {};
    if (e !== void 0) {
      const s = new KC();
      s.setTextures(t);
      for (let l = 0, d = e.length; l < d; l++) {
        const p = e[l];
        if (p.type === "MultiMaterial") {
          const g = [];
          for (let _ = 0; _ < p.materials.length; _++) {
            const w = p.materials[_];
            r[w.uuid] === void 0 && (r[w.uuid] = s.parse(w)), g.push(r[w.uuid]);
          }
          i[p.uuid] = g;
        } else
          r[p.uuid] === void 0 && (r[p.uuid] = s.parse(p)), i[p.uuid] = r[p.uuid];
      }
    }
    return i;
  }
  parseAnimations(e) {
    const t = {};
    if (e !== void 0)
      for (let r = 0; r < e.length; r++) {
        const i = e[r], s = WM.parse(i);
        t[s.uuid] = s;
      }
    return t;
  }
  parseImages(e, t) {
    const r = this, i = {};
    let s;
    function l(p) {
      return r.manager.itemStart(p), s.load(p, function() {
        r.manager.itemEnd(p);
      }, void 0, function() {
        r.manager.itemError(p), r.manager.itemEnd(p);
      });
    }
    function d(p) {
      if (typeof p == "string") {
        const g = p, _ = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(g) ? g : r.resourcePath + g;
        return l(_);
      } else
        return p.data ? {
          data: Gw(p.type, p.data),
          width: p.width,
          height: p.height
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      const p = new pL(t);
      s = new jM(p), s.setCrossOrigin(this.crossOrigin);
      for (let g = 0, _ = e.length; g < _; g++) {
        const w = e[g], T = w.url;
        if (Array.isArray(T)) {
          const R = [];
          for (let D = 0, O = T.length; D < O; D++) {
            const U = T[D], H = d(U);
            H !== null && (H instanceof HTMLImageElement ? R.push(H) : R.push(new qw(H.data, H.width, H.height)));
          }
          i[w.uuid] = new F_(R);
        } else {
          const R = d(w.url);
          i[w.uuid] = new F_(R);
        }
      }
    }
    return i;
  }
  async parseImagesAsync(e) {
    const t = this, r = {};
    let i;
    async function s(l) {
      if (typeof l == "string") {
        const d = l, p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(d) ? d : t.resourcePath + d;
        return await i.loadAsync(p);
      } else
        return l.data ? {
          data: Gw(l.type, l.data),
          width: l.width,
          height: l.height
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      i = new jM(this.manager), i.setCrossOrigin(this.crossOrigin);
      for (let l = 0, d = e.length; l < d; l++) {
        const p = e[l], g = p.url;
        if (Array.isArray(g)) {
          const _ = [];
          for (let w = 0, T = g.length; w < T; w++) {
            const R = g[w], D = await s(R);
            D !== null && (D instanceof HTMLImageElement ? _.push(D) : _.push(new qw(D.data, D.width, D.height)));
          }
          r[p.uuid] = new F_(_);
        } else {
          const _ = await s(p.url);
          r[p.uuid] = new F_(_);
        }
      }
    }
    return r;
  }
  parseTextures(e, t) {
    function r(s, l) {
      return typeof s == "number" ? s : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", s), l[s]);
    }
    const i = {};
    if (e !== void 0)
      for (let s = 0, l = e.length; s < l; s++) {
        const d = e[s];
        d.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', d.uuid), t[d.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", d.image);
        const p = t[d.image], g = p.data;
        let _;
        Array.isArray(g) ? (_ = new eT(), g.length === 6 && (_.needsUpdate = !0)) : (g && g.data ? _ = new qw() : _ = new su(), g && (_.needsUpdate = !0)), _.source = p, _.uuid = d.uuid, d.name !== void 0 && (_.name = d.name), d.mapping !== void 0 && (_.mapping = r(d.mapping, g7)), d.offset !== void 0 && _.offset.fromArray(d.offset), d.repeat !== void 0 && _.repeat.fromArray(d.repeat), d.center !== void 0 && _.center.fromArray(d.center), d.rotation !== void 0 && (_.rotation = d.rotation), d.wrap !== void 0 && (_.wrapS = r(d.wrap[0], kU), _.wrapT = r(d.wrap[1], kU)), d.format !== void 0 && (_.format = d.format), d.type !== void 0 && (_.type = d.type), d.encoding !== void 0 && (_.encoding = d.encoding), d.minFilter !== void 0 && (_.minFilter = r(d.minFilter, IU)), d.magFilter !== void 0 && (_.magFilter = r(d.magFilter, IU)), d.anisotropy !== void 0 && (_.anisotropy = d.anisotropy), d.flipY !== void 0 && (_.flipY = d.flipY), d.premultiplyAlpha !== void 0 && (_.premultiplyAlpha = d.premultiplyAlpha), d.unpackAlignment !== void 0 && (_.unpackAlignment = d.unpackAlignment), d.userData !== void 0 && (_.userData = d.userData), i[d.uuid] = _;
      }
    return i;
  }
  parseObject(e, t, r, i, s) {
    let l;
    function d(T) {
      return t[T] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", T), t[T];
    }
    function p(T) {
      if (T !== void 0) {
        if (Array.isArray(T)) {
          const R = [];
          for (let D = 0, O = T.length; D < O; D++) {
            const U = T[D];
            r[U] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", U), R.push(r[U]);
          }
          return R;
        }
        return r[T] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", T), r[T];
      }
    }
    function g(T) {
      return i[T] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", T), i[T];
    }
    let _, w;
    switch (e.type) {
      case "Scene":
        l = new NM(), e.background !== void 0 && (Number.isInteger(e.background) ? l.background = new Un(e.background) : l.background = g(e.background)), e.environment !== void 0 && (l.environment = g(e.environment)), e.fog !== void 0 && (e.fog.type === "Fog" ? l.fog = new WC(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (l.fog = new GC(e.fog.color, e.fog.density)));
        break;
      case "PerspectiveCamera":
        l = new ho(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (l.focus = e.focus), e.zoom !== void 0 && (l.zoom = e.zoom), e.filmGauge !== void 0 && (l.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (l.filmOffset = e.filmOffset), e.view !== void 0 && (l.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        l = new dy(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (l.zoom = e.zoom), e.view !== void 0 && (l.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        l = new Ek(e.color, e.intensity);
        break;
      case "DirectionalLight":
        l = new bk(e.color, e.intensity);
        break;
      case "PointLight":
        l = new wk(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        l = new Mk(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        l = new Sk(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
        break;
      case "HemisphereLight":
        l = new _k(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        l = new JC().fromJSON(e);
        break;
      case "SkinnedMesh":
        _ = d(e.geometry), w = p(e.material), l = new XF(_, w), e.bindMode !== void 0 && (l.bindMode = e.bindMode), e.bindMatrix !== void 0 && l.bindMatrix.fromArray(e.bindMatrix), e.skeleton !== void 0 && (l.skeleton = e.skeleton);
        break;
      case "Mesh":
        _ = d(e.geometry), w = p(e.material), l = new Fn(_, w);
        break;
      case "InstancedMesh":
        _ = d(e.geometry), w = p(e.material);
        const T = e.count, R = e.instanceMatrix, D = e.instanceColor;
        l = new qF(_, w, T), l.instanceMatrix = new q_(new Float32Array(R.array), 16), D !== void 0 && (l.instanceColor = new q_(new Float32Array(D.array), D.itemSize));
        break;
      case "LOD":
        l = new YF();
        break;
      case "Line":
        l = new fh(d(e.geometry), p(e.material));
        break;
      case "LineLoop":
        l = new QF(d(e.geometry), p(e.material));
        break;
      case "LineSegments":
        l = new xy(d(e.geometry), p(e.material));
        break;
      case "PointCloud":
      case "Points":
        l = new ZF(d(e.geometry), p(e.material));
        break;
      case "Sprite":
        l = new jF(p(e.material));
        break;
      case "Group":
        l = new jw();
        break;
      case "Bone":
        l = new tL();
        break;
      default:
        l = new Xa();
    }
    if (l.uuid = e.uuid, e.name !== void 0 && (l.name = e.name), e.matrix !== void 0 ? (l.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (l.matrixAutoUpdate = e.matrixAutoUpdate), l.matrixAutoUpdate && l.matrix.decompose(l.position, l.quaternion, l.scale)) : (e.position !== void 0 && l.position.fromArray(e.position), e.rotation !== void 0 && l.rotation.fromArray(e.rotation), e.quaternion !== void 0 && l.quaternion.fromArray(e.quaternion), e.scale !== void 0 && l.scale.fromArray(e.scale)), e.castShadow !== void 0 && (l.castShadow = e.castShadow), e.receiveShadow !== void 0 && (l.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.bias !== void 0 && (l.shadow.bias = e.shadow.bias), e.shadow.normalBias !== void 0 && (l.shadow.normalBias = e.shadow.normalBias), e.shadow.radius !== void 0 && (l.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && l.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (l.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (l.visible = e.visible), e.frustumCulled !== void 0 && (l.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (l.renderOrder = e.renderOrder), e.userData !== void 0 && (l.userData = e.userData), e.layers !== void 0 && (l.layers.mask = e.layers), e.children !== void 0) {
      const T = e.children;
      for (let R = 0; R < T.length; R++)
        l.add(this.parseObject(T[R], t, r, i, s));
    }
    if (e.animations !== void 0) {
      const T = e.animations;
      for (let R = 0; R < T.length; R++) {
        const D = T[R];
        l.animations.push(s[D]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (l.autoUpdate = e.autoUpdate);
      const T = e.levels;
      for (let R = 0; R < T.length; R++) {
        const D = T[R], O = l.getObjectByProperty("uuid", D.object);
        O !== void 0 && l.addLevel(O, D.distance);
      }
    }
    return l;
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 && e.traverse(function(r) {
      if (r.isSkinnedMesh === !0 && r.skeleton !== void 0) {
        const i = t[r.skeleton];
        i === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", r.skeleton) : r.bind(i, r.bindMatrix);
      }
    });
  }
}
const g7 = {
  UVMapping: FC,
  CubeReflectionMapping: t1,
  CubeRefractionMapping: n1,
  EquirectangularReflectionMapping: CM,
  EquirectangularRefractionMapping: RM,
  CubeUVReflectionMapping: hb
}, kU = {
  RepeatWrapping: Zw,
  ClampToEdgeWrapping: jh,
  MirroredRepeatWrapping: AM
}, IU = {
  NearestFilter: fo,
  NearestMipmapNearestFilter: EC,
  NearestMipmapLinearFilter: MC,
  LinearFilter: Oo,
  LinearMipmapNearestFilter: W3,
  LinearMipmapLinearFilter: s1
};
class y7 extends Rm {
  constructor(e) {
    super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
  }
  setOptions(e) {
    return this.options = e, this;
  }
  load(e, t, r, i) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const s = this, l = Z_.get(e);
    if (l !== void 0)
      return s.manager.itemStart(e), setTimeout(function() {
        t && t(l), s.manager.itemEnd(e);
      }, 0), l;
    const d = {};
    d.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", d.headers = this.requestHeader, fetch(e, d).then(function(p) {
      return p.blob();
    }).then(function(p) {
      return createImageBitmap(p, Object.assign(s.options, { colorSpaceConversion: "none" }));
    }).then(function(p) {
      Z_.add(e, p), t && t(p), s.manager.itemEnd(e);
    }).catch(function(p) {
      i && i(p), s.manager.itemError(e), s.manager.itemEnd(e);
    }), s.manager.itemStart(e);
  }
}
let H2;
const vL = {
  getContext: function() {
    return H2 === void 0 && (H2 = new (window.AudioContext || window.webkitAudioContext)()), H2;
  },
  setContext: function(a) {
    H2 = a;
  }
};
class x7 extends Rm {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const s = this, l = new O0(this.manager);
    l.setResponseType("arraybuffer"), l.setPath(this.path), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function(d) {
      try {
        const p = d.slice(0);
        vL.getContext().decodeAudioData(p, function(_) {
          t(_);
        });
      } catch (p) {
        i ? i(p) : console.error(p), s.manager.itemError(e);
      }
    }, r, i);
  }
}
class _7 extends JC {
  constructor(e, t, r = 1) {
    super(void 0, r), this.isHemisphereLightProbe = !0;
    const i = new Un().set(e), s = new Un().set(t), l = new ge(i.r, i.g, i.b), d = new ge(s.r, s.g, s.b), p = Math.sqrt(Math.PI), g = p * Math.sqrt(0.75);
    this.sh.coefficients[0].copy(l).add(d).multiplyScalar(p), this.sh.coefficients[1].copy(l).sub(d).multiplyScalar(g);
  }
}
class S7 extends JC {
  constructor(e, t = 1) {
    super(void 0, t), this.isAmbientLightProbe = !0;
    const r = new Un().set(e);
    this.sh.coefficients[0].set(r.r, r.g, r.b).multiplyScalar(2 * Math.sqrt(Math.PI));
  }
}
const BU = /* @__PURE__ */ new Kr(), HU = /* @__PURE__ */ new Kr(), g_ = /* @__PURE__ */ new Kr();
class w7 {
  constructor() {
    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new ho(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new ho(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
      focus: null,
      fov: null,
      aspect: null,
      near: null,
      far: null,
      zoom: null,
      eyeSep: null
    };
  }
  update(e) {
    const t = this._cache;
    if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
      t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, g_.copy(e.projectionMatrix);
      const i = t.eyeSep / 2, s = i * t.near / t.focus, l = t.near * Math.tan(H_ * t.fov * 0.5) / t.zoom;
      let d, p;
      HU.elements[12] = -i, BU.elements[12] = i, d = -l * t.aspect + s, p = l * t.aspect + s, g_.elements[0] = 2 * t.near / (p - d), g_.elements[8] = (p + d) / (p - d), this.cameraL.projectionMatrix.copy(g_), d = -l * t.aspect - s, p = l * t.aspect - s, g_.elements[0] = 2 * t.near / (p - d), g_.elements[8] = (p + d) / (p - d), this.cameraR.projectionMatrix.copy(g_);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(HU), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(BU);
  }
}
class gL {
  constructor(e = !0) {
    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
  }
  start() {
    this.startTime = VU(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  }
  stop() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      const t = VU();
      e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
    }
    return e;
  }
}
function VU() {
  return (typeof performance > "u" ? Date : performance).now();
}
const y_ = /* @__PURE__ */ new ge(), GU = /* @__PURE__ */ new Po(), b7 = /* @__PURE__ */ new ge(), x_ = /* @__PURE__ */ new ge();
class E7 extends Xa {
  constructor() {
    super(), this.type = "AudioListener", this.context = vL.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new gL();
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const t = this.context.listener, r = this.up;
    if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(y_, GU, b7), x_.set(0, 0, -1).applyQuaternion(GU), t.positionX) {
      const i = this.context.currentTime + this.timeDelta;
      t.positionX.linearRampToValueAtTime(y_.x, i), t.positionY.linearRampToValueAtTime(y_.y, i), t.positionZ.linearRampToValueAtTime(y_.z, i), t.forwardX.linearRampToValueAtTime(x_.x, i), t.forwardY.linearRampToValueAtTime(x_.y, i), t.forwardZ.linearRampToValueAtTime(x_.z, i), t.upX.linearRampToValueAtTime(r.x, i), t.upY.linearRampToValueAtTime(r.y, i), t.upZ.linearRampToValueAtTime(r.z, i);
    } else
      t.setPosition(y_.x, y_.y, y_.z), t.setOrientation(x_.x, x_.y, x_.z, r.x, r.y, r.z);
  }
}
class Rk extends Xa {
  constructor(e) {
    super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this;
  }
  setMediaElementSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this;
  }
  setMediaStreamSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this;
  }
  setBuffer(e) {
    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this;
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
  }
  stop() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else
      this.source.connect(this.getOutput());
    return this._connected = !0, this;
  }
  disconnect() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].disconnect(this.filters[e]);
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else
      this.source.disconnect(this.getOutput());
    return this._connected = !1, this;
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this;
  }
  setDetune(e) {
    if (this.detune = e, this.source.detune !== void 0)
      return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = !1;
  }
  getLoop() {
    return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this;
  }
  setLoopStart(e) {
    return this.loopStart = e, this;
  }
  setLoopEnd(e) {
    return this.loopEnd = e, this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
}
const __ = /* @__PURE__ */ new ge(), WU = /* @__PURE__ */ new Po(), M7 = /* @__PURE__ */ new ge(), S_ = /* @__PURE__ */ new ge();
class T7 extends Rk {
  constructor(e) {
    super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return this.panner.refDistance = e, this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return this.panner.rolloffFactor = e, this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return this.panner.distanceModel = e, this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return this.panner.maxDistance = e, this;
  }
  setDirectionalCone(e, t, r) {
    return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = r, this;
  }
  updateMatrixWorld(e) {
    if (super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1)
      return;
    this.matrixWorld.decompose(__, WU, M7), S_.set(0, 0, 1).applyQuaternion(WU);
    const t = this.panner;
    if (t.positionX) {
      const r = this.context.currentTime + this.listener.timeDelta;
      t.positionX.linearRampToValueAtTime(__.x, r), t.positionY.linearRampToValueAtTime(__.y, r), t.positionZ.linearRampToValueAtTime(__.z, r), t.orientationX.linearRampToValueAtTime(S_.x, r), t.orientationY.linearRampToValueAtTime(S_.y, r), t.orientationZ.linearRampToValueAtTime(S_.z, r);
    } else
      t.setPosition(__.x, __.y, __.z), t.setOrientation(S_.x, S_.y, S_.z);
  }
}
class C7 {
  constructor(e, t = 2048) {
    this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let e = 0;
    const t = this.getFrequencyData();
    for (let r = 0; r < t.length; r++)
      e += t[r];
    return e / t.length;
  }
}
class Ak {
  constructor(e, t, r) {
    this.binding = e, this.valueSize = r;
    let i, s, l;
    switch (t) {
      case "quaternion":
        i = this._slerp, s = this._slerpAdditive, l = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(r * 6), this._workIndex = 5;
        break;
      case "string":
      case "bool":
        i = this._select, s = this._select, l = this._setAdditiveIdentityOther, this.buffer = new Array(r * 5);
        break;
      default:
        i = this._lerp, s = this._lerpAdditive, l = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(r * 5);
    }
    this._mixBufferRegion = i, this._mixBufferRegionAdditive = s, this._setIdentity = l, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
  }
  accumulate(e, t) {
    const r = this.buffer, i = this.valueSize, s = e * i + i;
    let l = this.cumulativeWeight;
    if (l === 0) {
      for (let d = 0; d !== i; ++d)
        r[s + d] = r[d];
      l = t;
    } else {
      l += t;
      const d = t / l;
      this._mixBufferRegion(r, s, 0, d, i);
    }
    this.cumulativeWeight = l;
  }
  accumulateAdditive(e) {
    const t = this.buffer, r = this.valueSize, i = r * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, i, 0, e, r), this.cumulativeWeightAdditive += e;
  }
  apply(e) {
    const t = this.valueSize, r = this.buffer, i = e * t + t, s = this.cumulativeWeight, l = this.cumulativeWeightAdditive, d = this.binding;
    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, s < 1) {
      const p = t * this._origIndex;
      this._mixBufferRegion(
        r,
        i,
        p,
        1 - s,
        t
      );
    }
    l > 0 && this._mixBufferRegionAdditive(r, i, this._addIndex * t, 1, t);
    for (let p = t, g = t + t; p !== g; ++p)
      if (r[p] !== r[p + t]) {
        d.setValue(r, i);
        break;
      }
  }
  saveOriginalState() {
    const e = this.binding, t = this.buffer, r = this.valueSize, i = r * this._origIndex;
    e.getValue(t, i);
    for (let s = r, l = i; s !== l; ++s)
      t[s] = t[i + s % r];
    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
  }
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize, t = e + this.valueSize;
    for (let r = e; r < t; r++)
      this.buffer[r] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize;
    for (let r = 0; r < this.valueSize; r++)
      this.buffer[t + r] = this.buffer[e + r];
  }
  _select(e, t, r, i, s) {
    if (i >= 0.5)
      for (let l = 0; l !== s; ++l)
        e[t + l] = e[r + l];
  }
  _slerp(e, t, r, i) {
    Po.slerpFlat(e, t, e, t, e, r, i);
  }
  _slerpAdditive(e, t, r, i, s) {
    const l = this._workIndex * s;
    Po.multiplyQuaternionsFlat(e, l, e, t, e, r), Po.slerpFlat(e, t, e, t, e, l, i);
  }
  _lerp(e, t, r, i, s) {
    const l = 1 - i;
    for (let d = 0; d !== s; ++d) {
      const p = t + d;
      e[p] = e[p] * l + e[r + d] * i;
    }
  }
  _lerpAdditive(e, t, r, i, s) {
    for (let l = 0; l !== s; ++l) {
      const d = t + l;
      e[d] = e[d] + e[r + l] * i;
    }
  }
}
const yL = "\\[\\]\\.:\\/", R7 = new RegExp("[" + yL + "]", "g"), xL = "[^" + yL + "]", A7 = "[^" + yL.replace("\\.", "") + "]", D7 = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace("WC", xL), L7 = /* @__PURE__ */ /(WCOD+)?/.source.replace("WCOD", A7), P7 = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", xL), O7 = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", xL), U7 = new RegExp(
  "^" + D7 + L7 + P7 + O7 + "$"
), z7 = ["material", "materials", "bones"];
class N7 {
  constructor(e, t, r) {
    const i = r || Ja.parseTrackName(t);
    this._targetGroup = e, this._bindings = e.subscribe_(t, i);
  }
  getValue(e, t) {
    this.bind();
    const r = this._targetGroup.nCachedObjects_, i = this._bindings[r];
    i !== void 0 && i.getValue(e, t);
  }
  setValue(e, t) {
    const r = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, s = r.length; i !== s; ++i)
      r[i].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)
      e[t].unbind();
  }
}
class Ja {
  constructor(e, t, r) {
    this.path = t, this.parsedPath = r || Ja.parseTrackName(t), this.node = Ja.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
  static create(e, t, r) {
    return e && e.isAnimationObjectGroup ? new Ja.Composite(e, t, r) : new Ja(e, t, r);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(R7, "");
  }
  static parseTrackName(e) {
    const t = U7.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const r = {
      nodeName: t[2],
      objectName: t[3],
      objectIndex: t[4],
      propertyName: t[5],
      propertyIndex: t[6]
    }, i = r.nodeName && r.nodeName.lastIndexOf(".");
    if (i !== void 0 && i !== -1) {
      const s = r.nodeName.substring(i + 1);
      z7.indexOf(s) !== -1 && (r.nodeName = r.nodeName.substring(0, i), r.objectName = s);
    }
    if (r.propertyName === null || r.propertyName.length === 0)
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
    return r;
  }
  static findNode(e, t) {
    if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
      return e;
    if (e.skeleton) {
      const r = e.skeleton.getBoneByName(t);
      if (r !== void 0)
        return r;
    }
    if (e.children) {
      const r = function(s) {
        for (let l = 0; l < s.length; l++) {
          const d = s[l];
          if (d.name === t || d.uuid === t)
            return d;
          const p = r(d.children);
          if (p)
            return p;
        }
        return null;
      }, i = r(e.children);
      if (i)
        return i;
    }
    return null;
  }
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const r = this.resolvedProperty;
    for (let i = 0, s = r.length; i !== s; ++i)
      e[t++] = r[i];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_array(e, t) {
    const r = this.resolvedProperty;
    for (let i = 0, s = r.length; i !== s; ++i)
      r[i] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const r = this.resolvedProperty;
    for (let i = 0, s = r.length; i !== s; ++i)
      r[i] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const r = this.resolvedProperty;
    for (let i = 0, s = r.length; i !== s; ++i)
      r[i] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  bind() {
    let e = this.node;
    const t = this.parsedPath, r = t.objectName, i = t.propertyName;
    let s = t.propertyIndex;
    if (e || (e = Ja.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
      console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
      return;
    }
    if (r) {
      let g = t.objectIndex;
      switch (r) {
        case "materials":
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          e = e.skeleton.bones;
          for (let _ = 0; _ < e.length; _++)
            if (e[_].name === g) {
              g = _;
              break;
            }
          break;
        default:
          if (e[r] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          e = e[r];
      }
      if (g !== void 0) {
        if (e[g] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
          return;
        }
        e = e[g];
      }
    }
    const l = e[i];
    if (l === void 0) {
      const g = t.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + g + "." + i + " but it wasn't found.", e);
      return;
    }
    let d = this.Versioning.None;
    this.targetObject = e, e.needsUpdate !== void 0 ? d = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (d = this.Versioning.MatrixWorldNeedsUpdate);
    let p = this.BindingType.Direct;
    if (s !== void 0) {
      if (i === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          return;
        }
        e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s]);
      }
      p = this.BindingType.ArrayElement, this.resolvedProperty = l, this.propertyIndex = s;
    } else
      l.fromArray !== void 0 && l.toArray !== void 0 ? (p = this.BindingType.HasFromToArray, this.resolvedProperty = l) : Array.isArray(l) ? (p = this.BindingType.EntireArray, this.resolvedProperty = l) : this.propertyName = i;
    this.getValue = this.GetterByBindingType[p], this.setValue = this.SetterByBindingTypeAndVersioning[p][d];
  }
  unbind() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
}
Ja.Composite = N7;
Ja.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
Ja.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
Ja.prototype.GetterByBindingType = [
  Ja.prototype._getValue_direct,
  Ja.prototype._getValue_array,
  Ja.prototype._getValue_arrayElement,
  Ja.prototype._getValue_toArray
];
Ja.prototype.SetterByBindingTypeAndVersioning = [
  [
    Ja.prototype._setValue_direct,
    Ja.prototype._setValue_direct_setNeedsUpdate,
    Ja.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    Ja.prototype._setValue_array,
    Ja.prototype._setValue_array_setNeedsUpdate,
    Ja.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    Ja.prototype._setValue_arrayElement,
    Ja.prototype._setValue_arrayElement_setNeedsUpdate,
    Ja.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    Ja.prototype._setValue_fromArray,
    Ja.prototype._setValue_fromArray_setNeedsUpdate,
    Ja.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
class F7 {
  constructor() {
    this.isAnimationObjectGroup = !0, this.uuid = Em(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
    const e = {};
    this._indicesByUUID = e;
    for (let r = 0, i = arguments.length; r !== i; ++r)
      e[arguments[r].uuid] = r;
    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
    const t = this;
    this.stats = {
      objects: {
        get total() {
          return t._objects.length;
        },
        get inUse() {
          return this.total - t.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return t._bindings.length;
      }
    };
  }
  add() {
    const e = this._objects, t = this._indicesByUUID, r = this._paths, i = this._parsedPaths, s = this._bindings, l = s.length;
    let d, p = e.length, g = this.nCachedObjects_;
    for (let _ = 0, w = arguments.length; _ !== w; ++_) {
      const T = arguments[_], R = T.uuid;
      let D = t[R];
      if (D === void 0) {
        D = p++, t[R] = D, e.push(T);
        for (let O = 0, U = l; O !== U; ++O)
          s[O].push(new Ja(T, r[O], i[O]));
      } else if (D < g) {
        d = e[D];
        const O = --g, U = e[O];
        t[U.uuid] = D, e[D] = U, t[R] = O, e[O] = T;
        for (let H = 0, I = l; H !== I; ++H) {
          const G = s[H], B = G[O];
          let Q = G[D];
          G[D] = B, Q === void 0 && (Q = new Ja(T, r[H], i[H])), G[O] = Q;
        }
      } else
        e[D] !== d && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
    }
    this.nCachedObjects_ = g;
  }
  remove() {
    const e = this._objects, t = this._indicesByUUID, r = this._bindings, i = r.length;
    let s = this.nCachedObjects_;
    for (let l = 0, d = arguments.length; l !== d; ++l) {
      const p = arguments[l], g = p.uuid, _ = t[g];
      if (_ !== void 0 && _ >= s) {
        const w = s++, T = e[w];
        t[T.uuid] = _, e[_] = T, t[g] = w, e[w] = p;
        for (let R = 0, D = i; R !== D; ++R) {
          const O = r[R], U = O[w], H = O[_];
          O[_] = U, O[w] = H;
        }
      }
    }
    this.nCachedObjects_ = s;
  }
  uncache() {
    const e = this._objects, t = this._indicesByUUID, r = this._bindings, i = r.length;
    let s = this.nCachedObjects_, l = e.length;
    for (let d = 0, p = arguments.length; d !== p; ++d) {
      const g = arguments[d], _ = g.uuid, w = t[_];
      if (w !== void 0)
        if (delete t[_], w < s) {
          const T = --s, R = e[T], D = --l, O = e[D];
          t[R.uuid] = w, e[w] = R, t[O.uuid] = T, e[T] = O, e.pop();
          for (let U = 0, H = i; U !== H; ++U) {
            const I = r[U], G = I[T], B = I[D];
            I[w] = G, I[T] = B, I.pop();
          }
        } else {
          const T = --l, R = e[T];
          T > 0 && (t[R.uuid] = w), e[w] = R, e.pop();
          for (let D = 0, O = i; D !== O; ++D) {
            const U = r[D];
            U[w] = U[T], U.pop();
          }
        }
    }
    this.nCachedObjects_ = s;
  }
  subscribe_(e, t) {
    const r = this._bindingsIndicesByPath;
    let i = r[e];
    const s = this._bindings;
    if (i !== void 0)
      return s[i];
    const l = this._paths, d = this._parsedPaths, p = this._objects, g = p.length, _ = this.nCachedObjects_, w = new Array(g);
    i = s.length, r[e] = i, l.push(e), d.push(t), s.push(w);
    for (let T = _, R = p.length; T !== R; ++T) {
      const D = p[T];
      w[T] = new Ja(D, e, t);
    }
    return w;
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath, r = t[e];
    if (r !== void 0) {
      const i = this._paths, s = this._parsedPaths, l = this._bindings, d = l.length - 1, p = l[d], g = e[d];
      t[g] = r, l[r] = p, l.pop(), s[r] = s[d], s.pop(), i[r] = i[d], i.pop();
    }
  }
}
class k7 {
  constructor(e, t, r = null, i = t.blendMode) {
    this._mixer = e, this._clip = t, this._localRoot = r, this.blendMode = i;
    const s = t.tracks, l = s.length, d = new Array(l), p = {
      endingStart: z_,
      endingEnd: z_
    };
    for (let g = 0; g !== l; ++g) {
      const _ = s[g].createInterpolant(null);
      d[g] = _, _.settings = p;
    }
    this._interpolantSettings = p, this._interpolants = d, this._propertyBindings = new Array(l), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = MF, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
  }
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return this._startTime = e, this;
  }
  setLoop(e, t) {
    return this.loop = e, this.repetitions = t, this;
  }
  setEffectiveWeight(e) {
    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, r) {
    if (e.fadeOut(t), this.fadeIn(t), r) {
      const i = this._clip.duration, s = e._clip.duration, l = s / i, d = i / s;
      e.warp(1, l, t), this.warp(d, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, r) {
    return e.crossFadeFrom(this, t, r);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  setEffectiveTimeScale(e) {
    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return this.timeScale = this._clip.duration / e, this.stopWarping();
  }
  syncWith(e) {
    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, r) {
    const i = this._mixer, s = i.time, l = this.timeScale;
    let d = this._timeScaleInterpolant;
    d === null && (d = i._lendControlInterpolant(), this._timeScaleInterpolant = d);
    const p = d.parameterPositions, g = d.sampleValues;
    return p[0] = s, p[1] = s + r, g[0] = e / l, g[1] = t / l, this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(e, t, r, i) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const s = this._startTime;
    if (s !== null) {
      const p = (e - s) * r;
      if (p < 0 || r === 0)
        return;
      this._startTime = null, t = r * p;
    }
    t *= this._updateTimeScale(e);
    const l = this._updateTime(t), d = this._updateWeight(e);
    if (d > 0) {
      const p = this._interpolants, g = this._propertyBindings;
      switch (this.blendMode) {
        case Y3:
          for (let _ = 0, w = p.length; _ !== w; ++_)
            p[_].evaluate(l), g[_].accumulateAdditive(d);
          break;
        case kC:
        default:
          for (let _ = 0, w = p.length; _ !== w; ++_)
            p[_].evaluate(l), g[_].accumulate(i, d);
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const r = this._weightInterpolant;
      if (r !== null) {
        const i = r.evaluate(e)[0];
        t *= i, e > r.parameterPositions[1] && (this.stopFading(), i === 0 && (this.enabled = !1));
      }
    }
    return this._effectiveWeight = t, t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const r = this._timeScaleInterpolant;
      r !== null && (t *= r.evaluate(e)[0], e > r.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t));
    }
    return this._effectiveTimeScale = t, t;
  }
  _updateTime(e) {
    const t = this._clip.duration, r = this.loop;
    let i = this.time + e, s = this._loopCount;
    const l = r === TF;
    if (e === 0)
      return s === -1 ? i : l && (s & 1) === 1 ? t - i : i;
    if (r === EF) {
      s === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
      e: {
        if (i >= t)
          i = t;
        else if (i < 0)
          i = 0;
        else {
          this.time = i;
          break e;
        }
        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = i, this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: e < 0 ? -1 : 1
        });
      }
    } else {
      if (s === -1 && (e >= 0 ? (s = 0, this._setEndings(!0, this.repetitions === 0, l)) : this._setEndings(this.repetitions === 0, !0, l)), i >= t || i < 0) {
        const d = Math.floor(i / t);
        i -= t * d, s += Math.abs(d);
        const p = this.repetitions - s;
        if (p <= 0)
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, i = e > 0 ? t : 0, this.time = i, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e > 0 ? 1 : -1
          });
        else {
          if (p === 1) {
            const g = e < 0;
            this._setEndings(g, !g, l);
          } else
            this._setEndings(!1, !1, l);
          this._loopCount = s, this.time = i, this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta: d
          });
        }
      } else
        this.time = i;
      if (l && (s & 1) === 1)
        return t - i;
    }
    return i;
  }
  _setEndings(e, t, r) {
    const i = this._interpolantSettings;
    r ? (i.endingStart = N_, i.endingEnd = N_) : (e ? i.endingStart = this.zeroSlopeAtStart ? N_ : z_ : i.endingStart = PM, t ? i.endingEnd = this.zeroSlopeAtEnd ? N_ : z_ : i.endingEnd = PM);
  }
  _scheduleFading(e, t, r) {
    const i = this._mixer, s = i.time;
    let l = this._weightInterpolant;
    l === null && (l = i._lendControlInterpolant(), this._weightInterpolant = l);
    const d = l.parameterPositions, p = l.sampleValues;
    return d[0] = s, p[0] = t, d[1] = s + e, p[1] = r, this;
  }
}
const I7 = new Float32Array(1);
class B7 extends Cm {
  constructor(e) {
    super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
  }
  _bindAction(e, t) {
    const r = e._localRoot || this._root, i = e._clip.tracks, s = i.length, l = e._propertyBindings, d = e._interpolants, p = r.uuid, g = this._bindingsByRootAndName;
    let _ = g[p];
    _ === void 0 && (_ = {}, g[p] = _);
    for (let w = 0; w !== s; ++w) {
      const T = i[w], R = T.name;
      let D = _[R];
      if (D !== void 0)
        ++D.referenceCount, l[w] = D;
      else {
        if (D = l[w], D !== void 0) {
          D._cacheIndex === null && (++D.referenceCount, this._addInactiveBinding(D, p, R));
          continue;
        }
        const O = t && t._propertyBindings[w].binding.parsedPath;
        D = new Ak(
          Ja.create(r, R, O),
          T.ValueTypeName,
          T.getValueSize()
        ), ++D.referenceCount, this._addInactiveBinding(D, p, R), l[w] = D;
      }
      d[w].resultBuffer = D.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const r = (e._localRoot || this._root).uuid, i = e._clip.uuid, s = this._actionsByClip[i];
        this._bindAction(
          e,
          s && s.knownActions[0]
        ), this._addInactiveAction(e, i, r);
      }
      const t = e._propertyBindings;
      for (let r = 0, i = t.length; r !== i; ++r) {
        const s = t[r];
        s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let r = 0, i = t.length; r !== i; ++r) {
        const s = t[r];
        --s.useCount === 0 && (s.restoreOriginalState(), this._takeBackBinding(s));
      }
      this._takeBackAction(e);
    }
  }
  _initMemoryManager() {
    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        }
      }
    };
  }
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, r) {
    const i = this._actions, s = this._actionsByClip;
    let l = s[t];
    if (l === void 0)
      l = {
        knownActions: [e],
        actionByRoot: {}
      }, e._byClipCacheIndex = 0, s[t] = l;
    else {
      const d = l.knownActions;
      e._byClipCacheIndex = d.length, d.push(e);
    }
    e._cacheIndex = i.length, i.push(e), l.actionByRoot[r] = e;
  }
  _removeInactiveAction(e) {
    const t = this._actions, r = t[t.length - 1], i = e._cacheIndex;
    r._cacheIndex = i, t[i] = r, t.pop(), e._cacheIndex = null;
    const s = e._clip.uuid, l = this._actionsByClip, d = l[s], p = d.knownActions, g = p[p.length - 1], _ = e._byClipCacheIndex;
    g._byClipCacheIndex = _, p[_] = g, p.pop(), e._byClipCacheIndex = null;
    const w = d.actionByRoot, T = (e._localRoot || this._root).uuid;
    delete w[T], p.length === 0 && delete l[s], this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let r = 0, i = t.length; r !== i; ++r) {
      const s = t[r];
      --s.referenceCount === 0 && this._removeInactiveBinding(s);
    }
  }
  _lendAction(e) {
    const t = this._actions, r = e._cacheIndex, i = this._nActiveActions++, s = t[i];
    e._cacheIndex = i, t[i] = e, s._cacheIndex = r, t[r] = s;
  }
  _takeBackAction(e) {
    const t = this._actions, r = e._cacheIndex, i = --this._nActiveActions, s = t[i];
    e._cacheIndex = i, t[i] = e, s._cacheIndex = r, t[r] = s;
  }
  _addInactiveBinding(e, t, r) {
    const i = this._bindingsByRootAndName, s = this._bindings;
    let l = i[t];
    l === void 0 && (l = {}, i[t] = l), l[r] = e, e._cacheIndex = s.length, s.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings, r = e.binding, i = r.rootNode.uuid, s = r.path, l = this._bindingsByRootAndName, d = l[i], p = t[t.length - 1], g = e._cacheIndex;
    p._cacheIndex = g, t[g] = p, t.pop(), delete d[s], Object.keys(d).length === 0 && delete l[i];
  }
  _lendBinding(e) {
    const t = this._bindings, r = e._cacheIndex, i = this._nActiveBindings++, s = t[i];
    e._cacheIndex = i, t[i] = e, s._cacheIndex = r, t[r] = s;
  }
  _takeBackBinding(e) {
    const t = this._bindings, r = e._cacheIndex, i = --this._nActiveBindings, s = t[i];
    e._cacheIndex = i, t[i] = e, s._cacheIndex = r, t[r] = s;
  }
  _lendControlInterpolant() {
    const e = this._controlInterpolants, t = this._nActiveControlInterpolants++;
    let r = e[t];
    return r === void 0 && (r = new dL(
      new Float32Array(2),
      new Float32Array(2),
      1,
      I7
    ), r.__cacheIndex = t, e[t] = r), r;
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants, r = e.__cacheIndex, i = --this._nActiveControlInterpolants, s = t[i];
    e.__cacheIndex = i, t[i] = e, s.__cacheIndex = r, t[r] = s;
  }
  clipAction(e, t, r) {
    const i = t || this._root, s = i.uuid;
    let l = typeof e == "string" ? WM.findByName(i, e) : e;
    const d = l !== null ? l.uuid : e, p = this._actionsByClip[d];
    let g = null;
    if (r === void 0 && (l !== null ? r = l.blendMode : r = kC), p !== void 0) {
      const w = p.actionByRoot[s];
      if (w !== void 0 && w.blendMode === r)
        return w;
      g = p.knownActions[0], l === null && (l = g._clip);
    }
    if (l === null)
      return null;
    const _ = new k7(this, l, t, r);
    return this._bindAction(_, g), this._addInactiveAction(_, d, s), _;
  }
  existingAction(e, t) {
    const r = t || this._root, i = r.uuid, s = typeof e == "string" ? WM.findByName(r, e) : e, l = s ? s.uuid : e, d = this._actionsByClip[l];
    return d !== void 0 && d.actionByRoot[i] || null;
  }
  stopAllAction() {
    const e = this._actions, t = this._nActiveActions;
    for (let r = t - 1; r >= 0; --r)
      e[r].stop();
    return this;
  }
  update(e) {
    e *= this.timeScale;
    const t = this._actions, r = this._nActiveActions, i = this.time += e, s = Math.sign(e), l = this._accuIndex ^= 1;
    for (let g = 0; g !== r; ++g)
      t[g]._update(i, e, s, l);
    const d = this._bindings, p = this._nActiveBindings;
    for (let g = 0; g !== p; ++g)
      d[g].apply(l);
    return this;
  }
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++)
      this._actions[t].time = 0;
    return this.update(e);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(e) {
    const t = this._actions, r = e.uuid, i = this._actionsByClip, s = i[r];
    if (s !== void 0) {
      const l = s.knownActions;
      for (let d = 0, p = l.length; d !== p; ++d) {
        const g = l[d];
        this._deactivateAction(g);
        const _ = g._cacheIndex, w = t[t.length - 1];
        g._cacheIndex = null, g._byClipCacheIndex = null, w._cacheIndex = _, t[_] = w, t.pop(), this._removeInactiveBindingsForAction(g);
      }
      delete i[r];
    }
  }
  uncacheRoot(e) {
    const t = e.uuid, r = this._actionsByClip;
    for (const l in r) {
      const d = r[l].actionByRoot, p = d[t];
      p !== void 0 && (this._deactivateAction(p), this._removeInactiveAction(p));
    }
    const i = this._bindingsByRootAndName, s = i[t];
    if (s !== void 0)
      for (const l in s) {
        const d = s[l];
        d.restoreOriginalState(), this._removeInactiveBinding(d);
      }
  }
  uncacheAction(e, t) {
    const r = this.existingAction(e, t);
    r !== null && (this._deactivateAction(r), this._removeInactiveAction(r));
  }
}
class Pn {
  constructor(e) {
    typeof e == "string" && (console.warn("THREE.Uniform: Type parameter is no longer needed."), e = arguments[1]), this.value = e;
  }
  clone() {
    return new Pn(this.value.clone === void 0 ? this.value : this.value.clone());
  }
}
let H7 = 0;
class V7 extends Cm {
  constructor() {
    super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", { value: H7++ }), this.name = "", this.usage = OM, this.uniforms = [];
  }
  add(e) {
    return this.uniforms.push(e), this;
  }
  remove(e) {
    const t = this.uniforms.indexOf(e);
    return t !== -1 && this.uniforms.splice(t, 1), this;
  }
  setName(e) {
    return this.name = e, this;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(e) {
    this.name = e.name, this.usage = e.usage;
    const t = e.uniforms;
    this.uniforms.length = 0;
    for (let r = 0, i = t.length; r < i; r++)
      this.uniforms.push(t[r].clone());
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class RC extends jC {
  constructor(e, t, r = 1) {
    super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = r;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  clone(e) {
    const t = super.clone(e);
    return t.meshPerAttribute = this.meshPerAttribute, t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t;
  }
}
class G7 {
  constructor(e, t, r, i, s) {
    this.isGLBufferAttribute = !0, this.buffer = e, this.type = t, this.itemSize = r, this.elementSize = i, this.count = s, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setBuffer(e) {
    return this.buffer = e, this;
  }
  setType(e, t) {
    return this.type = e, this.elementSize = t, this;
  }
  setItemSize(e) {
    return this.itemSize = e, this;
  }
  setCount(e) {
    return this.count = e, this;
  }
}
class _L {
  constructor(e, t, r = 0, i = 1 / 0) {
    this.ray = new KM(e, t), this.near = r, this.far = i, this.camera = null, this.layers = new G_(), this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  intersectObject(e, t = !0, r = []) {
    return b3(e, this, r, t), r.sort(jU), r;
  }
  intersectObjects(e, t = !0, r = []) {
    for (let i = 0, s = e.length; i < s; i++)
      b3(e[i], this, r, t);
    return r.sort(jU), r;
  }
}
function jU(a, e) {
  return a.distance - e.distance;
}
function b3(a, e, t, r) {
  if (a.layers.test(e.layers) && a.raycast(e, t), r === !0) {
    const i = a.children;
    for (let s = 0, l = i.length; s < l; s++)
      b3(i[s], e, t, !0);
  }
}
class E3 {
  constructor(e = 1, t = 0, r = 0) {
    return this.radius = e, this.phi = t, this.theta = r, this;
  }
  set(e, t, r) {
    return this.radius = e, this.phi = t, this.theta = r, this;
  }
  copy(e) {
    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
  }
  makeSafe() {
    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, r) {
    return this.radius = Math.sqrt(e * e + t * t + r * r), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, r), this.phi = Math.acos(Zu(t / this.radius, -1, 1))), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class W7 {
  constructor(e = 1, t = 0, r = 0) {
    return this.radius = e, this.theta = t, this.y = r, this;
  }
  set(e, t, r) {
    return this.radius = e, this.theta = t, this.y = r, this;
  }
  copy(e) {
    return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, r) {
    return this.radius = Math.sqrt(e * e + r * r), this.theta = Math.atan2(e, r), this.y = t, this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const YU = /* @__PURE__ */ new zt();
class j7 {
  constructor(e = new zt(1 / 0, 1 / 0), t = new zt(-1 / 0, -1 / 0)) {
    this.isBox2 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const r = YU.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y);
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return YU.copy(e).clamp(this.min, this.max).sub(e).length();
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const XU = /* @__PURE__ */ new ge(), V2 = /* @__PURE__ */ new ge();
class SL {
  constructor(e = new ge(), t = new ge()) {
    this.start = e, this.end = t;
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    XU.subVectors(e, this.start), V2.subVectors(this.end, this.start);
    const r = V2.dot(V2);
    let s = V2.dot(XU) / r;
    return t && (s = Zu(s, 0, 1)), s;
  }
  closestPointToPoint(e, t, r) {
    const i = this.closestPointToPointParameter(e, t);
    return this.delta(r).multiplyScalar(i).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const qU = /* @__PURE__ */ new ge();
class Y7 extends Xa {
  constructor(e, t) {
    super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t;
    const r = new oi(), i = [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      -1,
      1
    ];
    for (let l = 0, d = 1, p = 32; l < p; l++, d++) {
      const g = l / p * Math.PI * 2, _ = d / p * Math.PI * 2;
      i.push(
        Math.cos(g),
        Math.sin(g),
        1,
        Math.cos(_),
        Math.sin(_),
        1
      );
    }
    r.setAttribute("position", new sr(i, 3));
    const s = new mh({ fog: !1, toneMapped: !1 });
    this.cone = new xy(r, s), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateMatrixWorld();
    const e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, e), qU.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(qU), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
  }
}
const jx = /* @__PURE__ */ new ge(), G2 = /* @__PURE__ */ new Kr(), rD = /* @__PURE__ */ new Kr();
class X7 extends xy {
  constructor(e) {
    const t = Dk(e), r = new oi(), i = [], s = [], l = new Un(0, 0, 1), d = new Un(0, 1, 0);
    for (let g = 0; g < t.length; g++) {
      const _ = t[g];
      _.parent && _.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), s.push(l.r, l.g, l.b), s.push(d.r, d.g, d.b));
    }
    r.setAttribute("position", new sr(i, 3)), r.setAttribute("color", new sr(s, 3));
    const p = new mh({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 });
    super(r, p), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1;
  }
  updateMatrixWorld(e) {
    const t = this.bones, r = this.geometry, i = r.getAttribute("position");
    rD.copy(this.root.matrixWorld).invert();
    for (let s = 0, l = 0; s < t.length; s++) {
      const d = t[s];
      d.parent && d.parent.isBone && (G2.multiplyMatrices(rD, d.matrixWorld), jx.setFromMatrixPosition(G2), i.setXYZ(l, jx.x, jx.y, jx.z), G2.multiplyMatrices(rD, d.parent.matrixWorld), jx.setFromMatrixPosition(G2), i.setXYZ(l + 1, jx.x, jx.y, jx.z), l += 2);
    }
    r.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e);
  }
}
function Dk(a) {
  const e = [];
  a.isBone === !0 && e.push(a);
  for (let t = 0; t < a.children.length; t++)
    e.push.apply(e, Dk(a.children[t]));
  return e;
}
class q7 extends Fn {
  constructor(e, t, r) {
    const i = new ug(t, 4, 2), s = new fg({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(i, s), this.light = e, this.light.updateMatrixWorld(), this.color = r, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
  }
}
const Q7 = /* @__PURE__ */ new ge(), QU = /* @__PURE__ */ new Un(), ZU = /* @__PURE__ */ new Un();
class Z7 extends Xa {
  constructor(e, t, r) {
    super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = r;
    const i = new sg(t);
    i.rotateY(Math.PI * 0.5), this.material = new fg({ wireframe: !0, fog: !1, toneMapped: !1 }), this.color === void 0 && (this.material.vertexColors = !0);
    const s = i.getAttribute("position"), l = new Float32Array(s.count * 3);
    i.setAttribute("color", new ls(l, 3)), this.add(new Fn(i, this.material)), this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0)
      this.material.color.set(this.color);
    else {
      const t = e.geometry.getAttribute("color");
      QU.copy(this.light.color), ZU.copy(this.light.groundColor);
      for (let r = 0, i = t.count; r < i; r++) {
        const s = r < i / 2 ? QU : ZU;
        t.setXYZ(r, s.r, s.g, s.b);
      }
      t.needsUpdate = !0;
    }
    e.lookAt(Q7.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class J7 extends xy {
  constructor(e = 10, t = 10, r = 4473924, i = 8947848) {
    r = new Un(r), i = new Un(i);
    const s = t / 2, l = e / t, d = e / 2, p = [], g = [];
    for (let T = 0, R = 0, D = -d; T <= t; T++, D += l) {
      p.push(-d, 0, D, d, 0, D), p.push(D, 0, -d, D, 0, d);
      const O = T === s ? r : i;
      O.toArray(g, R), R += 3, O.toArray(g, R), R += 3, O.toArray(g, R), R += 3, O.toArray(g, R), R += 3;
    }
    const _ = new oi();
    _.setAttribute("position", new sr(p, 3)), _.setAttribute("color", new sr(g, 3));
    const w = new mh({ vertexColors: !0, toneMapped: !1 });
    super(_, w), this.type = "GridHelper";
  }
}
class K7 extends xy {
  constructor(e = 10, t = 16, r = 8, i = 64, s = 4473924, l = 8947848) {
    s = new Un(s), l = new Un(l);
    const d = [], p = [];
    for (let w = 0; w <= t; w++) {
      const T = w / t * (Math.PI * 2), R = Math.sin(T) * e, D = Math.cos(T) * e;
      d.push(0, 0, 0), d.push(R, 0, D);
      const O = w & 1 ? s : l;
      p.push(O.r, O.g, O.b), p.push(O.r, O.g, O.b);
    }
    for (let w = 0; w <= r; w++) {
      const T = w & 1 ? s : l, R = e - e / r * w;
      for (let D = 0; D < i; D++) {
        let O = D / i * (Math.PI * 2), U = Math.sin(O) * R, H = Math.cos(O) * R;
        d.push(U, 0, H), p.push(T.r, T.g, T.b), O = (D + 1) / i * (Math.PI * 2), U = Math.sin(O) * R, H = Math.cos(O) * R, d.push(U, 0, H), p.push(T.r, T.g, T.b);
      }
    }
    const g = new oi();
    g.setAttribute("position", new sr(d, 3)), g.setAttribute("color", new sr(p, 3));
    const _ = new mh({ vertexColors: !0, toneMapped: !1 });
    super(g, _), this.type = "PolarGridHelper";
  }
}
const JU = /* @__PURE__ */ new ge(), W2 = /* @__PURE__ */ new ge(), KU = /* @__PURE__ */ new ge();
class $7 extends Xa {
  constructor(e, t, r) {
    super(), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = r, t === void 0 && (t = 1);
    let i = new oi();
    i.setAttribute("position", new sr([
      -t,
      t,
      0,
      t,
      t,
      0,
      t,
      -t,
      0,
      -t,
      -t,
      0,
      -t,
      t,
      0
    ], 3));
    const s = new mh({ fog: !1, toneMapped: !1 });
    this.lightPlane = new fh(i, s), this.add(this.lightPlane), i = new oi(), i.setAttribute("position", new sr([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new fh(i, s), this.add(this.targetLine), this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
  }
  update() {
    JU.setFromMatrixPosition(this.light.matrixWorld), W2.setFromMatrixPosition(this.light.target.matrixWorld), KU.subVectors(W2, JU), this.lightPlane.lookAt(W2), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(W2), this.targetLine.scale.z = KU.length();
  }
}
const j2 = /* @__PURE__ */ new ge(), Eu = /* @__PURE__ */ new pb();
class e9 extends xy {
  constructor(e) {
    const t = new oi(), r = new mh({ color: 16777215, vertexColors: !0, toneMapped: !1 }), i = [], s = [], l = {};
    d("n1", "n2"), d("n2", "n4"), d("n4", "n3"), d("n3", "n1"), d("f1", "f2"), d("f2", "f4"), d("f4", "f3"), d("f3", "f1"), d("n1", "f1"), d("n2", "f2"), d("n3", "f3"), d("n4", "f4"), d("p", "n1"), d("p", "n2"), d("p", "n3"), d("p", "n4"), d("u1", "u2"), d("u2", "u3"), d("u3", "u1"), d("c", "t"), d("p", "c"), d("cn1", "cn2"), d("cn3", "cn4"), d("cf1", "cf2"), d("cf3", "cf4");
    function d(D, O) {
      p(D), p(O);
    }
    function p(D) {
      i.push(0, 0, 0), s.push(0, 0, 0), l[D] === void 0 && (l[D] = []), l[D].push(i.length / 3 - 1);
    }
    t.setAttribute("position", new sr(i, 3)), t.setAttribute("color", new sr(s, 3)), super(t, r), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = l, this.update();
    const g = new Un(16755200), _ = new Un(16711680), w = new Un(43775), T = new Un(16777215), R = new Un(3355443);
    this.setColors(g, _, w, T, R);
  }
  setColors(e, t, r, i, s) {
    const d = this.geometry.getAttribute("color");
    d.setXYZ(0, e.r, e.g, e.b), d.setXYZ(1, e.r, e.g, e.b), d.setXYZ(2, e.r, e.g, e.b), d.setXYZ(3, e.r, e.g, e.b), d.setXYZ(4, e.r, e.g, e.b), d.setXYZ(5, e.r, e.g, e.b), d.setXYZ(6, e.r, e.g, e.b), d.setXYZ(7, e.r, e.g, e.b), d.setXYZ(8, e.r, e.g, e.b), d.setXYZ(9, e.r, e.g, e.b), d.setXYZ(10, e.r, e.g, e.b), d.setXYZ(11, e.r, e.g, e.b), d.setXYZ(12, e.r, e.g, e.b), d.setXYZ(13, e.r, e.g, e.b), d.setXYZ(14, e.r, e.g, e.b), d.setXYZ(15, e.r, e.g, e.b), d.setXYZ(16, e.r, e.g, e.b), d.setXYZ(17, e.r, e.g, e.b), d.setXYZ(18, e.r, e.g, e.b), d.setXYZ(19, e.r, e.g, e.b), d.setXYZ(20, e.r, e.g, e.b), d.setXYZ(21, e.r, e.g, e.b), d.setXYZ(22, e.r, e.g, e.b), d.setXYZ(23, e.r, e.g, e.b), d.setXYZ(24, t.r, t.g, t.b), d.setXYZ(25, t.r, t.g, t.b), d.setXYZ(26, t.r, t.g, t.b), d.setXYZ(27, t.r, t.g, t.b), d.setXYZ(28, t.r, t.g, t.b), d.setXYZ(29, t.r, t.g, t.b), d.setXYZ(30, t.r, t.g, t.b), d.setXYZ(31, t.r, t.g, t.b), d.setXYZ(32, r.r, r.g, r.b), d.setXYZ(33, r.r, r.g, r.b), d.setXYZ(34, r.r, r.g, r.b), d.setXYZ(35, r.r, r.g, r.b), d.setXYZ(36, r.r, r.g, r.b), d.setXYZ(37, r.r, r.g, r.b), d.setXYZ(38, i.r, i.g, i.b), d.setXYZ(39, i.r, i.g, i.b), d.setXYZ(40, s.r, s.g, s.b), d.setXYZ(41, s.r, s.g, s.b), d.setXYZ(42, s.r, s.g, s.b), d.setXYZ(43, s.r, s.g, s.b), d.setXYZ(44, s.r, s.g, s.b), d.setXYZ(45, s.r, s.g, s.b), d.setXYZ(46, s.r, s.g, s.b), d.setXYZ(47, s.r, s.g, s.b), d.setXYZ(48, s.r, s.g, s.b), d.setXYZ(49, s.r, s.g, s.b), d.needsUpdate = !0;
  }
  update() {
    const e = this.geometry, t = this.pointMap, r = 1, i = 1;
    Eu.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Qu("c", t, e, Eu, 0, 0, -1), Qu("t", t, e, Eu, 0, 0, 1), Qu("n1", t, e, Eu, -r, -i, -1), Qu("n2", t, e, Eu, r, -i, -1), Qu("n3", t, e, Eu, -r, i, -1), Qu("n4", t, e, Eu, r, i, -1), Qu("f1", t, e, Eu, -r, -i, 1), Qu("f2", t, e, Eu, r, -i, 1), Qu("f3", t, e, Eu, -r, i, 1), Qu("f4", t, e, Eu, r, i, 1), Qu("u1", t, e, Eu, r * 0.7, i * 1.1, -1), Qu("u2", t, e, Eu, -r * 0.7, i * 1.1, -1), Qu("u3", t, e, Eu, 0, i * 2, -1), Qu("cf1", t, e, Eu, -r, 0, 1), Qu("cf2", t, e, Eu, r, 0, 1), Qu("cf3", t, e, Eu, 0, -i, 1), Qu("cf4", t, e, Eu, 0, i, 1), Qu("cn1", t, e, Eu, -r, 0, -1), Qu("cn2", t, e, Eu, r, 0, -1), Qu("cn3", t, e, Eu, 0, -i, -1), Qu("cn4", t, e, Eu, 0, i, -1), e.getAttribute("position").needsUpdate = !0;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function Qu(a, e, t, r, i, s, l) {
  j2.set(i, s, l).unproject(r);
  const d = e[a];
  if (d !== void 0) {
    const p = t.getAttribute("position");
    for (let g = 0, _ = d.length; g < _; g++)
      p.setXYZ(d[g], j2.x, j2.y, j2.z);
  }
}
const Y2 = /* @__PURE__ */ new cg();
class t9 extends xy {
  constructor(e, t = 16776960) {
    const r = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i = new Float32Array(8 * 3), s = new oi();
    s.setIndex(new ls(r, 1)), s.setAttribute("position", new ls(i, 3)), super(s, new mh({ color: t, toneMapped: !1 })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update();
  }
  update(e) {
    if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && Y2.setFromObject(this.object), Y2.isEmpty())
      return;
    const t = Y2.min, r = Y2.max, i = this.geometry.attributes.position, s = i.array;
    s[0] = r.x, s[1] = r.y, s[2] = r.z, s[3] = t.x, s[4] = r.y, s[5] = r.z, s[6] = t.x, s[7] = t.y, s[8] = r.z, s[9] = r.x, s[10] = t.y, s[11] = r.z, s[12] = r.x, s[13] = r.y, s[14] = t.z, s[15] = t.x, s[16] = r.y, s[17] = t.z, s[18] = t.x, s[19] = t.y, s[20] = t.z, s[21] = r.x, s[22] = t.y, s[23] = t.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return this.object = e, this.update(), this;
  }
  copy(e, t) {
    return super.copy(e, t), this.object = e.object, this;
  }
}
class n9 extends xy {
  constructor(e, t = 16776960) {
    const r = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], s = new oi();
    s.setIndex(new ls(r, 1)), s.setAttribute("position", new sr(i, 3)), super(s, new mh({ color: t, toneMapped: !1 })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(0.5), super.updateMatrixWorld(e));
  }
}
class r9 extends fh {
  constructor(e, t = 1, r = 16776960) {
    const i = r, s = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], l = new oi();
    l.setAttribute("position", new sr(s, 3)), l.computeBoundingSphere(), super(l, new mh({ color: i, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = e, this.size = t;
    const d = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], p = new oi();
    p.setAttribute("position", new sr(d, 3)), p.computeBoundingSphere(), this.add(new Fn(p, new fg({ color: i, opacity: 0.2, transparent: !0, depthWrite: !1, toneMapped: !1 })));
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0), this.scale.set(0.5 * this.size, 0.5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e);
  }
}
const $U = /* @__PURE__ */ new ge();
let X2, iD;
class i9 extends Xa {
  constructor(e = new ge(0, 0, 1), t = new ge(0, 0, 0), r = 1, i = 16776960, s = r * 0.2, l = s * 0.2) {
    super(), this.type = "ArrowHelper", X2 === void 0 && (X2 = new oi(), X2.setAttribute("position", new sr([0, 0, 0, 0, 1, 0], 3)), iD = new Ko(0, 0.5, 1, 5, 1), iD.translate(0, -0.5, 0)), this.position.copy(t), this.line = new fh(X2, new mh({ color: i, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Fn(iD, new fg({ color: i, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(r, s, l);
  }
  setDirection(e) {
    if (e.y > 0.99999)
      this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999)
      this.quaternion.set(1, 0, 0, 0);
    else {
      $U.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle($U, t);
    }
  }
  setLength(e, t = e * 0.2, r = t * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(r, t, r), this.cone.position.y = e, this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this;
  }
}
class a9 extends xy {
  constructor(e = 1) {
    const t = [
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e
    ], r = [
      1,
      0,
      0,
      1,
      0.6,
      0,
      0,
      1,
      0,
      0.6,
      1,
      0,
      0,
      0,
      1,
      0,
      0.6,
      1
    ], i = new oi();
    i.setAttribute("position", new sr(t, 3)), i.setAttribute("color", new sr(r, 3));
    const s = new mh({ vertexColors: !0, toneMapped: !1 });
    super(i, s), this.type = "AxesHelper";
  }
  setColors(e, t, r) {
    const i = new Un(), s = this.geometry.attributes.color.array;
    return i.set(e), i.toArray(s, 0), i.toArray(s, 3), i.set(t), i.toArray(s, 6), i.toArray(s, 9), i.set(r), i.toArray(s, 12), i.toArray(s, 15), this.geometry.attributes.color.needsUpdate = !0, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class s9 {
  constructor() {
    this.type = "ShapePath", this.color = new Un(), this.subPaths = [], this.currentPath = null;
  }
  moveTo(e, t) {
    return this.currentPath = new FM(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this;
  }
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this;
  }
  quadraticCurveTo(e, t, r, i) {
    return this.currentPath.quadraticCurveTo(e, t, r, i), this;
  }
  bezierCurveTo(e, t, r, i, s, l) {
    return this.currentPath.bezierCurveTo(e, t, r, i, s, l), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e, t) {
    function r(I) {
      const G = [];
      for (let B = 0, Q = I.length; B < Q; B++) {
        const K = I[B], te = new W_();
        te.curves = K.curves, G.push(te);
      }
      return G;
    }
    function i(I, G) {
      const B = G.length;
      let Q = !1;
      for (let K = B - 1, te = 0; te < B; K = te++) {
        let Y = G[K], re = G[te], se = re.x - Y.x, ce = re.y - Y.y;
        if (Math.abs(ce) > Number.EPSILON) {
          if (ce < 0 && (Y = G[te], se = -se, re = G[K], ce = -ce), I.y < Y.y || I.y > re.y)
            continue;
          if (I.y === Y.y) {
            if (I.x === Y.x)
              return !0;
          } else {
            const ue = ce * (I.x - Y.x) - se * (I.y - Y.y);
            if (ue === 0)
              return !0;
            if (ue < 0)
              continue;
            Q = !Q;
          }
        } else {
          if (I.y !== Y.y)
            continue;
          if (re.x <= I.x && I.x <= Y.x || Y.x <= I.x && I.x <= re.x)
            return !0;
        }
      }
      return Q;
    }
    const s = hy.isClockWise, l = this.subPaths;
    if (l.length === 0)
      return [];
    if (t === !0)
      return r(l);
    let d, p, g;
    const _ = [];
    if (l.length === 1)
      return p = l[0], g = new W_(), g.curves = p.curves, _.push(g), _;
    let w = !s(l[0].getPoints());
    w = e ? !w : w;
    const T = [], R = [];
    let D = [], O = 0, U;
    R[O] = void 0, D[O] = [];
    for (let I = 0, G = l.length; I < G; I++)
      p = l[I], U = p.getPoints(), d = s(U), d = e ? !d : d, d ? (!w && R[O] && O++, R[O] = { s: new W_(), p: U }, R[O].s.curves = p.curves, w && O++, D[O] = []) : D[O].push({ h: p, p: U[0] });
    if (!R[0])
      return r(l);
    if (R.length > 1) {
      let I = !1, G = 0;
      for (let B = 0, Q = R.length; B < Q; B++)
        T[B] = [];
      for (let B = 0, Q = R.length; B < Q; B++) {
        const K = D[B];
        for (let te = 0; te < K.length; te++) {
          const Y = K[te];
          let re = !0;
          for (let se = 0; se < R.length; se++)
            i(Y.p, R[se].p) && (B !== se && G++, re ? (re = !1, T[se].push(Y)) : I = !0);
          re && T[B].push(Y);
        }
      }
      G > 0 && I === !1 && (D = T);
    }
    let H;
    for (let I = 0, G = R.length; I < G; I++) {
      g = R[I].s, _.push(g), H = D[I];
      for (let B = 0, Q = H.length; B < Q; B++)
        g.holes.push(H[B].h);
    }
    return _;
  }
}
const A0 = /* @__PURE__ */ o9();
function o9() {
  const a = new ArrayBuffer(4), e = new Float32Array(a), t = new Uint32Array(a), r = new Uint32Array(512), i = new Uint32Array(512);
  for (let p = 0; p < 256; ++p) {
    const g = p - 127;
    g < -27 ? (r[p] = 0, r[p | 256] = 32768, i[p] = 24, i[p | 256] = 24) : g < -14 ? (r[p] = 1024 >> -g - 14, r[p | 256] = 1024 >> -g - 14 | 32768, i[p] = -g - 1, i[p | 256] = -g - 1) : g <= 15 ? (r[p] = g + 15 << 10, r[p | 256] = g + 15 << 10 | 32768, i[p] = 13, i[p | 256] = 13) : g < 128 ? (r[p] = 31744, r[p | 256] = 64512, i[p] = 24, i[p | 256] = 24) : (r[p] = 31744, r[p | 256] = 64512, i[p] = 13, i[p | 256] = 13);
  }
  const s = new Uint32Array(2048), l = new Uint32Array(64), d = new Uint32Array(64);
  for (let p = 1; p < 1024; ++p) {
    let g = p << 13, _ = 0;
    for (; (g & 8388608) === 0; )
      g <<= 1, _ -= 8388608;
    g &= -8388609, _ += 947912704, s[p] = g | _;
  }
  for (let p = 1024; p < 2048; ++p)
    s[p] = 939524096 + (p - 1024 << 13);
  for (let p = 1; p < 31; ++p)
    l[p] = p << 23;
  l[31] = 1199570944, l[32] = 2147483648;
  for (let p = 33; p < 63; ++p)
    l[p] = 2147483648 + (p - 32 << 23);
  l[63] = 3347054592;
  for (let p = 1; p < 64; ++p)
    p !== 32 && (d[p] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: r,
    shiftTable: i,
    mantissaTable: s,
    exponentTable: l,
    offsetTable: d
  };
}
function l9(a) {
  Math.abs(a) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), a = Zu(a, -65504, 65504), A0.floatView[0] = a;
  const e = A0.uint32View[0], t = e >> 23 & 511;
  return A0.baseTable[t] + ((e & 8388607) >> A0.shiftTable[t]);
}
function u9(a) {
  const e = a >> 10;
  return A0.uint32View[0] = A0.mantissaTable[A0.offsetTable[e] + (a & 1023)] + A0.exponentTable[e], A0.floatView[0];
}
var c9 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  toHalfFloat: l9,
  fromHalfFloat: u9
});
class f9 extends oi {
  constructor() {
    console.error("THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js"), super();
  }
}
class d9 extends oi {
  constructor() {
    console.error("THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js"), super();
  }
}
function h9() {
  console.error("THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js");
}
function p9() {
  console.error("THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js");
}
function m9() {
  console.error("THREE.ImmediateRenderObject has been removed.");
}
class v9 extends po {
  constructor(e, t, r) {
    console.error('THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.'), super(e, t, r), this.samples = 4;
  }
}
class g9 extends JM {
  constructor(e, t, r, i) {
    console.warn("THREE.DataTexture2DArray has been renamed to DataArrayTexture."), super(e, t, r, i);
  }
}
class y9 extends IC {
  constructor(e, t, r, i) {
    console.warn("THREE.DataTexture3D has been renamed to Data3DTexture."), super(e, t, r, i);
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: a1
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = a1);
const x9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ACESFilmicToneMapping: G3,
  AddEquation: L_,
  AddOperation: iF,
  AdditiveAnimationBlendMode: Y3,
  AdditiveBlending: wC,
  AlphaFormat: pF,
  AlwaysDepth: JN,
  AlwaysStencilFunc: RF,
  AmbientLight: Ek,
  AmbientLightProbe: S7,
  AnimationClip: WM,
  AnimationLoader: l7,
  AnimationMixer: B7,
  AnimationObjectGroup: F7,
  AnimationUtils: i7,
  ArcCurve: KF,
  ArrayCamera: VF,
  ArrowHelper: i9,
  Audio: Rk,
  AudioAnalyser: C7,
  AudioContext: vL,
  AudioListener: E7,
  AudioLoader: x7,
  AxesHelper: a9,
  BackSide: cf,
  BasicDepthPacking: o1,
  BasicShadowMap: FN,
  Bone: tL,
  BooleanKeyframeTrack: eS,
  Box2: j7,
  Box3: cg,
  Box3Helper: n9,
  BoxBufferGeometry: fl,
  BoxGeometry: fl,
  BoxHelper: t9,
  BufferAttribute: ls,
  BufferGeometry: oi,
  BufferGeometryLoader: Ck,
  ByteType: uF,
  Cache: Z_,
  Camera: pb,
  CameraHelper: e9,
  CanvasTexture: RW,
  CapsuleBufferGeometry: $w,
  CapsuleGeometry: $w,
  CatmullRomCurve3: $F,
  CineonToneMapping: oF,
  CircleBufferGeometry: eb,
  CircleGeometry: eb,
  ClampToEdgeWrapping: jh,
  Clock: gL,
  Color: Un,
  ColorKeyframeTrack: hL,
  ColorManagement: xv,
  CompressedTexture: JF,
  CompressedTextureLoader: u7,
  ConeBufferGeometry: tb,
  ConeGeometry: tb,
  CubeCamera: OF,
  CubeReflectionMapping: t1,
  CubeRefractionMapping: n1,
  CubeTexture: eT,
  CubeTextureLoader: c7,
  CubeUVReflectionMapping: hb,
  CubicBezierCurve: rL,
  CubicBezierCurve3: ek,
  CubicInterpolant: vk,
  CullFaceBack: VD,
  CullFaceFront: NN,
  CullFaceFrontBack: O5,
  CullFaceNone: zN,
  Curve: dg,
  CurvePath: nk,
  CustomBlending: IN,
  CustomToneMapping: lF,
  CylinderBufferGeometry: Ko,
  CylinderGeometry: Ko,
  Cylindrical: W7,
  Data3DTexture: IC,
  DataArrayTexture: JM,
  DataTexture: qw,
  DataTexture2DArray: g9,
  DataTexture3D: y9,
  DataTextureLoader: f7,
  DataUtils: c9,
  DecrementStencilOp: Y5,
  DecrementWrapStencilOp: q5,
  DefaultLoadingManager: xk,
  DepthFormat: $x,
  DepthStencilFormat: r1,
  DepthTexture: K3,
  DirectionalLight: bk,
  DirectionalLightHelper: $7,
  DiscreteInterpolant: gk,
  DodecahedronBufferGeometry: nb,
  DodecahedronGeometry: nb,
  DoubleSide: Yh,
  DstAlphaFactor: jN,
  DstColorFactor: XN,
  DynamicCopyUsage: lH,
  DynamicDrawUsage: B_,
  DynamicReadUsage: aH,
  EdgesGeometry: rk,
  EllipseCurve: qC,
  EqualDepth: $N,
  EqualStencilFunc: K5,
  EquirectangularReflectionMapping: CM,
  EquirectangularRefractionMapping: RM,
  Euler: $_,
  EventDispatcher: Cm,
  ExtrudeBufferGeometry: rb,
  ExtrudeGeometry: rb,
  FileLoader: O0,
  FlatShading: kN,
  Float16BufferAttribute: WH,
  Float32BufferAttribute: sr,
  Float64BufferAttribute: jH,
  FloatType: fy,
  Fog: WC,
  FogExp2: GC,
  Font: p9,
  FontLoader: h9,
  FramebufferTexture: CW,
  FrontSide: vy,
  Frustum: BC,
  GLBufferAttribute: G7,
  GLSL1: cH,
  GLSL3: p3,
  GreaterDepth: tF,
  GreaterEqualDepth: eF,
  GreaterEqualStencilFunc: nH,
  GreaterStencilFunc: eH,
  GridHelper: J7,
  Group: jw,
  HalfFloatType: X_,
  HemisphereLight: _k,
  HemisphereLightHelper: Z7,
  HemisphereLightProbe: _7,
  IcosahedronBufferGeometry: ib,
  IcosahedronGeometry: ib,
  ImageBitmapLoader: y7,
  ImageLoader: jM,
  ImageUtils: q3,
  ImmediateRenderObject: m9,
  IncrementStencilOp: j5,
  IncrementWrapStencilOp: X5,
  InstancedBufferAttribute: q_,
  InstancedBufferGeometry: $C,
  InstancedInterleavedBuffer: RC,
  InstancedMesh: qF,
  Int16BufferAttribute: VH,
  Int32BufferAttribute: GH,
  Int8BufferAttribute: IH,
  IntType: fF,
  InterleavedBuffer: jC,
  InterleavedBufferAttribute: bm,
  Interpolant: nT,
  InterpolateDiscrete: DM,
  InterpolateLinear: LM,
  InterpolateSmooth: hC,
  InvertStencilOp: Q5,
  KeepStencilOp: pC,
  KeyframeTrack: hg,
  LOD: YF,
  LatheBufferGeometry: Q_,
  LatheGeometry: Q_,
  Layers: G_,
  LessDepth: KN,
  LessEqualDepth: bC,
  LessEqualStencilFunc: $5,
  LessStencilFunc: J5,
  Light: l1,
  LightProbe: JC,
  Line: fh,
  Line3: SL,
  LineBasicMaterial: mh,
  LineCurve: QC,
  LineCurve3: tk,
  LineDashedMaterial: pk,
  LineLoop: QF,
  LineSegments: xy,
  LinearEncoding: wv,
  LinearFilter: Oo,
  LinearInterpolant: dL,
  LinearMipMapLinearFilter: k5,
  LinearMipMapNearestFilter: F5,
  LinearMipmapLinearFilter: s1,
  LinearMipmapNearestFilter: W3,
  LinearSRGBColorSpace: Jx,
  LinearToneMapping: aF,
  Loader: Rm,
  LoaderUtils: w3,
  LoadingManager: pL,
  LoopOnce: EF,
  LoopPingPong: TF,
  LoopRepeat: MF,
  LuminanceAlphaFormat: gF,
  LuminanceFormat: vF,
  MOUSE: T_,
  Material: hf,
  MaterialLoader: KC,
  MathUtils: DF,
  Matrix3: Xh,
  Matrix4: Kr,
  MaxEquation: YD,
  Mesh: Fn,
  MeshBasicMaterial: fg,
  MeshDepthMaterial: tT,
  MeshDistanceMaterial: VC,
  MeshLambertMaterial: dk,
  MeshMatcapMaterial: hk,
  MeshNormalMaterial: uL,
  MeshPhongMaterial: ck,
  MeshPhysicalMaterial: uk,
  MeshStandardMaterial: HM,
  MeshToonMaterial: fk,
  MinEquation: jD,
  MirroredRepeatWrapping: AM,
  MixOperation: rF,
  MultiplyBlending: WD,
  MultiplyOperation: ZM,
  NearestFilter: fo,
  NearestMipMapLinearFilter: N5,
  NearestMipMapNearestFilter: z5,
  NearestMipmapLinearFilter: MC,
  NearestMipmapNearestFilter: EC,
  NeverDepth: ZN,
  NeverStencilFunc: Z5,
  NoBlending: ff,
  NoColorSpace: V5,
  NoToneMapping: og,
  NormalAnimationBlendMode: kC,
  NormalBlending: P0,
  NotEqualDepth: nF,
  NotEqualStencilFunc: tH,
  NumberKeyframeTrack: VM,
  Object3D: Xa,
  ObjectLoader: v7,
  ObjectSpaceNormalMap: CF,
  OctahedronBufferGeometry: sg,
  OctahedronGeometry: sg,
  OneFactor: VN,
  OneMinusDstAlphaFactor: YN,
  OneMinusDstColorFactor: qN,
  OneMinusSrcAlphaFactor: NC,
  OneMinusSrcColorFactor: WN,
  OrthographicCamera: dy,
  PCFShadowMap: UC,
  PCFSoftShadowMap: _M,
  PMREMGenerator: v3,
  ParametricGeometry: f9,
  Path: FM,
  PerspectiveCamera: ho,
  Plane: R0,
  PlaneBufferGeometry: lg,
  PlaneGeometry: lg,
  PlaneHelper: r9,
  PointLight: wk,
  PointLightHelper: q7,
  Points: ZF,
  PointsMaterial: XC,
  PolarGridHelper: K7,
  PolyhedronBufferGeometry: gy,
  PolyhedronGeometry: gy,
  PositionalAudio: T7,
  PropertyBinding: Ja,
  PropertyMixer: Ak,
  QuadraticBezierCurve: iL,
  QuadraticBezierCurve3: aL,
  Quaternion: Po,
  QuaternionKeyframeTrack: vb,
  QuaternionLinearInterpolant: yk,
  REVISION: a1,
  RGBADepthPacking: Jw,
  RGBAFormat: zp,
  RGBAIntegerFormat: wF,
  RGBA_ASTC_10x10_Format: c3,
  RGBA_ASTC_10x5_Format: o3,
  RGBA_ASTC_10x6_Format: l3,
  RGBA_ASTC_10x8_Format: u3,
  RGBA_ASTC_12x10_Format: f3,
  RGBA_ASTC_12x12_Format: d3,
  RGBA_ASTC_4x4_Format: $D,
  RGBA_ASTC_5x4_Format: e3,
  RGBA_ASTC_5x5_Format: t3,
  RGBA_ASTC_6x5_Format: n3,
  RGBA_ASTC_6x6_Format: r3,
  RGBA_ASTC_8x5_Format: i3,
  RGBA_ASTC_8x6_Format: a3,
  RGBA_ASTC_8x8_Format: s3,
  RGBA_BPTC_Format: h3,
  RGBA_ETC2_EAC_Format: KD,
  RGBA_PVRTC_2BPPV1_Format: ZD,
  RGBA_PVRTC_4BPPV1_Format: QD,
  RGBA_S3TC_DXT1_Format: cC,
  RGBA_S3TC_DXT3_Format: fC,
  RGBA_S3TC_DXT5_Format: dC,
  RGBFormat: mF,
  RGB_ETC1_Format: bF,
  RGB_ETC2_Format: JD,
  RGB_PVRTC_2BPPV1_Format: qD,
  RGB_PVRTC_4BPPV1_Format: XD,
  RGB_S3TC_DXT1_Format: uC,
  RGFormat: _F,
  RGIntegerFormat: SF,
  RawShaderMaterial: lk,
  Ray: KM,
  Raycaster: _L,
  RectAreaLight: Mk,
  RedFormat: yF,
  RedIntegerFormat: xF,
  ReinhardToneMapping: sF,
  RepeatWrapping: Zw,
  ReplaceStencilOp: W5,
  ReverseSubtractEquation: V3,
  RingBufferGeometry: ab,
  RingGeometry: ab,
  SRGBColorSpace: uy,
  Scene: NM,
  ShaderChunk: na,
  ShaderLib: Wh,
  ShaderMaterial: Mu,
  ShadowMaterial: ok,
  Shape: W_,
  ShapeBufferGeometry: sb,
  ShapeGeometry: sb,
  ShapePath: s9,
  ShapeUtils: hy,
  ShortType: cF,
  Skeleton: YC,
  SkeletonHelper: X7,
  SkinnedMesh: XF,
  SmoothShading: U5,
  Source: F_,
  Sphere: yy,
  SphereBufferGeometry: ug,
  SphereGeometry: ug,
  Spherical: E3,
  SphericalHarmonics3: Tk,
  SplineCurve: sL,
  SpotLight: Sk,
  SpotLightHelper: Y7,
  Sprite: jF,
  SpriteMaterial: eL,
  SrcAlphaFactor: zC,
  SrcAlphaSaturateFactor: QN,
  SrcColorFactor: GN,
  StaticCopyUsage: oH,
  StaticDrawUsage: OM,
  StaticReadUsage: iH,
  StereoCamera: w7,
  StreamCopyUsage: uH,
  StreamDrawUsage: rH,
  StreamReadUsage: sH,
  StringKeyframeTrack: tS,
  SubtractEquation: BN,
  SubtractiveBlending: GD,
  TOUCH: C_,
  TangentSpaceNormalMap: K_,
  TetrahedronBufferGeometry: ob,
  TetrahedronGeometry: ob,
  TextGeometry: d9,
  Texture: su,
  TextureLoader: d7,
  TorusBufferGeometry: ag,
  TorusGeometry: ag,
  TorusKnotBufferGeometry: lb,
  TorusKnotGeometry: lb,
  Triangle: wm,
  TriangleFanDrawMode: H5,
  TriangleStripDrawMode: B5,
  TrianglesDrawMode: I5,
  TubeBufferGeometry: ub,
  TubeGeometry: ub,
  UVMapping: FC,
  Uint16BufferAttribute: Q3,
  Uint32BufferAttribute: Z3,
  Uint8BufferAttribute: BH,
  Uint8ClampedBufferAttribute: HH,
  Uniform: Pn,
  UniformsGroup: V7,
  UniformsLib: In,
  UniformsUtils: $M,
  UnsignedByteType: df,
  UnsignedInt248Type: Kx,
  UnsignedIntType: L0,
  UnsignedShort4444Type: dF,
  UnsignedShort5551Type: hF,
  UnsignedShortType: j3,
  VSMShadowMap: U_,
  Vector2: zt,
  Vector3: ge,
  Vector4: ra,
  VectorKeyframeTrack: GM,
  VideoTexture: TW,
  WebGL1Renderer: GF,
  WebGL3DRenderTarget: AH,
  WebGLArrayRenderTarget: RH,
  WebGLCubeRenderTarget: UF,
  WebGLMultipleRenderTargets: DH,
  WebGLMultisampleRenderTarget: v9,
  WebGLRenderTarget: po,
  WebGLRenderer: $3,
  WebGLUtils: HF,
  WireframeGeometry: lL,
  WrapAroundEnding: PM,
  ZeroCurvatureEnding: z_,
  ZeroFactor: HN,
  ZeroSlopeEnding: N_,
  ZeroStencilOp: G5,
  _SRGBAFormat: TC,
  sRGBEncoding: gi
}, Symbol.toStringTag, { value: "Module" }));
var D0 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Lk(a) {
  return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a;
}
var I_ = { exports: {} }, Yx = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ez;
function _9() {
  return ez || (ez = 1, Yx.ConcurrentRoot = 1, Yx.ContinuousEventPriority = 4, Yx.DefaultEventPriority = 16, Yx.DiscreteEventPriority = 1, Yx.IdleEventPriority = 536870912, Yx.LegacyRoot = 0), Yx;
}
var Xx = {};
/**
 * @license React
 * react-reconciler-constants.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var tz;
function S9() {
  return tz || (tz = 1, process.env.NODE_ENV !== "production" && function() {
    var a = 1, e = 4, t = 16, r = 536870912, i = a, s = e, l = t, d = r, p = 0, g = 1;
    Xx.ConcurrentRoot = g, Xx.ContinuousEventPriority = s, Xx.DefaultEventPriority = l, Xx.DiscreteEventPriority = i, Xx.IdleEventPriority = d, Xx.LegacyRoot = p;
  }()), Xx;
}
(function(a) {
  process.env.NODE_ENV === "production" ? a.exports = _9() : a.exports = S9();
})(I_);
function w9(a) {
  let e;
  const t = /* @__PURE__ */ new Set(), r = (g, _) => {
    const w = typeof g == "function" ? g(e) : g;
    if (w !== e) {
      const T = e;
      e = _ ? w : Object.assign({}, e, w), t.forEach((R) => R(e, T));
    }
  }, i = () => e, s = (g, _ = i, w = Object.is) => {
    console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");
    let T = _(e);
    function R() {
      const D = _(e);
      if (!w(T, D)) {
        const O = T;
        g(T = D, O);
      }
    }
    return t.add(R), () => t.delete(R);
  }, p = { setState: r, getState: i, subscribe: (g, _, w) => _ || w ? s(g, _, w) : (t.add(g), () => t.delete(g)), destroy: () => t.clear() };
  return e = a(r, i, p), p;
}
const b9 = typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent), nz = b9 ? hh : H3;
function E9(a) {
  const e = typeof a == "function" ? w9(a) : a, t = (r = e.getState, i = Object.is) => {
    const [, s] = D5((U) => U + 1, 0), l = e.getState(), d = Xs(l), p = Xs(r), g = Xs(i), _ = Xs(!1), w = Xs();
    w.current === void 0 && (w.current = r(l));
    let T, R = !1;
    (d.current !== l || p.current !== r || g.current !== i || _.current) && (T = r(l), R = !i(w.current, T)), nz(() => {
      R && (w.current = T), d.current = l, p.current = r, g.current = i, _.current = !1;
    });
    const D = Xs(l);
    nz(() => {
      const U = () => {
        try {
          const I = e.getState(), G = p.current(I);
          g.current(w.current, G) || (d.current = I, w.current = G, s());
        } catch {
          _.current = !0, s();
        }
      }, H = e.subscribe(U);
      return e.getState() !== D.current && U(), H;
    }, []);
    const O = R ? T : w.current;
    return UN(O), O;
  };
  return Object.assign(t, e), t[Symbol.iterator] = function() {
    console.warn("[useStore, api] = create() is deprecated and will be removed in v4");
    const r = [t, e];
    return {
      next() {
        const i = r.length <= 0;
        return { value: r.shift(), done: i };
      }
    };
  }, t;
}
var Pk = { exports: {} }, YM = { exports: {} }, aD = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var rz;
function M9() {
  return rz || (rz = 1, function(a) {
    function e(ve, fe) {
      var he = ve.length;
      ve.push(fe);
      e:
        for (; 0 < he; ) {
          var ye = he - 1 >>> 1, Ee = ve[ye];
          if (0 < i(Ee, fe))
            ve[ye] = fe, ve[he] = Ee, he = ye;
          else
            break e;
        }
    }
    function t(ve) {
      return ve.length === 0 ? null : ve[0];
    }
    function r(ve) {
      if (ve.length === 0)
        return null;
      var fe = ve[0], he = ve.pop();
      if (he !== fe) {
        ve[0] = he;
        e:
          for (var ye = 0, Ee = ve.length, Ve = Ee >>> 1; ye < Ve; ) {
            var Je = 2 * (ye + 1) - 1, rt = ve[Je], Ne = Je + 1, ct = ve[Ne];
            if (0 > i(rt, he))
              Ne < Ee && 0 > i(ct, rt) ? (ve[ye] = ct, ve[Ne] = he, ye = Ne) : (ve[ye] = rt, ve[Je] = he, ye = Je);
            else if (Ne < Ee && 0 > i(ct, he))
              ve[ye] = ct, ve[Ne] = he, ye = Ne;
            else
              break e;
          }
      }
      return fe;
    }
    function i(ve, fe) {
      var he = ve.sortIndex - fe.sortIndex;
      return he !== 0 ? he : ve.id - fe.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var s = performance;
      a.unstable_now = function() {
        return s.now();
      };
    } else {
      var l = Date, d = l.now();
      a.unstable_now = function() {
        return l.now() - d;
      };
    }
    var p = [], g = [], _ = 1, w = null, T = 3, R = !1, D = !1, O = !1, U = typeof setTimeout == "function" ? setTimeout : null, H = typeof clearTimeout == "function" ? clearTimeout : null, I = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function G(ve) {
      for (var fe = t(g); fe !== null; ) {
        if (fe.callback === null)
          r(g);
        else if (fe.startTime <= ve)
          r(g), fe.sortIndex = fe.expirationTime, e(p, fe);
        else
          break;
        fe = t(g);
      }
    }
    function B(ve) {
      if (O = !1, G(ve), !D)
        if (t(p) !== null)
          D = !0, Re(Q);
        else {
          var fe = t(g);
          fe !== null && He(B, fe.startTime - ve);
        }
    }
    function Q(ve, fe) {
      D = !1, O && (O = !1, H(Y), Y = -1), R = !0;
      var he = T;
      try {
        for (G(fe), w = t(p); w !== null && (!(w.expirationTime > fe) || ve && !ce()); ) {
          var ye = w.callback;
          if (typeof ye == "function") {
            w.callback = null, T = w.priorityLevel;
            var Ee = ye(w.expirationTime <= fe);
            fe = a.unstable_now(), typeof Ee == "function" ? w.callback = Ee : w === t(p) && r(p), G(fe);
          } else
            r(p);
          w = t(p);
        }
        if (w !== null)
          var Ve = !0;
        else {
          var Je = t(g);
          Je !== null && He(B, Je.startTime - fe), Ve = !1;
        }
        return Ve;
      } finally {
        w = null, T = he, R = !1;
      }
    }
    var K = !1, te = null, Y = -1, re = 5, se = -1;
    function ce() {
      return !(a.unstable_now() - se < re);
    }
    function ue() {
      if (te !== null) {
        var ve = a.unstable_now();
        se = ve;
        var fe = !0;
        try {
          fe = te(!0, ve);
        } finally {
          fe ? Me() : (K = !1, te = null);
        }
      } else
        K = !1;
    }
    var Me;
    if (typeof I == "function")
      Me = function() {
        I(ue);
      };
    else if (typeof MessageChannel < "u") {
      var me = new MessageChannel(), De = me.port2;
      me.port1.onmessage = ue, Me = function() {
        De.postMessage(null);
      };
    } else
      Me = function() {
        U(ue, 0);
      };
    function Re(ve) {
      te = ve, K || (K = !0, Me());
    }
    function He(ve, fe) {
      Y = U(function() {
        ve(a.unstable_now());
      }, fe);
    }
    a.unstable_IdlePriority = 5, a.unstable_ImmediatePriority = 1, a.unstable_LowPriority = 4, a.unstable_NormalPriority = 3, a.unstable_Profiling = null, a.unstable_UserBlockingPriority = 2, a.unstable_cancelCallback = function(ve) {
      ve.callback = null;
    }, a.unstable_continueExecution = function() {
      D || R || (D = !0, Re(Q));
    }, a.unstable_forceFrameRate = function(ve) {
      0 > ve || 125 < ve ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : re = 0 < ve ? Math.floor(1e3 / ve) : 5;
    }, a.unstable_getCurrentPriorityLevel = function() {
      return T;
    }, a.unstable_getFirstCallbackNode = function() {
      return t(p);
    }, a.unstable_next = function(ve) {
      switch (T) {
        case 1:
        case 2:
        case 3:
          var fe = 3;
          break;
        default:
          fe = T;
      }
      var he = T;
      T = fe;
      try {
        return ve();
      } finally {
        T = he;
      }
    }, a.unstable_pauseExecution = function() {
    }, a.unstable_requestPaint = function() {
    }, a.unstable_runWithPriority = function(ve, fe) {
      switch (ve) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          ve = 3;
      }
      var he = T;
      T = ve;
      try {
        return fe();
      } finally {
        T = he;
      }
    }, a.unstable_scheduleCallback = function(ve, fe, he) {
      var ye = a.unstable_now();
      switch (typeof he == "object" && he !== null ? (he = he.delay, he = typeof he == "number" && 0 < he ? ye + he : ye) : he = ye, ve) {
        case 1:
          var Ee = -1;
          break;
        case 2:
          Ee = 250;
          break;
        case 5:
          Ee = 1073741823;
          break;
        case 4:
          Ee = 1e4;
          break;
        default:
          Ee = 5e3;
      }
      return Ee = he + Ee, ve = { id: _++, callback: fe, priorityLevel: ve, startTime: he, expirationTime: Ee, sortIndex: -1 }, he > ye ? (ve.sortIndex = he, e(g, ve), t(p) === null && ve === t(g) && (O ? (H(Y), Y = -1) : O = !0, He(B, he - ye))) : (ve.sortIndex = Ee, e(p, ve), D || R || (D = !0, Re(Q))), ve;
    }, a.unstable_shouldYield = ce, a.unstable_wrapCallback = function(ve) {
      var fe = T;
      return function() {
        var he = T;
        T = fe;
        try {
          return ve.apply(this, arguments);
        } finally {
          T = he;
        }
      };
    };
  }(aD)), aD;
}
var sD = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var iz;
function T9() {
  return iz || (iz = 1, function(a) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var e = !1, t = !1, r = 5;
      function i(Be, pe) {
        var Fe = Be.length;
        Be.push(pe), d(Be, pe, Fe);
      }
      function s(Be) {
        return Be.length === 0 ? null : Be[0];
      }
      function l(Be) {
        if (Be.length === 0)
          return null;
        var pe = Be[0], Fe = Be.pop();
        return Fe !== pe && (Be[0] = Fe, p(Be, Fe, 0)), pe;
      }
      function d(Be, pe, Fe) {
        for (var at = Fe; at > 0; ) {
          var st = at - 1 >>> 1, dn = Be[st];
          if (g(dn, pe) > 0)
            Be[st] = pe, Be[at] = dn, at = st;
          else
            return;
        }
      }
      function p(Be, pe, Fe) {
        for (var at = Fe, st = Be.length, dn = st >>> 1; at < dn; ) {
          var ze = (at + 1) * 2 - 1, wt = Be[ze], Pe = ze + 1, Gt = Be[Pe];
          if (g(wt, pe) < 0)
            Pe < st && g(Gt, wt) < 0 ? (Be[at] = Gt, Be[Pe] = pe, at = Pe) : (Be[at] = wt, Be[ze] = pe, at = ze);
          else if (Pe < st && g(Gt, pe) < 0)
            Be[at] = Gt, Be[Pe] = pe, at = Pe;
          else
            return;
        }
      }
      function g(Be, pe) {
        var Fe = Be.sortIndex - pe.sortIndex;
        return Fe !== 0 ? Fe : Be.id - pe.id;
      }
      var _ = 1, w = 2, T = 3, R = 4, D = 5;
      function O(Be, pe) {
      }
      var U = typeof performance == "object" && typeof performance.now == "function";
      if (U) {
        var H = performance;
        a.unstable_now = function() {
          return H.now();
        };
      } else {
        var I = Date, G = I.now();
        a.unstable_now = function() {
          return I.now() - G;
        };
      }
      var B = 1073741823, Q = -1, K = 250, te = 5e3, Y = 1e4, re = B, se = [], ce = [], ue = 1, Me = null, me = T, De = !1, Re = !1, He = !1, ve = typeof setTimeout == "function" ? setTimeout : null, fe = typeof clearTimeout == "function" ? clearTimeout : null, he = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function ye(Be) {
        for (var pe = s(ce); pe !== null; ) {
          if (pe.callback === null)
            l(ce);
          else if (pe.startTime <= Be)
            l(ce), pe.sortIndex = pe.expirationTime, i(se, pe);
          else
            return;
          pe = s(ce);
        }
      }
      function Ee(Be) {
        if (He = !1, ye(Be), !Re)
          if (s(se) !== null)
            Re = !0, Ft(Ve);
          else {
            var pe = s(ce);
            pe !== null && Ot(Ee, pe.startTime - Be);
          }
      }
      function Ve(Be, pe) {
        Re = !1, He && (He = !1, Wt()), De = !0;
        var Fe = me;
        try {
          var at;
          if (!t)
            return Je(Be, pe);
        } finally {
          Me = null, me = Fe, De = !1;
        }
      }
      function Je(Be, pe) {
        var Fe = pe;
        for (ye(Fe), Me = s(se); Me !== null && !e && !(Me.expirationTime > Fe && (!Be || Nt())); ) {
          var at = Me.callback;
          if (typeof at == "function") {
            Me.callback = null, me = Me.priorityLevel;
            var st = Me.expirationTime <= Fe, dn = at(st);
            Fe = a.unstable_now(), typeof dn == "function" ? Me.callback = dn : Me === s(se) && l(se), ye(Fe);
          } else
            l(se);
          Me = s(se);
        }
        if (Me !== null)
          return !0;
        var ze = s(ce);
        return ze !== null && Ot(Ee, ze.startTime - Fe), !1;
      }
      function rt(Be, pe) {
        switch (Be) {
          case _:
          case w:
          case T:
          case R:
          case D:
            break;
          default:
            Be = T;
        }
        var Fe = me;
        me = Be;
        try {
          return pe();
        } finally {
          me = Fe;
        }
      }
      function Ne(Be) {
        var pe;
        switch (me) {
          case _:
          case w:
          case T:
            pe = T;
            break;
          default:
            pe = me;
            break;
        }
        var Fe = me;
        me = pe;
        try {
          return Be();
        } finally {
          me = Fe;
        }
      }
      function ct(Be) {
        var pe = me;
        return function() {
          var Fe = me;
          me = pe;
          try {
            return Be.apply(this, arguments);
          } finally {
            me = Fe;
          }
        };
      }
      function tt(Be, pe, Fe) {
        var at = a.unstable_now(), st;
        if (typeof Fe == "object" && Fe !== null) {
          var dn = Fe.delay;
          typeof dn == "number" && dn > 0 ? st = at + dn : st = at;
        } else
          st = at;
        var ze;
        switch (Be) {
          case _:
            ze = Q;
            break;
          case w:
            ze = K;
            break;
          case D:
            ze = re;
            break;
          case R:
            ze = Y;
            break;
          case T:
          default:
            ze = te;
            break;
        }
        var wt = st + ze, Pe = {
          id: ue++,
          callback: pe,
          priorityLevel: Be,
          startTime: st,
          expirationTime: wt,
          sortIndex: -1
        };
        return st > at ? (Pe.sortIndex = st, i(ce, Pe), s(se) === null && Pe === s(ce) && (He ? Wt() : He = !0, Ot(Ee, st - at))) : (Pe.sortIndex = wt, i(se, Pe), !Re && !De && (Re = !0, Ft(Ve))), Pe;
      }
      function Tt() {
      }
      function gt() {
        !Re && !De && (Re = !0, Ft(Ve));
      }
      function ft() {
        return s(se);
      }
      function Ie(Be) {
        Be.callback = null;
      }
      function qe() {
        return me;
      }
      var dt = !1, ht = null, xt = -1, Vt = r, yt = -1;
      function Nt() {
        var Be = a.unstable_now() - yt;
        return !(Be < Vt);
      }
      function Zt() {
      }
      function Rt(Be) {
        if (Be < 0 || Be > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        Be > 0 ? Vt = Math.floor(1e3 / Be) : Vt = r;
      }
      var we = function() {
        if (ht !== null) {
          var Be = a.unstable_now();
          yt = Be;
          var pe = !0, Fe = !0;
          try {
            Fe = ht(pe, Be);
          } finally {
            Fe ? oe() : (dt = !1, ht = null);
          }
        } else
          dt = !1;
      }, oe;
      if (typeof he == "function")
        oe = function() {
          he(we);
        };
      else if (typeof MessageChannel < "u") {
        var Qe = new MessageChannel(), ut = Qe.port2;
        Qe.port1.onmessage = we, oe = function() {
          ut.postMessage(null);
        };
      } else
        oe = function() {
          ve(we, 0);
        };
      function Ft(Be) {
        ht = Be, dt || (dt = !0, oe());
      }
      function Ot(Be, pe) {
        xt = ve(function() {
          Be(a.unstable_now());
        }, pe);
      }
      function Wt() {
        fe(xt), xt = -1;
      }
      var it = Zt, an = null;
      a.unstable_IdlePriority = D, a.unstable_ImmediatePriority = _, a.unstable_LowPriority = R, a.unstable_NormalPriority = T, a.unstable_Profiling = an, a.unstable_UserBlockingPriority = w, a.unstable_cancelCallback = Ie, a.unstable_continueExecution = gt, a.unstable_forceFrameRate = Rt, a.unstable_getCurrentPriorityLevel = qe, a.unstable_getFirstCallbackNode = ft, a.unstable_next = Ne, a.unstable_pauseExecution = Tt, a.unstable_requestPaint = it, a.unstable_runWithPriority = rt, a.unstable_scheduleCallback = tt, a.unstable_shouldYield = Nt, a.unstable_wrapCallback = ct, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(sD)), sD;
}
(function(a) {
  process.env.NODE_ENV === "production" ? a.exports = M9() : a.exports = T9();
})(YM);
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var oD, az;
function C9() {
  return az || (az = 1, oD = function(e) {
    var t = {}, r = ph, i = YM.exports, s = Object.assign;
    function l(y) {
      for (var x = "https://reactjs.org/docs/error-decoder.html?invariant=" + y, L = 1; L < arguments.length; L++)
        x += "&args[]=" + encodeURIComponent(arguments[L]);
      return "Minified React error #" + y + "; visit " + x + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var d = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, p = Symbol.for("react.element"), g = Symbol.for("react.portal"), _ = Symbol.for("react.fragment"), w = Symbol.for("react.strict_mode"), T = Symbol.for("react.profiler"), R = Symbol.for("react.provider"), D = Symbol.for("react.context"), O = Symbol.for("react.forward_ref"), U = Symbol.for("react.suspense"), H = Symbol.for("react.suspense_list"), I = Symbol.for("react.memo"), G = Symbol.for("react.lazy"), B = Symbol.for("react.offscreen"), Q = Symbol.iterator;
    function K(y) {
      return y === null || typeof y != "object" ? null : (y = Q && y[Q] || y["@@iterator"], typeof y == "function" ? y : null);
    }
    function te(y) {
      if (y == null)
        return null;
      if (typeof y == "function")
        return y.displayName || y.name || null;
      if (typeof y == "string")
        return y;
      switch (y) {
        case _:
          return "Fragment";
        case g:
          return "Portal";
        case T:
          return "Profiler";
        case w:
          return "StrictMode";
        case U:
          return "Suspense";
        case H:
          return "SuspenseList";
      }
      if (typeof y == "object")
        switch (y.$$typeof) {
          case D:
            return (y.displayName || "Context") + ".Consumer";
          case R:
            return (y._context.displayName || "Context") + ".Provider";
          case O:
            var x = y.render;
            return y = y.displayName, y || (y = x.displayName || x.name || "", y = y !== "" ? "ForwardRef(" + y + ")" : "ForwardRef"), y;
          case I:
            return x = y.displayName || null, x !== null ? x : te(y.type) || "Memo";
          case G:
            x = y._payload, y = y._init;
            try {
              return te(y(x));
            } catch {
            }
        }
      return null;
    }
    function Y(y) {
      var x = y.type;
      switch (y.tag) {
        case 24:
          return "Cache";
        case 9:
          return (x.displayName || "Context") + ".Consumer";
        case 10:
          return (x._context.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return y = x.render, y = y.displayName || y.name || "", x.displayName || (y !== "" ? "ForwardRef(" + y + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 5:
          return x;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return te(x);
        case 8:
          return x === w ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
          if (typeof x == "function")
            return x.displayName || x.name || null;
          if (typeof x == "string")
            return x;
      }
      return null;
    }
    function re(y) {
      var x = y, L = y;
      if (y.alternate)
        for (; x.return; )
          x = x.return;
      else {
        y = x;
        do
          x = y, (x.flags & 4098) !== 0 && (L = x.return), y = x.return;
        while (y);
      }
      return x.tag === 3 ? L : null;
    }
    function se(y) {
      if (re(y) !== y)
        throw Error(l(188));
    }
    function ce(y) {
      var x = y.alternate;
      if (!x) {
        if (x = re(y), x === null)
          throw Error(l(188));
        return x !== y ? null : y;
      }
      for (var L = y, k = x; ; ) {
        var X = L.return;
        if (X === null)
          break;
        var $ = X.alternate;
        if ($ === null) {
          if (k = X.return, k !== null) {
            L = k;
            continue;
          }
          break;
        }
        if (X.child === $.child) {
          for ($ = X.child; $; ) {
            if ($ === L)
              return se(X), y;
            if ($ === k)
              return se(X), x;
            $ = $.sibling;
          }
          throw Error(l(188));
        }
        if (L.return !== k.return)
          L = X, k = $;
        else {
          for (var Ae = !1, $e = X.child; $e; ) {
            if ($e === L) {
              Ae = !0, L = X, k = $;
              break;
            }
            if ($e === k) {
              Ae = !0, k = X, L = $;
              break;
            }
            $e = $e.sibling;
          }
          if (!Ae) {
            for ($e = $.child; $e; ) {
              if ($e === L) {
                Ae = !0, L = $, k = X;
                break;
              }
              if ($e === k) {
                Ae = !0, k = $, L = X;
                break;
              }
              $e = $e.sibling;
            }
            if (!Ae)
              throw Error(l(189));
          }
        }
        if (L.alternate !== k)
          throw Error(l(190));
      }
      if (L.tag !== 3)
        throw Error(l(188));
      return L.stateNode.current === L ? y : x;
    }
    function ue(y) {
      return y = ce(y), y !== null ? Me(y) : null;
    }
    function Me(y) {
      if (y.tag === 5 || y.tag === 6)
        return y;
      for (y = y.child; y !== null; ) {
        var x = Me(y);
        if (x !== null)
          return x;
        y = y.sibling;
      }
      return null;
    }
    function me(y) {
      if (y.tag === 5 || y.tag === 6)
        return y;
      for (y = y.child; y !== null; ) {
        if (y.tag !== 4) {
          var x = me(y);
          if (x !== null)
            return x;
        }
        y = y.sibling;
      }
      return null;
    }
    var De = Array.isArray, Re = e.getPublicInstance, He = e.getRootHostContext, ve = e.getChildHostContext, fe = e.prepareForCommit, he = e.resetAfterCommit, ye = e.createInstance, Ee = e.appendInitialChild, Ve = e.finalizeInitialChildren, Je = e.prepareUpdate, rt = e.shouldSetTextContent, Ne = e.createTextInstance, ct = e.scheduleTimeout, tt = e.cancelTimeout, Tt = e.noTimeout, gt = e.isPrimaryRenderer, ft = e.supportsMutation, Ie = e.supportsPersistence, qe = e.supportsHydration, dt = e.getInstanceFromNode, ht = e.preparePortalMount, xt = e.getCurrentEventPriority, Vt = e.detachDeletedInstance, yt = e.supportsMicrotasks, Nt = e.scheduleMicrotask, Zt = e.supportsTestSelectors, Rt = e.findFiberRoot, we = e.getBoundingRect, oe = e.getTextContent, Qe = e.isHiddenSubtree, ut = e.matchAccessibilityRole, Ft = e.setFocusIfFocusable, Ot = e.setupIntersectionObserver, Wt = e.appendChild, it = e.appendChildToContainer, an = e.commitTextUpdate, Be = e.commitMount, pe = e.commitUpdate, Fe = e.insertBefore, at = e.insertInContainerBefore, st = e.removeChild, dn = e.removeChildFromContainer, ze = e.resetTextContent, wt = e.hideInstance, Pe = e.hideTextInstance, Gt = e.unhideInstance, At = e.unhideTextInstance, cn = e.clearContainer, ki = e.cloneInstance, Or = e.createContainerChildSet, Ii = e.appendChildToContainerChildSet, Ir = e.finalizeContainerChildren, Bn = e.replaceContainerChildren, Mi = e.cloneHiddenInstance, yi = e.cloneHiddenTextInstance, ii = e.canHydrateInstance, Bi = e.canHydrateTextInstance, xi = e.canHydrateSuspenseInstance, $r = e.isSuspenseInstancePending, ai = e.isSuspenseInstanceFallback, Te = e.registerSuspenseInstanceRetry, ot = e.getNextHydratableSibling, de = e.getFirstHydratableChild, Le = e.getFirstHydratableChildWithinContainer, Ye = e.getFirstHydratableChildWithinSuspenseInstance, $t = e.hydrateInstance, mn = e.hydrateTextInstance, Rn = e.hydrateSuspenseInstance, gn = e.getNextHydratableInstanceAfterSuspenseInstance, yn = e.commitHydratedContainer, Jn = e.commitHydratedSuspenseInstance, rr = e.clearSuspenseBoundary, wr = e.clearSuspenseBoundaryFromContainer, Yi = e.shouldDeleteUnhydratedTailInstances, La = e.didNotMatchHydratedContainerTextInstance, qs = e.didNotMatchHydratedTextInstance, en;
    function Xr(y) {
      if (en === void 0)
        try {
          throw Error();
        } catch (L) {
          var x = L.stack.trim().match(/\n( *(at )?)/);
          en = x && x[1] || "";
        }
      return `
` + en + y;
    }
    var us = !1;
    function qn(y, x) {
      if (!y || us)
        return "";
      us = !0;
      var L = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        if (x)
          if (x = function() {
            throw Error();
          }, Object.defineProperty(x.prototype, "props", { set: function() {
            throw Error();
          } }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(x, []);
            } catch (hn) {
              var k = hn;
            }
            Reflect.construct(y, [], x);
          } else {
            try {
              x.call();
            } catch (hn) {
              k = hn;
            }
            y.call(x.prototype);
          }
        else {
          try {
            throw Error();
          } catch (hn) {
            k = hn;
          }
          y();
        }
      } catch (hn) {
        if (hn && k && typeof hn.stack == "string") {
          for (var X = hn.stack.split(`
`), $ = k.stack.split(`
`), Ae = X.length - 1, $e = $.length - 1; 1 <= Ae && 0 <= $e && X[Ae] !== $[$e]; )
            $e--;
          for (; 1 <= Ae && 0 <= $e; Ae--, $e--)
            if (X[Ae] !== $[$e]) {
              if (Ae !== 1 || $e !== 1)
                do
                  if (Ae--, $e--, 0 > $e || X[Ae] !== $[$e]) {
                    var kt = `
` + X[Ae].replace(" at new ", " at ");
                    return y.displayName && kt.includes("<anonymous>") && (kt = kt.replace("<anonymous>", y.displayName)), kt;
                  }
                while (1 <= Ae && 0 <= $e);
              break;
            }
        }
      } finally {
        us = !1, Error.prepareStackTrace = L;
      }
      return (y = y ? y.displayName || y.name : "") ? Xr(y) : "";
    }
    var qa = Object.prototype.hasOwnProperty, mo = [], Ls = -1;
    function cs(y) {
      return { current: y };
    }
    function mr(y) {
      0 > Ls || (y.current = mo[Ls], mo[Ls] = null, Ls--);
    }
    function di(y, x) {
      Ls++, mo[Ls] = y.current, y.current = x;
    }
    var Ea = {}, Si = cs(Ea), Ti = cs(!1), Uo = Ea;
    function zo(y, x) {
      var L = y.type.contextTypes;
      if (!L)
        return Ea;
      var k = y.stateNode;
      if (k && k.__reactInternalMemoizedUnmaskedChildContext === x)
        return k.__reactInternalMemoizedMaskedChildContext;
      var X = {}, $;
      for ($ in L)
        X[$] = x[$];
      return k && (y = y.stateNode, y.__reactInternalMemoizedUnmaskedChildContext = x, y.__reactInternalMemoizedMaskedChildContext = X), X;
    }
    function Pa(y) {
      return y = y.childContextTypes, y != null;
    }
    function Dl() {
      mr(Ti), mr(Si);
    }
    function vo(y, x, L) {
      if (Si.current !== Ea)
        throw Error(l(168));
      di(Si, x), di(Ti, L);
    }
    function Yf(y, x, L) {
      var k = y.stateNode;
      if (x = x.childContextTypes, typeof k.getChildContext != "function")
        return L;
      k = k.getChildContext();
      for (var X in k)
        if (!(X in x))
          throw Error(l(108, Y(y) || "Unknown", X));
      return s({}, L, k);
    }
    function Ll(y) {
      return y = (y = y.stateNode) && y.__reactInternalMemoizedMergedChildContext || Ea, Uo = Si.current, di(Si, y), di(Ti, Ti.current), !0;
    }
    function Nd(y, x, L) {
      var k = y.stateNode;
      if (!k)
        throw Error(l(169));
      L ? (y = Yf(y, x, Uo), k.__reactInternalMemoizedMergedChildContext = y, mr(Ti), mr(Si), di(Si, y)) : mr(Ti), di(Ti, L);
    }
    var Ps = Math.clz32 ? Math.clz32 : Jh, Ju = Math.log, ou = Math.LN2;
    function Jh(y) {
      return y >>>= 0, y === 0 ? 32 : 31 - (Ju(y) / ou | 0) | 0;
    }
    var Pl = 64, ei = 4194304;
    function go(y) {
      switch (y & -y) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return y & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return y & 130023424;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 1073741824;
        default:
          return y;
      }
    }
    function Xf(y, x) {
      var L = y.pendingLanes;
      if (L === 0)
        return 0;
      var k = 0, X = y.suspendedLanes, $ = y.pingedLanes, Ae = L & 268435455;
      if (Ae !== 0) {
        var $e = Ae & ~X;
        $e !== 0 ? k = go($e) : ($ &= Ae, $ !== 0 && (k = go($)));
      } else
        Ae = L & ~X, Ae !== 0 ? k = go(Ae) : $ !== 0 && (k = go($));
      if (k === 0)
        return 0;
      if (x !== 0 && x !== k && (x & X) === 0 && (X = k & -k, $ = x & -x, X >= $ || X === 16 && ($ & 4194240) !== 0))
        return x;
      if ((k & 4) !== 0 && (k |= L & 16), x = y.entangledLanes, x !== 0)
        for (y = y.entanglements, x &= k; 0 < x; )
          L = 31 - Ps(x), X = 1 << L, k |= y[L], x &= ~X;
      return k;
    }
    function No(y, x) {
      switch (y) {
        case 1:
        case 2:
        case 4:
          return x + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return x + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function Ci(y, x) {
      for (var L = y.suspendedLanes, k = y.pingedLanes, X = y.expirationTimes, $ = y.pendingLanes; 0 < $; ) {
        var Ae = 31 - Ps($), $e = 1 << Ae, kt = X[Ae];
        kt === -1 ? (($e & L) === 0 || ($e & k) !== 0) && (X[Ae] = No($e, x)) : kt <= x && (y.expiredLanes |= $e), $ &= ~$e;
      }
    }
    function fs(y) {
      return y = y.pendingLanes & -1073741825, y !== 0 ? y : y & 1073741824 ? 1073741824 : 0;
    }
    function qf(y) {
      for (var x = [], L = 0; 31 > L; L++)
        x.push(y);
      return x;
    }
    function xr(y, x, L) {
      y.pendingLanes |= x, x !== 536870912 && (y.suspendedLanes = 0, y.pingedLanes = 0), y = y.eventTimes, x = 31 - Ps(x), y[x] = L;
    }
    function Tu(y, x) {
      var L = y.pendingLanes & ~x;
      y.pendingLanes = x, y.suspendedLanes = 0, y.pingedLanes = 0, y.expiredLanes &= x, y.mutableReadLanes &= x, y.entangledLanes &= x, x = y.entanglements;
      var k = y.eventTimes;
      for (y = y.expirationTimes; 0 < L; ) {
        var X = 31 - Ps(L), $ = 1 << X;
        x[X] = 0, k[X] = -1, y[X] = -1, L &= ~$;
      }
    }
    function ua(y, x) {
      var L = y.entangledLanes |= x;
      for (y = y.entanglements; L; ) {
        var k = 31 - Ps(L), X = 1 << k;
        X & x | y[k] & x && (y[k] |= x), L &= ~X;
      }
    }
    var Cr = 0;
    function dl(y) {
      return y &= -y, 1 < y ? 4 < y ? (y & 268435455) !== 0 ? 16 : 536870912 : 4 : 1;
    }
    var yo = i.unstable_scheduleCallback, Ka = i.unstable_cancelCallback, Xi = i.unstable_shouldYield, Lm = i.unstable_requestPaint, hi = i.unstable_now, Qa = i.unstable_ImmediatePriority, Sc = i.unstable_UserBlockingPriority, hl = i.unstable_NormalPriority, pf = i.unstable_IdlePriority, mf = null, lu = null;
    function Hi(y) {
      if (lu && typeof lu.onCommitFiberRoot == "function")
        try {
          lu.onCommitFiberRoot(mf, y, void 0, (y.current.flags & 128) === 128);
        } catch {
        }
    }
    function Ri(y, x) {
      return y === x && (y !== 0 || 1 / y === 1 / x) || y !== y && x !== x;
    }
    var Fo = typeof Object.is == "function" ? Object.is : Ri, Os = null, wc = !1, Ol = !1;
    function Qf(y) {
      Os === null ? Os = [y] : Os.push(y);
    }
    function Zf(y) {
      wc = !0, Qf(y);
    }
    function ko() {
      if (!Ol && Os !== null) {
        Ol = !0;
        var y = 0, x = Cr;
        try {
          var L = Os;
          for (Cr = 1; y < L.length; y++) {
            var k = L[y];
            do
              k = k(!0);
            while (k !== null);
          }
          Os = null, wc = !1;
        } catch (X) {
          throw Os !== null && (Os = Os.slice(y + 1)), yo(Qa, ko), X;
        } finally {
          Cr = x, Ol = !1;
        }
      }
      return null;
    }
    var Jf = d.ReactCurrentBatchConfig;
    function Ki(y, x) {
      if (Fo(y, x))
        return !0;
      if (typeof y != "object" || y === null || typeof x != "object" || x === null)
        return !1;
      var L = Object.keys(y), k = Object.keys(x);
      if (L.length !== k.length)
        return !1;
      for (k = 0; k < L.length; k++) {
        var X = L[k];
        if (!qa.call(x, X) || !Fo(y[X], x[X]))
          return !1;
      }
      return !0;
    }
    function Cu(y) {
      switch (y.tag) {
        case 5:
          return Xr(y.type);
        case 16:
          return Xr("Lazy");
        case 13:
          return Xr("Suspense");
        case 19:
          return Xr("SuspenseList");
        case 0:
        case 2:
        case 15:
          return y = qn(y.type, !1), y;
        case 11:
          return y = qn(y.type.render, !1), y;
        case 1:
          return y = qn(y.type, !0), y;
        default:
          return "";
      }
    }
    function Oa(y, x) {
      if (y && y.defaultProps) {
        x = s({}, x), y = y.defaultProps;
        for (var L in y)
          x[L] === void 0 && (x[L] = y[L]);
        return x;
      }
      return x;
    }
    var xs = cs(null), uu = null, Ua = null, bc = null;
    function xo() {
      bc = Ua = uu = null;
    }
    function Ru(y, x, L) {
      gt ? (di(xs, x._currentValue), x._currentValue = L) : (di(xs, x._currentValue2), x._currentValue2 = L);
    }
    function Ul(y) {
      var x = xs.current;
      mr(xs), gt ? y._currentValue = x : y._currentValue2 = x;
    }
    function za(y, x, L) {
      for (; y !== null; ) {
        var k = y.alternate;
        if ((y.childLanes & x) !== x ? (y.childLanes |= x, k !== null && (k.childLanes |= x)) : k !== null && (k.childLanes & x) !== x && (k.childLanes |= x), y === L)
          break;
        y = y.return;
      }
    }
    function Qs(y, x) {
      uu = y, bc = Ua = null, y = y.dependencies, y !== null && y.firstContext !== null && ((y.lanes & x) !== 0 && (si = !0), y.firstContext = null);
    }
    function qr(y) {
      var x = gt ? y._currentValue : y._currentValue2;
      if (bc !== y)
        if (y = { context: y, memoizedValue: x, next: null }, Ua === null) {
          if (uu === null)
            throw Error(l(308));
          Ua = y, uu.dependencies = { lanes: 0, firstContext: y };
        } else
          Ua = Ua.next = y;
      return x;
    }
    var _s = null, va = !1;
    function Zs(y) {
      y.updateQueue = { baseState: y.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
    }
    function Kf(y, x) {
      y = y.updateQueue, x.updateQueue === y && (x.updateQueue = { baseState: y.baseState, firstBaseUpdate: y.firstBaseUpdate, lastBaseUpdate: y.lastBaseUpdate, shared: y.shared, effects: y.effects });
    }
    function el(y, x) {
      return { eventTime: y, lane: x, tag: 0, payload: null, callback: null, next: null };
    }
    function Ku(y, x) {
      var L = y.updateQueue;
      L !== null && (L = L.shared, Ra !== null && (y.mode & 1) !== 0 && (Qr & 2) === 0 ? (y = L.interleaved, y === null ? (x.next = x, _s === null ? _s = [L] : _s.push(L)) : (x.next = y.next, y.next = x), L.interleaved = x) : (y = L.pending, y === null ? x.next = x : (x.next = y.next, y.next = x), L.pending = x));
    }
    function Kh(y, x, L) {
      if (x = x.updateQueue, x !== null && (x = x.shared, (L & 4194240) !== 0)) {
        var k = x.lanes;
        k &= y.pendingLanes, L |= k, x.lanes = L, ua(y, L);
      }
    }
    function qi(y, x) {
      var L = y.updateQueue, k = y.alternate;
      if (k !== null && (k = k.updateQueue, L === k)) {
        var X = null, $ = null;
        if (L = L.firstBaseUpdate, L !== null) {
          do {
            var Ae = { eventTime: L.eventTime, lane: L.lane, tag: L.tag, payload: L.payload, callback: L.callback, next: null };
            $ === null ? X = $ = Ae : $ = $.next = Ae, L = L.next;
          } while (L !== null);
          $ === null ? X = $ = x : $ = $.next = x;
        } else
          X = $ = x;
        L = { baseState: k.baseState, firstBaseUpdate: X, lastBaseUpdate: $, shared: k.shared, effects: k.effects }, y.updateQueue = L;
        return;
      }
      y = L.lastBaseUpdate, y === null ? L.firstBaseUpdate = x : y.next = x, L.lastBaseUpdate = x;
    }
    function Au(y, x, L, k) {
      var X = y.updateQueue;
      va = !1;
      var $ = X.firstBaseUpdate, Ae = X.lastBaseUpdate, $e = X.shared.pending;
      if ($e !== null) {
        X.shared.pending = null;
        var kt = $e, hn = kt.next;
        kt.next = null, Ae === null ? $ = hn : Ae.next = hn, Ae = kt;
        var wn = y.alternate;
        wn !== null && (wn = wn.updateQueue, $e = wn.lastBaseUpdate, $e !== Ae && ($e === null ? wn.firstBaseUpdate = hn : $e.next = hn, wn.lastBaseUpdate = kt));
      }
      if ($ !== null) {
        var br = X.baseState;
        Ae = 0, wn = hn = kt = null, $e = $;
        do {
          var ur = $e.lane, Sa = $e.eventTime;
          if ((k & ur) === ur) {
            wn !== null && (wn = wn.next = {
              eventTime: Sa,
              lane: 0,
              tag: $e.tag,
              payload: $e.payload,
              callback: $e.callback,
              next: null
            });
            e: {
              var Tn = y, Li = $e;
              switch (ur = x, Sa = L, Li.tag) {
                case 1:
                  if (Tn = Li.payload, typeof Tn == "function") {
                    br = Tn.call(Sa, br, ur);
                    break e;
                  }
                  br = Tn;
                  break e;
                case 3:
                  Tn.flags = Tn.flags & -65537 | 128;
                case 0:
                  if (Tn = Li.payload, ur = typeof Tn == "function" ? Tn.call(Sa, br, ur) : Tn, ur == null)
                    break e;
                  br = s({}, br, ur);
                  break e;
                case 2:
                  va = !0;
              }
            }
            $e.callback !== null && $e.lane !== 0 && (y.flags |= 64, ur = X.effects, ur === null ? X.effects = [$e] : ur.push($e));
          } else
            Sa = { eventTime: Sa, lane: ur, tag: $e.tag, payload: $e.payload, callback: $e.callback, next: null }, wn === null ? (hn = wn = Sa, kt = br) : wn = wn.next = Sa, Ae |= ur;
          if ($e = $e.next, $e === null) {
            if ($e = X.shared.pending, $e === null)
              break;
            ur = $e, $e = ur.next, ur.next = null, X.lastBaseUpdate = ur, X.shared.pending = null;
          }
        } while (1);
        if (wn === null && (kt = br), X.baseState = kt, X.firstBaseUpdate = hn, X.lastBaseUpdate = wn, x = X.shared.interleaved, x !== null) {
          X = x;
          do
            Ae |= X.lane, X = X.next;
          while (X !== x);
        } else
          $ === null && (X.shared.lanes = 0);
        Nc |= Ae, y.lanes = Ae, y.memoizedState = br;
      }
    }
    function Fp(y, x, L) {
      if (y = x.effects, x.effects = null, y !== null)
        for (x = 0; x < y.length; x++) {
          var k = y[x], X = k.callback;
          if (X !== null) {
            if (k.callback = null, k = L, typeof X != "function")
              throw Error(l(191, X));
            X.call(k);
          }
        }
    }
    var pg = new r.Component().refs;
    function $h(y, x, L, k) {
      x = y.memoizedState, L = L(k, x), L = L == null ? x : s({}, x, L), y.memoizedState = L, y.lanes === 0 && (y.updateQueue.baseState = L);
    }
    var Pm = { isMounted: function(y) {
      return (y = y._reactInternals) ? re(y) === y : !1;
    }, enqueueSetState: function(y, x, L) {
      y = y._reactInternals;
      var k = ui(), X = Fs(y), $ = el(k, X);
      $.payload = x, L != null && ($.callback = L), Ku(y, $), x = Xl(y, X, k), x !== null && Kh(x, y, X);
    }, enqueueReplaceState: function(y, x, L) {
      y = y._reactInternals;
      var k = ui(), X = Fs(y), $ = el(k, X);
      $.tag = 1, $.payload = x, L != null && ($.callback = L), Ku(y, $), x = Xl(y, X, k), x !== null && Kh(x, y, X);
    }, enqueueForceUpdate: function(y, x) {
      y = y._reactInternals;
      var L = ui(), k = Fs(y), X = el(
        L,
        k
      );
      X.tag = 2, x != null && (X.callback = x), Ku(y, X), x = Xl(y, k, L), x !== null && Kh(x, y, k);
    } };
    function Om(y, x, L, k, X, $, Ae) {
      return y = y.stateNode, typeof y.shouldComponentUpdate == "function" ? y.shouldComponentUpdate(k, $, Ae) : x.prototype && x.prototype.isPureReactComponent ? !Ki(L, k) || !Ki(X, $) : !0;
    }
    function Um(y, x, L) {
      var k = !1, X = Ea, $ = x.contextType;
      return typeof $ == "object" && $ !== null ? $ = qr($) : (X = Pa(x) ? Uo : Si.current, k = x.contextTypes, $ = (k = k != null) ? zo(y, X) : Ea), x = new x(L, $), y.memoizedState = x.state !== null && x.state !== void 0 ? x.state : null, x.updater = Pm, y.stateNode = x, x._reactInternals = y, k && (y = y.stateNode, y.__reactInternalMemoizedUnmaskedChildContext = X, y.__reactInternalMemoizedMaskedChildContext = $), x;
    }
    function zm(y, x, L, k) {
      y = x.state, typeof x.componentWillReceiveProps == "function" && x.componentWillReceiveProps(L, k), typeof x.UNSAFE_componentWillReceiveProps == "function" && x.UNSAFE_componentWillReceiveProps(L, k), x.state !== y && Pm.enqueueReplaceState(x, x.state, null);
    }
    function gh(y, x, L, k) {
      var X = y.stateNode;
      X.props = L, X.state = y.memoizedState, X.refs = pg, Zs(y);
      var $ = x.contextType;
      typeof $ == "object" && $ !== null ? X.context = qr($) : ($ = Pa(x) ? Uo : Si.current, X.context = zo(y, $)), X.state = y.memoizedState, $ = x.getDerivedStateFromProps, typeof $ == "function" && ($h(y, x, $, L), X.state = y.memoizedState), typeof x.getDerivedStateFromProps == "function" || typeof X.getSnapshotBeforeUpdate == "function" || typeof X.UNSAFE_componentWillMount != "function" && typeof X.componentWillMount != "function" || (x = X.state, typeof X.componentWillMount == "function" && X.componentWillMount(), typeof X.UNSAFE_componentWillMount == "function" && X.UNSAFE_componentWillMount(), x !== X.state && Pm.enqueueReplaceState(X, X.state, null), Au(y, L, X, k), X.state = y.memoizedState), typeof X.componentDidMount == "function" && (y.flags |= 4194308);
    }
    var $u = [], Fd = 0, Du = null, kp = 0, pl = [], tl = 0, vf = null, $f = 1, cu = "";
    function gf(y, x) {
      $u[Fd++] = kp, $u[Fd++] = Du, Du = y, kp = x;
    }
    function zl(y, x, L) {
      pl[tl++] = $f, pl[tl++] = cu, pl[tl++] = vf, vf = y;
      var k = $f;
      y = cu;
      var X = 32 - Ps(k) - 1;
      k &= ~(1 << X), L += 1;
      var $ = 32 - Ps(x) + X;
      if (30 < $) {
        var Ae = X - X % 5;
        $ = (k & (1 << Ae) - 1).toString(32), k >>= Ae, X -= Ae, $f = 1 << 32 - Ps(x) + X | L << X | k, cu = $ + y;
      } else
        $f = 1 << $ | L << X | k, cu = y;
    }
    function ec(y) {
      y.return !== null && (gf(y, 1), zl(y, 1, 0));
    }
    function Oi(y) {
      for (; y === Du; )
        Du = $u[--Fd], $u[Fd] = null, kp = $u[--Fd], $u[Fd] = null;
      for (; y === vf; )
        vf = pl[--tl], pl[tl] = null, cu = pl[--tl], pl[tl] = null, $f = pl[--tl], pl[tl] = null;
    }
    var Za = null, Ma = null, ca = !1, kd = !1, nl = null;
    function Nm(y, x) {
      var L = Mo(5, null, null, 0);
      L.elementType = "DELETED", L.stateNode = x, L.return = y, x = y.deletions, x === null ? (y.deletions = [L], y.flags |= 16) : x.push(L);
    }
    function Fm(y, x) {
      switch (y.tag) {
        case 5:
          return x = ii(x, y.type, y.pendingProps), x !== null ? (y.stateNode = x, Za = y, Ma = de(x), !0) : !1;
        case 6:
          return x = Bi(x, y.pendingProps), x !== null ? (y.stateNode = x, Za = y, Ma = null, !0) : !1;
        case 13:
          if (x = xi(x), x !== null) {
            var L = vf !== null ? { id: $f, overflow: cu } : null;
            return y.memoizedState = { dehydrated: x, treeContext: L, retryLane: 1073741824 }, L = Mo(18, null, null, 0), L.stateNode = x, L.return = y, y.child = L, Za = y, Ma = null, !0;
          }
          return !1;
        default:
          return !1;
      }
    }
    function yh(y) {
      return (y.mode & 1) !== 0 && (y.flags & 128) === 0;
    }
    function ed(y) {
      if (ca) {
        var x = Ma;
        if (x) {
          var L = x;
          if (!Fm(y, x)) {
            if (yh(y))
              throw Error(l(418));
            x = ot(L);
            var k = Za;
            x && Fm(y, x) ? Nm(k, L) : (y.flags = y.flags & -4097 | 2, ca = !1, Za = y);
          }
        } else {
          if (yh(y))
            throw Error(l(418));
          y.flags = y.flags & -4097 | 2, ca = !1, Za = y;
        }
      }
    }
    function Id(y) {
      for (y = y.return; y !== null && y.tag !== 5 && y.tag !== 3 && y.tag !== 13; )
        y = y.return;
      Za = y;
    }
    function Ip(y) {
      if (!qe || y !== Za)
        return !1;
      if (!ca)
        return Id(y), ca = !0, !1;
      if (y.tag !== 3 && (y.tag !== 5 || Yi(y.type) && !rt(y.type, y.memoizedProps))) {
        var x = Ma;
        if (x) {
          if (yh(y)) {
            for (y = Ma; y; )
              y = ot(y);
            throw Error(l(418));
          }
          for (; x; )
            Nm(y, x), x = ot(x);
        }
      }
      if (Id(y), y.tag === 13) {
        if (!qe)
          throw Error(l(316));
        if (y = y.memoizedState, y = y !== null ? y.dehydrated : null, !y)
          throw Error(l(317));
        Ma = gn(y);
      } else
        Ma = Za ? ot(y.stateNode) : null;
      return !0;
    }
    function xh() {
      qe && (Ma = Za = null, kd = ca = !1);
    }
    function Bd(y) {
      nl === null ? nl = [y] : nl.push(y);
    }
    function td(y, x, L) {
      if (y = L.ref, y !== null && typeof y != "function" && typeof y != "object") {
        if (L._owner) {
          if (L = L._owner, L) {
            if (L.tag !== 1)
              throw Error(l(309));
            var k = L.stateNode;
          }
          if (!k)
            throw Error(l(147, y));
          var X = k, $ = "" + y;
          return x !== null && x.ref !== null && typeof x.ref == "function" && x.ref._stringRef === $ ? x.ref : (x = function(Ae) {
            var $e = X.refs;
            $e === pg && ($e = X.refs = {}), Ae === null ? delete $e[$] : $e[$] = Ae;
          }, x._stringRef = $, x);
        }
        if (typeof y != "string")
          throw Error(l(284));
        if (!L._owner)
          throw Error(l(290, y));
      }
      return y;
    }
    function Ss(y, x) {
      throw y = Object.prototype.toString.call(x), Error(l(31, y === "[object Object]" ? "object with keys {" + Object.keys(x).join(", ") + "}" : y));
    }
    function tc(y) {
      var x = y._init;
      return x(y._payload);
    }
    function yf(y) {
      function x(pt, Ze) {
        if (y) {
          var Lt = pt.deletions;
          Lt === null ? (pt.deletions = [Ze], pt.flags |= 16) : Lt.push(Ze);
        }
      }
      function L(pt, Ze) {
        if (!y)
          return null;
        for (; Ze !== null; )
          x(pt, Ze), Ze = Ze.sibling;
        return null;
      }
      function k(pt, Ze) {
        for (pt = /* @__PURE__ */ new Map(); Ze !== null; )
          Ze.key !== null ? pt.set(Ze.key, Ze) : pt.set(Ze.index, Ze), Ze = Ze.sibling;
        return pt;
      }
      function X(pt, Ze) {
        return pt = Xo(pt, Ze), pt.index = 0, pt.sibling = null, pt;
      }
      function $(pt, Ze, Lt) {
        return pt.index = Lt, y ? (Lt = pt.alternate, Lt !== null ? (Lt = Lt.index, Lt < Ze ? (pt.flags |= 2, Ze) : Lt) : (pt.flags |= 2, Ze)) : (pt.flags |= 1048576, Ze);
      }
      function Ae(pt) {
        return y && pt.alternate === null && (pt.flags |= 2), pt;
      }
      function $e(pt, Ze, Lt, Qt) {
        return Ze === null || Ze.tag !== 6 ? (Ze = Ts(Lt, pt.mode, Qt), Ze.return = pt, Ze) : (Ze = X(Ze, Lt), Ze.return = pt, Ze);
      }
      function kt(pt, Ze, Lt, Qt) {
        var jn = Lt.type;
        return jn === _ ? wn(pt, Ze, Lt.props.children, Qt, Lt.key) : Ze !== null && (Ze.elementType === jn || typeof jn == "object" && jn !== null && jn.$$typeof === G && tc(jn) === Ze.type) ? (Qt = X(Ze, Lt.props), Qt.ref = td(pt, Ze, Lt), Qt.return = pt, Qt) : (Qt = hd(Lt.type, Lt.key, Lt.props, null, pt.mode, Qt), Qt.ref = td(pt, Ze, Lt), Qt.return = pt, Qt);
      }
      function hn(pt, Ze, Lt, Qt) {
        return Ze === null || Ze.tag !== 4 || Ze.stateNode.containerInfo !== Lt.containerInfo || Ze.stateNode.implementation !== Lt.implementation ? (Ze = Is(Lt, pt.mode, Qt), Ze.return = pt, Ze) : (Ze = X(Ze, Lt.children || []), Ze.return = pt, Ze);
      }
      function wn(pt, Ze, Lt, Qt, jn) {
        return Ze === null || Ze.tag !== 7 ? (Ze = gu(Lt, pt.mode, Qt, jn), Ze.return = pt, Ze) : (Ze = X(Ze, Lt), Ze.return = pt, Ze);
      }
      function br(pt, Ze, Lt) {
        if (typeof Ze == "string" && Ze !== "" || typeof Ze == "number")
          return Ze = Ts("" + Ze, pt.mode, Lt), Ze.return = pt, Ze;
        if (typeof Ze == "object" && Ze !== null) {
          switch (Ze.$$typeof) {
            case p:
              return Lt = hd(Ze.type, Ze.key, Ze.props, null, pt.mode, Lt), Lt.ref = td(pt, null, Ze), Lt.return = pt, Lt;
            case g:
              return Ze = Is(Ze, pt.mode, Lt), Ze.return = pt, Ze;
            case G:
              var Qt = Ze._init;
              return br(pt, Qt(Ze._payload), Lt);
          }
          if (De(Ze) || K(Ze))
            return Ze = gu(Ze, pt.mode, Lt, null), Ze.return = pt, Ze;
          Ss(pt, Ze);
        }
        return null;
      }
      function ur(pt, Ze, Lt, Qt) {
        var jn = Ze !== null ? Ze.key : null;
        if (typeof Lt == "string" && Lt !== "" || typeof Lt == "number")
          return jn !== null ? null : $e(pt, Ze, "" + Lt, Qt);
        if (typeof Lt == "object" && Lt !== null) {
          switch (Lt.$$typeof) {
            case p:
              return Lt.key === jn ? kt(pt, Ze, Lt, Qt) : null;
            case g:
              return Lt.key === jn ? hn(pt, Ze, Lt, Qt) : null;
            case G:
              return jn = Lt._init, ur(
                pt,
                Ze,
                jn(Lt._payload),
                Qt
              );
          }
          if (De(Lt) || K(Lt))
            return jn !== null ? null : wn(pt, Ze, Lt, Qt, null);
          Ss(pt, Lt);
        }
        return null;
      }
      function Sa(pt, Ze, Lt, Qt, jn) {
        if (typeof Qt == "string" && Qt !== "" || typeof Qt == "number")
          return pt = pt.get(Lt) || null, $e(Ze, pt, "" + Qt, jn);
        if (typeof Qt == "object" && Qt !== null) {
          switch (Qt.$$typeof) {
            case p:
              return pt = pt.get(Qt.key === null ? Lt : Qt.key) || null, kt(Ze, pt, Qt, jn);
            case g:
              return pt = pt.get(Qt.key === null ? Lt : Qt.key) || null, hn(Ze, pt, Qt, jn);
            case G:
              var Wr = Qt._init;
              return Sa(pt, Ze, Lt, Wr(Qt._payload), jn);
          }
          if (De(Qt) || K(Qt))
            return pt = pt.get(Lt) || null, wn(Ze, pt, Qt, jn, null);
          Ss(Ze, Qt);
        }
        return null;
      }
      function Tn(pt, Ze, Lt, Qt) {
        for (var jn = null, Wr = null, Er = Ze, Ar = Ze = 0, Va = null; Er !== null && Ar < Lt.length; Ar++) {
          Er.index > Ar ? (Va = Er, Er = null) : Va = Er.sibling;
          var Zr = ur(pt, Er, Lt[Ar], Qt);
          if (Zr === null) {
            Er === null && (Er = Va);
            break;
          }
          y && Er && Zr.alternate === null && x(pt, Er), Ze = $(Zr, Ze, Ar), Wr === null ? jn = Zr : Wr.sibling = Zr, Wr = Zr, Er = Va;
        }
        if (Ar === Lt.length)
          return L(pt, Er), ca && gf(pt, Ar), jn;
        if (Er === null) {
          for (; Ar < Lt.length; Ar++)
            Er = br(pt, Lt[Ar], Qt), Er !== null && (Ze = $(Er, Ze, Ar), Wr === null ? jn = Er : Wr.sibling = Er, Wr = Er);
          return ca && gf(pt, Ar), jn;
        }
        for (Er = k(pt, Er); Ar < Lt.length; Ar++)
          Va = Sa(Er, pt, Ar, Lt[Ar], Qt), Va !== null && (y && Va.alternate !== null && Er.delete(Va.key === null ? Ar : Va.key), Ze = $(Va, Ze, Ar), Wr === null ? jn = Va : Wr.sibling = Va, Wr = Va);
        return y && Er.forEach(function(hc) {
          return x(pt, hc);
        }), ca && gf(pt, Ar), jn;
      }
      function Li(pt, Ze, Lt, Qt) {
        var jn = K(Lt);
        if (typeof jn != "function")
          throw Error(l(150));
        if (Lt = jn.call(Lt), Lt == null)
          throw Error(l(151));
        for (var Wr = jn = null, Er = Ze, Ar = Ze = 0, Va = null, Zr = Lt.next(); Er !== null && !Zr.done; Ar++, Zr = Lt.next()) {
          Er.index > Ar ? (Va = Er, Er = null) : Va = Er.sibling;
          var hc = ur(pt, Er, Zr.value, Qt);
          if (hc === null) {
            Er === null && (Er = Va);
            break;
          }
          y && Er && hc.alternate === null && x(pt, Er), Ze = $(hc, Ze, Ar), Wr === null ? jn = hc : Wr.sibling = hc, Wr = hc, Er = Va;
        }
        if (Zr.done)
          return L(
            pt,
            Er
          ), ca && gf(pt, Ar), jn;
        if (Er === null) {
          for (; !Zr.done; Ar++, Zr = Lt.next())
            Zr = br(pt, Zr.value, Qt), Zr !== null && (Ze = $(Zr, Ze, Ar), Wr === null ? jn = Zr : Wr.sibling = Zr, Wr = Zr);
          return ca && gf(pt, Ar), jn;
        }
        for (Er = k(pt, Er); !Zr.done; Ar++, Zr = Lt.next())
          Zr = Sa(Er, pt, Ar, Zr.value, Qt), Zr !== null && (y && Zr.alternate !== null && Er.delete(Zr.key === null ? Ar : Zr.key), Ze = $(Zr, Ze, Ar), Wr === null ? jn = Zr : Wr.sibling = Zr, Wr = Zr);
        return y && Er.forEach(function(md) {
          return x(pt, md);
        }), ca && gf(pt, Ar), jn;
      }
      function vs(pt, Ze, Lt, Qt) {
        if (typeof Lt == "object" && Lt !== null && Lt.type === _ && Lt.key === null && (Lt = Lt.props.children), typeof Lt == "object" && Lt !== null) {
          switch (Lt.$$typeof) {
            case p:
              e: {
                for (var jn = Lt.key, Wr = Ze; Wr !== null; ) {
                  if (Wr.key === jn) {
                    if (jn = Lt.type, jn === _) {
                      if (Wr.tag === 7) {
                        L(pt, Wr.sibling), Ze = X(Wr, Lt.props.children), Ze.return = pt, pt = Ze;
                        break e;
                      }
                    } else if (Wr.elementType === jn || typeof jn == "object" && jn !== null && jn.$$typeof === G && tc(jn) === Wr.type) {
                      L(pt, Wr.sibling), Ze = X(Wr, Lt.props), Ze.ref = td(pt, Wr, Lt), Ze.return = pt, pt = Ze;
                      break e;
                    }
                    L(pt, Wr);
                    break;
                  } else
                    x(pt, Wr);
                  Wr = Wr.sibling;
                }
                Lt.type === _ ? (Ze = gu(Lt.props.children, pt.mode, Qt, Lt.key), Ze.return = pt, pt = Ze) : (Qt = hd(Lt.type, Lt.key, Lt.props, null, pt.mode, Qt), Qt.ref = td(pt, Ze, Lt), Qt.return = pt, pt = Qt);
              }
              return Ae(pt);
            case g:
              e: {
                for (Wr = Lt.key; Ze !== null; ) {
                  if (Ze.key === Wr)
                    if (Ze.tag === 4 && Ze.stateNode.containerInfo === Lt.containerInfo && Ze.stateNode.implementation === Lt.implementation) {
                      L(pt, Ze.sibling), Ze = X(Ze, Lt.children || []), Ze.return = pt, pt = Ze;
                      break e;
                    } else {
                      L(pt, Ze);
                      break;
                    }
                  else
                    x(pt, Ze);
                  Ze = Ze.sibling;
                }
                Ze = Is(Lt, pt.mode, Qt), Ze.return = pt, pt = Ze;
              }
              return Ae(pt);
            case G:
              return Wr = Lt._init, vs(pt, Ze, Wr(Lt._payload), Qt);
          }
          if (De(Lt))
            return Tn(pt, Ze, Lt, Qt);
          if (K(Lt))
            return Li(pt, Ze, Lt, Qt);
          Ss(pt, Lt);
        }
        return typeof Lt == "string" && Lt !== "" || typeof Lt == "number" ? (Lt = "" + Lt, Ze !== null && Ze.tag === 6 ? (L(pt, Ze.sibling), Ze = X(Ze, Lt), Ze.return = pt, pt = Ze) : (L(pt, Ze), Ze = Ts(Lt, pt.mode, Qt), Ze.return = pt, pt = Ze), Ae(pt)) : L(pt, Ze);
      }
      return vs;
    }
    var Ec = yf(!0), Bp = yf(!1), nc = {}, Na = cs(nc), Hd = cs(nc), nd = cs(nc);
    function rc(y) {
      if (y === nc)
        throw Error(l(174));
      return y;
    }
    function Hp(y, x) {
      di(nd, x), di(Hd, y), di(Na, nc), y = He(x), mr(Na), di(Na, y);
    }
    function _h() {
      mr(Na), mr(Hd), mr(nd);
    }
    function Vp(y) {
      var x = rc(nd.current), L = rc(Na.current);
      x = ve(L, y.type, x), L !== x && (di(Hd, y), di(Na, x));
    }
    function Io(y) {
      Hd.current === y && (mr(Na), mr(Hd));
    }
    var Xe = cs(0);
    function Bt(y) {
      for (var x = y; x !== null; ) {
        if (x.tag === 13) {
          var L = x.memoizedState;
          if (L !== null && (L = L.dehydrated, L === null || $r(L) || ai(L)))
            return x;
        } else if (x.tag === 19 && x.memoizedProps.revealOrder !== void 0) {
          if ((x.flags & 128) !== 0)
            return x;
        } else if (x.child !== null) {
          x.child.return = x, x = x.child;
          continue;
        }
        if (x === y)
          break;
        for (; x.sibling === null; ) {
          if (x.return === null || x.return === y)
            return null;
          x = x.return;
        }
        x.sibling.return = x.return, x = x.sibling;
      }
      return null;
    }
    var vt = [];
    function Mn() {
      for (var y = 0; y < vt.length; y++) {
        var x = vt[y];
        gt ? x._workInProgressVersionPrimary = null : x._workInProgressVersionSecondary = null;
      }
      vt.length = 0;
    }
    var $n = d.ReactCurrentDispatcher, or = d.ReactCurrentBatchConfig, Ta = 0, er = null, Ui = null, ia = null, Bo = !1, ds = !1, Vd = 0, Nl = 0;
    function $a() {
      throw Error(l(321));
    }
    function ml(y, x) {
      if (x === null)
        return !1;
      for (var L = 0; L < x.length && L < y.length; L++)
        if (!Fo(y[L], x[L]))
          return !1;
      return !0;
    }
    function _i(y, x, L, k, X, $) {
      if (Ta = $, er = x, x.memoizedState = null, x.updateQueue = null, x.lanes = 0, $n.current = y === null || y.memoizedState === null ? Ou : ad, y = L(k, X), ds) {
        $ = 0;
        do {
          if (ds = !1, Vd = 0, 25 <= $)
            throw Error(l(301));
          $ += 1, ia = Ui = null, x.updateQueue = null, $n.current = fu, y = L(k, X);
        } while (ds);
      }
      if ($n.current = Sf, x = Ui !== null && Ui.next !== null, Ta = 0, ia = Ui = er = null, Bo = !1, x)
        throw Error(l(300));
      return y;
    }
    function Mc() {
      var y = Vd !== 0;
      return Vd = 0, y;
    }
    function Lu() {
      var y = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
      return ia === null ? er.memoizedState = ia = y : ia = ia.next = y, ia;
    }
    function vl() {
      if (Ui === null) {
        var y = er.alternate;
        y = y !== null ? y.memoizedState : null;
      } else
        y = Ui.next;
      var x = ia === null ? er.memoizedState : ia.next;
      if (x !== null)
        ia = x, Ui = y;
      else {
        if (y === null)
          throw Error(l(310));
        Ui = y, y = { memoizedState: Ui.memoizedState, baseState: Ui.baseState, baseQueue: Ui.baseQueue, queue: Ui.queue, next: null }, ia === null ? er.memoizedState = ia = y : ia = ia.next = y;
      }
      return ia;
    }
    function Ca(y, x) {
      return typeof x == "function" ? x(y) : x;
    }
    function Sh(y) {
      var x = vl(), L = x.queue;
      if (L === null)
        throw Error(l(311));
      L.lastRenderedReducer = y;
      var k = Ui, X = k.baseQueue, $ = L.pending;
      if ($ !== null) {
        if (X !== null) {
          var Ae = X.next;
          X.next = $.next, $.next = Ae;
        }
        k.baseQueue = X = $, L.pending = null;
      }
      if (X !== null) {
        $ = X.next, k = k.baseState;
        var $e = Ae = null, kt = null, hn = $;
        do {
          var wn = hn.lane;
          if ((Ta & wn) === wn)
            kt !== null && (kt = kt.next = { lane: 0, action: hn.action, hasEagerState: hn.hasEagerState, eagerState: hn.eagerState, next: null }), k = hn.hasEagerState ? hn.eagerState : y(k, hn.action);
          else {
            var br = {
              lane: wn,
              action: hn.action,
              hasEagerState: hn.hasEagerState,
              eagerState: hn.eagerState,
              next: null
            };
            kt === null ? ($e = kt = br, Ae = k) : kt = kt.next = br, er.lanes |= wn, Nc |= wn;
          }
          hn = hn.next;
        } while (hn !== null && hn !== $);
        kt === null ? Ae = k : kt.next = $e, Fo(k, x.memoizedState) || (si = !0), x.memoizedState = k, x.baseState = Ae, x.baseQueue = kt, L.lastRenderedState = k;
      }
      if (y = L.interleaved, y !== null) {
        X = y;
        do
          $ = X.lane, er.lanes |= $, Nc |= $, X = X.next;
        while (X !== y);
      } else
        X === null && (L.lanes = 0);
      return [x.memoizedState, L.dispatch];
    }
    function Gp(y) {
      var x = vl(), L = x.queue;
      if (L === null)
        throw Error(l(311));
      L.lastRenderedReducer = y;
      var k = L.dispatch, X = L.pending, $ = x.memoizedState;
      if (X !== null) {
        L.pending = null;
        var Ae = X = X.next;
        do
          $ = y($, Ae.action), Ae = Ae.next;
        while (Ae !== X);
        Fo($, x.memoizedState) || (si = !0), x.memoizedState = $, x.baseQueue === null && (x.baseState = $), L.lastRenderedState = $;
      }
      return [$, k];
    }
    function Tc() {
    }
    function Cc(y, x) {
      var L = er, k = vl(), X = x(), $ = !Fo(k.memoizedState, X);
      if ($ && (k.memoizedState = X, si = !0), k = k.queue, sn(Br.bind(null, L, k, y), [y]), k.getSnapshot !== x || $ || ia !== null && ia.memoizedState.tag & 1) {
        if (L.flags |= 2048, rd(9, $i.bind(null, L, k, X, x), void 0, null), Ra === null)
          throw Error(l(349));
        (Ta & 30) !== 0 || Mr(L, x, X);
      }
      return X;
    }
    function Mr(y, x, L) {
      y.flags |= 16384, y = { getSnapshot: x, value: L }, x = er.updateQueue, x === null ? (x = { lastEffect: null, stores: null }, er.updateQueue = x, x.stores = [y]) : (L = x.stores, L === null ? x.stores = [y] : L.push(y));
    }
    function $i(y, x, L, k) {
      x.value = L, x.getSnapshot = k, Fa(x) && Xl(y, 1, -1);
    }
    function Br(y, x, L) {
      return L(function() {
        Fa(x) && Xl(y, 1, -1);
      });
    }
    function Fa(y) {
      var x = y.getSnapshot;
      y = y.value;
      try {
        var L = x();
        return !Fo(y, L);
      } catch {
        return !0;
      }
    }
    function _o(y) {
      var x = Lu();
      return typeof y == "function" && (y = y()), x.memoizedState = x.baseState = y, y = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Ca, lastRenderedState: y }, x.queue = y, y = y.dispatch = Js.bind(null, er, y), [x.memoizedState, y];
    }
    function rd(y, x, L, k) {
      return y = { tag: y, create: x, destroy: L, deps: k, next: null }, x = er.updateQueue, x === null ? (x = { lastEffect: null, stores: null }, er.updateQueue = x, x.lastEffect = y.next = y) : (L = x.lastEffect, L === null ? x.lastEffect = y.next = y : (k = L.next, L.next = y, y.next = k, x.lastEffect = y)), y;
    }
    function wh() {
      return vl().memoizedState;
    }
    function ic(y, x, L, k) {
      var X = Lu();
      er.flags |= y, X.memoizedState = rd(1 | x, L, void 0, k === void 0 ? null : k);
    }
    function xf(y, x, L, k) {
      var X = vl();
      k = k === void 0 ? null : k;
      var $ = void 0;
      if (Ui !== null) {
        var Ae = Ui.memoizedState;
        if ($ = Ae.destroy, k !== null && ml(k, Ae.deps)) {
          X.memoizedState = rd(x, L, $, k);
          return;
        }
      }
      er.flags |= y, X.memoizedState = rd(1 | x, L, $, k);
    }
    function id(y, x) {
      return ic(8390656, 8, y, x);
    }
    function sn(y, x) {
      return xf(2048, 8, y, x);
    }
    function kr(y, x) {
      return xf(4, 2, y, x);
    }
    function Hr(y, x) {
      return xf(4, 4, y, x);
    }
    function Ho(y, x) {
      if (typeof x == "function")
        return y = y(), x(y), function() {
          x(null);
        };
      if (x != null)
        return y = y(), x.current = y, function() {
          x.current = null;
        };
    }
    function rl(y, x, L) {
      return L = L != null ? L.concat([y]) : null, xf(4, 4, Ho.bind(null, x, y), L);
    }
    function ac() {
    }
    function Pu(y, x) {
      var L = vl();
      x = x === void 0 ? null : x;
      var k = L.memoizedState;
      return k !== null && x !== null && ml(x, k[1]) ? k[0] : (L.memoizedState = [y, x], y);
    }
    function Rc(y, x) {
      var L = vl();
      x = x === void 0 ? null : x;
      var k = L.memoizedState;
      return k !== null && x !== null && ml(x, k[1]) ? k[0] : (y = y(), L.memoizedState = [y, x], y);
    }
    function _f(y, x) {
      var L = Cr;
      Cr = L !== 0 && 4 > L ? L : 4, y(!0);
      var k = or.transition;
      or.transition = {};
      try {
        y(!1), x();
      } finally {
        Cr = L, or.transition = k;
      }
    }
    function sc() {
      return vl().memoizedState;
    }
    function hs(y, x, L) {
      var k = Fs(y);
      L = { lane: k, action: L, hasEagerState: !1, eagerState: null, next: null }, km(y) ? ep(x, L) : (Gd(y, x, L), L = ui(), y = Xl(y, k, L), y !== null && bh(y, x, k));
    }
    function Js(y, x, L) {
      var k = Fs(y), X = { lane: k, action: L, hasEagerState: !1, eagerState: null, next: null };
      if (km(y))
        ep(x, X);
      else {
        Gd(y, x, X);
        var $ = y.alternate;
        if (y.lanes === 0 && ($ === null || $.lanes === 0) && ($ = x.lastRenderedReducer, $ !== null))
          try {
            var Ae = x.lastRenderedState, $e = $(Ae, L);
            if (X.hasEagerState = !0, X.eagerState = $e, Fo($e, Ae))
              return;
          } catch {
          } finally {
          }
        L = ui(), y = Xl(y, k, L), y !== null && bh(y, x, k);
      }
    }
    function km(y) {
      var x = y.alternate;
      return y === er || x !== null && x === er;
    }
    function ep(y, x) {
      ds = Bo = !0;
      var L = y.pending;
      L === null ? x.next = x : (x.next = L.next, L.next = x), y.pending = x;
    }
    function Gd(y, x, L) {
      Ra !== null && (y.mode & 1) !== 0 && (Qr & 2) === 0 ? (y = x.interleaved, y === null ? (L.next = L, _s === null ? _s = [x] : _s.push(x)) : (L.next = y.next, y.next = L), x.interleaved = L) : (y = x.pending, y === null ? L.next = L : (L.next = y.next, y.next = L), x.pending = L);
    }
    function bh(y, x, L) {
      if ((L & 4194240) !== 0) {
        var k = x.lanes;
        k &= y.pendingLanes, L |= k, x.lanes = L, ua(y, L);
      }
    }
    var Sf = { readContext: qr, useCallback: $a, useContext: $a, useEffect: $a, useImperativeHandle: $a, useInsertionEffect: $a, useLayoutEffect: $a, useMemo: $a, useReducer: $a, useRef: $a, useState: $a, useDebugValue: $a, useDeferredValue: $a, useTransition: $a, useMutableSource: $a, useSyncExternalStore: $a, useId: $a, unstable_isNewReconciler: !1 }, Ou = { readContext: qr, useCallback: function(y, x) {
      return Lu().memoizedState = [y, x === void 0 ? null : x], y;
    }, useContext: qr, useEffect: id, useImperativeHandle: function(y, x, L) {
      return L = L != null ? L.concat([y]) : null, ic(
        4194308,
        4,
        Ho.bind(null, x, y),
        L
      );
    }, useLayoutEffect: function(y, x) {
      return ic(4194308, 4, y, x);
    }, useInsertionEffect: function(y, x) {
      return ic(4, 2, y, x);
    }, useMemo: function(y, x) {
      var L = Lu();
      return x = x === void 0 ? null : x, y = y(), L.memoizedState = [y, x], y;
    }, useReducer: function(y, x, L) {
      var k = Lu();
      return x = L !== void 0 ? L(x) : x, k.memoizedState = k.baseState = x, y = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: y, lastRenderedState: x }, k.queue = y, y = y.dispatch = hs.bind(null, er, y), [k.memoizedState, y];
    }, useRef: function(y) {
      var x = Lu();
      return y = { current: y }, x.memoizedState = y;
    }, useState: _o, useDebugValue: ac, useDeferredValue: function(y) {
      var x = _o(y), L = x[0], k = x[1];
      return id(function() {
        var X = or.transition;
        or.transition = {};
        try {
          k(y);
        } finally {
          or.transition = X;
        }
      }, [y]), L;
    }, useTransition: function() {
      var y = _o(!1), x = y[0];
      return y = _f.bind(null, y[1]), Lu().memoizedState = y, [x, y];
    }, useMutableSource: function() {
    }, useSyncExternalStore: function(y, x, L) {
      var k = er, X = Lu();
      if (ca) {
        if (L === void 0)
          throw Error(l(407));
        L = L();
      } else {
        if (L = x(), Ra === null)
          throw Error(l(349));
        (Ta & 30) !== 0 || Mr(k, x, L);
      }
      X.memoizedState = L;
      var $ = { value: L, getSnapshot: x };
      return X.queue = $, id(Br.bind(null, k, $, y), [y]), k.flags |= 2048, rd(9, $i.bind(null, k, $, L, x), void 0, null), L;
    }, useId: function() {
      var y = Lu(), x = Ra.identifierPrefix;
      if (ca) {
        var L = cu, k = $f;
        L = (k & ~(1 << 32 - Ps(k) - 1)).toString(32) + L, x = ":" + x + "R" + L, L = Vd++, 0 < L && (x += "H" + L.toString(32)), x += ":";
      } else
        L = Nl++, x = ":" + x + "r" + L.toString(32) + ":";
      return y.memoizedState = x;
    }, unstable_isNewReconciler: !1 }, ad = {
      readContext: qr,
      useCallback: Pu,
      useContext: qr,
      useEffect: sn,
      useImperativeHandle: rl,
      useInsertionEffect: kr,
      useLayoutEffect: Hr,
      useMemo: Rc,
      useReducer: Sh,
      useRef: wh,
      useState: function() {
        return Sh(Ca);
      },
      useDebugValue: ac,
      useDeferredValue: function(y) {
        var x = Sh(Ca), L = x[0], k = x[1];
        return sn(function() {
          var X = or.transition;
          or.transition = {};
          try {
            k(y);
          } finally {
            or.transition = X;
          }
        }, [y]), L;
      },
      useTransition: function() {
        var y = Sh(Ca)[0], x = vl().memoizedState;
        return [y, x];
      },
      useMutableSource: Tc,
      useSyncExternalStore: Cc,
      useId: sc,
      unstable_isNewReconciler: !1
    }, fu = {
      readContext: qr,
      useCallback: Pu,
      useContext: qr,
      useEffect: sn,
      useImperativeHandle: rl,
      useInsertionEffect: kr,
      useLayoutEffect: Hr,
      useMemo: Rc,
      useReducer: Gp,
      useRef: wh,
      useState: function() {
        return Gp(Ca);
      },
      useDebugValue: ac,
      useDeferredValue: function(y) {
        var x = Gp(Ca), L = x[0], k = x[1];
        return sn(function() {
          var X = or.transition;
          or.transition = {};
          try {
            k(y);
          } finally {
            or.transition = X;
          }
        }, [y]), L;
      },
      useTransition: function() {
        var y = Gp(Ca)[0], x = vl().memoizedState;
        return [y, x];
      },
      useMutableSource: Tc,
      useSyncExternalStore: Cc,
      useId: sc,
      unstable_isNewReconciler: !1
    };
    function wf(y, x) {
      try {
        var L = "", k = x;
        do
          L += Cu(k), k = k.return;
        while (k);
        var X = L;
      } catch ($) {
        X = `
Error generating stack: ` + $.message + `
` + $.stack;
      }
      return { value: y, source: x, stack: X };
    }
    function Ac(y, x) {
      try {
        console.error(x.value);
      } catch (L) {
        setTimeout(function() {
          throw L;
        });
      }
    }
    var Wd = typeof WeakMap == "function" ? WeakMap : Map;
    function sd(y, x, L) {
      L = el(-1, L), L.tag = 3, L.payload = { element: null };
      var k = x.value;
      return L.callback = function() {
        Cf || (Cf = !0, Wl = k), Ac(y, x);
      }, L;
    }
    function Dc(y, x, L) {
      L = el(-1, L), L.tag = 3;
      var k = y.type.getDerivedStateFromError;
      if (typeof k == "function") {
        var X = x.value;
        L.payload = function() {
          return k(X);
        }, L.callback = function() {
          Ac(y, x);
        };
      }
      var $ = y.stateNode;
      return $ !== null && typeof $.componentDidCatch == "function" && (L.callback = function() {
        Ac(y, x), typeof k != "function" && (jl === null ? jl = /* @__PURE__ */ new Set([this]) : jl.add(this));
        var Ae = x.stack;
        this.componentDidCatch(x.value, { componentStack: Ae !== null ? Ae : "" });
      }), L;
    }
    function Fl(y, x, L) {
      var k = y.pingCache;
      if (k === null) {
        k = y.pingCache = new Wd();
        var X = /* @__PURE__ */ new Set();
        k.set(x, X);
      } else
        X = k.get(x), X === void 0 && (X = /* @__PURE__ */ new Set(), k.set(x, X));
      X.has(L) || (X.add(L), y = no.bind(null, y, x, L), x.then(y, y));
    }
    function Lc(y) {
      do {
        var x;
        if ((x = y.tag === 13) && (x = y.memoizedState, x = x !== null ? x.dehydrated !== null : !0), x)
          return y;
        y = y.return;
      } while (y !== null);
      return null;
    }
    function Pc(y, x, L, k, X) {
      return (y.mode & 1) === 0 ? (y === x ? y.flags |= 65536 : (y.flags |= 128, L.flags |= 131072, L.flags &= -52805, L.tag === 1 && (L.alternate === null ? L.tag = 17 : (x = el(-1, 1), x.tag = 2, Ku(L, x))), L.lanes |= 1), y) : (y.flags |= 65536, y.lanes = X, y);
    }
    function Us(y) {
      y.flags |= 4;
    }
    function Uu(y, x) {
      if (y !== null && y.child === x.child)
        return !0;
      if ((x.flags & 16) !== 0)
        return !1;
      for (y = x.child; y !== null; ) {
        if ((y.flags & 12854) !== 0 || (y.subtreeFlags & 12854) !== 0)
          return !1;
        y = y.sibling;
      }
      return !0;
    }
    var So, od, xe, oc;
    if (ft)
      So = function(y, x) {
        for (var L = x.child; L !== null; ) {
          if (L.tag === 5 || L.tag === 6)
            Ee(y, L.stateNode);
          else if (L.tag !== 4 && L.child !== null) {
            L.child.return = L, L = L.child;
            continue;
          }
          if (L === x)
            break;
          for (; L.sibling === null; ) {
            if (L.return === null || L.return === x)
              return;
            L = L.return;
          }
          L.sibling.return = L.return, L = L.sibling;
        }
      }, od = function() {
      }, xe = function(y, x, L, k, X) {
        if (y = y.memoizedProps, y !== k) {
          var $ = x.stateNode, Ae = rc(Na.current);
          L = Je($, L, y, k, X, Ae), (x.updateQueue = L) && Us(x);
        }
      }, oc = function(y, x, L, k) {
        L !== k && Us(x);
      };
    else if (Ie) {
      So = function(y, x, L, k) {
        for (var X = x.child; X !== null; ) {
          if (X.tag === 5) {
            var $ = X.stateNode;
            L && k && ($ = Mi($, X.type, X.memoizedProps, X)), Ee(y, $);
          } else if (X.tag === 6)
            $ = X.stateNode, L && k && ($ = yi($, X.memoizedProps, X)), Ee(y, $);
          else if (X.tag !== 4) {
            if (X.tag === 22 && X.memoizedState !== null)
              $ = X.child, $ !== null && ($.return = X), So(y, X, !0, !0);
            else if (X.child !== null) {
              X.child.return = X, X = X.child;
              continue;
            }
          }
          if (X === x)
            break;
          for (; X.sibling === null; ) {
            if (X.return === null || X.return === x)
              return;
            X = X.return;
          }
          X.sibling.return = X.return, X = X.sibling;
        }
      };
      var Ks = function(y, x, L, k) {
        for (var X = x.child; X !== null; ) {
          if (X.tag === 5) {
            var $ = X.stateNode;
            L && k && ($ = Mi($, X.type, X.memoizedProps, X)), Ii(y, $);
          } else if (X.tag === 6)
            $ = X.stateNode, L && k && ($ = yi($, X.memoizedProps, X)), Ii(y, $);
          else if (X.tag !== 4) {
            if (X.tag === 22 && X.memoizedState !== null)
              $ = X.child, $ !== null && ($.return = X), Ks(y, X, !0, !0);
            else if (X.child !== null) {
              X.child.return = X, X = X.child;
              continue;
            }
          }
          if (X === x)
            break;
          for (; X.sibling === null; ) {
            if (X.return === null || X.return === x)
              return;
            X = X.return;
          }
          X.sibling.return = X.return, X = X.sibling;
        }
      };
      od = function(y, x) {
        var L = x.stateNode;
        if (!Uu(y, x)) {
          y = L.containerInfo;
          var k = Or(y);
          Ks(k, x, !1, !1), L.pendingChildren = k, Us(x), Ir(y, k);
        }
      }, xe = function(y, x, L, k, X) {
        var $ = y.stateNode, Ae = y.memoizedProps;
        if ((y = Uu(y, x)) && Ae === k)
          x.stateNode = $;
        else {
          var $e = x.stateNode, kt = rc(Na.current), hn = null;
          Ae !== k && (hn = Je($e, L, Ae, k, X, kt)), y && hn === null ? x.stateNode = $ : ($ = ki($, hn, L, Ae, k, x, y, $e), Ve($, L, k, X, kt) && Us(x), x.stateNode = $, y ? Us(x) : So($, x, !1, !1));
        }
      }, oc = function(y, x, L, k) {
        L !== k ? (y = rc(nd.current), L = rc(Na.current), x.stateNode = Ne(k, y, L, x), Us(x)) : x.stateNode = y.stateNode;
      };
    } else
      od = function() {
      }, xe = function() {
      }, oc = function() {
      };
    function ka(y, x) {
      if (!ca)
        switch (y.tailMode) {
          case "hidden":
            x = y.tail;
            for (var L = null; x !== null; )
              x.alternate !== null && (L = x), x = x.sibling;
            L === null ? y.tail = null : L.sibling = null;
            break;
          case "collapsed":
            L = y.tail;
            for (var k = null; L !== null; )
              L.alternate !== null && (k = L), L = L.sibling;
            k === null ? x || y.tail === null ? y.tail = null : y.tail.sibling = null : k.sibling = null;
        }
    }
    function Gn(y) {
      var x = y.alternate !== null && y.alternate.child === y.child, L = 0, k = 0;
      if (x)
        for (var X = y.child; X !== null; )
          L |= X.lanes | X.childLanes, k |= X.subtreeFlags & 14680064, k |= X.flags & 14680064, X.return = y, X = X.sibling;
      else
        for (X = y.child; X !== null; )
          L |= X.lanes | X.childLanes, k |= X.subtreeFlags, k |= X.flags, X.return = y, X = X.sibling;
      return y.subtreeFlags |= k, y.childLanes = L, x;
    }
    function vr(y, x, L) {
      var k = x.pendingProps;
      switch (Oi(x), x.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return Gn(x), null;
        case 1:
          return Pa(x.type) && Dl(), Gn(x), null;
        case 3:
          return k = x.stateNode, _h(), mr(Ti), mr(Si), Mn(), k.pendingContext && (k.context = k.pendingContext, k.pendingContext = null), (y === null || y.child === null) && (Ip(x) ? Us(x) : y === null || y.memoizedState.isDehydrated && (x.flags & 256) === 0 || (x.flags |= 1024, nl !== null && (Ht(nl), nl = null))), od(y, x), Gn(x), null;
        case 5:
          Io(x), L = rc(nd.current);
          var X = x.type;
          if (y !== null && x.stateNode != null)
            xe(y, x, X, k, L), y.ref !== x.ref && (x.flags |= 512, x.flags |= 2097152);
          else {
            if (!k) {
              if (x.stateNode === null)
                throw Error(l(166));
              return Gn(x), null;
            }
            if (y = rc(Na.current), Ip(x)) {
              if (!qe)
                throw Error(l(175));
              y = $t(x.stateNode, x.type, x.memoizedProps, L, y, x, !kd), x.updateQueue = y, y !== null && Us(x);
            } else {
              var $ = ye(X, k, L, y, x);
              So($, x, !1, !1), x.stateNode = $, Ve($, X, k, L, y) && Us(x);
            }
            x.ref !== null && (x.flags |= 512, x.flags |= 2097152);
          }
          return Gn(x), null;
        case 6:
          if (y && x.stateNode != null)
            oc(y, x, y.memoizedProps, k);
          else {
            if (typeof k != "string" && x.stateNode === null)
              throw Error(l(166));
            if (y = rc(nd.current), L = rc(Na.current), Ip(x)) {
              if (!qe)
                throw Error(l(176));
              if (y = x.stateNode, k = x.memoizedProps, (L = mn(y, k, x, !kd)) && (X = Za, X !== null))
                switch ($ = (X.mode & 1) !== 0, X.tag) {
                  case 3:
                    La(X.stateNode.containerInfo, y, k, $);
                    break;
                  case 5:
                    qs(X.type, X.memoizedProps, X.stateNode, y, k, $);
                }
              L && Us(x);
            } else
              x.stateNode = Ne(k, y, L, x);
          }
          return Gn(x), null;
        case 13:
          if (mr(Xe), k = x.memoizedState, ca && Ma !== null && (x.mode & 1) !== 0 && (x.flags & 128) === 0) {
            for (y = Ma; y; )
              y = ot(y);
            return xh(), x.flags |= 98560, x;
          }
          if (k !== null && k.dehydrated !== null) {
            if (k = Ip(x), y === null) {
              if (!k)
                throw Error(l(318));
              if (!qe)
                throw Error(l(344));
              if (y = x.memoizedState, y = y !== null ? y.dehydrated : null, !y)
                throw Error(l(317));
              Rn(y, x);
            } else
              xh(), (x.flags & 128) === 0 && (x.memoizedState = null), x.flags |= 4;
            return Gn(x), null;
          }
          return nl !== null && (Ht(nl), nl = null), (x.flags & 128) !== 0 ? (x.lanes = L, x) : (k = k !== null, L = !1, y === null ? Ip(x) : L = y.memoizedState !== null, k && !L && (x.child.flags |= 8192, (x.mode & 1) !== 0 && (y === null || (Xe.current & 1) !== 0 ? Es === 0 && (Es = 3) : Df())), x.updateQueue !== null && (x.flags |= 4), Gn(x), null);
        case 4:
          return _h(), od(y, x), y === null && ht(x.stateNode.containerInfo), Gn(x), null;
        case 10:
          return Ul(x.type._context), Gn(x), null;
        case 17:
          return Pa(x.type) && Dl(), Gn(x), null;
        case 19:
          if (mr(Xe), X = x.memoizedState, X === null)
            return Gn(x), null;
          if (k = (x.flags & 128) !== 0, $ = X.rendering, $ === null)
            if (k)
              ka(X, !1);
            else {
              if (Es !== 0 || y !== null && (y.flags & 128) !== 0)
                for (y = x.child; y !== null; ) {
                  if ($ = Bt(y), $ !== null) {
                    for (x.flags |= 128, ka(X, !1), y = $.updateQueue, y !== null && (x.updateQueue = y, x.flags |= 4), x.subtreeFlags = 0, y = L, k = x.child; k !== null; )
                      L = k, X = y, L.flags &= 14680066, $ = L.alternate, $ === null ? (L.childLanes = 0, L.lanes = X, L.child = null, L.subtreeFlags = 0, L.memoizedProps = null, L.memoizedState = null, L.updateQueue = null, L.dependencies = null, L.stateNode = null) : (L.childLanes = $.childLanes, L.lanes = $.lanes, L.child = $.child, L.subtreeFlags = 0, L.deletions = null, L.memoizedProps = $.memoizedProps, L.memoizedState = $.memoizedState, L.updateQueue = $.updateQueue, L.type = $.type, X = $.dependencies, L.dependencies = X === null ? null : { lanes: X.lanes, firstContext: X.firstContext }), k = k.sibling;
                    return di(Xe, Xe.current & 1 | 2), x.child;
                  }
                  y = y.sibling;
                }
              X.tail !== null && hi() > Tf && (x.flags |= 128, k = !0, ka(X, !1), x.lanes = 4194304);
            }
          else {
            if (!k)
              if (y = Bt($), y !== null) {
                if (x.flags |= 128, k = !0, y = y.updateQueue, y !== null && (x.updateQueue = y, x.flags |= 4), ka(X, !0), X.tail === null && X.tailMode === "hidden" && !$.alternate && !ca)
                  return Gn(x), null;
              } else
                2 * hi() - X.renderingStartTime > Tf && L !== 1073741824 && (x.flags |= 128, k = !0, ka(X, !1), x.lanes = 4194304);
            X.isBackwards ? ($.sibling = x.child, x.child = $) : (y = X.last, y !== null ? y.sibling = $ : x.child = $, X.last = $);
          }
          return X.tail !== null ? (x = X.tail, X.rendering = x, X.tail = x.sibling, X.renderingStartTime = hi(), x.sibling = null, y = Xe.current, di(Xe, k ? y & 1 | 2 : y & 1), x) : (Gn(x), null);
        case 22:
        case 23:
          return Yo(), k = x.memoizedState !== null, y !== null && y.memoizedState !== null !== k && (x.flags |= 8192), k && (x.mode & 1) !== 0 ? (Gl & 1073741824) !== 0 && (Gn(x), ft && x.subtreeFlags & 6 && (x.flags |= 8192)) : Gn(x), null;
        case 24:
          return null;
        case 25:
          return null;
      }
      throw Error(l(156, x.tag));
    }
    var Vi = d.ReactCurrentOwner, si = !1;
    function Wn(y, x, L, k) {
      x.child = y === null ? Bp(x, null, L, k) : Ec(x, y.child, L, k);
    }
    function wi(y, x, L, k, X) {
      L = L.render;
      var $ = x.ref;
      return Qs(x, X), k = _i(y, x, L, k, $, X), L = Mc(), y !== null && !si ? (x.updateQueue = y.updateQueue, x.flags &= -2053, y.lanes &= ~X, Vr(y, x, X)) : (ca && L && ec(x), x.flags |= 1, Wn(y, x, k, X), x.child);
    }
    function zi(y, x, L, k, X) {
      if (y === null) {
        var $ = L.type;
        return typeof $ == "function" && !Hc($) && $.defaultProps === void 0 && L.compare === null && L.defaultProps === void 0 ? (x.tag = 15, x.type = $, Oc(y, x, $, k, X)) : (y = hd(L.type, null, k, x, x.mode, X), y.ref = x.ref, y.return = x, x.child = y);
      }
      if ($ = y.child, (y.lanes & X) === 0) {
        var Ae = $.memoizedProps;
        if (L = L.compare, L = L !== null ? L : Ki, L(Ae, k) && y.ref === x.ref)
          return Vr(y, x, X);
      }
      return x.flags |= 1, y = Xo($, k), y.ref = x.ref, y.return = x, x.child = y;
    }
    function Oc(y, x, L, k, X) {
      if (y !== null && Ki(y.memoizedProps, k) && y.ref === x.ref)
        if (si = !1, (y.lanes & X) !== 0)
          (y.flags & 131072) !== 0 && (si = !0);
        else
          return x.lanes = y.lanes, Vr(y, x, X);
      return es(y, x, L, k, X);
    }
    function Rr(y, x, L) {
      var k = x.pendingProps, X = k.children, $ = y !== null ? y.memoizedState : null;
      if (k.mode === "hidden")
        if ((x.mode & 1) === 0)
          x.memoizedState = { baseLanes: 0, cachePool: null }, di(ud, Gl), Gl |= L;
        else if ((L & 1073741824) !== 0)
          x.memoizedState = { baseLanes: 0, cachePool: null }, k = $ !== null ? $.baseLanes : L, di(ud, Gl), Gl |= k;
        else
          return y = $ !== null ? $.baseLanes | L : L, x.lanes = x.childLanes = 1073741824, x.memoizedState = { baseLanes: y, cachePool: null }, x.updateQueue = null, di(ud, Gl), Gl |= y, null;
      else
        $ !== null ? (k = $.baseLanes | L, x.memoizedState = null) : k = L, di(ud, Gl), Gl |= k;
      return Wn(y, x, X, L), x.child;
    }
    function ps(y, x) {
      var L = x.ref;
      (y === null && L !== null || y !== null && y.ref !== L) && (x.flags |= 512, x.flags |= 2097152);
    }
    function es(y, x, L, k, X) {
      var $ = Pa(L) ? Uo : Si.current;
      return $ = zo(x, $), Qs(x, X), L = _i(y, x, L, k, $, X), k = Mc(), y !== null && !si ? (x.updateQueue = y.updateQueue, x.flags &= -2053, y.lanes &= ~X, Vr(y, x, X)) : (ca && k && ec(x), x.flags |= 1, Wn(y, x, L, X), x.child);
    }
    function kl(y, x, L, k, X) {
      if (Pa(L)) {
        var $ = !0;
        Ll(x);
      } else
        $ = !1;
      if (Qs(x, X), x.stateNode === null)
        y !== null && (y.alternate = null, x.alternate = null, x.flags |= 2), Um(x, L, k), gh(x, L, k, X), k = !0;
      else if (y === null) {
        var Ae = x.stateNode, $e = x.memoizedProps;
        Ae.props = $e;
        var kt = Ae.context, hn = L.contextType;
        typeof hn == "object" && hn !== null ? hn = qr(hn) : (hn = Pa(L) ? Uo : Si.current, hn = zo(x, hn));
        var wn = L.getDerivedStateFromProps, br = typeof wn == "function" || typeof Ae.getSnapshotBeforeUpdate == "function";
        br || typeof Ae.UNSAFE_componentWillReceiveProps != "function" && typeof Ae.componentWillReceiveProps != "function" || ($e !== k || kt !== hn) && zm(x, Ae, k, hn), va = !1;
        var ur = x.memoizedState;
        Ae.state = ur, Au(x, k, Ae, X), kt = x.memoizedState, $e !== k || ur !== kt || Ti.current || va ? (typeof wn == "function" && ($h(x, L, wn, k), kt = x.memoizedState), ($e = va || Om(x, L, $e, k, ur, kt, hn)) ? (br || typeof Ae.UNSAFE_componentWillMount != "function" && typeof Ae.componentWillMount != "function" || (typeof Ae.componentWillMount == "function" && Ae.componentWillMount(), typeof Ae.UNSAFE_componentWillMount == "function" && Ae.UNSAFE_componentWillMount()), typeof Ae.componentDidMount == "function" && (x.flags |= 4194308)) : (typeof Ae.componentDidMount == "function" && (x.flags |= 4194308), x.memoizedProps = k, x.memoizedState = kt), Ae.props = k, Ae.state = kt, Ae.context = hn, k = $e) : (typeof Ae.componentDidMount == "function" && (x.flags |= 4194308), k = !1);
      } else {
        Ae = x.stateNode, Kf(y, x), $e = x.memoizedProps, hn = x.type === x.elementType ? $e : Oa(x.type, $e), Ae.props = hn, br = x.pendingProps, ur = Ae.context, kt = L.contextType, typeof kt == "object" && kt !== null ? kt = qr(kt) : (kt = Pa(L) ? Uo : Si.current, kt = zo(x, kt));
        var Sa = L.getDerivedStateFromProps;
        (wn = typeof Sa == "function" || typeof Ae.getSnapshotBeforeUpdate == "function") || typeof Ae.UNSAFE_componentWillReceiveProps != "function" && typeof Ae.componentWillReceiveProps != "function" || ($e !== br || ur !== kt) && zm(x, Ae, k, kt), va = !1, ur = x.memoizedState, Ae.state = ur, Au(x, k, Ae, X);
        var Tn = x.memoizedState;
        $e !== br || ur !== Tn || Ti.current || va ? (typeof Sa == "function" && ($h(x, L, Sa, k), Tn = x.memoizedState), (hn = va || Om(x, L, hn, k, ur, Tn, kt) || !1) ? (wn || typeof Ae.UNSAFE_componentWillUpdate != "function" && typeof Ae.componentWillUpdate != "function" || (typeof Ae.componentWillUpdate == "function" && Ae.componentWillUpdate(
          k,
          Tn,
          kt
        ), typeof Ae.UNSAFE_componentWillUpdate == "function" && Ae.UNSAFE_componentWillUpdate(k, Tn, kt)), typeof Ae.componentDidUpdate == "function" && (x.flags |= 4), typeof Ae.getSnapshotBeforeUpdate == "function" && (x.flags |= 1024)) : (typeof Ae.componentDidUpdate != "function" || $e === y.memoizedProps && ur === y.memoizedState || (x.flags |= 4), typeof Ae.getSnapshotBeforeUpdate != "function" || $e === y.memoizedProps && ur === y.memoizedState || (x.flags |= 1024), x.memoizedProps = k, x.memoizedState = Tn), Ae.props = k, Ae.state = Tn, Ae.context = kt, k = hn) : (typeof Ae.componentDidUpdate != "function" || $e === y.memoizedProps && ur === y.memoizedState || (x.flags |= 4), typeof Ae.getSnapshotBeforeUpdate != "function" || $e === y.memoizedProps && ur === y.memoizedState || (x.flags |= 1024), k = !1);
      }
      return Ia(y, x, L, k, $, X);
    }
    function Ia(y, x, L, k, X, $) {
      ps(y, x);
      var Ae = (x.flags & 128) !== 0;
      if (!k && !Ae)
        return X && Nd(x, L, !1), Vr(y, x, $);
      k = x.stateNode, Vi.current = x;
      var $e = Ae && typeof L.getDerivedStateFromError != "function" ? null : k.render();
      return x.flags |= 1, y !== null && Ae ? (x.child = Ec(x, y.child, null, $), x.child = Ec(x, null, $e, $)) : Wn(y, x, $e, $), x.memoizedState = k.state, X && Nd(x, L, !0), x.child;
    }
    function Il(y) {
      var x = y.stateNode;
      x.pendingContext ? vo(y, x.pendingContext, x.pendingContext !== x.context) : x.context && vo(y, x.context, !1), Hp(y, x.containerInfo);
    }
    function bf(y, x, L, k, X) {
      return xh(), Bd(X), x.flags |= 256, Wn(y, x, L, k), x.child;
    }
    var jd = { dehydrated: null, treeContext: null, retryLane: 0 };
    function Vo(y) {
      return { baseLanes: y, cachePool: null };
    }
    function bv(y, x, L) {
      var k = x.pendingProps, X = Xe.current, $ = !1, Ae = (x.flags & 128) !== 0, $e;
      if (($e = Ae) || ($e = y !== null && y.memoizedState === null ? !1 : (X & 2) !== 0), $e ? ($ = !0, x.flags &= -129) : (y === null || y.memoizedState !== null) && (X |= 1), di(Xe, X & 1), y === null)
        return ed(x), y = x.memoizedState, y !== null && (y = y.dehydrated, y !== null) ? ((x.mode & 1) === 0 ? x.lanes = 1 : ai(y) ? x.lanes = 8 : x.lanes = 1073741824, null) : (X = k.children, y = k.fallback, $ ? (k = x.mode, $ = x.child, X = { mode: "hidden", children: X }, (k & 1) === 0 && $ !== null ? ($.childLanes = 0, $.pendingProps = X) : $ = pd(X, k, 0, null), y = gu(y, k, L, null), $.return = x, y.return = x, $.sibling = y, x.child = $, x.child.memoizedState = Vo(L), x.memoizedState = jd, y) : gl(x, X));
      if (X = y.memoizedState, X !== null) {
        if ($e = X.dehydrated, $e !== null) {
          if (Ae)
            return x.flags & 256 ? (x.flags &= -257, lc(y, x, L, Error(l(422)))) : x.memoizedState !== null ? (x.child = y.child, x.flags |= 128, null) : ($ = k.fallback, X = x.mode, k = pd({ mode: "visible", children: k.children }, X, 0, null), $ = gu($, X, L, null), $.flags |= 2, k.return = x, $.return = x, k.sibling = $, x.child = k, (x.mode & 1) !== 0 && Ec(
              x,
              y.child,
              null,
              L
            ), x.child.memoizedState = Vo(L), x.memoizedState = jd, $);
          if ((x.mode & 1) === 0)
            x = lc(y, x, L, null);
          else if (ai($e))
            x = lc(y, x, L, Error(l(419)));
          else if (k = (L & y.childLanes) !== 0, si || k) {
            if (k = Ra, k !== null) {
              switch (L & -L) {
                case 4:
                  $ = 2;
                  break;
                case 16:
                  $ = 8;
                  break;
                case 64:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                case 67108864:
                  $ = 32;
                  break;
                case 536870912:
                  $ = 268435456;
                  break;
                default:
                  $ = 0;
              }
              k = ($ & (k.suspendedLanes | L)) !== 0 ? 0 : $, k !== 0 && k !== X.retryLane && (X.retryLane = k, Xl(y, k, -1));
            }
            Df(), x = lc(y, x, L, Error(l(421)));
          } else
            $r($e) ? (x.flags |= 128, x.child = y.child, x = Bc.bind(null, y), Te($e, x), x = null) : (L = X.treeContext, qe && (Ma = Ye($e), Za = x, ca = !0, nl = null, kd = !1, L !== null && (pl[tl++] = $f, pl[tl++] = cu, pl[tl++] = vf, $f = L.id, cu = L.overflow, vf = x)), x = gl(x, x.pendingProps.children), x.flags |= 4096);
          return x;
        }
        return $ ? (k = tp(y, x, k.children, k.fallback, L), $ = x.child, X = y.child.memoizedState, $.memoizedState = X === null ? Vo(L) : { baseLanes: X.baseLanes | L, cachePool: null }, $.childLanes = y.childLanes & ~L, x.memoizedState = jd, k) : (L = wo(y, x, k.children, L), x.memoizedState = null, L);
      }
      return $ ? (k = tp(y, x, k.children, k.fallback, L), $ = x.child, X = y.child.memoizedState, $.memoizedState = X === null ? Vo(L) : { baseLanes: X.baseLanes | L, cachePool: null }, $.childLanes = y.childLanes & ~L, x.memoizedState = jd, k) : (L = wo(y, x, k.children, L), x.memoizedState = null, L);
    }
    function gl(y, x) {
      return x = pd({ mode: "visible", children: x }, y.mode, 0, null), x.return = y, y.child = x;
    }
    function wo(y, x, L, k) {
      var X = y.child;
      return y = X.sibling, L = Xo(X, { mode: "visible", children: L }), (x.mode & 1) === 0 && (L.lanes = k), L.return = x, L.sibling = null, y !== null && (k = x.deletions, k === null ? (x.deletions = [y], x.flags |= 16) : k.push(y)), x.child = L;
    }
    function tp(y, x, L, k, X) {
      var $ = x.mode;
      y = y.child;
      var Ae = y.sibling, $e = { mode: "hidden", children: L };
      return ($ & 1) === 0 && x.child !== y ? (L = x.child, L.childLanes = 0, L.pendingProps = $e, x.deletions = null) : (L = Xo(y, $e), L.subtreeFlags = y.subtreeFlags & 14680064), Ae !== null ? k = Xo(Ae, k) : (k = gu(k, $, X, null), k.flags |= 2), k.return = x, L.return = x, L.sibling = k, x.child = L, k;
    }
    function lc(y, x, L, k) {
      return k !== null && Bd(k), Ec(x, y.child, null, L), y = gl(x, x.pendingProps.children), y.flags |= 2, x.memoizedState = null, y;
    }
    function du(y, x, L) {
      y.lanes |= x;
      var k = y.alternate;
      k !== null && (k.lanes |= x), za(y.return, x, L);
    }
    function ws(y, x, L, k, X) {
      var $ = y.memoizedState;
      $ === null ? y.memoizedState = { isBackwards: x, rendering: null, renderingStartTime: 0, last: k, tail: L, tailMode: X } : ($.isBackwards = x, $.rendering = null, $.renderingStartTime = 0, $.last = k, $.tail = L, $.tailMode = X);
    }
    function Uc(y, x, L) {
      var k = x.pendingProps, X = k.revealOrder, $ = k.tail;
      if (Wn(y, x, k.children, L), k = Xe.current, (k & 2) !== 0)
        k = k & 1 | 2, x.flags |= 128;
      else {
        if (y !== null && (y.flags & 128) !== 0)
          e:
            for (y = x.child; y !== null; ) {
              if (y.tag === 13)
                y.memoizedState !== null && du(y, L, x);
              else if (y.tag === 19)
                du(y, L, x);
              else if (y.child !== null) {
                y.child.return = y, y = y.child;
                continue;
              }
              if (y === x)
                break e;
              for (; y.sibling === null; ) {
                if (y.return === null || y.return === x)
                  break e;
                y = y.return;
              }
              y.sibling.return = y.return, y = y.sibling;
            }
        k &= 1;
      }
      if (di(Xe, k), (x.mode & 1) === 0)
        x.memoizedState = null;
      else
        switch (X) {
          case "forwards":
            for (L = x.child, X = null; L !== null; )
              y = L.alternate, y !== null && Bt(y) === null && (X = L), L = L.sibling;
            L = X, L === null ? (X = x.child, x.child = null) : (X = L.sibling, L.sibling = null), ws(x, !1, X, L, $);
            break;
          case "backwards":
            for (L = null, X = x.child, x.child = null; X !== null; ) {
              if (y = X.alternate, y !== null && Bt(y) === null) {
                x.child = X;
                break;
              }
              y = X.sibling, X.sibling = L, L = X, X = y;
            }
            ws(x, !0, L, null, $);
            break;
          case "together":
            ws(x, !1, null, null, void 0);
            break;
          default:
            x.memoizedState = null;
        }
      return x.child;
    }
    function Vr(y, x, L) {
      if (y !== null && (x.dependencies = y.dependencies), Nc |= x.lanes, (L & x.childLanes) === 0)
        return null;
      if (y !== null && x.child !== y.child)
        throw Error(l(153));
      if (x.child !== null) {
        for (y = x.child, L = Xo(y, y.pendingProps), x.child = L, L.return = x; y.sibling !== null; )
          y = y.sibling, L = L.sibling = Xo(y, y.pendingProps), L.return = x;
        L.sibling = null;
      }
      return x.child;
    }
    function uc(y, x, L) {
      switch (x.tag) {
        case 3:
          Il(x), xh();
          break;
        case 5:
          Vp(x);
          break;
        case 1:
          Pa(x.type) && Ll(x);
          break;
        case 4:
          Hp(x, x.stateNode.containerInfo);
          break;
        case 10:
          Ru(x, x.type._context, x.memoizedProps.value);
          break;
        case 13:
          var k = x.memoizedState;
          if (k !== null)
            return k.dehydrated !== null ? (di(Xe, Xe.current & 1), x.flags |= 128, null) : (L & x.child.childLanes) !== 0 ? bv(y, x, L) : (di(Xe, Xe.current & 1), y = Vr(y, x, L), y !== null ? y.sibling : null);
          di(Xe, Xe.current & 1);
          break;
        case 19:
          if (k = (L & x.childLanes) !== 0, (y.flags & 128) !== 0) {
            if (k)
              return Uc(
                y,
                x,
                L
              );
            x.flags |= 128;
          }
          var X = x.memoizedState;
          if (X !== null && (X.rendering = null, X.tail = null, X.lastEffect = null), di(Xe, Xe.current), k)
            break;
          return null;
        case 22:
        case 23:
          return x.lanes = 0, Rr(y, x, L);
      }
      return Vr(y, x, L);
    }
    function Ur(y, x) {
      switch (Oi(x), x.tag) {
        case 1:
          return Pa(x.type) && Dl(), y = x.flags, y & 65536 ? (x.flags = y & -65537 | 128, x) : null;
        case 3:
          return _h(), mr(Ti), mr(Si), Mn(), y = x.flags, (y & 65536) !== 0 && (y & 128) === 0 ? (x.flags = y & -65537 | 128, x) : null;
        case 5:
          return Io(x), null;
        case 13:
          if (mr(Xe), y = x.memoizedState, y !== null && y.dehydrated !== null) {
            if (x.alternate === null)
              throw Error(l(340));
            xh();
          }
          return y = x.flags, y & 65536 ? (x.flags = y & -65537 | 128, x) : null;
        case 19:
          return mr(Xe), null;
        case 4:
          return _h(), null;
        case 10:
          return Ul(x.type._context), null;
        case 22:
        case 23:
          return Yo(), null;
        case 24:
          return null;
        default:
          return null;
      }
    }
    var $s = !1, ms = !1, zc = typeof WeakSet == "function" ? WeakSet : Set, vn = null;
    function Bl(y, x) {
      var L = y.ref;
      if (L !== null)
        if (typeof L == "function")
          try {
            L(null);
          } catch (k) {
            bi(y, x, k);
          }
        else
          L.current = null;
    }
    function bo(y, x, L) {
      try {
        L();
      } catch (k) {
        bi(y, x, k);
      }
    }
    var Im = !1;
    function Eh(y, x) {
      for (fe(y.containerInfo), vn = x; vn !== null; )
        if (y = vn, x = y.child, (y.subtreeFlags & 1028) !== 0 && x !== null)
          x.return = y, vn = x;
        else
          for (; vn !== null; ) {
            y = vn;
            try {
              var L = y.alternate;
              if ((y.flags & 1024) !== 0)
                switch (y.tag) {
                  case 0:
                  case 11:
                  case 15:
                    break;
                  case 1:
                    if (L !== null) {
                      var k = L.memoizedProps, X = L.memoizedState, $ = y.stateNode, Ae = $.getSnapshotBeforeUpdate(y.elementType === y.type ? k : Oa(y.type, k), X);
                      $.__reactInternalSnapshotBeforeUpdate = Ae;
                    }
                    break;
                  case 3:
                    ft && cn(y.stateNode.containerInfo);
                    break;
                  case 5:
                  case 6:
                  case 4:
                  case 17:
                    break;
                  default:
                    throw Error(l(163));
                }
            } catch ($e) {
              bi(y, y.return, $e);
            }
            if (x = y.sibling, x !== null) {
              x.return = y.return, vn = x;
              break;
            }
            vn = y.return;
          }
      return L = Im, Im = !1, L;
    }
    function zu(y, x, L) {
      var k = x.updateQueue;
      if (k = k !== null ? k.lastEffect : null, k !== null) {
        var X = k = k.next;
        do {
          if ((X.tag & y) === y) {
            var $ = X.destroy;
            X.destroy = void 0, $ !== void 0 && bo(x, L, $);
          }
          X = X.next;
        } while (X !== k);
      }
    }
    function bs(y, x) {
      if (x = x.updateQueue, x = x !== null ? x.lastEffect : null, x !== null) {
        var L = x = x.next;
        do {
          if ((L.tag & y) === y) {
            var k = L.create;
            L.destroy = k();
          }
          L = L.next;
        } while (L !== x);
      }
    }
    function yl(y) {
      var x = y.ref;
      if (x !== null) {
        var L = y.stateNode;
        switch (y.tag) {
          case 5:
            y = Re(L);
            break;
          default:
            y = L;
        }
        typeof x == "function" ? x(y) : x.current = y;
      }
    }
    function ga(y, x, L) {
      if (lu && typeof lu.onCommitFiberUnmount == "function")
        try {
          lu.onCommitFiberUnmount(mf, x);
        } catch {
        }
      switch (x.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          if (y = x.updateQueue, y !== null && (y = y.lastEffect, y !== null)) {
            var k = y = y.next;
            do {
              var X = k, $ = X.destroy;
              X = X.tag, $ !== void 0 && ((X & 2) !== 0 || (X & 4) !== 0) && bo(x, L, $), k = k.next;
            } while (k !== y);
          }
          break;
        case 1:
          if (Bl(x, L), y = x.stateNode, typeof y.componentWillUnmount == "function")
            try {
              y.props = x.memoizedProps, y.state = x.memoizedState, y.componentWillUnmount();
            } catch (Ae) {
              bi(
                x,
                L,
                Ae
              );
            }
          break;
        case 5:
          Bl(x, L);
          break;
        case 4:
          ft ? Ns(y, x, L) : Ie && Ie && (x = x.stateNode.containerInfo, L = Or(x), Bn(x, L));
      }
    }
    function hu(y, x, L) {
      for (var k = x; ; )
        if (ga(y, k, L), k.child === null || ft && k.tag === 4) {
          if (k === x)
            break;
          for (; k.sibling === null; ) {
            if (k.return === null || k.return === x)
              return;
            k = k.return;
          }
          k.sibling.return = k.return, k = k.sibling;
        } else
          k.child.return = k, k = k.child;
    }
    function zs(y) {
      var x = y.alternate;
      x !== null && (y.alternate = null, zs(x)), y.child = null, y.deletions = null, y.sibling = null, y.tag === 5 && (x = y.stateNode, x !== null && Vt(x)), y.stateNode = null, y.return = null, y.dependencies = null, y.memoizedProps = null, y.memoizedState = null, y.pendingProps = null, y.stateNode = null, y.updateQueue = null;
    }
    function ld(y) {
      return y.tag === 5 || y.tag === 3 || y.tag === 4;
    }
    function Hl(y) {
      e:
        for (; ; ) {
          for (; y.sibling === null; ) {
            if (y.return === null || ld(y.return))
              return null;
            y = y.return;
          }
          for (y.sibling.return = y.return, y = y.sibling; y.tag !== 5 && y.tag !== 6 && y.tag !== 18; ) {
            if (y.flags & 2 || y.child === null || y.tag === 4)
              continue e;
            y.child.return = y, y = y.child;
          }
          if (!(y.flags & 2))
            return y.stateNode;
        }
    }
    function Go(y) {
      if (ft) {
        e: {
          for (var x = y.return; x !== null; ) {
            if (ld(x))
              break e;
            x = x.return;
          }
          throw Error(l(160));
        }
        var L = x;
        switch (L.tag) {
          case 5:
            x = L.stateNode, L.flags & 32 && (ze(x), L.flags &= -33), L = Hl(y), il(y, L, x);
            break;
          case 3:
          case 4:
            x = L.stateNode.containerInfo, L = Hl(y), Yd(y, L, x);
            break;
          default:
            throw Error(l(161));
        }
      }
    }
    function Yd(y, x, L) {
      var k = y.tag;
      if (k === 5 || k === 6)
        y = y.stateNode, x ? at(L, y, x) : it(L, y);
      else if (k !== 4 && (y = y.child, y !== null))
        for (Yd(y, x, L), y = y.sibling; y !== null; )
          Yd(y, x, L), y = y.sibling;
    }
    function il(y, x, L) {
      var k = y.tag;
      if (k === 5 || k === 6)
        y = y.stateNode, x ? Fe(L, y, x) : Wt(L, y);
      else if (k !== 4 && (y = y.child, y !== null))
        for (il(y, x, L), y = y.sibling; y !== null; )
          il(y, x, L), y = y.sibling;
    }
    function Ns(y, x, L) {
      for (var k = x, X = !1, $, Ae; ; ) {
        if (!X) {
          X = k.return;
          e:
            for (; ; ) {
              if (X === null)
                throw Error(l(160));
              switch ($ = X.stateNode, X.tag) {
                case 5:
                  Ae = !1;
                  break e;
                case 3:
                  $ = $.containerInfo, Ae = !0;
                  break e;
                case 4:
                  $ = $.containerInfo, Ae = !0;
                  break e;
              }
              X = X.return;
            }
          X = !0;
        }
        if (k.tag === 5 || k.tag === 6)
          hu(y, k, L), Ae ? dn($, k.stateNode) : st($, k.stateNode);
        else if (k.tag === 18)
          Ae ? wr($, k.stateNode) : rr($, k.stateNode);
        else if (k.tag === 4) {
          if (k.child !== null) {
            $ = k.stateNode.containerInfo, Ae = !0, k.child.return = k, k = k.child;
            continue;
          }
        } else if (ga(y, k, L), k.child !== null) {
          k.child.return = k, k = k.child;
          continue;
        }
        if (k === x)
          break;
        for (; k.sibling === null; ) {
          if (k.return === null || k.return === x)
            return;
          k = k.return, k.tag === 4 && (X = !1);
        }
        k.sibling.return = k.return, k = k.sibling;
      }
    }
    function fa(y, x) {
      if (ft) {
        switch (x.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            zu(3, x, x.return), bs(3, x), zu(5, x, x.return);
            return;
          case 1:
            return;
          case 5:
            var L = x.stateNode;
            if (L != null) {
              var k = x.memoizedProps;
              y = y !== null ? y.memoizedProps : k;
              var X = x.type, $ = x.updateQueue;
              x.updateQueue = null, $ !== null && pe(L, $, X, y, k, x);
            }
            return;
          case 6:
            if (x.stateNode === null)
              throw Error(l(162));
            L = x.memoizedProps, an(x.stateNode, y !== null ? y.memoizedProps : L, L);
            return;
          case 3:
            qe && y !== null && y.memoizedState.isDehydrated && yn(x.stateNode.containerInfo);
            return;
          case 12:
            return;
          case 13:
            Nu(x);
            return;
          case 19:
            Nu(x);
            return;
          case 17:
            return;
        }
        throw Error(l(163));
      }
      switch (x.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          zu(3, x, x.return), bs(3, x), zu(5, x, x.return);
          return;
        case 12:
          return;
        case 13:
          Nu(x);
          return;
        case 19:
          Nu(x);
          return;
        case 3:
          qe && y !== null && y.memoizedState.isDehydrated && yn(x.stateNode.containerInfo);
          break;
        case 22:
        case 23:
          return;
      }
      e:
        if (Ie) {
          switch (x.tag) {
            case 1:
            case 5:
            case 6:
              break e;
            case 3:
            case 4:
              x = x.stateNode, Bn(x.containerInfo, x.pendingChildren);
              break e;
          }
          throw Error(l(163));
        }
    }
    function Nu(y) {
      var x = y.updateQueue;
      if (x !== null) {
        y.updateQueue = null;
        var L = y.stateNode;
        L === null && (L = y.stateNode = new zc()), x.forEach(function(k) {
          var X = mu.bind(null, y, k);
          L.has(k) || (L.add(k), k.then(X, X));
        });
      }
    }
    function Wp(y, x) {
      for (vn = x; vn !== null; ) {
        x = vn;
        var L = x.deletions;
        if (L !== null)
          for (var k = 0; k < L.length; k++) {
            var X = L[k];
            try {
              var $ = y;
              ft ? Ns($, X, x) : hu($, X, x);
              var Ae = X.alternate;
              Ae !== null && (Ae.return = null), X.return = null;
            } catch (jn) {
              bi(X, x, jn);
            }
          }
        if (L = x.child, (x.subtreeFlags & 12854) !== 0 && L !== null)
          L.return = x, vn = L;
        else
          for (; vn !== null; ) {
            x = vn;
            try {
              var $e = x.flags;
              if ($e & 32 && ft && ze(x.stateNode), $e & 512) {
                var kt = x.alternate;
                if (kt !== null) {
                  var hn = kt.ref;
                  hn !== null && (typeof hn == "function" ? hn(null) : hn.current = null);
                }
              }
              if ($e & 8192)
                switch (x.tag) {
                  case 13:
                    if (x.memoizedState !== null) {
                      var wn = x.alternate;
                      (wn === null || wn.memoizedState === null) && (Bm = hi());
                    }
                    break;
                  case 22:
                    var br = x.memoizedState !== null, ur = x.alternate, Sa = ur !== null && ur.memoizedState !== null;
                    if (L = x, ft) {
                      e:
                        if (k = L, X = br, $ = null, ft)
                          for (var Tn = k; ; ) {
                            if (Tn.tag === 5) {
                              if ($ === null) {
                                $ = Tn;
                                var Li = Tn.stateNode;
                                X ? wt(Li) : Gt(Tn.stateNode, Tn.memoizedProps);
                              }
                            } else if (Tn.tag === 6) {
                              if ($ === null) {
                                var vs = Tn.stateNode;
                                X ? Pe(vs) : At(vs, Tn.memoizedProps);
                              }
                            } else if ((Tn.tag !== 22 && Tn.tag !== 23 || Tn.memoizedState === null || Tn === k) && Tn.child !== null) {
                              Tn.child.return = Tn, Tn = Tn.child;
                              continue;
                            }
                            if (Tn === k)
                              break;
                            for (; Tn.sibling === null; ) {
                              if (Tn.return === null || Tn.return === k)
                                break e;
                              $ === Tn && ($ = null), Tn = Tn.return;
                            }
                            $ === Tn && ($ = null), Tn.sibling.return = Tn.return, Tn = Tn.sibling;
                          }
                    }
                    if (br && !Sa && (L.mode & 1) !== 0) {
                      vn = L;
                      for (var pt = L.child; pt !== null; ) {
                        for (L = vn = pt; vn !== null; ) {
                          k = vn;
                          var Ze = k.child;
                          switch (k.tag) {
                            case 0:
                            case 11:
                            case 14:
                            case 15:
                              zu(4, k, k.return);
                              break;
                            case 1:
                              Bl(k, k.return);
                              var Lt = k.stateNode;
                              if (typeof Lt.componentWillUnmount == "function") {
                                var Qt = k.return;
                                try {
                                  Lt.props = k.memoizedProps, Lt.state = k.memoizedState, Lt.componentWillUnmount();
                                } catch (jn) {
                                  bi(
                                    k,
                                    Qt,
                                    jn
                                  );
                                }
                              }
                              break;
                            case 5:
                              Bl(k, k.return);
                              break;
                            case 22:
                              if (k.memoizedState !== null) {
                                Ef(L);
                                continue;
                              }
                          }
                          Ze !== null ? (Ze.return = k, vn = Ze) : Ef(L);
                        }
                        pt = pt.sibling;
                      }
                    }
                }
              switch ($e & 4102) {
                case 2:
                  Go(x), x.flags &= -3;
                  break;
                case 6:
                  Go(x), x.flags &= -3, fa(x.alternate, x);
                  break;
                case 4096:
                  x.flags &= -4097;
                  break;
                case 4100:
                  x.flags &= -4097, fa(x.alternate, x);
                  break;
                case 4:
                  fa(x.alternate, x);
              }
            } catch (jn) {
              bi(x, x.return, jn);
            }
            if (L = x.sibling, L !== null) {
              L.return = x.return, vn = L;
              break;
            }
            vn = x.return;
          }
      }
    }
    function pu(y, x, L) {
      vn = y, Vl(y);
    }
    function Vl(y, x, L) {
      for (var k = (y.mode & 1) !== 0; vn !== null; ) {
        var X = vn, $ = X.child;
        if (X.tag === 22 && k) {
          var Ae = X.memoizedState !== null || $s;
          if (!Ae) {
            var $e = X.alternate, kt = $e !== null && $e.memoizedState !== null || ms;
            $e = $s;
            var hn = ms;
            if ($s = Ae, (ms = kt) && !hn)
              for (vn = X; vn !== null; )
                Ae = vn, kt = Ae.child, Ae.tag === 22 && Ae.memoizedState !== null ? eo(X) : kt !== null ? (kt.return = Ae, vn = kt) : eo(X);
            for (; $ !== null; )
              vn = $, Vl($), $ = $.sibling;
            vn = X, $s = $e, ms = hn;
          }
          np(y);
        } else
          (X.subtreeFlags & 8772) !== 0 && $ !== null ? ($.return = X, vn = $) : np(y);
      }
    }
    function np(y) {
      for (; vn !== null; ) {
        var x = vn;
        if ((x.flags & 8772) !== 0) {
          var L = x.alternate;
          try {
            if ((x.flags & 8772) !== 0)
              switch (x.tag) {
                case 0:
                case 11:
                case 15:
                  ms || bs(5, x);
                  break;
                case 1:
                  var k = x.stateNode;
                  if (x.flags & 4 && !ms)
                    if (L === null)
                      k.componentDidMount();
                    else {
                      var X = x.elementType === x.type ? L.memoizedProps : Oa(x.type, L.memoizedProps);
                      k.componentDidUpdate(X, L.memoizedState, k.__reactInternalSnapshotBeforeUpdate);
                    }
                  var $ = x.updateQueue;
                  $ !== null && Fp(x, $, k);
                  break;
                case 3:
                  var Ae = x.updateQueue;
                  if (Ae !== null) {
                    if (L = null, x.child !== null)
                      switch (x.child.tag) {
                        case 5:
                          L = Re(x.child.stateNode);
                          break;
                        case 1:
                          L = x.child.stateNode;
                      }
                    Fp(x, Ae, L);
                  }
                  break;
                case 5:
                  var $e = x.stateNode;
                  L === null && x.flags & 4 && Be($e, x.type, x.memoizedProps, x);
                  break;
                case 6:
                  break;
                case 4:
                  break;
                case 12:
                  break;
                case 13:
                  if (qe && x.memoizedState === null) {
                    var kt = x.alternate;
                    if (kt !== null) {
                      var hn = kt.memoizedState;
                      if (hn !== null) {
                        var wn = hn.dehydrated;
                        wn !== null && Jn(wn);
                      }
                    }
                  }
                  break;
                case 19:
                case 17:
                case 21:
                case 22:
                case 23:
                  break;
                default:
                  throw Error(l(163));
              }
            ms || x.flags & 512 && yl(x);
          } catch (br) {
            bi(x, x.return, br);
          }
        }
        if (x === y) {
          vn = null;
          break;
        }
        if (L = x.sibling, L !== null) {
          L.return = x.return, vn = L;
          break;
        }
        vn = x.return;
      }
    }
    function Ef(y) {
      for (; vn !== null; ) {
        var x = vn;
        if (x === y) {
          vn = null;
          break;
        }
        var L = x.sibling;
        if (L !== null) {
          L.return = x.return, vn = L;
          break;
        }
        vn = x.return;
      }
    }
    function eo(y) {
      for (; vn !== null; ) {
        var x = vn;
        try {
          switch (x.tag) {
            case 0:
            case 11:
            case 15:
              var L = x.return;
              try {
                bs(4, x);
              } catch (kt) {
                bi(x, L, kt);
              }
              break;
            case 1:
              var k = x.stateNode;
              if (typeof k.componentDidMount == "function") {
                var X = x.return;
                try {
                  k.componentDidMount();
                } catch (kt) {
                  bi(x, X, kt);
                }
              }
              var $ = x.return;
              try {
                yl(x);
              } catch (kt) {
                bi(x, $, kt);
              }
              break;
            case 5:
              var Ae = x.return;
              try {
                yl(x);
              } catch (kt) {
                bi(x, Ae, kt);
              }
          }
        } catch (kt) {
          bi(x, x.return, kt);
        }
        if (x === y) {
          vn = null;
          break;
        }
        var $e = x.sibling;
        if ($e !== null) {
          $e.return = x.return, vn = $e;
          break;
        }
        vn = x.return;
      }
    }
    var Xd = 0, da = 1, Gi = 2, bn = 3, Qi = 4;
    if (typeof Symbol == "function" && Symbol.for) {
      var ya = Symbol.for;
      Xd = ya("selector.component"), da = ya("selector.has_pseudo_class"), Gi = ya("selector.role"), bn = ya("selector.test_id"), Qi = ya("selector.text");
    }
    function rp(y) {
      var x = dt(y);
      if (x != null) {
        if (typeof x.memoizedProps["data-testname"] != "string")
          throw Error(l(364));
        return x;
      }
      if (y = Rt(y), y === null)
        throw Error(l(362));
      return y.stateNode.current;
    }
    function Wo(y, x) {
      switch (x.$$typeof) {
        case Xd:
          if (y.type === x.value)
            return !0;
          break;
        case da:
          e: {
            x = x.value, y = [y, 0];
            for (var L = 0; L < y.length; ) {
              var k = y[L++], X = y[L++], $ = x[X];
              if (k.tag !== 5 || !Qe(k)) {
                for (; $ != null && Wo(k, $); )
                  X++, $ = x[X];
                if (X === x.length) {
                  x = !0;
                  break e;
                } else
                  for (k = k.child; k !== null; )
                    y.push(k, X), k = k.sibling;
              }
            }
            x = !1;
          }
          return x;
        case Gi:
          if (y.tag === 5 && ut(y.stateNode, x.value))
            return !0;
          break;
        case Qi:
          if ((y.tag === 5 || y.tag === 6) && (y = oe(y), y !== null && 0 <= y.indexOf(x.value)))
            return !0;
          break;
        case bn:
          if (y.tag === 5 && (y = y.memoizedProps["data-testname"], typeof y == "string" && y.toLowerCase() === x.value.toLowerCase()))
            return !0;
          break;
        default:
          throw Error(l(365));
      }
      return !1;
    }
    function jo(y) {
      switch (y.$$typeof) {
        case Xd:
          return "<" + (te(y.value) || "Unknown") + ">";
        case da:
          return ":has(" + (jo(y) || "") + ")";
        case Gi:
          return '[role="' + y.value + '"]';
        case Qi:
          return '"' + y.value + '"';
        case bn:
          return '[data-testname="' + y.value + '"]';
        default:
          throw Error(l(365));
      }
    }
    function ts(y, x) {
      var L = [];
      y = [y, 0];
      for (var k = 0; k < y.length; ) {
        var X = y[k++], $ = y[k++], Ae = x[$];
        if (X.tag !== 5 || !Qe(X)) {
          for (; Ae != null && Wo(X, Ae); )
            $++, Ae = x[$];
          if ($ === x.length)
            L.push(X);
          else
            for (X = X.child; X !== null; )
              y.push(X, $), X = X.sibling;
        }
      }
      return L;
    }
    function An(y, x) {
      if (!Zt)
        throw Error(l(363));
      y = rp(y), y = ts(y, x), x = [], y = Array.from(y);
      for (var L = 0; L < y.length; ) {
        var k = y[L++];
        if (k.tag === 5)
          Qe(k) || x.push(k.stateNode);
        else
          for (k = k.child; k !== null; )
            y.push(k), k = k.sibling;
      }
      return x;
    }
    var xa = Math.ceil, ns = d.ReactCurrentDispatcher, Mf = d.ReactCurrentOwner, _a = d.ReactCurrentBatchConfig, Qr = 0, Ra = null, Ba = null, li = 0, Gl = 0, ud = cs(0), Es = 0, qd = null, Nc = 0, cc = 0, Qd = 0, cd = null, al = null, Bm = 0, Tf = 1 / 0;
    function Zd() {
      Tf = hi() + 500;
    }
    var Cf = !1, Wl = null, jl = null, fd = !1, Yl = null, Mh = 0, fc = 0, hr = null, Gr = -1, fr = 0;
    function ui() {
      return (Qr & 6) !== 0 ? hi() : Gr !== -1 ? Gr : Gr = hi();
    }
    function Fs(y) {
      return (y.mode & 1) === 0 ? 1 : (Qr & 2) !== 0 && li !== 0 ? li & -li : Jf.transition !== null ? (fr === 0 && (y = Pl, Pl <<= 1, (Pl & 4194240) === 0 && (Pl = 64), fr = y), fr) : (y = Cr, y !== 0 ? y : xt());
    }
    function Xl(y, x, L) {
      if (50 < fc)
        throw fc = 0, hr = null, Error(l(185));
      var k = Fc(y, x);
      return k === null ? null : (xr(k, x, L), ((Qr & 2) === 0 || k !== Ra) && (k === Ra && ((Qr & 2) === 0 && (cc |= x), Es === 4 && lr(k, li)), _r(k, L), x === 1 && Qr === 0 && (y.mode & 1) === 0 && (Zd(), wc && ko())), k);
    }
    function Fc(y, x) {
      y.lanes |= x;
      var L = y.alternate;
      for (L !== null && (L.lanes |= x), L = y, y = y.return; y !== null; )
        y.childLanes |= x, L = y.alternate, L !== null && (L.childLanes |= x), L = y, y = y.return;
      return L.tag === 3 ? L.stateNode : null;
    }
    function _r(y, x) {
      var L = y.callbackNode;
      Ci(y, x);
      var k = Xf(y, y === Ra ? li : 0);
      if (k === 0)
        L !== null && Ka(L), y.callbackNode = null, y.callbackPriority = 0;
      else if (x = k & -k, y.callbackPriority !== x) {
        if (L != null && Ka(L), x === 1)
          y.tag === 0 ? Zf(kc.bind(null, y)) : Qf(kc.bind(null, y)), yt ? Nt(function() {
            Qr === 0 && ko();
          }) : yo(Qa, ko), L = null;
        else {
          switch (dl(k)) {
            case 1:
              L = Qa;
              break;
            case 4:
              L = Sc;
              break;
            case 16:
              L = hl;
              break;
            case 536870912:
              L = pf;
              break;
            default:
              L = hl;
          }
          L = vu(L, Eo.bind(null, y));
        }
        y.callbackPriority = x, y.callbackNode = L;
      }
    }
    function Eo(y, x) {
      if (Gr = -1, fr = 0, (Qr & 6) !== 0)
        throw Error(l(327));
      var L = y.callbackNode;
      if (Ic() && y.callbackNode !== L)
        return null;
      var k = Xf(y, y === Ra ? li : 0);
      if (k === 0)
        return null;
      if ((k & 30) !== 0 || (k & y.expiredLanes) !== 0 || x)
        x = aa(y, k);
      else {
        x = k;
        var X = Qr;
        Qr |= 2;
        var $ = Af();
        (Ra !== y || li !== x) && (Zd(), Di(y, x));
        do
          try {
            Lf();
            break;
          } catch ($e) {
            Rf(y, $e);
          }
        while (1);
        xo(), ns.current = $, Qr = X, Ba !== null ? x = 0 : (Ra = null, li = 0, x = Es);
      }
      if (x !== 0) {
        if (x === 2 && (X = fs(y), X !== 0 && (k = X, x = Ai(y, X))), x === 1)
          throw L = qd, Di(y, 0), lr(y, k), _r(y, hi()), L;
        if (x === 6)
          lr(y, k);
        else {
          if (X = y.current.alternate, (k & 30) === 0 && !pi(X) && (x = aa(y, k), x === 2 && ($ = fs(y), $ !== 0 && (k = $, x = Ai(y, $))), x === 1))
            throw L = qd, Di(y, 0), lr(y, k), _r(y, hi()), L;
          switch (y.finishedWork = X, y.finishedLanes = k, x) {
            case 0:
            case 1:
              throw Error(l(345));
            case 2:
              ql(y, al);
              break;
            case 3:
              if (lr(y, k), (k & 130023424) === k && (x = Bm + 500 - hi(), 10 < x)) {
                if (Xf(y, 0) !== 0)
                  break;
                if (X = y.suspendedLanes, (X & k) !== k) {
                  ui(), y.pingedLanes |= y.suspendedLanes & X;
                  break;
                }
                y.timeoutHandle = ct(ql.bind(null, y, al), x);
                break;
              }
              ql(y, al);
              break;
            case 4:
              if (lr(y, k), (k & 4194240) === k)
                break;
              for (x = y.eventTimes, X = -1; 0 < k; ) {
                var Ae = 31 - Ps(k);
                $ = 1 << Ae, Ae = x[Ae], Ae > X && (X = Ae), k &= ~$;
              }
              if (k = X, k = hi() - k, k = (120 > k ? 120 : 480 > k ? 480 : 1080 > k ? 1080 : 1920 > k ? 1920 : 3e3 > k ? 3e3 : 4320 > k ? 4320 : 1960 * xa(k / 1960)) - k, 10 < k) {
                y.timeoutHandle = ct(ql.bind(null, y, al), k);
                break;
              }
              ql(y, al);
              break;
            case 5:
              ql(y, al);
              break;
            default:
              throw Error(l(329));
          }
        }
      }
      return _r(y, hi()), y.callbackNode === L ? Eo.bind(null, y) : null;
    }
    function Ai(y, x) {
      var L = cd;
      return y.current.memoizedState.isDehydrated && (Di(y, x).flags |= 256), y = aa(y, x), y !== 2 && (x = al, al = L, x !== null && Ht(x)), y;
    }
    function Ht(y) {
      al === null ? al = y : al.push.apply(al, y);
    }
    function pi(y) {
      for (var x = y; ; ) {
        if (x.flags & 16384) {
          var L = x.updateQueue;
          if (L !== null && (L = L.stores, L !== null))
            for (var k = 0; k < L.length; k++) {
              var X = L[k], $ = X.getSnapshot;
              X = X.value;
              try {
                if (!Fo($(), X))
                  return !1;
              } catch {
                return !1;
              }
            }
        }
        if (L = x.child, x.subtreeFlags & 16384 && L !== null)
          L.return = x, x = L;
        else {
          if (x === y)
            break;
          for (; x.sibling === null; ) {
            if (x.return === null || x.return === y)
              return !0;
            x = x.return;
          }
          x.sibling.return = x.return, x = x.sibling;
        }
      }
      return !0;
    }
    function lr(y, x) {
      for (x &= ~Qd, x &= ~cc, y.suspendedLanes |= x, y.pingedLanes &= ~x, y = y.expirationTimes; 0 < x; ) {
        var L = 31 - Ps(x), k = 1 << L;
        y[L] = -1, x &= ~k;
      }
    }
    function kc(y) {
      if ((Qr & 6) !== 0)
        throw Error(l(327));
      Ic();
      var x = Xf(y, 0);
      if ((x & 1) === 0)
        return _r(y, hi()), null;
      var L = aa(y, x);
      if (y.tag !== 0 && L === 2) {
        var k = fs(y);
        k !== 0 && (x = k, L = Ai(y, k));
      }
      if (L === 1)
        throw L = qd, Di(y, 0), lr(y, x), _r(y, hi()), L;
      if (L === 6)
        throw Error(l(345));
      return y.finishedWork = y.current.alternate, y.finishedLanes = x, ql(y, al), _r(y, hi()), null;
    }
    function Ha(y) {
      Yl !== null && Yl.tag === 0 && (Qr & 6) === 0 && Ic();
      var x = Qr;
      Qr |= 1;
      var L = _a.transition, k = Cr;
      try {
        if (_a.transition = null, Cr = 1, y)
          return y();
      } finally {
        Cr = k, _a.transition = L, Qr = x, (Qr & 6) === 0 && ko();
      }
    }
    function Yo() {
      Gl = ud.current, mr(ud);
    }
    function Di(y, x) {
      y.finishedWork = null, y.finishedLanes = 0;
      var L = y.timeoutHandle;
      if (L !== Tt && (y.timeoutHandle = Tt, tt(L)), Ba !== null)
        for (L = Ba.return; L !== null; ) {
          var k = L;
          switch (Oi(k), k.tag) {
            case 1:
              k = k.type.childContextTypes, k != null && Dl();
              break;
            case 3:
              _h(), mr(Ti), mr(Si), Mn();
              break;
            case 5:
              Io(k);
              break;
            case 4:
              _h();
              break;
            case 13:
              mr(Xe);
              break;
            case 19:
              mr(Xe);
              break;
            case 10:
              Ul(k.type._context);
              break;
            case 22:
            case 23:
              Yo();
          }
          L = L.return;
        }
      if (Ra = y, Ba = y = Xo(y.current, null), li = Gl = x, Es = 0, qd = null, Qd = cc = Nc = 0, al = cd = null, _s !== null) {
        for (x = 0; x < _s.length; x++)
          if (L = _s[x], k = L.interleaved, k !== null) {
            L.interleaved = null;
            var X = k.next, $ = L.pending;
            if ($ !== null) {
              var Ae = $.next;
              $.next = X, k.next = Ae;
            }
            L.pending = k;
          }
        _s = null;
      }
      return y;
    }
    function Rf(y, x) {
      do {
        var L = Ba;
        try {
          if (xo(), $n.current = Sf, Bo) {
            for (var k = er.memoizedState; k !== null; ) {
              var X = k.queue;
              X !== null && (X.pending = null), k = k.next;
            }
            Bo = !1;
          }
          if (Ta = 0, ia = Ui = er = null, ds = !1, Vd = 0, Mf.current = null, L === null || L.return === null) {
            Es = 1, qd = x, Ba = null;
            break;
          }
          e: {
            var $ = y, Ae = L.return, $e = L, kt = x;
            if (x = li, $e.flags |= 32768, kt !== null && typeof kt == "object" && typeof kt.then == "function") {
              var hn = kt, wn = $e, br = wn.tag;
              if ((wn.mode & 1) === 0 && (br === 0 || br === 11 || br === 15)) {
                var ur = wn.alternate;
                ur ? (wn.updateQueue = ur.updateQueue, wn.memoizedState = ur.memoizedState, wn.lanes = ur.lanes) : (wn.updateQueue = null, wn.memoizedState = null);
              }
              var Sa = Lc(Ae);
              if (Sa !== null) {
                Sa.flags &= -257, Pc(Sa, Ae, $e, $, x), Sa.mode & 1 && Fl($, hn, x), x = Sa, kt = hn;
                var Tn = x.updateQueue;
                if (Tn === null) {
                  var Li = /* @__PURE__ */ new Set();
                  Li.add(kt), x.updateQueue = Li;
                } else
                  Tn.add(kt);
                break e;
              } else {
                if ((x & 1) === 0) {
                  Fl($, hn, x), Df();
                  break e;
                }
                kt = Error(l(426));
              }
            } else if (ca && $e.mode & 1) {
              var vs = Lc(Ae);
              if (vs !== null) {
                (vs.flags & 65536) === 0 && (vs.flags |= 256), Pc(vs, Ae, $e, $, x), Bd(kt);
                break e;
              }
            }
            $ = kt, Es !== 4 && (Es = 2), cd === null ? cd = [$] : cd.push($), kt = wf(kt, $e), $e = Ae;
            do {
              switch ($e.tag) {
                case 3:
                  $e.flags |= 65536, x &= -x, $e.lanes |= x;
                  var pt = sd($e, kt, x);
                  qi($e, pt);
                  break e;
                case 1:
                  $ = kt;
                  var Ze = $e.type, Lt = $e.stateNode;
                  if (($e.flags & 128) === 0 && (typeof Ze.getDerivedStateFromError == "function" || Lt !== null && typeof Lt.componentDidCatch == "function" && (jl === null || !jl.has(Lt)))) {
                    $e.flags |= 65536, x &= -x, $e.lanes |= x;
                    var Qt = Dc($e, $, x);
                    qi($e, Qt);
                    break e;
                  }
              }
              $e = $e.return;
            } while ($e !== null);
          }
          to(L);
        } catch (jn) {
          x = jn, Ba === L && L !== null && (Ba = L = L.return);
          continue;
        }
        break;
      } while (1);
    }
    function Af() {
      var y = ns.current;
      return ns.current = Sf, y === null ? Sf : y;
    }
    function Df() {
      (Es === 0 || Es === 3 || Es === 2) && (Es = 4), Ra === null || (Nc & 268435455) === 0 && (cc & 268435455) === 0 || lr(Ra, li);
    }
    function aa(y, x) {
      var L = Qr;
      Qr |= 2;
      var k = Af();
      Ra === y && li === x || Di(y, x);
      do
        try {
          ks();
          break;
        } catch (X) {
          Rf(y, X);
        }
      while (1);
      if (xo(), Qr = L, ns.current = k, Ba !== null)
        throw Error(l(261));
      return Ra = null, li = 0, Es;
    }
    function ks() {
      for (; Ba !== null; )
        Jd(Ba);
    }
    function Lf() {
      for (; Ba !== null && !Xi(); )
        Jd(Ba);
    }
    function Jd(y) {
      var x = Pf(y.alternate, y, Gl);
      y.memoizedProps = y.pendingProps, x === null ? to(y) : Ba = x, Mf.current = null;
    }
    function to(y) {
      var x = y;
      do {
        var L = x.alternate;
        if (y = x.return, (x.flags & 32768) === 0) {
          if (L = vr(L, x, Gl), L !== null) {
            Ba = L;
            return;
          }
        } else {
          if (L = Ur(L, x), L !== null) {
            L.flags &= 32767, Ba = L;
            return;
          }
          if (y !== null)
            y.flags |= 32768, y.subtreeFlags = 0, y.deletions = null;
          else {
            Es = 6, Ba = null;
            return;
          }
        }
        if (x = x.sibling, x !== null) {
          Ba = x;
          return;
        }
        Ba = x = y;
      } while (x !== null);
      Es === 0 && (Es = 5);
    }
    function ql(y, x) {
      var L = Cr, k = _a.transition;
      try {
        _a.transition = null, Cr = 1, ip(y, x, L);
      } finally {
        _a.transition = k, Cr = L;
      }
      return null;
    }
    function ip(y, x, L) {
      do
        Ic();
      while (Yl !== null);
      if ((Qr & 6) !== 0)
        throw Error(l(327));
      var k = y.finishedWork, X = y.finishedLanes;
      if (k === null)
        return null;
      if (y.finishedWork = null, y.finishedLanes = 0, k === y.current)
        throw Error(l(177));
      y.callbackNode = null, y.callbackPriority = 0;
      var $ = k.lanes | k.childLanes;
      if (Tu(y, $), y === Ra && (Ba = Ra = null, li = 0), (k.subtreeFlags & 2064) === 0 && (k.flags & 2064) === 0 || fd || (fd = !0, vu(hl, function() {
        return Ic(), null;
      })), $ = (k.flags & 15990) !== 0, (k.subtreeFlags & 15990) !== 0 || $) {
        $ = _a.transition, _a.transition = null;
        var Ae = Cr;
        Cr = 1;
        var $e = Qr;
        Qr |= 4, Mf.current = null, Eh(y, k), Wp(y, k), he(y.containerInfo), y.current = k, pu(k), Lm(), Qr = $e, Cr = Ae, _a.transition = $;
      } else
        y.current = k;
      if (fd && (fd = !1, Yl = y, Mh = X), $ = y.pendingLanes, $ === 0 && (jl = null), Hi(k.stateNode), _r(y, hi()), x !== null)
        for (L = y.onRecoverableError, k = 0; k < x.length; k++)
          L(x[k]);
      if (Cf)
        throw Cf = !1, y = Wl, Wl = null, y;
      return (Mh & 1) !== 0 && y.tag !== 0 && Ic(), $ = y.pendingLanes, ($ & 1) !== 0 ? y === hr ? fc++ : (fc = 0, hr = y) : fc = 0, ko(), null;
    }
    function Ic() {
      if (Yl !== null) {
        var y = dl(Mh), x = _a.transition, L = Cr;
        try {
          if (_a.transition = null, Cr = 16 > y ? 16 : y, Yl === null)
            var k = !1;
          else {
            if (y = Yl, Yl = null, Mh = 0, (Qr & 6) !== 0)
              throw Error(l(331));
            var X = Qr;
            for (Qr |= 4, vn = y.current; vn !== null; ) {
              var $ = vn, Ae = $.child;
              if ((vn.flags & 16) !== 0) {
                var $e = $.deletions;
                if ($e !== null) {
                  for (var kt = 0; kt < $e.length; kt++) {
                    var hn = $e[kt];
                    for (vn = hn; vn !== null; ) {
                      var wn = vn;
                      switch (wn.tag) {
                        case 0:
                        case 11:
                        case 15:
                          zu(8, wn, $);
                      }
                      var br = wn.child;
                      if (br !== null)
                        br.return = wn, vn = br;
                      else
                        for (; vn !== null; ) {
                          wn = vn;
                          var ur = wn.sibling, Sa = wn.return;
                          if (zs(wn), wn === hn) {
                            vn = null;
                            break;
                          }
                          if (ur !== null) {
                            ur.return = Sa, vn = ur;
                            break;
                          }
                          vn = Sa;
                        }
                    }
                  }
                  var Tn = $.alternate;
                  if (Tn !== null) {
                    var Li = Tn.child;
                    if (Li !== null) {
                      Tn.child = null;
                      do {
                        var vs = Li.sibling;
                        Li.sibling = null, Li = vs;
                      } while (Li !== null);
                    }
                  }
                  vn = $;
                }
              }
              if (($.subtreeFlags & 2064) !== 0 && Ae !== null)
                Ae.return = $, vn = Ae;
              else
                e:
                  for (; vn !== null; ) {
                    if ($ = vn, ($.flags & 2048) !== 0)
                      switch ($.tag) {
                        case 0:
                        case 11:
                        case 15:
                          zu(9, $, $.return);
                      }
                    var pt = $.sibling;
                    if (pt !== null) {
                      pt.return = $.return, vn = pt;
                      break e;
                    }
                    vn = $.return;
                  }
            }
            var Ze = y.current;
            for (vn = Ze; vn !== null; ) {
              Ae = vn;
              var Lt = Ae.child;
              if ((Ae.subtreeFlags & 2064) !== 0 && Lt !== null)
                Lt.return = Ae, vn = Lt;
              else
                e:
                  for (Ae = Ze; vn !== null; ) {
                    if ($e = vn, ($e.flags & 2048) !== 0)
                      try {
                        switch ($e.tag) {
                          case 0:
                          case 11:
                          case 15:
                            bs(9, $e);
                        }
                      } catch (jn) {
                        bi($e, $e.return, jn);
                      }
                    if ($e === Ae) {
                      vn = null;
                      break e;
                    }
                    var Qt = $e.sibling;
                    if (Qt !== null) {
                      Qt.return = $e.return, vn = Qt;
                      break e;
                    }
                    vn = $e.return;
                  }
            }
            if (Qr = X, ko(), lu && typeof lu.onPostCommitFiberRoot == "function")
              try {
                lu.onPostCommitFiberRoot(mf, y);
              } catch {
              }
            k = !0;
          }
          return k;
        } finally {
          Cr = L, _a.transition = x;
        }
      }
      return !1;
    }
    function Ms(y, x, L) {
      x = wf(L, x), x = sd(y, x, 1), Ku(y, x), x = ui(), y = Fc(y, 1), y !== null && (xr(y, 1, x), _r(y, x));
    }
    function bi(y, x, L) {
      if (y.tag === 3)
        Ms(y, y, L);
      else
        for (; x !== null; ) {
          if (x.tag === 3) {
            Ms(x, y, L);
            break;
          } else if (x.tag === 1) {
            var k = x.stateNode;
            if (typeof x.type.getDerivedStateFromError == "function" || typeof k.componentDidCatch == "function" && (jl === null || !jl.has(k))) {
              y = wf(L, y), y = Dc(x, y, 1), Ku(x, y), y = ui(), x = Fc(x, 1), x !== null && (xr(x, 1, y), _r(x, y));
              break;
            }
          }
          x = x.return;
        }
    }
    function no(y, x, L) {
      var k = y.pingCache;
      k !== null && k.delete(x), x = ui(), y.pingedLanes |= y.suspendedLanes & L, Ra === y && (li & L) === L && (Es === 4 || Es === 3 && (li & 130023424) === li && 500 > hi() - Bm ? Di(y, 0) : Qd |= L), _r(y, x);
    }
    function Ql(y, x) {
      x === 0 && ((y.mode & 1) === 0 ? x = 1 : (x = ei, ei <<= 1, (ei & 130023424) === 0 && (ei = 4194304)));
      var L = ui();
      y = Fc(y, x), y !== null && (xr(y, x, L), _r(y, L));
    }
    function Bc(y) {
      var x = y.memoizedState, L = 0;
      x !== null && (L = x.retryLane), Ql(y, L);
    }
    function mu(y, x) {
      var L = 0;
      switch (y.tag) {
        case 13:
          var k = y.stateNode, X = y.memoizedState;
          X !== null && (L = X.retryLane);
          break;
        case 19:
          k = y.stateNode;
          break;
        default:
          throw Error(l(314));
      }
      k !== null && k.delete(x), Ql(y, L);
    }
    var Pf;
    Pf = function(y, x, L) {
      if (y !== null)
        if (y.memoizedProps !== x.pendingProps || Ti.current)
          si = !0;
        else {
          if ((y.lanes & L) === 0 && (x.flags & 128) === 0)
            return si = !1, uc(y, x, L);
          si = (y.flags & 131072) !== 0;
        }
      else
        si = !1, ca && (x.flags & 1048576) !== 0 && zl(x, kp, x.index);
      switch (x.lanes = 0, x.tag) {
        case 2:
          var k = x.type;
          y !== null && (y.alternate = null, x.alternate = null, x.flags |= 2), y = x.pendingProps;
          var X = zo(x, Si.current);
          Qs(x, L), X = _i(null, x, k, y, X, L);
          var $ = Mc();
          return x.flags |= 1, typeof X == "object" && X !== null && typeof X.render == "function" && X.$$typeof === void 0 ? (x.tag = 1, x.memoizedState = null, x.updateQueue = null, Pa(k) ? ($ = !0, Ll(x)) : $ = !1, x.memoizedState = X.state !== null && X.state !== void 0 ? X.state : null, Zs(x), X.updater = Pm, x.stateNode = X, X._reactInternals = x, gh(x, k, y, L), x = Ia(null, x, k, !0, $, L)) : (x.tag = 0, ca && $ && ec(x), Wn(null, x, X, L), x = x.child), x;
        case 16:
          k = x.elementType;
          e: {
            switch (y !== null && (y.alternate = null, x.alternate = null, x.flags |= 2), y = x.pendingProps, X = k._init, k = X(k._payload), x.type = k, X = x.tag = dd(k), y = Oa(k, y), X) {
              case 0:
                x = es(null, x, k, y, L);
                break e;
              case 1:
                x = kl(
                  null,
                  x,
                  k,
                  y,
                  L
                );
                break e;
              case 11:
                x = wi(null, x, k, y, L);
                break e;
              case 14:
                x = zi(null, x, k, Oa(k.type, y), L);
                break e;
            }
            throw Error(l(306, k, ""));
          }
          return x;
        case 0:
          return k = x.type, X = x.pendingProps, X = x.elementType === k ? X : Oa(k, X), es(y, x, k, X, L);
        case 1:
          return k = x.type, X = x.pendingProps, X = x.elementType === k ? X : Oa(k, X), kl(y, x, k, X, L);
        case 3:
          e: {
            if (Il(x), y === null)
              throw Error(l(387));
            k = x.pendingProps, $ = x.memoizedState, X = $.element, Kf(y, x), Au(x, k, null, L);
            var Ae = x.memoizedState;
            if (k = Ae.element, qe && $.isDehydrated)
              if ($ = {
                element: k,
                isDehydrated: !1,
                cache: Ae.cache,
                transitions: Ae.transitions
              }, x.updateQueue.baseState = $, x.memoizedState = $, x.flags & 256) {
                X = Error(l(423)), x = bf(y, x, k, L, X);
                break e;
              } else if (k !== X) {
                X = Error(l(424)), x = bf(y, x, k, L, X);
                break e;
              } else
                for (qe && (Ma = Le(x.stateNode.containerInfo), Za = x, ca = !0, nl = null, kd = !1), L = Bp(x, null, k, L), x.child = L; L; )
                  L.flags = L.flags & -3 | 4096, L = L.sibling;
            else {
              if (xh(), k === X) {
                x = Vr(y, x, L);
                break e;
              }
              Wn(y, x, k, L);
            }
            x = x.child;
          }
          return x;
        case 5:
          return Vp(x), y === null && ed(x), k = x.type, X = x.pendingProps, $ = y !== null ? y.memoizedProps : null, Ae = X.children, rt(k, X) ? Ae = null : $ !== null && rt(k, $) && (x.flags |= 32), ps(y, x), Wn(y, x, Ae, L), x.child;
        case 6:
          return y === null && ed(x), null;
        case 13:
          return bv(y, x, L);
        case 4:
          return Hp(x, x.stateNode.containerInfo), k = x.pendingProps, y === null ? x.child = Ec(x, null, k, L) : Wn(y, x, k, L), x.child;
        case 11:
          return k = x.type, X = x.pendingProps, X = x.elementType === k ? X : Oa(k, X), wi(y, x, k, X, L);
        case 7:
          return Wn(y, x, x.pendingProps, L), x.child;
        case 8:
          return Wn(y, x, x.pendingProps.children, L), x.child;
        case 12:
          return Wn(y, x, x.pendingProps.children, L), x.child;
        case 10:
          e: {
            if (k = x.type._context, X = x.pendingProps, $ = x.memoizedProps, Ae = X.value, Ru(x, k, Ae), $ !== null)
              if (Fo($.value, Ae)) {
                if ($.children === X.children && !Ti.current) {
                  x = Vr(y, x, L);
                  break e;
                }
              } else
                for ($ = x.child, $ !== null && ($.return = x); $ !== null; ) {
                  var $e = $.dependencies;
                  if ($e !== null) {
                    Ae = $.child;
                    for (var kt = $e.firstContext; kt !== null; ) {
                      if (kt.context === k) {
                        if ($.tag === 1) {
                          kt = el(-1, L & -L), kt.tag = 2;
                          var hn = $.updateQueue;
                          if (hn !== null) {
                            hn = hn.shared;
                            var wn = hn.pending;
                            wn === null ? kt.next = kt : (kt.next = wn.next, wn.next = kt), hn.pending = kt;
                          }
                        }
                        $.lanes |= L, kt = $.alternate, kt !== null && (kt.lanes |= L), za($.return, L, x), $e.lanes |= L;
                        break;
                      }
                      kt = kt.next;
                    }
                  } else if ($.tag === 10)
                    Ae = $.type === x.type ? null : $.child;
                  else if ($.tag === 18) {
                    if (Ae = $.return, Ae === null)
                      throw Error(l(341));
                    Ae.lanes |= L, $e = Ae.alternate, $e !== null && ($e.lanes |= L), za(Ae, L, x), Ae = $.sibling;
                  } else
                    Ae = $.child;
                  if (Ae !== null)
                    Ae.return = $;
                  else
                    for (Ae = $; Ae !== null; ) {
                      if (Ae === x) {
                        Ae = null;
                        break;
                      }
                      if ($ = Ae.sibling, $ !== null) {
                        $.return = Ae.return, Ae = $;
                        break;
                      }
                      Ae = Ae.return;
                    }
                  $ = Ae;
                }
            Wn(y, x, X.children, L), x = x.child;
          }
          return x;
        case 9:
          return X = x.type, k = x.pendingProps.children, Qs(x, L), X = qr(X), k = k(X), x.flags |= 1, Wn(y, x, k, L), x.child;
        case 14:
          return k = x.type, X = Oa(k, x.pendingProps), X = Oa(k.type, X), zi(y, x, k, X, L);
        case 15:
          return Oc(y, x, x.type, x.pendingProps, L);
        case 17:
          return k = x.type, X = x.pendingProps, X = x.elementType === k ? X : Oa(k, X), y !== null && (y.alternate = null, x.alternate = null, x.flags |= 2), x.tag = 1, Pa(k) ? (y = !0, Ll(x)) : y = !1, Qs(x, L), Um(x, k, X), gh(x, k, X, L), Ia(null, x, k, !0, y, L);
        case 19:
          return Uc(y, x, L);
        case 22:
          return Rr(y, x, L);
      }
      throw Error(l(156, x.tag));
    };
    function vu(y, x) {
      return yo(y, x);
    }
    function Fu(y, x, L, k) {
      this.tag = y, this.key = L, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = x, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = k, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
    }
    function Mo(y, x, L, k) {
      return new Fu(y, x, L, k);
    }
    function Hc(y) {
      return y = y.prototype, !(!y || !y.isReactComponent);
    }
    function dd(y) {
      if (typeof y == "function")
        return Hc(y) ? 1 : 0;
      if (y != null) {
        if (y = y.$$typeof, y === O)
          return 11;
        if (y === I)
          return 14;
      }
      return 2;
    }
    function Xo(y, x) {
      var L = y.alternate;
      return L === null ? (L = Mo(y.tag, x, y.key, y.mode), L.elementType = y.elementType, L.type = y.type, L.stateNode = y.stateNode, L.alternate = y, y.alternate = L) : (L.pendingProps = x, L.type = y.type, L.flags = 0, L.subtreeFlags = 0, L.deletions = null), L.flags = y.flags & 14680064, L.childLanes = y.childLanes, L.lanes = y.lanes, L.child = y.child, L.memoizedProps = y.memoizedProps, L.memoizedState = y.memoizedState, L.updateQueue = y.updateQueue, x = y.dependencies, L.dependencies = x === null ? null : { lanes: x.lanes, firstContext: x.firstContext }, L.sibling = y.sibling, L.index = y.index, L.ref = y.ref, L;
    }
    function hd(y, x, L, k, X, $) {
      var Ae = 2;
      if (k = y, typeof y == "function")
        Hc(y) && (Ae = 1);
      else if (typeof y == "string")
        Ae = 5;
      else
        e:
          switch (y) {
            case _:
              return gu(L.children, X, $, x);
            case w:
              Ae = 8, X |= 8;
              break;
            case T:
              return y = Mo(12, L, x, X | 2), y.elementType = T, y.lanes = $, y;
            case U:
              return y = Mo(13, L, x, X), y.elementType = U, y.lanes = $, y;
            case H:
              return y = Mo(19, L, x, X), y.elementType = H, y.lanes = $, y;
            case B:
              return pd(L, X, $, x);
            default:
              if (typeof y == "object" && y !== null)
                switch (y.$$typeof) {
                  case R:
                    Ae = 10;
                    break e;
                  case D:
                    Ae = 9;
                    break e;
                  case O:
                    Ae = 11;
                    break e;
                  case I:
                    Ae = 14;
                    break e;
                  case G:
                    Ae = 16, k = null;
                    break e;
                }
              throw Error(l(130, y == null ? y : typeof y, ""));
          }
      return x = Mo(Ae, L, x, X), x.elementType = y, x.type = k, x.lanes = $, x;
    }
    function gu(y, x, L, k) {
      return y = Mo(7, y, k, x), y.lanes = L, y;
    }
    function pd(y, x, L, k) {
      return y = Mo(22, y, k, x), y.elementType = B, y.lanes = L, y.stateNode = {}, y;
    }
    function Ts(y, x, L) {
      return y = Mo(6, y, null, x), y.lanes = L, y;
    }
    function Is(y, x, L) {
      return x = Mo(4, y.children !== null ? y.children : [], y.key, x), x.lanes = L, x.stateNode = { containerInfo: y.containerInfo, pendingChildren: null, implementation: y.implementation }, x;
    }
    function yu(y, x, L, k, X) {
      this.tag = x, this.containerInfo = y, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = Tt, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = qf(0), this.expirationTimes = qf(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = qf(0), this.identifierPrefix = k, this.onRecoverableError = X, qe && (this.mutableSourceEagerHydrationData = null);
    }
    function mg(y, x, L, k, X, $, Ae, $e, kt) {
      return y = new yu(y, x, L, $e, kt), x === 1 ? (x = 1, $ === !0 && (x |= 8)) : x = 0, $ = Mo(3, null, null, x), y.current = $, $.stateNode = y, $.memoizedState = { element: k, isDehydrated: L, cache: null, transitions: null }, Zs($), y;
    }
    function ti(y) {
      if (!y)
        return Ea;
      y = y._reactInternals;
      e: {
        if (re(y) !== y || y.tag !== 1)
          throw Error(l(170));
        var x = y;
        do {
          switch (x.tag) {
            case 3:
              x = x.stateNode.context;
              break e;
            case 1:
              if (Pa(x.type)) {
                x = x.stateNode.__reactInternalMemoizedMergedChildContext;
                break e;
              }
          }
          x = x.return;
        } while (x !== null);
        throw Error(l(171));
      }
      if (y.tag === 1) {
        var L = y.type;
        if (Pa(L))
          return Yf(y, L, x);
      }
      return x;
    }
    function ku(y) {
      var x = y._reactInternals;
      if (x === void 0)
        throw typeof y.render == "function" ? Error(l(188)) : (y = Object.keys(y).join(","), Error(l(268, y)));
      return y = ue(x), y === null ? null : y.stateNode;
    }
    function Of(y, x) {
      if (y = y.memoizedState, y !== null && y.dehydrated !== null) {
        var L = y.retryLane;
        y.retryLane = L !== 0 && L < x ? L : x;
      }
    }
    function dc(y, x) {
      Of(y, x), (y = y.alternate) && Of(y, x);
    }
    function Uf(y) {
      return y = ue(y), y === null ? null : y.stateNode;
    }
    function jp() {
      return null;
    }
    return t.attemptContinuousHydration = function(y) {
      if (y.tag === 13) {
        var x = ui();
        Xl(y, 134217728, x), dc(y, 134217728);
      }
    }, t.attemptHydrationAtCurrentPriority = function(y) {
      if (y.tag === 13) {
        var x = ui(), L = Fs(y);
        Xl(y, L, x), dc(y, L);
      }
    }, t.attemptSynchronousHydration = function(y) {
      switch (y.tag) {
        case 3:
          var x = y.stateNode;
          if (x.current.memoizedState.isDehydrated) {
            var L = go(x.pendingLanes);
            L !== 0 && (ua(x, L | 1), _r(x, hi()), (Qr & 6) === 0 && (Zd(), ko()));
          }
          break;
        case 13:
          var k = ui();
          Ha(function() {
            return Xl(y, 1, k);
          }), dc(y, 1);
      }
    }, t.batchedUpdates = function(y, x) {
      var L = Qr;
      Qr |= 1;
      try {
        return y(x);
      } finally {
        Qr = L, Qr === 0 && (Zd(), wc && ko());
      }
    }, t.createComponentSelector = function(y) {
      return { $$typeof: Xd, value: y };
    }, t.createContainer = function(y, x, L, k, X, $, Ae) {
      return mg(y, x, !1, null, L, k, X, $, Ae);
    }, t.createHasPseudoClassSelector = function(y) {
      return { $$typeof: da, value: y };
    }, t.createHydrationContainer = function(y, x, L, k, X, $, Ae, $e, kt) {
      return y = mg(L, k, !0, y, X, $, Ae, $e, kt), y.context = ti(null), L = y.current, k = ui(), X = Fs(L), $ = el(k, X), $.callback = x != null ? x : null, Ku(L, $), y.current.lanes = X, xr(y, X, k), _r(y, k), y;
    }, t.createPortal = function(y, x, L) {
      var k = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      return { $$typeof: g, key: k == null ? null : "" + k, children: y, containerInfo: x, implementation: L };
    }, t.createRoleSelector = function(y) {
      return { $$typeof: Gi, value: y };
    }, t.createTestNameSelector = function(y) {
      return { $$typeof: bn, value: y };
    }, t.createTextSelector = function(y) {
      return { $$typeof: Qi, value: y };
    }, t.deferredUpdates = function(y) {
      var x = Cr, L = _a.transition;
      try {
        return _a.transition = null, Cr = 16, y();
      } finally {
        Cr = x, _a.transition = L;
      }
    }, t.discreteUpdates = function(y, x, L, k, X) {
      var $ = Cr, Ae = _a.transition;
      try {
        return _a.transition = null, Cr = 1, y(x, L, k, X);
      } finally {
        Cr = $, _a.transition = Ae, Qr === 0 && Zd();
      }
    }, t.findAllNodes = An, t.findBoundingRects = function(y, x) {
      if (!Zt)
        throw Error(l(363));
      x = An(y, x), y = [];
      for (var L = 0; L < x.length; L++)
        y.push(we(x[L]));
      for (x = y.length - 1; 0 < x; x--) {
        L = y[x];
        for (var k = L.x, X = k + L.width, $ = L.y, Ae = $ + L.height, $e = x - 1; 0 <= $e; $e--)
          if (x !== $e) {
            var kt = y[$e], hn = kt.x, wn = hn + kt.width, br = kt.y, ur = br + kt.height;
            if (k >= hn && $ >= br && X <= wn && Ae <= ur) {
              y.splice(x, 1);
              break;
            } else if (k !== hn || L.width !== kt.width || ur < $ || br > Ae) {
              if (!($ !== br || L.height !== kt.height || wn < k || hn > X)) {
                hn > k && (kt.width += hn - k, kt.x = k), wn < X && (kt.width = X - hn), y.splice(x, 1);
                break;
              }
            } else {
              br > $ && (kt.height += br - $, kt.y = $), ur < Ae && (kt.height = Ae - br), y.splice(x, 1);
              break;
            }
          }
      }
      return y;
    }, t.findHostInstance = ku, t.findHostInstanceWithNoPortals = function(y) {
      return y = ce(y), y = y !== null ? me(y) : null, y === null ? null : y.stateNode;
    }, t.findHostInstanceWithWarning = function(y) {
      return ku(y);
    }, t.flushControlled = function(y) {
      var x = Qr;
      Qr |= 1;
      var L = _a.transition, k = Cr;
      try {
        _a.transition = null, Cr = 1, y();
      } finally {
        Cr = k, _a.transition = L, Qr = x, Qr === 0 && (Zd(), ko());
      }
    }, t.flushPassiveEffects = Ic, t.flushSync = Ha, t.focusWithin = function(y, x) {
      if (!Zt)
        throw Error(l(363));
      for (y = rp(y), x = ts(y, x), x = Array.from(x), y = 0; y < x.length; ) {
        var L = x[y++];
        if (!Qe(L)) {
          if (L.tag === 5 && Ft(L.stateNode))
            return !0;
          for (L = L.child; L !== null; )
            x.push(L), L = L.sibling;
        }
      }
      return !1;
    }, t.getCurrentUpdatePriority = function() {
      return Cr;
    }, t.getFindAllNodesFailureDescription = function(y, x) {
      if (!Zt)
        throw Error(l(363));
      var L = 0, k = [];
      y = [rp(y), 0];
      for (var X = 0; X < y.length; ) {
        var $ = y[X++], Ae = y[X++], $e = x[Ae];
        if (($.tag !== 5 || !Qe($)) && (Wo($, $e) && (k.push(jo($e)), Ae++, Ae > L && (L = Ae)), Ae < x.length))
          for ($ = $.child; $ !== null; )
            y.push($, Ae), $ = $.sibling;
      }
      if (L < x.length) {
        for (y = []; L < x.length; L++)
          y.push(jo(x[L]));
        return `findAllNodes was able to match part of the selector:
  ` + (k.join(" > ") + `

No matching component was found for:
  `) + y.join(" > ");
      }
      return null;
    }, t.getPublicRootInstance = function(y) {
      if (y = y.current, !y.child)
        return null;
      switch (y.child.tag) {
        case 5:
          return Re(y.child.stateNode);
        default:
          return y.child.stateNode;
      }
    }, t.injectIntoDevTools = function(y) {
      if (y = { bundleType: y.bundleType, version: y.version, rendererPackageName: y.rendererPackageName, rendererConfig: y.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: d.ReactCurrentDispatcher, findHostInstanceByFiber: Uf, findFiberByHostInstance: y.findFiberByHostInstance || jp, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.0.0-fc46dba67-20220329" }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        y = !1;
      else {
        var x = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (x.isDisabled || !x.supportsFiber)
          y = !0;
        else {
          try {
            mf = x.inject(y), lu = x;
          } catch {
          }
          y = !!x.checkDCE;
        }
      }
      return y;
    }, t.isAlreadyRendering = function() {
      return !1;
    }, t.observeVisibleRects = function(y, x, L, k) {
      if (!Zt)
        throw Error(l(363));
      y = An(y, x);
      var X = Ot(y, L, k).disconnect;
      return { disconnect: function() {
        X();
      } };
    }, t.registerMutableSourceForHydration = function(y, x) {
      var L = x._getVersion;
      L = L(x._source), y.mutableSourceEagerHydrationData == null ? y.mutableSourceEagerHydrationData = [x, L] : y.mutableSourceEagerHydrationData.push(x, L);
    }, t.runWithPriority = function(y, x) {
      var L = Cr;
      try {
        return Cr = y, x();
      } finally {
        Cr = L;
      }
    }, t.shouldError = function() {
      return null;
    }, t.shouldSuspend = function() {
      return !1;
    }, t.updateContainer = function(y, x, L, k) {
      var X = x.current, $ = ui(), Ae = Fs(X);
      return L = ti(L), x.context === null ? x.context = L : x.pendingContext = L, x = el($, Ae), x.payload = { element: y }, k = k === void 0 ? null : k, k !== null && (x.callback = k), Ku(X, x), y = Xl(X, Ae, $), y !== null && Kh(y, X, Ae), Ae;
    }, t;
  }), oD;
}
var lD = { exports: {} };
/**
 * @license React
 * react-reconciler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var sz;
function R9() {
  return sz || (sz = 1, process.env.NODE_ENV !== "production" && (lD.exports = function(e) {
    var t = {}, r = ph, i = YM.exports, s = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, l = !1;
    function d(u) {
      l = u;
    }
    function p(u) {
      if (!l) {
        for (var f = arguments.length, M = new Array(f > 1 ? f - 1 : 0), A = 1; A < f; A++)
          M[A - 1] = arguments[A];
        _("warn", u, M);
      }
    }
    function g(u) {
      if (!l) {
        for (var f = arguments.length, M = new Array(f > 1 ? f - 1 : 0), A = 1; A < f; A++)
          M[A - 1] = arguments[A];
        _("error", u, M);
      }
    }
    function _(u, f, M) {
      {
        var A = s.ReactDebugCurrentFrame, z = A.getStackAddendum();
        z !== "" && (f += "%s", M = M.concat([z]));
        var W = M.map(function(ee) {
          return String(ee);
        });
        W.unshift("Warning: " + f), Function.prototype.apply.call(console[u], console, W);
      }
    }
    var w = Object.assign;
    function T(u) {
      return u._reactInternals;
    }
    function R(u, f) {
      u._reactInternals = f;
    }
    var D = !1, O = !1, U = !1, H = !1, I = !1, G = !1, B = !0, Q = !0, K = !0, te = 0, Y = 1, re = 2, se = 3, ce = 4, ue = 5, Me = 6, me = 7, De = 8, Re = 9, He = 10, ve = 11, fe = 12, he = 13, ye = 14, Ee = 15, Ve = 16, Je = 17, rt = 18, Ne = 19, ct = 21, tt = 22, Tt = 23, gt = 24, ft = 25, Ie = Symbol.for("react.element"), qe = Symbol.for("react.portal"), dt = Symbol.for("react.fragment"), ht = Symbol.for("react.strict_mode"), xt = Symbol.for("react.profiler"), Vt = Symbol.for("react.provider"), yt = Symbol.for("react.context"), Nt = Symbol.for("react.forward_ref"), Zt = Symbol.for("react.suspense"), Rt = Symbol.for("react.suspense_list"), we = Symbol.for("react.memo"), oe = Symbol.for("react.lazy"), Qe = Symbol.for("react.scope"), ut = Symbol.for("react.debug_trace_mode"), Ft = Symbol.for("react.offscreen"), Ot = Symbol.for("react.legacy_hidden"), Wt = Symbol.for("react.cache"), it = Symbol.for("react.tracing_marker"), an = Symbol.iterator, Be = "@@iterator";
    function pe(u) {
      if (u === null || typeof u != "object")
        return null;
      var f = an && u[an] || u[Be];
      return typeof f == "function" ? f : null;
    }
    function Fe(u, f, M) {
      var A = u.displayName;
      if (A)
        return A;
      var z = f.displayName || f.name || "";
      return z !== "" ? M + "(" + z + ")" : M;
    }
    function at(u) {
      return u.displayName || "Context";
    }
    function st(u) {
      if (u == null)
        return null;
      if (typeof u.tag == "number" && g("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof u == "function")
        return u.displayName || u.name || null;
      if (typeof u == "string")
        return u;
      switch (u) {
        case dt:
          return "Fragment";
        case qe:
          return "Portal";
        case xt:
          return "Profiler";
        case ht:
          return "StrictMode";
        case Zt:
          return "Suspense";
        case Rt:
          return "SuspenseList";
      }
      if (typeof u == "object")
        switch (u.$$typeof) {
          case yt:
            var f = u;
            return at(f) + ".Consumer";
          case Vt:
            var M = u;
            return at(M._context) + ".Provider";
          case Nt:
            return Fe(u, u.render, "ForwardRef");
          case we:
            var A = u.displayName || null;
            return A !== null ? A : st(u.type) || "Memo";
          case oe: {
            var z = u, W = z._payload, ee = z._init;
            try {
              return st(ee(W));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function dn(u, f, M) {
      var A = f.displayName || f.name || "";
      return u.displayName || (A !== "" ? M + "(" + A + ")" : M);
    }
    function ze(u) {
      return u.displayName || "Context";
    }
    function wt(u) {
      var f = u.tag, M = u.type;
      switch (f) {
        case gt:
          return "Cache";
        case Re:
          var A = M;
          return ze(A) + ".Consumer";
        case He:
          var z = M;
          return ze(z._context) + ".Provider";
        case rt:
          return "DehydratedFragment";
        case ve:
          return dn(M, M.render, "ForwardRef");
        case me:
          return "Fragment";
        case ue:
          return M;
        case ce:
          return "Portal";
        case se:
          return "Root";
        case Me:
          return "Text";
        case Ve:
          return st(M);
        case De:
          return M === ht ? "StrictMode" : "Mode";
        case tt:
          return "Offscreen";
        case fe:
          return "Profiler";
        case ct:
          return "Scope";
        case he:
          return "Suspense";
        case Ne:
          return "SuspenseList";
        case ft:
          return "TracingMarker";
        case Y:
        case te:
        case Je:
        case re:
        case ye:
        case Ee:
          if (typeof M == "function")
            return M.displayName || M.name || null;
          if (typeof M == "string")
            return M;
          break;
      }
      return null;
    }
    var Pe = 0, Gt = 1, At = 2, cn = 4, ki = At | cn, Or = 16, Ii = 32, Ir = 64, Bn = 128, Mi = 256, yi = 512, ii = 1024, Bi = 2048, xi = 4096, $r = xi | cn, ai = 8192, Te = 16384, ot = Bi | cn | Ir | yi | ii | Te, de = 32767, Le = 32768, Ye = 65536, $t = 131072, mn = 1048576, Rn = 2097152, gn = 4194304, yn = 8388608, Jn = 16777216, rr = 33554432, wr = cn | ii | 0, Yi = At | cn | Or | Ii | yi | xi | ai, La = cn | Ir | yi | ai, qs = Bi | Or, en = gn | yn | Rn, Xr = s.ReactCurrentOwner;
    function us(u) {
      var f = u, M = u;
      if (u.alternate)
        for (; f.return; )
          f = f.return;
      else {
        var A = f;
        do
          f = A, (f.flags & (At | xi)) !== Pe && (M = f.return), A = f.return;
        while (A);
      }
      return f.tag === se ? M : null;
    }
    function qn(u) {
      return us(u) === u;
    }
    function qa(u) {
      {
        var f = Xr.current;
        if (f !== null && f.tag === Y) {
          var M = f, A = M.stateNode;
          A._warnedAboutRefsInRender || g("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", wt(M) || "A component"), A._warnedAboutRefsInRender = !0;
        }
      }
      var z = T(u);
      return z ? us(z) === z : !1;
    }
    function mo(u) {
      if (us(u) !== u)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function Ls(u) {
      var f = u.alternate;
      if (!f) {
        var M = us(u);
        if (M === null)
          throw new Error("Unable to find node on an unmounted component.");
        return M !== u ? null : u;
      }
      for (var A = u, z = f; ; ) {
        var W = A.return;
        if (W === null)
          break;
        var ee = W.alternate;
        if (ee === null) {
          var ae = W.return;
          if (ae !== null) {
            A = z = ae;
            continue;
          }
          break;
        }
        if (W.child === ee.child) {
          for (var _e = W.child; _e; ) {
            if (_e === A)
              return mo(W), u;
            if (_e === z)
              return mo(W), f;
            _e = _e.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (A.return !== z.return)
          A = W, z = ee;
        else {
          for (var Ue = !1, We = W.child; We; ) {
            if (We === A) {
              Ue = !0, A = W, z = ee;
              break;
            }
            if (We === z) {
              Ue = !0, z = W, A = ee;
              break;
            }
            We = We.sibling;
          }
          if (!Ue) {
            for (We = ee.child; We; ) {
              if (We === A) {
                Ue = !0, A = ee, z = W;
                break;
              }
              if (We === z) {
                Ue = !0, z = ee, A = W;
                break;
              }
              We = We.sibling;
            }
            if (!Ue)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (A.alternate !== z)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (A.tag !== se)
        throw new Error("Unable to find node on an unmounted component.");
      return A.stateNode.current === A ? u : f;
    }
    function cs(u) {
      var f = Ls(u);
      return f !== null ? mr(f) : null;
    }
    function mr(u) {
      if (u.tag === ue || u.tag === Me)
        return u;
      for (var f = u.child; f !== null; ) {
        var M = mr(f);
        if (M !== null)
          return M;
        f = f.sibling;
      }
      return null;
    }
    function di(u) {
      var f = Ls(u);
      return f !== null ? Ea(f) : null;
    }
    function Ea(u) {
      if (u.tag === ue || u.tag === Me)
        return u;
      for (var f = u.child; f !== null; ) {
        if (f.tag !== ce) {
          var M = Ea(f);
          if (M !== null)
            return M;
        }
        f = f.sibling;
      }
      return null;
    }
    var Si = Array.isArray;
    function Ti(u) {
      return Si(u);
    }
    var Uo = e.getPublicInstance, zo = e.getRootHostContext, Pa = e.getChildHostContext, Dl = e.prepareForCommit, vo = e.resetAfterCommit, Yf = e.createInstance, Ll = e.appendInitialChild, Nd = e.finalizeInitialChildren, Ps = e.prepareUpdate, Ju = e.shouldSetTextContent, ou = e.createTextInstance, Jh = e.scheduleTimeout, Pl = e.cancelTimeout, ei = e.noTimeout;
    e.now;
    var go = e.isPrimaryRenderer, Xf = e.warnsIfNotActing, No = e.supportsMutation, Ci = e.supportsPersistence, fs = e.supportsHydration, qf = e.getInstanceFromNode;
    e.beforeActiveInstanceBlur, e.afterActiveInstanceBlur;
    var xr = e.preparePortalMount;
    e.preparePortalMount, e.getInstanceFromScope;
    var Tu = e.getCurrentEventPriority, ua = e.detachDeletedInstance, Cr = e.supportsMicrotasks, dl = e.scheduleMicrotask, yo = e.supportsTestSelectors, Ka = e.findFiberRoot, Xi = e.getBoundingRect, Lm = e.getTextContent, hi = e.isHiddenSubtree, Qa = e.matchAccessibilityRole, Sc = e.setFocusIfFocusable, hl = e.setupIntersectionObserver, pf = e.appendChild, mf = e.appendChildToContainer, lu = e.commitTextUpdate, Hi = e.commitMount, Ri = e.commitUpdate, Fo = e.insertBefore, Os = e.insertInContainerBefore, wc = e.removeChild, Ol = e.removeChildFromContainer, Qf = e.resetTextContent, Zf = e.hideInstance, ko = e.hideTextInstance, Jf = e.unhideInstance, Ki = e.unhideTextInstance, Cu = e.clearContainer, Oa = e.cloneInstance, xs = e.createContainerChildSet, uu = e.appendChildToContainerChildSet, Ua = e.finalizeContainerChildren, bc = e.replaceContainerChildren;
    e.getOffscreenContainerType;
    var xo = e.getOffscreenContainerProps, Ru = e.cloneHiddenInstance, Ul = e.cloneHiddenTextInstance, za = e.canHydrateInstance, Qs = e.canHydrateTextInstance, qr = e.canHydrateSuspenseInstance, _s = e.isSuspenseInstancePending, va = e.isSuspenseInstanceFallback, Zs = e.registerSuspenseInstanceRetry, Kf = e.getNextHydratableSibling, el = e.getFirstHydratableChild, Ku = e.getFirstHydratableChildWithinContainer, Kh = e.getFirstHydratableChildWithinSuspenseInstance, qi = e.hydrateInstance, Au = e.hydrateTextInstance, Fp = e.hydrateSuspenseInstance, pg = e.getNextHydratableInstanceAfterSuspenseInstance, $h = e.commitHydratedContainer, Pm = e.commitHydratedSuspenseInstance, Om = e.clearSuspenseBoundary, Um = e.clearSuspenseBoundaryFromContainer, zm = e.shouldDeleteUnhydratedTailInstances, gh = e.didNotMatchHydratedContainerTextInstance, $u = e.didNotMatchHydratedTextInstance, Fd = e.didNotHydrateInstanceWithinContainer, Du = e.didNotHydrateInstanceWithinSuspenseInstance, kp = e.didNotHydrateInstance, pl = e.didNotFindHydratableInstanceWithinContainer, tl = e.didNotFindHydratableTextInstanceWithinContainer, vf = e.didNotFindHydratableSuspenseInstanceWithinContainer, $f = e.didNotFindHydratableInstanceWithinSuspenseInstance, cu = e.didNotFindHydratableTextInstanceWithinSuspenseInstance, gf = e.didNotFindHydratableSuspenseInstanceWithinSuspenseInstance, zl = e.didNotFindHydratableInstance, ec = e.didNotFindHydratableTextInstance, Oi = e.didNotFindHydratableSuspenseInstance, Za = e.errorHydratingContainer, Ma = 0, ca, kd, nl, Nm, Fm, yh, ed;
    function Id() {
    }
    Id.__reactDisabledLog = !0;
    function Ip() {
      {
        if (Ma === 0) {
          ca = console.log, kd = console.info, nl = console.warn, Nm = console.error, Fm = console.group, yh = console.groupCollapsed, ed = console.groupEnd;
          var u = {
            configurable: !0,
            enumerable: !0,
            value: Id,
            writable: !0
          };
          Object.defineProperties(console, {
            info: u,
            log: u,
            warn: u,
            error: u,
            group: u,
            groupCollapsed: u,
            groupEnd: u
          });
        }
        Ma++;
      }
    }
    function xh() {
      {
        if (Ma--, Ma === 0) {
          var u = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: w({}, u, {
              value: ca
            }),
            info: w({}, u, {
              value: kd
            }),
            warn: w({}, u, {
              value: nl
            }),
            error: w({}, u, {
              value: Nm
            }),
            group: w({}, u, {
              value: Fm
            }),
            groupCollapsed: w({}, u, {
              value: yh
            }),
            groupEnd: w({}, u, {
              value: ed
            })
          });
        }
        Ma < 0 && g("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Bd = s.ReactCurrentDispatcher, td;
    function Ss(u, f, M) {
      {
        if (td === void 0)
          try {
            throw Error();
          } catch (z) {
            var A = z.stack.trim().match(/\n( *(at )?)/);
            td = A && A[1] || "";
          }
        return `
` + td + u;
      }
    }
    var tc = !1, yf;
    {
      var Ec = typeof WeakMap == "function" ? WeakMap : Map;
      yf = new Ec();
    }
    function Bp(u, f) {
      if (!u || tc)
        return "";
      {
        var M = yf.get(u);
        if (M !== void 0)
          return M;
      }
      var A;
      tc = !0;
      var z = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var W;
      W = Bd.current, Bd.current = null, Ip();
      try {
        if (f) {
          var ee = function() {
            throw Error();
          };
          if (Object.defineProperty(ee.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(ee, []);
            } catch (pn) {
              A = pn;
            }
            Reflect.construct(u, [], ee);
          } else {
            try {
              ee.call();
            } catch (pn) {
              A = pn;
            }
            u.call(ee.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (pn) {
            A = pn;
          }
          u();
        }
      } catch (pn) {
        if (pn && A && typeof pn.stack == "string") {
          for (var ae = pn.stack.split(`
`), _e = A.stack.split(`
`), Ue = ae.length - 1, We = _e.length - 1; Ue >= 1 && We >= 0 && ae[Ue] !== _e[We]; )
            We--;
          for (; Ue >= 1 && We >= 0; Ue--, We--)
            if (ae[Ue] !== _e[We]) {
              if (Ue !== 1 || We !== 1)
                do
                  if (Ue--, We--, We < 0 || ae[Ue] !== _e[We]) {
                    var St = `
` + ae[Ue].replace(" at new ", " at ");
                    return u.displayName && St.includes("<anonymous>") && (St = St.replace("<anonymous>", u.displayName)), typeof u == "function" && yf.set(u, St), St;
                  }
                while (Ue >= 1 && We >= 0);
              break;
            }
        }
      } finally {
        tc = !1, Bd.current = W, xh(), Error.prepareStackTrace = z;
      }
      var It = u ? u.displayName || u.name : "", Yt = It ? Ss(It) : "";
      return typeof u == "function" && yf.set(u, Yt), Yt;
    }
    function nc(u, f, M) {
      return Bp(u, !0);
    }
    function Na(u, f, M) {
      return Bp(u, !1);
    }
    function Hd(u) {
      var f = u.prototype;
      return !!(f && f.isReactComponent);
    }
    function nd(u, f, M) {
      if (u == null)
        return "";
      if (typeof u == "function")
        return Bp(u, Hd(u));
      if (typeof u == "string")
        return Ss(u);
      switch (u) {
        case Zt:
          return Ss("Suspense");
        case Rt:
          return Ss("SuspenseList");
      }
      if (typeof u == "object")
        switch (u.$$typeof) {
          case Nt:
            return Na(u.render);
          case we:
            return nd(u.type, f, M);
          case oe: {
            var A = u, z = A._payload, W = A._init;
            try {
              return nd(W(z), f, M);
            } catch {
            }
          }
        }
      return "";
    }
    var rc = Object.prototype.hasOwnProperty, Hp = {}, _h = s.ReactDebugCurrentFrame;
    function Vp(u) {
      if (u) {
        var f = u._owner, M = nd(u.type, u._source, f ? f.type : null);
        _h.setExtraStackFrame(M);
      } else
        _h.setExtraStackFrame(null);
    }
    function Io(u, f, M, A, z) {
      {
        var W = Function.call.bind(rc);
        for (var ee in u)
          if (W(u, ee)) {
            var ae = void 0;
            try {
              if (typeof u[ee] != "function") {
                var _e = Error((A || "React class") + ": " + M + " type `" + ee + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof u[ee] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw _e.name = "Invariant Violation", _e;
              }
              ae = u[ee](f, ee, A, M, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Ue) {
              ae = Ue;
            }
            ae && !(ae instanceof Error) && (Vp(z), g("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", A || "React class", M, ee, typeof ae), Vp(null)), ae instanceof Error && !(ae.message in Hp) && (Hp[ae.message] = !0, Vp(z), g("Failed %s type: %s", M, ae.message), Vp(null));
          }
      }
    }
    var Xe = [], Bt;
    Bt = [];
    var vt = -1;
    function Mn(u) {
      return {
        current: u
      };
    }
    function $n(u, f) {
      if (vt < 0) {
        g("Unexpected pop.");
        return;
      }
      f !== Bt[vt] && g("Unexpected Fiber popped."), u.current = Xe[vt], Xe[vt] = null, Bt[vt] = null, vt--;
    }
    function or(u, f, M) {
      vt++, Xe[vt] = u.current, Bt[vt] = M, u.current = f;
    }
    var Ta;
    Ta = {};
    var er = {};
    Object.freeze(er);
    var Ui = Mn(er), ia = Mn(!1), Bo = er;
    function ds(u, f, M) {
      return M && ml(f) ? Bo : Ui.current;
    }
    function Vd(u, f, M) {
      {
        var A = u.stateNode;
        A.__reactInternalMemoizedUnmaskedChildContext = f, A.__reactInternalMemoizedMaskedChildContext = M;
      }
    }
    function Nl(u, f) {
      {
        var M = u.type, A = M.contextTypes;
        if (!A)
          return er;
        var z = u.stateNode;
        if (z && z.__reactInternalMemoizedUnmaskedChildContext === f)
          return z.__reactInternalMemoizedMaskedChildContext;
        var W = {};
        for (var ee in A)
          W[ee] = f[ee];
        {
          var ae = wt(u) || "Unknown";
          Io(A, W, "context", ae);
        }
        return z && Vd(u, f, W), W;
      }
    }
    function $a() {
      return ia.current;
    }
    function ml(u) {
      {
        var f = u.childContextTypes;
        return f != null;
      }
    }
    function _i(u) {
      $n(ia, u), $n(Ui, u);
    }
    function Mc(u) {
      $n(ia, u), $n(Ui, u);
    }
    function Lu(u, f, M) {
      {
        if (Ui.current !== er)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        or(Ui, f, u), or(ia, M, u);
      }
    }
    function vl(u, f, M) {
      {
        var A = u.stateNode, z = f.childContextTypes;
        if (typeof A.getChildContext != "function") {
          {
            var W = wt(u) || "Unknown";
            Ta[W] || (Ta[W] = !0, g("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", W, W));
          }
          return M;
        }
        var ee = A.getChildContext();
        for (var ae in ee)
          if (!(ae in z))
            throw new Error((wt(u) || "Unknown") + '.getChildContext(): key "' + ae + '" is not defined in childContextTypes.');
        {
          var _e = wt(u) || "Unknown";
          Io(z, ee, "child context", _e);
        }
        return w({}, M, ee);
      }
    }
    function Ca(u) {
      {
        var f = u.stateNode, M = f && f.__reactInternalMemoizedMergedChildContext || er;
        return Bo = Ui.current, or(Ui, M, u), or(ia, ia.current, u), !0;
      }
    }
    function Sh(u, f, M) {
      {
        var A = u.stateNode;
        if (!A)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (M) {
          var z = vl(u, f, Bo);
          A.__reactInternalMemoizedMergedChildContext = z, $n(ia, u), $n(Ui, u), or(Ui, z, u), or(ia, M, u);
        } else
          $n(ia, u), or(ia, M, u);
      }
    }
    function Gp(u) {
      {
        if (!qn(u) || u.tag !== Y)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var f = u;
        do {
          switch (f.tag) {
            case se:
              return f.stateNode.context;
            case Y: {
              var M = f.type;
              if (ml(M))
                return f.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          f = f.return;
        } while (f !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var Tc = 0, Cc = 1, Mr = 0, $i = 1, Br = 2, Fa = 8, _o = 16, rd = Math.clz32 ? Math.clz32 : xf, wh = Math.log, ic = Math.LN2;
    function xf(u) {
      var f = u >>> 0;
      return f === 0 ? 32 : 31 - (wh(f) / ic | 0) | 0;
    }
    var id = 31, sn = 0, kr = 0, Hr = 1, Ho = 2, rl = 4, ac = 8, Pu = 16, Rc = 32, _f = 4194240, sc = 64, hs = 128, Js = 256, km = 512, ep = 1024, Gd = 2048, bh = 4096, Sf = 8192, Ou = 16384, ad = 32768, fu = 65536, wf = 131072, Ac = 262144, Wd = 524288, sd = 1048576, Dc = 2097152, Fl = 130023424, Lc = 4194304, Pc = 8388608, Us = 16777216, Uu = 33554432, So = 67108864, od = Lc, xe = 134217728, oc = 268435455, Ks = 268435456, ka = 536870912, Gn = 1073741824;
    function vr(u) {
      {
        if (u & Hr)
          return "Sync";
        if (u & Ho)
          return "InputContinuousHydration";
        if (u & rl)
          return "InputContinuous";
        if (u & ac)
          return "DefaultHydration";
        if (u & Pu)
          return "Default";
        if (u & Rc)
          return "TransitionHydration";
        if (u & _f)
          return "Transition";
        if (u & Fl)
          return "Retry";
        if (u & xe)
          return "SelectiveHydration";
        if (u & Ks)
          return "IdleHydration";
        if (u & ka)
          return "Idle";
        if (u & Gn)
          return "Offscreen";
      }
    }
    var Vi = -1, si = sc, Wn = Lc;
    function wi(u) {
      switch (lc(u)) {
        case Hr:
          return Hr;
        case Ho:
          return Ho;
        case rl:
          return rl;
        case ac:
          return ac;
        case Pu:
          return Pu;
        case Rc:
          return Rc;
        case sc:
        case hs:
        case Js:
        case km:
        case ep:
        case Gd:
        case bh:
        case Sf:
        case Ou:
        case ad:
        case fu:
        case wf:
        case Ac:
        case Wd:
        case sd:
        case Dc:
          return u & _f;
        case Lc:
        case Pc:
        case Us:
        case Uu:
        case So:
          return u & Fl;
        case xe:
          return xe;
        case Ks:
          return Ks;
        case ka:
          return ka;
        case Gn:
          return Gn;
        default:
          return g("Should have found matching lanes. This is a bug in React."), u;
      }
    }
    function zi(u, f) {
      var M = u.pendingLanes;
      if (M === sn)
        return sn;
      var A = sn, z = u.suspendedLanes, W = u.pingedLanes, ee = M & oc;
      if (ee !== sn) {
        var ae = ee & ~z;
        if (ae !== sn)
          A = wi(ae);
        else {
          var _e = ee & W;
          _e !== sn && (A = wi(_e));
        }
      } else {
        var Ue = M & ~z;
        Ue !== sn ? A = wi(Ue) : W !== sn && (A = wi(W));
      }
      if (A === sn)
        return sn;
      if (f !== sn && f !== A && (f & z) === sn) {
        var We = lc(A), St = lc(f);
        if (We >= St || We === Pu && (St & _f) !== sn)
          return f;
      }
      (A & rl) !== sn && (A |= M & Pu);
      var It = u.entangledLanes;
      if (It !== sn)
        for (var Yt = u.entanglements, pn = A & It; pn > 0; ) {
          var Sn = ws(pn), Tr = 1 << Sn;
          A |= Yt[Sn], pn &= ~Tr;
        }
      return A;
    }
    function Oc(u, f) {
      for (var M = u.eventTimes, A = Vi; f > 0; ) {
        var z = ws(f), W = 1 << z, ee = M[z];
        ee > A && (A = ee), f &= ~W;
      }
      return A;
    }
    function Rr(u, f) {
      switch (u) {
        case Hr:
        case Ho:
        case rl:
          return f + 250;
        case ac:
        case Pu:
        case Rc:
        case sc:
        case hs:
        case Js:
        case km:
        case ep:
        case Gd:
        case bh:
        case Sf:
        case Ou:
        case ad:
        case fu:
        case wf:
        case Ac:
        case Wd:
        case sd:
        case Dc:
          return f + 5e3;
        case Lc:
        case Pc:
        case Us:
        case Uu:
        case So:
          return Vi;
        case xe:
        case Ks:
        case ka:
        case Gn:
          return Vi;
        default:
          return g("Should have found matching lanes. This is a bug in React."), Vi;
      }
    }
    function ps(u, f) {
      for (var M = u.pendingLanes, A = u.suspendedLanes, z = u.pingedLanes, W = u.expirationTimes, ee = M; ee > 0; ) {
        var ae = ws(ee), _e = 1 << ae, Ue = W[ae];
        Ue === Vi ? ((_e & A) === sn || (_e & z) !== sn) && (W[ae] = Rr(_e, f)) : Ue <= f && (u.expiredLanes |= _e), ee &= ~_e;
      }
    }
    function es(u) {
      return wi(u.pendingLanes);
    }
    function kl(u) {
      var f = u.pendingLanes & ~Gn;
      return f !== sn ? f : f & Gn ? Gn : sn;
    }
    function Ia(u) {
      return (u & Hr) !== sn;
    }
    function Il(u) {
      return (u & oc) !== sn;
    }
    function bf(u) {
      return (u & Fl) === u;
    }
    function jd(u) {
      return (u & _f) === u;
    }
    function Vo(u, f) {
      var M = Ho | rl | ac | Pu;
      return (f & M) !== sn;
    }
    function bv(u, f) {
      return (f & u.expiredLanes) !== sn;
    }
    function gl(u) {
      return (u & _f) !== 0;
    }
    function wo() {
      var u = si;
      return si <<= 1, (si & _f) === 0 && (si = sc), u;
    }
    function tp() {
      var u = Wn;
      return Wn <<= 1, (Wn & Fl) === 0 && (Wn = Lc), u;
    }
    function lc(u) {
      return u & -u;
    }
    function du(u) {
      return lc(u);
    }
    function ws(u) {
      return 31 - rd(u);
    }
    function Uc(u) {
      return ws(u);
    }
    function Vr(u, f) {
      return (u & f) !== sn;
    }
    function uc(u, f) {
      return (u & f) === f;
    }
    function Ur(u, f) {
      return u | f;
    }
    function $s(u, f) {
      return u & ~f;
    }
    function ms(u, f) {
      return u & f;
    }
    function zc(u) {
      return u;
    }
    function vn(u, f) {
      return u !== kr && u < f ? u : f;
    }
    function Bl(u) {
      for (var f = [], M = 0; M < id; M++)
        f.push(u);
      return f;
    }
    function bo(u, f, M) {
      u.pendingLanes |= f, f !== ka && (u.suspendedLanes = sn, u.pingedLanes = sn);
      var A = u.eventTimes, z = Uc(f);
      A[z] = M;
    }
    function Im(u, f) {
      u.suspendedLanes |= f, u.pingedLanes &= ~f;
      for (var M = u.expirationTimes, A = f; A > 0; ) {
        var z = ws(A), W = 1 << z;
        M[z] = Vi, A &= ~W;
      }
    }
    function Eh(u, f, M) {
      u.pingedLanes |= u.suspendedLanes & f;
    }
    function zu(u, f) {
      var M = u.pendingLanes & ~f;
      u.pendingLanes = f, u.suspendedLanes = 0, u.pingedLanes = 0, u.expiredLanes &= f, u.mutableReadLanes &= f, u.entangledLanes &= f;
      for (var A = u.entanglements, z = u.eventTimes, W = u.expirationTimes, ee = M; ee > 0; ) {
        var ae = ws(ee), _e = 1 << ae;
        A[ae] = sn, z[ae] = Vi, W[ae] = Vi, ee &= ~_e;
      }
    }
    function bs(u, f) {
      for (var M = u.entangledLanes |= f, A = u.entanglements, z = M; z; ) {
        var W = ws(z), ee = 1 << W;
        ee & f | A[W] & f && (A[W] |= f), z &= ~ee;
      }
    }
    function yl(u, f) {
      var M = lc(f), A;
      switch (M) {
        case rl:
          A = Ho;
          break;
        case Pu:
          A = ac;
          break;
        case sc:
        case hs:
        case Js:
        case km:
        case ep:
        case Gd:
        case bh:
        case Sf:
        case Ou:
        case ad:
        case fu:
        case wf:
        case Ac:
        case Wd:
        case sd:
        case Dc:
        case Lc:
        case Pc:
        case Us:
        case Uu:
        case So:
          A = Rc;
          break;
        case ka:
          A = Ks;
          break;
        default:
          A = kr;
          break;
      }
      return (A & (u.suspendedLanes | f)) !== kr ? kr : A;
    }
    function ga(u, f, M) {
      if (!!ns)
        for (var A = u.pendingUpdatersLaneMap; M > 0; ) {
          var z = Uc(M), W = 1 << z, ee = A[z];
          ee.add(f), M &= ~W;
        }
    }
    function hu(u, f) {
      if (!!ns)
        for (var M = u.pendingUpdatersLaneMap, A = u.memoizedUpdaters; f > 0; ) {
          var z = Uc(f), W = 1 << z, ee = M[z];
          ee.size > 0 && (ee.forEach(function(ae) {
            var _e = ae.alternate;
            (_e === null || !A.has(_e)) && A.add(ae);
          }), ee.clear()), f &= ~W;
        }
    }
    var zs = Hr, ld = rl, Hl = Pu, Go = ka, Yd = kr;
    function il() {
      return Yd;
    }
    function Ns(u) {
      Yd = u;
    }
    function fa(u, f) {
      var M = Yd;
      try {
        return Yd = u, f();
      } finally {
        Yd = M;
      }
    }
    function Nu(u, f) {
      return u !== 0 && u < f ? u : f;
    }
    function Wp(u, f) {
      return u === 0 || u > f ? u : f;
    }
    function pu(u, f) {
      return u !== 0 && u < f;
    }
    function Vl(u) {
      var f = lc(u);
      return pu(zs, f) ? pu(ld, f) ? Il(f) ? Hl : Go : ld : zs;
    }
    var np = i.unstable_scheduleCallback, Ef = i.unstable_cancelCallback, eo = i.unstable_shouldYield, Xd = i.unstable_requestPaint, da = i.unstable_now, Gi = i.unstable_ImmediatePriority, bn = i.unstable_UserBlockingPriority, Qi = i.unstable_NormalPriority, ya = i.unstable_IdlePriority, rp = i.unstable_yieldValue, Wo = i.unstable_setDisableYieldValue, jo = null, ts = null, An = null, xa = !1, ns = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function Mf(u) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var f = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (f.isDisabled)
        return !0;
      if (!f.supportsFiber)
        return g("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        B && (u = w({}, u, {
          getLaneLabelMap: ud,
          injectProfilingHooks: Gl
        })), jo = f.inject(u), ts = f;
      } catch (M) {
        g("React instrumentation encountered an error: %s.", M);
      }
      return !!f.checkDCE;
    }
    function _a(u, f) {
      if (ts && typeof ts.onScheduleFiberRoot == "function")
        try {
          ts.onScheduleFiberRoot(jo, u, f);
        } catch (M) {
          xa || (xa = !0, g("React instrumentation encountered an error: %s", M));
        }
    }
    function Qr(u, f) {
      if (ts && typeof ts.onCommitFiberRoot == "function")
        try {
          var M = (u.current.flags & Bn) === Bn;
          if (Q) {
            var A;
            switch (f) {
              case zs:
                A = Gi;
                break;
              case ld:
                A = bn;
                break;
              case Hl:
                A = Qi;
                break;
              case Go:
                A = ya;
                break;
              default:
                A = Qi;
                break;
            }
            ts.onCommitFiberRoot(jo, u, A, M);
          }
        } catch (z) {
          xa || (xa = !0, g("React instrumentation encountered an error: %s", z));
        }
    }
    function Ra(u) {
      if (ts && typeof ts.onPostCommitFiberRoot == "function")
        try {
          ts.onPostCommitFiberRoot(jo, u);
        } catch (f) {
          xa || (xa = !0, g("React instrumentation encountered an error: %s", f));
        }
    }
    function Ba(u) {
      if (ts && typeof ts.onCommitFiberUnmount == "function")
        try {
          ts.onCommitFiberUnmount(jo, u);
        } catch (f) {
          xa || (xa = !0, g("React instrumentation encountered an error: %s", f));
        }
    }
    function li(u) {
      if (typeof rp == "function" && (Wo(u), d(u)), ts && typeof ts.setStrictMode == "function")
        try {
          ts.setStrictMode(jo, u);
        } catch (f) {
          xa || (xa = !0, g("React instrumentation encountered an error: %s", f));
        }
    }
    function Gl(u) {
      An = u;
    }
    function ud() {
      {
        for (var u = /* @__PURE__ */ new Map(), f = 1, M = 0; M < id; M++) {
          var A = vr(f);
          u.set(f, A), f *= 2;
        }
        return u;
      }
    }
    function Es(u) {
      An !== null && typeof An.markCommitStarted == "function" && An.markCommitStarted(u);
    }
    function qd() {
      An !== null && typeof An.markCommitStopped == "function" && An.markCommitStopped();
    }
    function Nc(u) {
      An !== null && typeof An.markComponentRenderStarted == "function" && An.markComponentRenderStarted(u);
    }
    function cc() {
      An !== null && typeof An.markComponentRenderStopped == "function" && An.markComponentRenderStopped();
    }
    function Qd(u) {
      An !== null && typeof An.markComponentPassiveEffectMountStarted == "function" && An.markComponentPassiveEffectMountStarted(u);
    }
    function cd() {
      An !== null && typeof An.markComponentPassiveEffectMountStopped == "function" && An.markComponentPassiveEffectMountStopped();
    }
    function al(u) {
      An !== null && typeof An.markComponentPassiveEffectUnmountStarted == "function" && An.markComponentPassiveEffectUnmountStarted(u);
    }
    function Bm() {
      An !== null && typeof An.markComponentPassiveEffectUnmountStopped == "function" && An.markComponentPassiveEffectUnmountStopped();
    }
    function Tf(u) {
      An !== null && typeof An.markComponentLayoutEffectMountStarted == "function" && An.markComponentLayoutEffectMountStarted(u);
    }
    function Zd() {
      An !== null && typeof An.markComponentLayoutEffectMountStopped == "function" && An.markComponentLayoutEffectMountStopped();
    }
    function Cf(u) {
      An !== null && typeof An.markComponentLayoutEffectUnmountStarted == "function" && An.markComponentLayoutEffectUnmountStarted(u);
    }
    function Wl() {
      An !== null && typeof An.markComponentLayoutEffectUnmountStopped == "function" && An.markComponentLayoutEffectUnmountStopped();
    }
    function jl(u, f, M) {
      An !== null && typeof An.markComponentErrored == "function" && An.markComponentErrored(u, f, M);
    }
    function fd(u, f, M) {
      An !== null && typeof An.markComponentSuspended == "function" && An.markComponentSuspended(u, f, M);
    }
    function Yl(u) {
      An !== null && typeof An.markLayoutEffectsStarted == "function" && An.markLayoutEffectsStarted(u);
    }
    function Mh() {
      An !== null && typeof An.markLayoutEffectsStopped == "function" && An.markLayoutEffectsStopped();
    }
    function fc(u) {
      An !== null && typeof An.markPassiveEffectsStarted == "function" && An.markPassiveEffectsStarted(u);
    }
    function hr() {
      An !== null && typeof An.markPassiveEffectsStopped == "function" && An.markPassiveEffectsStopped();
    }
    function Gr(u) {
      An !== null && typeof An.markRenderStarted == "function" && An.markRenderStarted(u);
    }
    function fr() {
      An !== null && typeof An.markRenderYielded == "function" && An.markRenderYielded();
    }
    function ui() {
      An !== null && typeof An.markRenderStopped == "function" && An.markRenderStopped();
    }
    function Fs(u) {
      An !== null && typeof An.markRenderScheduled == "function" && An.markRenderScheduled(u);
    }
    function Xl(u, f) {
      An !== null && typeof An.markForceUpdateScheduled == "function" && An.markForceUpdateScheduled(u, f);
    }
    function Fc(u, f) {
      An !== null && typeof An.markStateUpdateScheduled == "function" && An.markStateUpdateScheduled(u, f);
    }
    function _r(u, f) {
      return u === f && (u !== 0 || 1 / u === 1 / f) || u !== u && f !== f;
    }
    var Eo = typeof Object.is == "function" ? Object.is : _r, Ai = null, Ht = !1, pi = !1;
    function lr(u) {
      Ai === null ? Ai = [u] : Ai.push(u);
    }
    function kc(u) {
      Ht = !0, lr(u);
    }
    function Ha() {
      Ht && Yo();
    }
    function Yo() {
      if (!pi && Ai !== null) {
        pi = !0;
        var u = 0, f = il();
        try {
          var M = !0, A = Ai;
          for (Ns(zs); u < A.length; u++) {
            var z = A[u];
            do
              z = z(M);
            while (z !== null);
          }
          Ai = null, Ht = !1;
        } catch (W) {
          throw Ai !== null && (Ai = Ai.slice(u + 1)), np(Gi, Yo), W;
        } finally {
          Ns(f), pi = !1;
        }
      }
      return null;
    }
    function Di(u) {
      var f = u.current.memoizedState;
      return f.isDehydrated;
    }
    var Rf = s.ReactCurrentBatchConfig, Af = null;
    function Df() {
      return Rf.transition;
    }
    function aa(u, f) {
      if (Eo(u, f))
        return !0;
      if (typeof u != "object" || u === null || typeof f != "object" || f === null)
        return !1;
      var M = Object.keys(u), A = Object.keys(f);
      if (M.length !== A.length)
        return !1;
      for (var z = 0; z < M.length; z++) {
        var W = M[z];
        if (!rc.call(f, W) || !Eo(u[W], f[W]))
          return !1;
      }
      return !0;
    }
    function ks(u) {
      switch (u._debugOwner && u._debugOwner.type, u._debugSource, u.tag) {
        case ue:
          return Ss(u.type);
        case Ve:
          return Ss("Lazy");
        case he:
          return Ss("Suspense");
        case Ne:
          return Ss("SuspenseList");
        case te:
        case re:
        case Ee:
          return Na(u.type);
        case ve:
          return Na(u.type.render);
        case Y:
          return nc(u.type);
        default:
          return "";
      }
    }
    function Lf(u) {
      try {
        var f = "", M = u;
        do
          f += ks(M), M = M.return;
        while (M);
        return f;
      } catch (A) {
        return `
Error generating stack: ` + A.message + `
` + A.stack;
      }
    }
    var Jd = s.ReactDebugCurrentFrame, to = null, ql = !1;
    function ip() {
      {
        if (to === null)
          return null;
        var u = to._debugOwner;
        if (u !== null && typeof u < "u")
          return wt(u);
      }
      return null;
    }
    function Ic() {
      return to === null ? "" : Lf(to);
    }
    function Ms() {
      Jd.getCurrentStack = null, to = null, ql = !1;
    }
    function bi(u) {
      Jd.getCurrentStack = Ic, to = u, ql = !1;
    }
    function no(u) {
      ql = u;
    }
    var Ql = {
      recordUnsafeLifecycleWarnings: function(u, f) {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function(u, f) {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    };
    {
      var Bc = function(u) {
        for (var f = null, M = u; M !== null; )
          M.mode & Fa && (f = M), M = M.return;
        return f;
      }, mu = function(u) {
        var f = [];
        return u.forEach(function(M) {
          f.push(M);
        }), f.sort().join(", ");
      }, Pf = [], vu = [], Fu = [], Mo = [], Hc = [], dd = [], Xo = /* @__PURE__ */ new Set();
      Ql.recordUnsafeLifecycleWarnings = function(u, f) {
        Xo.has(u.type) || (typeof f.componentWillMount == "function" && f.componentWillMount.__suppressDeprecationWarning !== !0 && Pf.push(u), u.mode & Fa && typeof f.UNSAFE_componentWillMount == "function" && vu.push(u), typeof f.componentWillReceiveProps == "function" && f.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && Fu.push(u), u.mode & Fa && typeof f.UNSAFE_componentWillReceiveProps == "function" && Mo.push(u), typeof f.componentWillUpdate == "function" && f.componentWillUpdate.__suppressDeprecationWarning !== !0 && Hc.push(u), u.mode & Fa && typeof f.UNSAFE_componentWillUpdate == "function" && dd.push(u));
      }, Ql.flushPendingUnsafeLifecycleWarnings = function() {
        var u = /* @__PURE__ */ new Set();
        Pf.length > 0 && (Pf.forEach(function(It) {
          u.add(wt(It) || "Component"), Xo.add(It.type);
        }), Pf = []);
        var f = /* @__PURE__ */ new Set();
        vu.length > 0 && (vu.forEach(function(It) {
          f.add(wt(It) || "Component"), Xo.add(It.type);
        }), vu = []);
        var M = /* @__PURE__ */ new Set();
        Fu.length > 0 && (Fu.forEach(function(It) {
          M.add(wt(It) || "Component"), Xo.add(It.type);
        }), Fu = []);
        var A = /* @__PURE__ */ new Set();
        Mo.length > 0 && (Mo.forEach(function(It) {
          A.add(wt(It) || "Component"), Xo.add(It.type);
        }), Mo = []);
        var z = /* @__PURE__ */ new Set();
        Hc.length > 0 && (Hc.forEach(function(It) {
          z.add(wt(It) || "Component"), Xo.add(It.type);
        }), Hc = []);
        var W = /* @__PURE__ */ new Set();
        if (dd.length > 0 && (dd.forEach(function(It) {
          W.add(wt(It) || "Component"), Xo.add(It.type);
        }), dd = []), f.size > 0) {
          var ee = mu(f);
          g(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, ee);
        }
        if (A.size > 0) {
          var ae = mu(A);
          g(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, ae);
        }
        if (W.size > 0) {
          var _e = mu(W);
          g(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, _e);
        }
        if (u.size > 0) {
          var Ue = mu(u);
          p(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, Ue);
        }
        if (M.size > 0) {
          var We = mu(M);
          p(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, We);
        }
        if (z.size > 0) {
          var St = mu(z);
          p(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, St);
        }
      };
      var hd = /* @__PURE__ */ new Map(), gu = /* @__PURE__ */ new Set();
      Ql.recordLegacyContextWarning = function(u, f) {
        var M = Bc(u);
        if (M === null) {
          g("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!gu.has(u.type)) {
          var A = hd.get(M);
          (u.type.contextTypes != null || u.type.childContextTypes != null || f !== null && typeof f.getChildContext == "function") && (A === void 0 && (A = [], hd.set(M, A)), A.push(u));
        }
      }, Ql.flushLegacyContextWarning = function() {
        hd.forEach(function(u, f) {
          if (u.length !== 0) {
            var M = u[0], A = /* @__PURE__ */ new Set();
            u.forEach(function(W) {
              A.add(wt(W) || "Component"), gu.add(W.type);
            });
            var z = mu(A);
            try {
              bi(M), g(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, z);
            } finally {
              Ms();
            }
          }
        });
      }, Ql.discardPendingWarnings = function() {
        Pf = [], vu = [], Fu = [], Mo = [], Hc = [], dd = [], hd = /* @__PURE__ */ new Map();
      };
    }
    function pd(u) {
      {
        var f = typeof Symbol == "function" && Symbol.toStringTag, M = f && u[Symbol.toStringTag] || u.constructor.name || "Object";
        return M;
      }
    }
    function Ts(u) {
      try {
        return Is(u), !1;
      } catch {
        return !0;
      }
    }
    function Is(u) {
      return "" + u;
    }
    function yu(u) {
      if (Ts(u))
        return g("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", pd(u)), Is(u);
    }
    function mg(u, f) {
      if (Ts(u))
        return g("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", f, pd(u)), Is(u);
    }
    function ti(u, f) {
      if (u && u.defaultProps) {
        var M = w({}, f), A = u.defaultProps;
        for (var z in A)
          M[z] === void 0 && (M[z] = A[z]);
        return M;
      }
      return f;
    }
    var ku = Mn(null), Of;
    Of = {};
    var dc = null, Uf = null, jp = null, y = !1;
    function x() {
      dc = null, Uf = null, jp = null, y = !1;
    }
    function L() {
      y = !0;
    }
    function k() {
      y = !1;
    }
    function X(u, f, M) {
      go ? (or(ku, f._currentValue, u), f._currentValue = M, f._currentRenderer !== void 0 && f._currentRenderer !== null && f._currentRenderer !== Of && g("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), f._currentRenderer = Of) : (or(ku, f._currentValue2, u), f._currentValue2 = M, f._currentRenderer2 !== void 0 && f._currentRenderer2 !== null && f._currentRenderer2 !== Of && g("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), f._currentRenderer2 = Of);
    }
    function $(u, f) {
      var M = ku.current;
      $n(ku, f), go ? u._currentValue = M : u._currentValue2 = M;
    }
    function Ae(u, f, M) {
      for (var A = u; A !== null; ) {
        var z = A.alternate;
        if (uc(A.childLanes, f) ? z !== null && !uc(z.childLanes, f) && (z.childLanes = Ur(z.childLanes, f)) : (A.childLanes = Ur(A.childLanes, f), z !== null && (z.childLanes = Ur(z.childLanes, f))), A === M)
          break;
        A = A.return;
      }
      A !== M && g("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function $e(u, f, M) {
      kt(u, f, M);
    }
    function kt(u, f, M) {
      var A = u.child;
      for (A !== null && (A.return = u); A !== null; ) {
        var z = void 0, W = A.dependencies;
        if (W !== null) {
          z = A.child;
          for (var ee = W.firstContext; ee !== null; ) {
            if (ee.context === f) {
              if (A.tag === Y) {
                var ae = du(M), _e = Er(Vi, ae);
                _e.tag = vs;
                var Ue = A.updateQueue;
                if (Ue !== null) {
                  var We = Ue.shared, St = We.pending;
                  St === null ? _e.next = _e : (_e.next = St.next, St.next = _e), We.pending = _e;
                }
              }
              A.lanes = Ur(A.lanes, M);
              var It = A.alternate;
              It !== null && (It.lanes = Ur(It.lanes, M)), Ae(A.return, M, u), W.lanes = Ur(W.lanes, M);
              break;
            }
            ee = ee.next;
          }
        } else if (A.tag === He)
          z = A.type === u.type ? null : A.child;
        else if (A.tag === rt) {
          var Yt = A.return;
          if (Yt === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          Yt.lanes = Ur(Yt.lanes, M);
          var pn = Yt.alternate;
          pn !== null && (pn.lanes = Ur(pn.lanes, M)), Ae(Yt, M, u), z = A.sibling;
        } else
          z = A.child;
        if (z !== null)
          z.return = A;
        else
          for (z = A; z !== null; ) {
            if (z === u) {
              z = null;
              break;
            }
            var Sn = z.sibling;
            if (Sn !== null) {
              Sn.return = z.return, z = Sn;
              break;
            }
            z = z.return;
          }
        A = z;
      }
    }
    function hn(u, f) {
      dc = u, Uf = null, jp = null;
      var M = u.dependencies;
      if (M !== null) {
        var A = M.firstContext;
        A !== null && (Vr(M.lanes, f) && sx(), M.firstContext = null);
      }
    }
    function wn(u) {
      y && g("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var f = go ? u._currentValue : u._currentValue2;
      if (jp !== u) {
        var M = {
          context: u,
          memoizedValue: f,
          next: null
        };
        if (Uf === null) {
          if (dc === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          Uf = M, dc.dependencies = {
            lanes: sn,
            firstContext: M
          };
        } else
          Uf = Uf.next = M;
      }
      return f;
    }
    var br = null;
    function ur(u) {
      br === null ? br = [u] : br.push(u);
    }
    function Sa() {
      if (br !== null) {
        for (var u = 0; u < br.length; u++) {
          var f = br[u], M = f.interleaved;
          if (M !== null) {
            f.interleaved = null;
            var A = M.next, z = f.pending;
            if (z !== null) {
              var W = z.next;
              z.next = A, M.next = W;
            }
            f.pending = M;
          }
        }
        br = null;
      }
    }
    var Tn = 0, Li = 1, vs = 2, pt = 3, Ze = !1, Lt, Qt;
    Lt = !1, Qt = null;
    function jn(u) {
      var f = {
        baseState: u.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          interleaved: null,
          lanes: sn
        },
        effects: null
      };
      u.updateQueue = f;
    }
    function Wr(u, f) {
      var M = f.updateQueue, A = u.updateQueue;
      if (M === A) {
        var z = {
          baseState: A.baseState,
          firstBaseUpdate: A.firstBaseUpdate,
          lastBaseUpdate: A.lastBaseUpdate,
          shared: A.shared,
          effects: A.effects
        };
        f.updateQueue = z;
      }
    }
    function Er(u, f) {
      var M = {
        eventTime: u,
        lane: f,
        tag: Tn,
        payload: null,
        callback: null,
        next: null
      };
      return M;
    }
    function Ar(u, f, M) {
      var A = u.updateQueue;
      if (A !== null) {
        var z = A.shared;
        if (HS(u)) {
          var W = z.interleaved;
          W === null ? (f.next = f, ur(z)) : (f.next = W.next, W.next = f), z.interleaved = f;
        } else {
          var ee = z.pending;
          ee === null ? f.next = f : (f.next = ee.next, ee.next = f), z.pending = f;
        }
        Qt === z && !Lt && (g("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), Lt = !0);
      }
    }
    function Va(u, f, M) {
      var A = f.updateQueue;
      if (A !== null) {
        var z = A.shared;
        if (gl(M)) {
          var W = z.lanes;
          W = ms(W, u.pendingLanes);
          var ee = Ur(W, M);
          z.lanes = ee, bs(u, ee);
        }
      }
    }
    function Zr(u, f) {
      var M = u.updateQueue, A = u.alternate;
      if (A !== null) {
        var z = A.updateQueue;
        if (M === z) {
          var W = null, ee = null, ae = M.firstBaseUpdate;
          if (ae !== null) {
            var _e = ae;
            do {
              var Ue = {
                eventTime: _e.eventTime,
                lane: _e.lane,
                tag: _e.tag,
                payload: _e.payload,
                callback: _e.callback,
                next: null
              };
              ee === null ? W = ee = Ue : (ee.next = Ue, ee = Ue), _e = _e.next;
            } while (_e !== null);
            ee === null ? W = ee = f : (ee.next = f, ee = f);
          } else
            W = ee = f;
          M = {
            baseState: z.baseState,
            firstBaseUpdate: W,
            lastBaseUpdate: ee,
            shared: z.shared,
            effects: z.effects
          }, u.updateQueue = M;
          return;
        }
      }
      var We = M.lastBaseUpdate;
      We === null ? M.firstBaseUpdate = f : We.next = f, M.lastBaseUpdate = f;
    }
    function hc(u, f, M, A, z, W) {
      switch (M.tag) {
        case Li: {
          var ee = M.payload;
          if (typeof ee == "function") {
            L();
            var ae = ee.call(W, A, z);
            {
              if (u.mode & Fa) {
                li(!0);
                try {
                  ee.call(W, A, z);
                } finally {
                  li(!1);
                }
              }
              k();
            }
            return ae;
          }
          return ee;
        }
        case pt:
          u.flags = u.flags & ~Ye | Bn;
        case Tn: {
          var _e = M.payload, Ue;
          if (typeof _e == "function") {
            L(), Ue = _e.call(W, A, z);
            {
              if (u.mode & Fa) {
                li(!0);
                try {
                  _e.call(W, A, z);
                } finally {
                  li(!1);
                }
              }
              k();
            }
          } else
            Ue = _e;
          return Ue == null ? A : w({}, A, Ue);
        }
        case vs:
          return Ze = !0, A;
      }
      return A;
    }
    function md(u, f, M, A) {
      var z = u.updateQueue;
      Ze = !1, Qt = z.shared;
      var W = z.firstBaseUpdate, ee = z.lastBaseUpdate, ae = z.shared.pending;
      if (ae !== null) {
        z.shared.pending = null;
        var _e = ae, Ue = _e.next;
        _e.next = null, ee === null ? W = Ue : ee.next = Ue, ee = _e;
        var We = u.alternate;
        if (We !== null) {
          var St = We.updateQueue, It = St.lastBaseUpdate;
          It !== ee && (It === null ? St.firstBaseUpdate = Ue : It.next = Ue, St.lastBaseUpdate = _e);
        }
      }
      if (W !== null) {
        var Yt = z.baseState, pn = sn, Sn = null, Tr = null, vi = null, Pr = W;
        do {
          var lo = Pr.lane, uo = Pr.eventTime;
          if (uc(A, lo)) {
            if (vi !== null) {
              var Jt = {
                eventTime: uo,
                lane: kr,
                tag: Pr.tag,
                payload: Pr.payload,
                callback: Pr.callback,
                next: null
              };
              vi = vi.next = Jt;
            }
            Yt = hc(u, z, Pr, Yt, f, M);
            var Mt = Pr.callback;
            if (Mt !== null && Pr.lane !== kr) {
              u.flags |= Ir;
              var En = z.effects;
              En === null ? z.effects = [Pr] : En.push(Pr);
            }
          } else {
            var Ct = {
              eventTime: uo,
              lane: lo,
              tag: Pr.tag,
              payload: Pr.payload,
              callback: Pr.callback,
              next: null
            };
            vi === null ? (Tr = vi = Ct, Sn = Yt) : vi = vi.next = Ct, pn = Ur(pn, lo);
          }
          if (Pr = Pr.next, Pr === null) {
            if (ae = z.shared.pending, ae === null)
              break;
            var yr = ae, Nn = yr.next;
            yr.next = null, Pr = Nn, z.lastBaseUpdate = yr, z.shared.pending = null;
          }
        } while (!0);
        vi === null && (Sn = Yt), z.baseState = Sn, z.firstBaseUpdate = Tr, z.lastBaseUpdate = vi;
        var ni = z.shared.interleaved;
        if (ni !== null) {
          var wa = ni;
          do
            pn = Ur(pn, wa.lane), wa = wa.next;
          while (wa !== ni);
        } else
          W === null && (z.shared.lanes = sn);
        gx(pn), u.lanes = pn, u.memoizedState = Yt;
      }
      Qt = null;
    }
    function ap(u, f) {
      if (typeof u != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + u));
      u.call(f);
    }
    function gr() {
      Ze = !1;
    }
    function Yp() {
      return Ze;
    }
    function Hm(u, f, M) {
      var A = f.effects;
      if (f.effects = null, A !== null)
        for (var z = 0; z < A.length; z++) {
          var W = A[z], ee = W.callback;
          ee !== null && (W.callback = null, ap(ee, M));
        }
    }
    var zf = {}, vg = new r.Component().refs, qo, Qo, rs, Xp, Th, pc, ro, sp, xl, _y;
    {
      qo = /* @__PURE__ */ new Set(), Qo = /* @__PURE__ */ new Set(), rs = /* @__PURE__ */ new Set(), Xp = /* @__PURE__ */ new Set(), sp = /* @__PURE__ */ new Set(), Th = /* @__PURE__ */ new Set(), xl = /* @__PURE__ */ new Set(), _y = /* @__PURE__ */ new Set();
      var gg = /* @__PURE__ */ new Set();
      ro = function(u, f) {
        if (!(u === null || typeof u == "function")) {
          var M = f + "_" + u;
          gg.has(M) || (gg.add(M), g("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", f, u));
        }
      }, pc = function(u, f) {
        if (f === void 0) {
          var M = st(u) || "Component";
          Th.has(M) || (Th.add(M), g("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", M));
        }
      }, Object.defineProperty(zf, "_processChildContext", {
        enumerable: !1,
        value: function() {
          throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
      }), Object.freeze(zf);
    }
    function Iu(u, f, M, A) {
      var z = u.memoizedState, W = M(A, z);
      {
        if (u.mode & Fa) {
          li(!0);
          try {
            W = M(A, z);
          } finally {
            li(!1);
          }
        }
        pc(f, W);
      }
      var ee = W == null ? z : w({}, z, W);
      if (u.memoizedState = ee, u.lanes === sn) {
        var ae = u.updateQueue;
        ae.baseState = ee;
      }
    }
    var Wi = {
      isMounted: qa,
      enqueueSetState: function(u, f, M) {
        var A = T(u), z = yc(), W = Xv(A), ee = Er(z, W);
        ee.payload = f, M != null && (ro(M, "setState"), ee.callback = M), Ar(A, ee);
        var ae = Tl(A, W, z);
        ae !== null && Va(ae, A, W), Fc(A, W);
      },
      enqueueReplaceState: function(u, f, M) {
        var A = T(u), z = yc(), W = Xv(A), ee = Er(z, W);
        ee.tag = Li, ee.payload = f, M != null && (ro(M, "replaceState"), ee.callback = M), Ar(A, ee);
        var ae = Tl(A, W, z);
        ae !== null && Va(ae, A, W), Fc(A, W);
      },
      enqueueForceUpdate: function(u, f) {
        var M = T(u), A = yc(), z = Xv(M), W = Er(A, z);
        W.tag = vs, f != null && (ro(f, "forceUpdate"), W.callback = f), Ar(M, W);
        var ee = Tl(M, z, A);
        ee !== null && Va(ee, M, z), Xl(M, z);
      }
    };
    function Ev(u, f, M, A, z, W, ee) {
      var ae = u.stateNode;
      if (typeof ae.shouldComponentUpdate == "function") {
        var _e = ae.shouldComponentUpdate(A, W, ee);
        {
          if (u.mode & Fa) {
            li(!0);
            try {
              _e = ae.shouldComponentUpdate(A, W, ee);
            } finally {
              li(!1);
            }
          }
          _e === void 0 && g("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", st(f) || "Component");
        }
        return _e;
      }
      return f.prototype && f.prototype.isPureReactComponent ? !aa(M, A) || !aa(z, W) : !0;
    }
    function Kn(u, f, M) {
      var A = u.stateNode;
      {
        var z = st(f) || "Component", W = A.render;
        W || (f.prototype && typeof f.prototype.render == "function" ? g("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", z) : g("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", z)), A.getInitialState && !A.getInitialState.isReactClassApproved && !A.state && g("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", z), A.getDefaultProps && !A.getDefaultProps.isReactClassApproved && g("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", z), A.propTypes && g("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", z), A.contextType && g("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", z), A.contextTypes && g("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", z), f.contextType && f.contextTypes && !xl.has(f) && (xl.add(f), g("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", z)), typeof A.componentShouldUpdate == "function" && g("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", z), f.prototype && f.prototype.isPureReactComponent && typeof A.shouldComponentUpdate < "u" && g("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", st(f) || "A pure component"), typeof A.componentDidUnmount == "function" && g("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", z), typeof A.componentDidReceiveProps == "function" && g("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", z), typeof A.componentWillRecieveProps == "function" && g("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", z), typeof A.UNSAFE_componentWillRecieveProps == "function" && g("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", z);
        var ee = A.props !== M;
        A.props !== void 0 && ee && g("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", z, z), A.defaultProps && g("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", z, z), typeof A.getSnapshotBeforeUpdate == "function" && typeof A.componentDidUpdate != "function" && !rs.has(f) && (rs.add(f), g("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", st(f))), typeof A.getDerivedStateFromProps == "function" && g("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", z), typeof A.getDerivedStateFromError == "function" && g("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", z), typeof f.getSnapshotBeforeUpdate == "function" && g("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", z);
        var ae = A.state;
        ae && (typeof ae != "object" || Ti(ae)) && g("%s.state: must be set to an object or null", z), typeof A.getChildContext == "function" && typeof f.childContextTypes != "object" && g("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", z);
      }
    }
    function Ch(u, f) {
      f.updater = Wi, u.stateNode = f, R(f, u), f._reactInternalInstance = zf;
    }
    function Vm(u, f, M) {
      var A = !1, z = er, W = er, ee = f.contextType;
      if ("contextType" in f) {
        var ae = ee === null || ee !== void 0 && ee.$$typeof === yt && ee._context === void 0;
        if (!ae && !_y.has(f)) {
          _y.add(f);
          var _e = "";
          ee === void 0 ? _e = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof ee != "object" ? _e = " However, it is set to a " + typeof ee + "." : ee.$$typeof === Vt ? _e = " Did you accidentally pass the Context.Provider instead?" : ee._context !== void 0 ? _e = " Did you accidentally pass the Context.Consumer instead?" : _e = " However, it is set to an object with keys {" + Object.keys(ee).join(", ") + "}.", g("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", st(f) || "Component", _e);
        }
      }
      if (typeof ee == "object" && ee !== null)
        W = wn(ee);
      else {
        z = ds(u, f, !0);
        var Ue = f.contextTypes;
        A = Ue != null, W = A ? Nl(u, z) : er;
      }
      var We = new f(M, W);
      if (u.mode & Fa) {
        li(!0);
        try {
          We = new f(M, W);
        } finally {
          li(!1);
        }
      }
      var St = u.memoizedState = We.state !== null && We.state !== void 0 ? We.state : null;
      Ch(u, We);
      {
        if (typeof f.getDerivedStateFromProps == "function" && St === null) {
          var It = st(f) || "Component";
          Qo.has(It) || (Qo.add(It), g("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", It, We.state === null ? "null" : "undefined", It));
        }
        if (typeof f.getDerivedStateFromProps == "function" || typeof We.getSnapshotBeforeUpdate == "function") {
          var Yt = null, pn = null, Sn = null;
          if (typeof We.componentWillMount == "function" && We.componentWillMount.__suppressDeprecationWarning !== !0 ? Yt = "componentWillMount" : typeof We.UNSAFE_componentWillMount == "function" && (Yt = "UNSAFE_componentWillMount"), typeof We.componentWillReceiveProps == "function" && We.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? pn = "componentWillReceiveProps" : typeof We.UNSAFE_componentWillReceiveProps == "function" && (pn = "UNSAFE_componentWillReceiveProps"), typeof We.componentWillUpdate == "function" && We.componentWillUpdate.__suppressDeprecationWarning !== !0 ? Sn = "componentWillUpdate" : typeof We.UNSAFE_componentWillUpdate == "function" && (Sn = "UNSAFE_componentWillUpdate"), Yt !== null || pn !== null || Sn !== null) {
            var Tr = st(f) || "Component", vi = typeof f.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            Xp.has(Tr) || (Xp.add(Tr), g(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, Tr, vi, Yt !== null ? `
  ` + Yt : "", pn !== null ? `
  ` + pn : "", Sn !== null ? `
  ` + Sn : ""));
          }
        }
      }
      return A && Vd(u, z, W), We;
    }
    function z0(u, f) {
      var M = f.state;
      typeof f.componentWillMount == "function" && f.componentWillMount(), typeof f.UNSAFE_componentWillMount == "function" && f.UNSAFE_componentWillMount(), M !== f.state && (g("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", wt(u) || "Component"), Wi.enqueueReplaceState(f, f.state, null));
    }
    function qp(u, f, M, A) {
      var z = f.state;
      if (typeof f.componentWillReceiveProps == "function" && f.componentWillReceiveProps(M, A), typeof f.UNSAFE_componentWillReceiveProps == "function" && f.UNSAFE_componentWillReceiveProps(M, A), f.state !== z) {
        {
          var W = wt(u) || "Component";
          qo.has(W) || (qo.add(W), g("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", W));
        }
        Wi.enqueueReplaceState(f, f.state, null);
      }
    }
    function op(u, f, M, A) {
      Kn(u, f, M);
      var z = u.stateNode;
      z.props = M, z.state = u.memoizedState, z.refs = vg, jn(u);
      var W = f.contextType;
      if (typeof W == "object" && W !== null)
        z.context = wn(W);
      else {
        var ee = ds(u, f, !0);
        z.context = Nl(u, ee);
      }
      {
        if (z.state === M) {
          var ae = st(f) || "Component";
          sp.has(ae) || (sp.add(ae), g("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", ae));
        }
        u.mode & Fa && Ql.recordLegacyContextWarning(u, z), Ql.recordUnsafeLifecycleWarnings(u, z);
      }
      z.state = u.memoizedState;
      var _e = f.getDerivedStateFromProps;
      if (typeof _e == "function" && (Iu(u, f, _e, M), z.state = u.memoizedState), typeof f.getDerivedStateFromProps != "function" && typeof z.getSnapshotBeforeUpdate != "function" && (typeof z.UNSAFE_componentWillMount == "function" || typeof z.componentWillMount == "function") && (z0(u, z), md(u, M, z, A), z.state = u.memoizedState), typeof z.componentDidMount == "function") {
        var Ue = cn;
        Ue |= gn, (u.mode & _o) !== Mr && (Ue |= Jn), u.flags |= Ue;
      }
    }
    function Gm(u, f, M, A) {
      var z = u.stateNode, W = u.memoizedProps;
      z.props = W;
      var ee = z.context, ae = f.contextType, _e = er;
      if (typeof ae == "object" && ae !== null)
        _e = wn(ae);
      else {
        var Ue = ds(u, f, !0);
        _e = Nl(u, Ue);
      }
      var We = f.getDerivedStateFromProps, St = typeof We == "function" || typeof z.getSnapshotBeforeUpdate == "function";
      !St && (typeof z.UNSAFE_componentWillReceiveProps == "function" || typeof z.componentWillReceiveProps == "function") && (W !== M || ee !== _e) && qp(u, z, M, _e), gr();
      var It = u.memoizedState, Yt = z.state = It;
      if (md(u, M, z, A), Yt = u.memoizedState, W === M && It === Yt && !$a() && !Yp()) {
        if (typeof z.componentDidMount == "function") {
          var pn = cn;
          pn |= gn, (u.mode & _o) !== Mr && (pn |= Jn), u.flags |= pn;
        }
        return !1;
      }
      typeof We == "function" && (Iu(u, f, We, M), Yt = u.memoizedState);
      var Sn = Yp() || Ev(u, f, W, M, It, Yt, _e);
      if (Sn) {
        if (!St && (typeof z.UNSAFE_componentWillMount == "function" || typeof z.componentWillMount == "function") && (typeof z.componentWillMount == "function" && z.componentWillMount(), typeof z.UNSAFE_componentWillMount == "function" && z.UNSAFE_componentWillMount()), typeof z.componentDidMount == "function") {
          var Tr = cn;
          Tr |= gn, (u.mode & _o) !== Mr && (Tr |= Jn), u.flags |= Tr;
        }
      } else {
        if (typeof z.componentDidMount == "function") {
          var vi = cn;
          vi |= gn, (u.mode & _o) !== Mr && (vi |= Jn), u.flags |= vi;
        }
        u.memoizedProps = M, u.memoizedState = Yt;
      }
      return z.props = M, z.state = Yt, z.context = _e, Sn;
    }
    function Sy(u, f, M, A, z) {
      var W = f.stateNode;
      Wr(u, f);
      var ee = f.memoizedProps, ae = f.type === f.elementType ? ee : ti(f.type, ee);
      W.props = ae;
      var _e = f.pendingProps, Ue = W.context, We = M.contextType, St = er;
      if (typeof We == "object" && We !== null)
        St = wn(We);
      else {
        var It = ds(f, M, !0);
        St = Nl(f, It);
      }
      var Yt = M.getDerivedStateFromProps, pn = typeof Yt == "function" || typeof W.getSnapshotBeforeUpdate == "function";
      !pn && (typeof W.UNSAFE_componentWillReceiveProps == "function" || typeof W.componentWillReceiveProps == "function") && (ee !== _e || Ue !== St) && qp(f, W, A, St), gr();
      var Sn = f.memoizedState, Tr = W.state = Sn;
      if (md(f, A, W, z), Tr = f.memoizedState, ee === _e && Sn === Tr && !$a() && !Yp() && !U)
        return typeof W.componentDidUpdate == "function" && (ee !== u.memoizedProps || Sn !== u.memoizedState) && (f.flags |= cn), typeof W.getSnapshotBeforeUpdate == "function" && (ee !== u.memoizedProps || Sn !== u.memoizedState) && (f.flags |= ii), !1;
      typeof Yt == "function" && (Iu(f, M, Yt, A), Tr = f.memoizedState);
      var vi = Yp() || Ev(f, M, ae, A, Sn, Tr, St) || U;
      return vi ? (!pn && (typeof W.UNSAFE_componentWillUpdate == "function" || typeof W.componentWillUpdate == "function") && (typeof W.componentWillUpdate == "function" && W.componentWillUpdate(A, Tr, St), typeof W.UNSAFE_componentWillUpdate == "function" && W.UNSAFE_componentWillUpdate(A, Tr, St)), typeof W.componentDidUpdate == "function" && (f.flags |= cn), typeof W.getSnapshotBeforeUpdate == "function" && (f.flags |= ii)) : (typeof W.componentDidUpdate == "function" && (ee !== u.memoizedProps || Sn !== u.memoizedState) && (f.flags |= cn), typeof W.getSnapshotBeforeUpdate == "function" && (ee !== u.memoizedProps || Sn !== u.memoizedState) && (f.flags |= ii), f.memoizedProps = A, f.memoizedState = Tr), W.props = A, W.state = Tr, W.context = St, vi;
    }
    var lp = [], Qp = 0, Zp = null, Kd = 0, io = [], ji = 0, is = null, To = 1, _l = "";
    function vd(u) {
      return Rh(), (u.flags & mn) !== Pe;
    }
    function Nf(u) {
      return Rh(), Kd;
    }
    function wy() {
      var u = _l, f = To, M = f & ~by(f);
      return M.toString(32) + u;
    }
    function sl(u, f) {
      Rh(), lp[Qp++] = Kd, lp[Qp++] = Zp, Zp = u, Kd = f;
    }
    function yg(u, f, M) {
      Rh(), io[ji++] = To, io[ji++] = _l, io[ji++] = is, is = u;
      var A = To, z = _l, W = gd(A) - 1, ee = A & ~(1 << W), ae = M + 1, _e = gd(f) + W;
      if (_e > 30) {
        var Ue = W - W % 5, We = (1 << Ue) - 1, St = (ee & We).toString(32), It = ee >> Ue, Yt = W - Ue, pn = gd(f) + Yt, Sn = ae << Yt, Tr = Sn | It, vi = St + z;
        To = 1 << pn | Tr, _l = vi;
      } else {
        var Pr = ae << W, lo = Pr | ee, uo = z;
        To = 1 << _e | lo, _l = uo;
      }
    }
    function Zl(u) {
      Rh();
      var f = u.return;
      if (f !== null) {
        var M = 1, A = 0;
        sl(u, M), yg(u, M, A);
      }
    }
    function gd(u) {
      return 32 - rd(u);
    }
    function by(u) {
      return 1 << gd(u) - 1;
    }
    function Mv(u) {
      for (; u === Zp; )
        Zp = lp[--Qp], lp[Qp] = null, Kd = lp[--Qp], lp[Qp] = null;
      for (; u === is; )
        is = io[--ji], io[ji] = null, _l = io[--ji], io[ji] = null, To = io[--ji], io[ji] = null;
    }
    function xg() {
      return Rh(), is !== null ? {
        id: To,
        overflow: _l
      } : null;
    }
    function Tv(u, f) {
      Rh(), io[ji++] = To, io[ji++] = _l, io[ji++] = is, To = f.id, _l = f.overflow, is = u;
    }
    function Rh() {
      ha() || g("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var sa = null, zr = null, ea = !1, Ga = !1, gs = null;
    function Vc() {
      ea && g("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function Wm() {
      Ga = !0;
    }
    function ol(u) {
      if (!fs)
        return !1;
      var f = u.stateNode.containerInfo;
      return zr = Ku(f), sa = u, ea = !0, gs = null, Ga = !1, !0;
    }
    function jm(u, f, M) {
      return fs ? (zr = Kh(f), sa = u, ea = !0, gs = null, Ga = !1, M !== null && Tv(u, M), !0) : !1;
    }
    function yd(u, f) {
      switch (u.tag) {
        case se:
          Fd(u.stateNode.containerInfo, f);
          break;
        case ue:
          kp(u.type, u.memoizedProps, u.stateNode, f);
          break;
        case he:
          var M = u.memoizedState;
          M.dehydrated !== null && Du(M.dehydrated, f);
          break;
      }
    }
    function Ym(u, f) {
      yd(u, f);
      var M = gE();
      M.stateNode = f, M.return = u;
      var A = u.deletions;
      A === null ? (u.deletions = [M], u.flags |= Or) : A.push(M);
    }
    function up(u, f) {
      {
        if (Ga)
          return;
        switch (u.tag) {
          case se: {
            var M = u.stateNode.containerInfo;
            switch (f.tag) {
              case ue:
                var A = f.type, z = f.pendingProps;
                pl(M, A, z);
                break;
              case Me:
                var W = f.pendingProps;
                tl(M, W);
                break;
              case he:
                vf(M);
                break;
            }
            break;
          }
          case ue: {
            var ee = u.type, ae = u.memoizedProps, _e = u.stateNode;
            switch (f.tag) {
              case ue:
                var Ue = f.type, We = f.pendingProps;
                zl(ee, ae, _e, Ue, We);
                break;
              case Me:
                var St = f.pendingProps;
                ec(ee, ae, _e, St);
                break;
              case he:
                Oi(ee, ae, _e);
                break;
            }
            break;
          }
          case he: {
            var It = u.memoizedState, Yt = It.dehydrated;
            if (Yt !== null)
              switch (f.tag) {
                case ue:
                  var pn = f.type, Sn = f.pendingProps;
                  $f(Yt, pn, Sn);
                  break;
                case Me:
                  var Tr = f.pendingProps;
                  cu(Yt, Tr);
                  break;
                case he:
                  gf(Yt);
                  break;
              }
            break;
          }
          default:
            return;
        }
      }
    }
    function cp(u, f) {
      f.flags = f.flags & ~xi | At, up(u, f);
    }
    function xu(u, f) {
      switch (u.tag) {
        case ue: {
          var M = u.type, A = u.pendingProps, z = za(f, M, A);
          return z !== null ? (u.stateNode = z, sa = u, zr = el(z), !0) : !1;
        }
        case Me: {
          var W = u.pendingProps, ee = Qs(f, W);
          return ee !== null ? (u.stateNode = ee, sa = u, zr = null, !0) : !1;
        }
        case he: {
          {
            var ae = qr(f);
            if (ae !== null) {
              var _e = {
                dehydrated: ae,
                treeContext: xg(),
                retryLane: Gn
              };
              u.memoizedState = _e;
              var Ue = Wa(ae);
              return Ue.return = u, u.child = Ue, sa = u, zr = null, !0;
            }
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function Xm(u) {
      return (u.mode & $i) !== Mr && (u.flags & Bn) === Pe;
    }
    function fp(u) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function xd(u) {
      if (!!ea) {
        var f = zr;
        if (!f) {
          Xm(u) && (up(sa, u), fp()), cp(sa, u), ea = !1, sa = u;
          return;
        }
        var M = f;
        if (!xu(u, f)) {
          Xm(u) && (up(sa, u), fp()), f = Kf(M);
          var A = sa;
          if (!f || !xu(u, f)) {
            cp(sa, u), ea = !1, sa = u;
            return;
          }
          Ym(A, M);
        }
      }
    }
    function _g(u, f, M) {
      if (!fs)
        throw new Error("Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var A = u.stateNode, z = !Ga, W = qi(A, u.type, u.memoizedProps, f, M, u, z);
      return u.updateQueue = W, W !== null;
    }
    function Jp(u) {
      if (!fs)
        throw new Error("Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var f = u.stateNode, M = u.memoizedProps, A = !Ga, z = Au(f, M, u, A);
      if (z) {
        var W = sa;
        if (W !== null) {
          var ee = (W.mode & $i) !== Mr;
          switch (W.tag) {
            case se: {
              var ae = W.stateNode.containerInfo;
              gh(
                ae,
                f,
                M,
                ee
              );
              break;
            }
            case ue: {
              var _e = W.type, Ue = W.memoizedProps, We = W.stateNode;
              $u(
                _e,
                Ue,
                We,
                f,
                M,
                ee
              );
              break;
            }
          }
        }
      }
      return z;
    }
    function $d(u) {
      if (!fs)
        throw new Error("Expected prepareToHydrateHostSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var f = u.memoizedState, M = f !== null ? f.dehydrated : null;
      if (!M)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      Fp(M, u);
    }
    function dp(u) {
      if (!fs)
        throw new Error("Expected skipPastDehydratedSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var f = u.memoizedState, M = f !== null ? f.dehydrated : null;
      if (!M)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return pg(M);
    }
    function Zo(u) {
      for (var f = u.return; f !== null && f.tag !== ue && f.tag !== se && f.tag !== he; )
        f = f.return;
      sa = f;
    }
    function hp(u) {
      if (!fs || u !== sa)
        return !1;
      if (!ea)
        return Zo(u), ea = !0, !1;
      if (u.tag !== se && (u.tag !== ue || zm(u.type) && !Ju(u.type, u.memoizedProps))) {
        var f = zr;
        if (f)
          if (Xm(u))
            Cv(u), fp();
          else
            for (; f; )
              Ym(u, f), f = Kf(f);
      }
      return Zo(u), u.tag === he ? zr = dp(u) : zr = sa ? Kf(u.stateNode) : null, !0;
    }
    function qm() {
      return ea && zr !== null;
    }
    function Cv(u) {
      for (var f = zr; f; )
        yd(u, f), f = Kf(f);
    }
    function Gc() {
      !fs || (sa = null, zr = null, ea = !1, Ga = !1);
    }
    function pp() {
      gs !== null && (sv(gs), gs = null);
    }
    function ha() {
      return ea;
    }
    function ao(u) {
      gs === null ? gs = [u] : gs.push(u);
    }
    var Sl, Jo, mp, Rv, Kp, Sg = function(u, f) {
    };
    Sl = !1, Jo = !1, mp = {}, Rv = {}, Kp = {}, Sg = function(u, f) {
      if (!(u === null || typeof u != "object") && !(!u._store || u._store.validated || u.key != null)) {
        if (typeof u._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        u._store.validated = !0;
        var M = wt(f) || "Component";
        Rv[M] || (Rv[M] = !0, g('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function _u(u, f, M) {
      var A = M.ref;
      if (A !== null && typeof A != "function" && typeof A != "object") {
        if ((u.mode & Fa || G) && !(M._owner && M._self && M._owner.stateNode !== M._self)) {
          var z = wt(u) || "Component";
          mp[z] || (g('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', A), mp[z] = !0);
        }
        if (M._owner) {
          var W = M._owner, ee;
          if (W) {
            var ae = W;
            if (ae.tag !== Y)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            ee = ae.stateNode;
          }
          if (!ee)
            throw new Error("Missing owner for string ref " + A + ". This error is likely caused by a bug in React. Please file an issue.");
          var _e = ee;
          mg(A, "ref");
          var Ue = "" + A;
          if (f !== null && f.ref !== null && typeof f.ref == "function" && f.ref._stringRef === Ue)
            return f.ref;
          var We = function(St) {
            var It = _e.refs;
            It === vg && (It = _e.refs = {}), St === null ? delete It[Ue] : It[Ue] = St;
          };
          return We._stringRef = Ue, We;
        } else {
          if (typeof A != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!M._owner)
            throw new Error("Element ref was specified as a string (" + A + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return A;
    }
    function Av(u, f) {
      var M = Object.prototype.toString.call(f);
      throw new Error("Objects are not valid as a React child (found: " + (M === "[object Object]" ? "object with keys {" + Object.keys(f).join(", ") + "}" : M) + "). If you meant to render a collection of children, use an array instead.");
    }
    function Ah(u) {
      {
        var f = wt(u) || "Component";
        if (Kp[f])
          return;
        Kp[f] = !0, g("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function Dh(u) {
      var f = u._payload, M = u._init;
      return M(f);
    }
    function wg(u) {
      function f(Ct, Jt) {
        if (!!u) {
          var Mt = Ct.deletions;
          Mt === null ? (Ct.deletions = [Jt], Ct.flags |= Or) : Mt.push(Jt);
        }
      }
      function M(Ct, Jt) {
        if (!u)
          return null;
        for (var Mt = Jt; Mt !== null; )
          f(Ct, Mt), Mt = Mt.sibling;
        return null;
      }
      function A(Ct, Jt) {
        for (var Mt = /* @__PURE__ */ new Map(), En = Jt; En !== null; )
          En.key !== null ? Mt.set(En.key, En) : Mt.set(En.index, En), En = En.sibling;
        return Mt;
      }
      function z(Ct, Jt) {
        var Mt = la(Ct, Jt);
        return Mt.index = 0, Mt.sibling = null, Mt;
      }
      function W(Ct, Jt, Mt) {
        if (Ct.index = Mt, !u)
          return Ct.flags |= mn, Jt;
        var En = Ct.alternate;
        if (En !== null) {
          var yr = En.index;
          return yr < Jt ? (Ct.flags |= At, Jt) : yr;
        } else
          return Ct.flags |= At, Jt;
      }
      function ee(Ct) {
        return u && Ct.alternate === null && (Ct.flags |= At), Ct;
      }
      function ae(Ct, Jt, Mt, En) {
        if (Jt === null || Jt.tag !== Me) {
          var yr = fv(Mt, Ct.mode, En);
          return yr.return = Ct, yr;
        } else {
          var Nn = z(Jt, Mt);
          return Nn.return = Ct, Nn;
        }
      }
      function _e(Ct, Jt, Mt, En) {
        var yr = Mt.type;
        if (yr === dt)
          return We(Ct, Jt, Mt.props.children, En, Mt.key);
        if (Jt !== null && (Jt.elementType === yr || c0(Jt, Mt) || typeof yr == "object" && yr !== null && yr.$$typeof === oe && Dh(yr) === Jt.type)) {
          var Nn = z(Jt, Mt.props);
          return Nn.ref = _u(Ct, Jt, Mt), Nn.return = Ct, Nn._debugSource = Mt._source, Nn._debugOwner = Mt._owner, Nn;
        }
        var ni = d0(Mt, Ct.mode, En);
        return ni.ref = _u(Ct, Jt, Mt), ni.return = Ct, ni;
      }
      function Ue(Ct, Jt, Mt, En) {
        if (Jt === null || Jt.tag !== ce || Jt.stateNode.containerInfo !== Mt.containerInfo || Jt.stateNode.implementation !== Mt.implementation) {
          var yr = Dn(Mt, Ct.mode, En);
          return yr.return = Ct, yr;
        } else {
          var Nn = z(Jt, Mt.children || []);
          return Nn.return = Ct, Nn;
        }
      }
      function We(Ct, Jt, Mt, En, yr) {
        if (Jt === null || Jt.tag !== me) {
          var Nn = Rp(Mt, Ct.mode, En, yr);
          return Nn.return = Ct, Nn;
        } else {
          var ni = z(Jt, Mt);
          return ni.return = Ct, ni;
        }
      }
      function St(Ct, Jt, Mt) {
        if (typeof Jt == "string" && Jt !== "" || typeof Jt == "number") {
          var En = fv("" + Jt, Ct.mode, Mt);
          return En.return = Ct, En;
        }
        if (typeof Jt == "object" && Jt !== null) {
          switch (Jt.$$typeof) {
            case Ie: {
              var yr = d0(Jt, Ct.mode, Mt);
              return yr.ref = _u(Ct, null, Jt), yr.return = Ct, yr;
            }
            case qe: {
              var Nn = Dn(Jt, Ct.mode, Mt);
              return Nn.return = Ct, Nn;
            }
            case oe: {
              var ni = Jt._payload, wa = Jt._init;
              return St(Ct, wa(ni), Mt);
            }
          }
          if (Ti(Jt) || pe(Jt)) {
            var ys = Rp(Jt, Ct.mode, Mt, null);
            return ys.return = Ct, ys;
          }
          Av(Ct, Jt);
        }
        return typeof Jt == "function" && Ah(Ct), null;
      }
      function It(Ct, Jt, Mt, En) {
        var yr = Jt !== null ? Jt.key : null;
        if (typeof Mt == "string" && Mt !== "" || typeof Mt == "number")
          return yr !== null ? null : ae(Ct, Jt, "" + Mt, En);
        if (typeof Mt == "object" && Mt !== null) {
          switch (Mt.$$typeof) {
            case Ie:
              return Mt.key === yr ? _e(Ct, Jt, Mt, En) : null;
            case qe:
              return Mt.key === yr ? Ue(Ct, Jt, Mt, En) : null;
            case oe: {
              var Nn = Mt._payload, ni = Mt._init;
              return It(Ct, Jt, ni(Nn), En);
            }
          }
          if (Ti(Mt) || pe(Mt))
            return yr !== null ? null : We(Ct, Jt, Mt, En, null);
          Av(Ct, Mt);
        }
        return typeof Mt == "function" && Ah(Ct), null;
      }
      function Yt(Ct, Jt, Mt, En, yr) {
        if (typeof En == "string" && En !== "" || typeof En == "number") {
          var Nn = Ct.get(Mt) || null;
          return ae(Jt, Nn, "" + En, yr);
        }
        if (typeof En == "object" && En !== null) {
          switch (En.$$typeof) {
            case Ie: {
              var ni = Ct.get(En.key === null ? Mt : En.key) || null;
              return _e(Jt, ni, En, yr);
            }
            case qe: {
              var wa = Ct.get(En.key === null ? Mt : En.key) || null;
              return Ue(Jt, wa, En, yr);
            }
            case oe: {
              var ys = En._payload, kn = En._init;
              return Yt(Ct, Jt, Mt, kn(ys), yr);
            }
          }
          if (Ti(En) || pe(En)) {
            var as = Ct.get(Mt) || null;
            return We(Jt, as, En, yr, null);
          }
          Av(Jt, En);
        }
        return typeof En == "function" && Ah(Jt), null;
      }
      function pn(Ct, Jt, Mt) {
        {
          if (typeof Ct != "object" || Ct === null)
            return Jt;
          switch (Ct.$$typeof) {
            case Ie:
            case qe:
              Sg(Ct, Mt);
              var En = Ct.key;
              if (typeof En != "string")
                break;
              if (Jt === null) {
                Jt = /* @__PURE__ */ new Set(), Jt.add(En);
                break;
              }
              if (!Jt.has(En)) {
                Jt.add(En);
                break;
              }
              g("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.", En);
              break;
            case oe: {
              var yr = Ct._payload, Nn = Ct._init;
              pn(Nn(yr), Jt, Mt);
              break;
            }
          }
        }
        return Jt;
      }
      function Sn(Ct, Jt, Mt, En) {
        for (var yr = null, Nn = 0; Nn < Mt.length; Nn++) {
          var ni = Mt[Nn];
          yr = pn(ni, yr, Ct);
        }
        for (var wa = null, ys = null, kn = Jt, as = 0, ba = 0, Ei = null; kn !== null && ba < Mt.length; ba++) {
          kn.index > ba ? (Ei = kn, kn = null) : Ei = kn.sibling;
          var Ao = It(Ct, kn, Mt[ba], En);
          if (Ao === null) {
            kn === null && (kn = Ei);
            break;
          }
          u && kn && Ao.alternate === null && f(Ct, kn), as = W(Ao, as, ba), ys === null ? wa = Ao : ys.sibling = Ao, ys = Ao, kn = Ei;
        }
        if (ba === Mt.length) {
          if (M(Ct, kn), ha()) {
            var co = ba;
            sl(Ct, co);
          }
          return wa;
        }
        if (kn === null) {
          for (; ba < Mt.length; ba++) {
            var rh = St(Ct, Mt[ba], En);
            rh !== null && (as = W(rh, as, ba), ys === null ? wa = rh : ys.sibling = rh, ys = rh);
          }
          if (ha()) {
            var wu = ba;
            sl(Ct, wu);
          }
          return wa;
        }
        for (var ih = A(Ct, kn); ba < Mt.length; ba++) {
          var Fh = Yt(ih, Ct, ba, Mt[ba], En);
          Fh !== null && (u && Fh.alternate !== null && ih.delete(Fh.key === null ? ba : Fh.key), as = W(Fh, as, ba), ys === null ? wa = Fh : ys.sibling = Fh, ys = Fh);
        }
        if (u && ih.forEach(function(Lx) {
          return f(Ct, Lx);
        }), ha()) {
          var hv = ba;
          sl(Ct, hv);
        }
        return wa;
      }
      function Tr(Ct, Jt, Mt, En) {
        var yr = pe(Mt);
        if (typeof yr != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && Mt[Symbol.toStringTag] === "Generator" && (Jo || g("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), Jo = !0), Mt.entries === yr && (Sl || g("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), Sl = !0);
          var Nn = yr.call(Mt);
          if (Nn)
            for (var ni = null, wa = Nn.next(); !wa.done; wa = Nn.next()) {
              var ys = wa.value;
              ni = pn(ys, ni, Ct);
            }
        }
        var kn = yr.call(Mt);
        if (kn == null)
          throw new Error("An iterable object provided no iterator.");
        for (var as = null, ba = null, Ei = Jt, Ao = 0, co = 0, rh = null, wu = kn.next(); Ei !== null && !wu.done; co++, wu = kn.next()) {
          Ei.index > co ? (rh = Ei, Ei = null) : rh = Ei.sibling;
          var ih = It(Ct, Ei, wu.value, En);
          if (ih === null) {
            Ei === null && (Ei = rh);
            break;
          }
          u && Ei && ih.alternate === null && f(Ct, Ei), Ao = W(ih, Ao, co), ba === null ? as = ih : ba.sibling = ih, ba = ih, Ei = rh;
        }
        if (wu.done) {
          if (M(Ct, Ei), ha()) {
            var Fh = co;
            sl(Ct, Fh);
          }
          return as;
        }
        if (Ei === null) {
          for (; !wu.done; co++, wu = kn.next()) {
            var hv = St(Ct, wu.value, En);
            hv !== null && (Ao = W(hv, Ao, co), ba === null ? as = hv : ba.sibling = hv, ba = hv);
          }
          if (ha()) {
            var Lx = co;
            sl(Ct, Lx);
          }
          return as;
        }
        for (var p0 = A(Ct, Ei); !wu.done; co++, wu = kn.next()) {
          var ah = Yt(p0, Ct, co, wu.value, En);
          ah !== null && (u && ah.alternate !== null && p0.delete(ah.key === null ? co : ah.key), Ao = W(ah, Ao, co), ba === null ? as = ah : ba.sibling = ah, ba = ah);
        }
        if (u && p0.forEach(function(fw) {
          return f(Ct, fw);
        }), ha()) {
          var Qv = co;
          sl(Ct, Qv);
        }
        return as;
      }
      function vi(Ct, Jt, Mt, En) {
        if (Jt !== null && Jt.tag === Me) {
          M(Ct, Jt.sibling);
          var yr = z(Jt, Mt);
          return yr.return = Ct, yr;
        }
        M(Ct, Jt);
        var Nn = fv(Mt, Ct.mode, En);
        return Nn.return = Ct, Nn;
      }
      function Pr(Ct, Jt, Mt, En) {
        for (var yr = Mt.key, Nn = Jt; Nn !== null; ) {
          if (Nn.key === yr) {
            var ni = Mt.type;
            if (ni === dt) {
              if (Nn.tag === me) {
                M(Ct, Nn.sibling);
                var wa = z(Nn, Mt.props.children);
                return wa.return = Ct, wa._debugSource = Mt._source, wa._debugOwner = Mt._owner, wa;
              }
            } else if (Nn.elementType === ni || c0(Nn, Mt) || typeof ni == "object" && ni !== null && ni.$$typeof === oe && Dh(ni) === Nn.type) {
              M(Ct, Nn.sibling);
              var ys = z(Nn, Mt.props);
              return ys.ref = _u(Ct, Nn, Mt), ys.return = Ct, ys._debugSource = Mt._source, ys._debugOwner = Mt._owner, ys;
            }
            M(Ct, Nn);
            break;
          } else
            f(Ct, Nn);
          Nn = Nn.sibling;
        }
        if (Mt.type === dt) {
          var kn = Rp(Mt.props.children, Ct.mode, En, Mt.key);
          return kn.return = Ct, kn;
        } else {
          var as = d0(Mt, Ct.mode, En);
          return as.ref = _u(Ct, Jt, Mt), as.return = Ct, as;
        }
      }
      function lo(Ct, Jt, Mt, En) {
        for (var yr = Mt.key, Nn = Jt; Nn !== null; ) {
          if (Nn.key === yr)
            if (Nn.tag === ce && Nn.stateNode.containerInfo === Mt.containerInfo && Nn.stateNode.implementation === Mt.implementation) {
              M(Ct, Nn.sibling);
              var ni = z(Nn, Mt.children || []);
              return ni.return = Ct, ni;
            } else {
              M(Ct, Nn);
              break;
            }
          else
            f(Ct, Nn);
          Nn = Nn.sibling;
        }
        var wa = Dn(Mt, Ct.mode, En);
        return wa.return = Ct, wa;
      }
      function uo(Ct, Jt, Mt, En) {
        var yr = typeof Mt == "object" && Mt !== null && Mt.type === dt && Mt.key === null;
        if (yr && (Mt = Mt.props.children), typeof Mt == "object" && Mt !== null) {
          switch (Mt.$$typeof) {
            case Ie:
              return ee(Pr(Ct, Jt, Mt, En));
            case qe:
              return ee(lo(Ct, Jt, Mt, En));
            case oe: {
              var Nn = Mt._payload, ni = Mt._init;
              return uo(Ct, Jt, ni(Nn), En);
            }
          }
          if (Ti(Mt))
            return Sn(Ct, Jt, Mt, En);
          if (pe(Mt))
            return Tr(Ct, Jt, Mt, En);
          Av(Ct, Mt);
        }
        return typeof Mt == "string" && Mt !== "" || typeof Mt == "number" ? ee(vi(Ct, Jt, "" + Mt, En)) : (typeof Mt == "function" && Ah(Ct), M(Ct, Jt));
      }
      return uo;
    }
    var Ff = wg(!0), Ey = wg(!1);
    function bg(u, f) {
      if (u !== null && f.child !== u.child)
        throw new Error("Resuming work not yet implemented.");
      if (f.child !== null) {
        var M = f.child, A = la(M, M.pendingProps);
        for (f.child = A, A.return = f; M.sibling !== null; )
          M = M.sibling, A = A.sibling = la(M, M.pendingProps), A.return = f;
        A.sibling = null;
      }
    }
    function My(u, f) {
      for (var M = u.child; M !== null; )
        Yu(M, f), M = M.sibling;
    }
    var vp = {}, gp = Mn(vp), Dv = Mn(vp), Lv = Mn(vp);
    function Qm(u) {
      if (u === vp)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return u;
    }
    function Lh() {
      var u = Qm(Lv.current);
      return u;
    }
    function Ty(u, f) {
      or(Lv, f, u), or(Dv, u, u), or(gp, vp, u);
      var M = zo(f);
      $n(gp, u), or(gp, M, u);
    }
    function Wc(u) {
      $n(gp, u), $n(Dv, u), $n(Lv, u);
    }
    function $p() {
      var u = Qm(gp.current);
      return u;
    }
    function Bs(u) {
      var f = Qm(Lv.current), M = Qm(gp.current), A = Pa(M, u.type, f);
      M !== A && (or(Dv, u, u), or(gp, A, u));
    }
    function Cy(u) {
      Dv.current === u && ($n(gp, u), $n(Dv, u));
    }
    var Eg = 0, N0 = 1, F0 = 1, Zm = 2, jc = Mn(Eg);
    function Ry(u, f) {
      return (u & f) !== 0;
    }
    function wl(u) {
      return u & N0;
    }
    function Pv(u, f) {
      return u & N0 | f;
    }
    function Mg(u, f) {
      return u | f;
    }
    function Bu(u, f) {
      or(jc, f, u);
    }
    function Ph(u) {
      $n(jc, u);
    }
    function em(u, f) {
      var M = u.memoizedState;
      return M !== null ? M.dehydrated !== null : (u.memoizedProps, !0);
    }
    function yp(u) {
      for (var f = u; f !== null; ) {
        if (f.tag === he) {
          var M = f.memoizedState;
          if (M !== null) {
            var A = M.dehydrated;
            if (A === null || _s(A) || va(A))
              return f;
          }
        } else if (f.tag === Ne && f.memoizedProps.revealOrder !== void 0) {
          var z = (f.flags & Bn) !== Pe;
          if (z)
            return f;
        } else if (f.child !== null) {
          f.child.return = f, f = f.child;
          continue;
        }
        if (f === u)
          return null;
        for (; f.sibling === null; ) {
          if (f.return === null || f.return === u)
            return null;
          f = f.return;
        }
        f.sibling.return = f.return, f = f.sibling;
      }
      return null;
    }
    var mc = 0, Aa = 1, xp = 2, Cs = 4, bl = 8, Ov = [];
    function Tg() {
      for (var u = 0; u < Ov.length; u++) {
        var f = Ov[u];
        go ? f._workInProgressVersionPrimary = null : f._workInProgressVersionSecondary = null;
      }
      Ov.length = 0;
    }
    function Uv(u, f) {
      var M = f._getVersion, A = M(f._source);
      u.mutableSourceEagerHydrationData == null ? u.mutableSourceEagerHydrationData = [f, A] : u.mutableSourceEagerHydrationData.push(f, A);
    }
    var zn = s.ReactCurrentDispatcher, Hu = s.ReactCurrentBatchConfig, zv, tm;
    zv = /* @__PURE__ */ new Set();
    var Oh = sn, oa = null, Rs = null, Co = null, nm = !1, Jm = !1, _p = 0, Cg = 0, u1 = 25, jt = null, kf = null, _d = -1, c = !1;
    function h() {
      {
        var u = jt;
        kf === null ? kf = [u] : kf.push(u);
      }
    }
    function E() {
      {
        var u = jt;
        kf !== null && (_d++, kf[_d] !== u && V(u));
      }
    }
    function P(u) {
      u != null && !Ti(u) && g("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", jt, typeof u);
    }
    function V(u) {
      {
        var f = wt(oa);
        if (!zv.has(f) && (zv.add(f), kf !== null)) {
          for (var M = "", A = 30, z = 0; z <= _d; z++) {
            for (var W = kf[z], ee = z === _d ? u : W, ae = z + 1 + ". " + W; ae.length < A; )
              ae += " ";
            ae += ee + `
`, M += ae;
          }
          g(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, f, M);
        }
      }
    }
    function q() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function le(u, f) {
      if (c)
        return !1;
      if (f === null)
        return g("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", jt), !1;
      u.length !== f.length && g(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, jt, "[" + f.join(", ") + "]", "[" + u.join(", ") + "]");
      for (var M = 0; M < f.length && M < u.length; M++)
        if (!Eo(u[M], f[M]))
          return !1;
      return !0;
    }
    function Oe(u, f, M, A, z, W) {
      Oh = W, oa = f, kf = u !== null ? u._debugHookTypes : null, _d = -1, c = u !== null && u.type !== f.type, f.memoizedState = null, f.updateQueue = null, f.lanes = sn, u !== null && u.memoizedState !== null ? zn.current = Ni : kf !== null ? zn.current = Uy : zn.current = q0;
      var ee = M(A, z);
      if (Jm) {
        var ae = 0;
        do {
          if (Jm = !1, _p = 0, ae >= u1)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          ae += 1, c = !1, Rs = null, Co = null, f.updateQueue = null, _d = -1, zn.current = am, ee = M(A, z);
        } while (Jm);
      }
      zn.current = X0, f._debugHookTypes = kf;
      var _e = Rs !== null && Rs.next !== null;
      if (Oh = sn, oa = null, Rs = null, Co = null, jt = null, kf = null, _d = -1, u !== null && (u.flags & en) !== (f.flags & en) && (u.mode & $i) !== Mr && g("Internal React error: Expected static flag was missing. Please notify the React team."), nm = !1, _e)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return ee;
    }
    function Ge() {
      var u = _p !== 0;
      return _p = 0, u;
    }
    function Dt(u, f, M) {
      f.updateQueue = u.updateQueue, (f.mode & _o) !== Mr ? f.flags &= ~(rr | Jn | Bi | cn) : f.flags &= ~(Bi | cn), u.lanes = $s(u.lanes, M);
    }
    function fn() {
      if (zn.current = X0, nm) {
        for (var u = oa.memoizedState; u !== null; ) {
          var f = u.queue;
          f !== null && (f.pending = null), u = u.next;
        }
        nm = !1;
      }
      Oh = sn, oa = null, Rs = null, Co = null, kf = null, _d = -1, jt = null, so = !1, Jm = !1, _p = 0;
    }
    function un() {
      var u = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return Co === null ? oa.memoizedState = Co = u : Co = Co.next = u, Co;
    }
    function rn() {
      var u;
      if (Rs === null) {
        var f = oa.alternate;
        f !== null ? u = f.memoizedState : u = null;
      } else
        u = Rs.next;
      var M;
      if (Co === null ? M = oa.memoizedState : M = Co.next, M !== null)
        Co = M, M = Co.next, Rs = u;
      else {
        if (u === null)
          throw new Error("Rendered more hooks than during the previous render.");
        Rs = u;
        var A = {
          memoizedState: Rs.memoizedState,
          baseState: Rs.baseState,
          baseQueue: Rs.baseQueue,
          queue: Rs.queue,
          next: null
        };
        Co === null ? oa.memoizedState = Co = A : Co = Co.next = A;
      }
      return Co;
    }
    function Hn() {
      return {
        lastEffect: null,
        stores: null
      };
    }
    function Qn(u, f) {
      return typeof f == "function" ? f(u) : f;
    }
    function ir(u, f, M) {
      var A = un(), z;
      M !== void 0 ? z = M(f) : z = f, A.memoizedState = A.baseState = z;
      var W = {
        pending: null,
        interleaved: null,
        lanes: sn,
        dispatch: null,
        lastRenderedReducer: u,
        lastRenderedState: z
      };
      A.queue = W;
      var ee = W.dispatch = Km.bind(null, oa, W);
      return [A.memoizedState, ee];
    }
    function Hs(u, f, M) {
      var A = rn(), z = A.queue;
      if (z === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      z.lastRenderedReducer = u;
      var W = Rs, ee = W.baseQueue, ae = z.pending;
      if (ae !== null) {
        if (ee !== null) {
          var _e = ee.next, Ue = ae.next;
          ee.next = Ue, ae.next = _e;
        }
        W.baseQueue !== ee && g("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), W.baseQueue = ee = ae, z.pending = null;
      }
      if (ee !== null) {
        var We = ee.next, St = W.baseState, It = null, Yt = null, pn = null, Sn = We;
        do {
          var Tr = Sn.lane;
          if (uc(Oh, Tr)) {
            if (pn !== null) {
              var Pr = {
                lane: kr,
                action: Sn.action,
                hasEagerState: Sn.hasEagerState,
                eagerState: Sn.eagerState,
                next: null
              };
              pn = pn.next = Pr;
            }
            if (Sn.hasEagerState)
              St = Sn.eagerState;
            else {
              var lo = Sn.action;
              St = u(St, lo);
            }
          } else {
            var vi = {
              lane: Tr,
              action: Sn.action,
              hasEagerState: Sn.hasEagerState,
              eagerState: Sn.eagerState,
              next: null
            };
            pn === null ? (Yt = pn = vi, It = St) : pn = pn.next = vi, oa.lanes = Ur(oa.lanes, Tr), gx(Tr);
          }
          Sn = Sn.next;
        } while (Sn !== null && Sn !== We);
        pn === null ? It = St : pn.next = Yt, Eo(St, A.memoizedState) || sx(), A.memoizedState = St, A.baseState = It, A.baseQueue = pn, z.lastRenderedState = St;
      }
      var uo = z.interleaved;
      if (uo !== null) {
        var Ct = uo;
        do {
          var Jt = Ct.lane;
          oa.lanes = Ur(oa.lanes, Jt), gx(Jt), Ct = Ct.next;
        } while (Ct !== uo);
      } else
        ee === null && (z.lanes = sn);
      var Mt = z.dispatch;
      return [A.memoizedState, Mt];
    }
    function mt(u, f, M) {
      var A = rn(), z = A.queue;
      if (z === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      z.lastRenderedReducer = u;
      var W = z.dispatch, ee = z.pending, ae = A.memoizedState;
      if (ee !== null) {
        z.pending = null;
        var _e = ee.next, Ue = _e;
        do {
          var We = Ue.action;
          ae = u(ae, We), Ue = Ue.next;
        } while (Ue !== _e);
        Eo(ae, A.memoizedState) || sx(), A.memoizedState = ae, A.baseQueue === null && (A.baseState = ae), z.lastRenderedState = ae;
      }
      return [ae, W];
    }
    function Ke(u, f, M) {
    }
    function _t(u, f, M) {
    }
    function _n(u, f, M) {
      var A = oa, z = un(), W, ee = ha();
      if (ee) {
        if (M === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        W = M(), tm || W !== M() && (g("The result of getServerSnapshot should be cached to avoid an infinite loop"), tm = !0);
      } else {
        if (W = f(), !tm) {
          var ae = f();
          Eo(W, ae) || (g("The result of getSnapshot should be cached to avoid an infinite loop"), tm = !0);
        }
        var _e = BS();
        if (_e === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Vo(_e, Oh) || Zn(A, f, W);
      }
      z.memoizedState = W;
      var Ue = {
        value: W,
        getSnapshot: f
      };
      return z.queue = Ue, Nv(Lr.bind(null, A, Ue, u), [u]), A.flags |= Bi, Ag(Aa | bl, pr.bind(null, A, Ue, W, f), void 0, null), W;
    }
    function ar(u, f, M) {
      var A = oa, z = rn(), W = f();
      if (!tm) {
        var ee = f();
        Eo(W, ee) || (g("The result of getSnapshot should be cached to avoid an infinite loop"), tm = !0);
      }
      var ae = z.memoizedState, _e = !Eo(ae, W);
      _e && (z.memoizedState = W, sx());
      var Ue = z.queue;
      if (Vu(Lr.bind(null, A, Ue, u), [u]), Ue.getSnapshot !== f || _e || Co !== null && Co.memoizedState.tag & Aa) {
        A.flags |= Bi, Ag(Aa | bl, pr.bind(null, A, Ue, W, f), void 0, null);
        var We = BS();
        if (We === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Vo(We, Oh) || Zn(A, f, W);
      }
      return W;
    }
    function Zn(u, f, M) {
      u.flags |= Te;
      var A = {
        getSnapshot: f,
        value: M
      }, z = oa.updateQueue;
      if (z === null)
        z = Hn(), oa.updateQueue = z, z.stores = [A];
      else {
        var W = z.stores;
        W === null ? z.stores = [A] : W.push(A);
      }
    }
    function pr(u, f, M, A) {
      f.value = M, f.getSnapshot = A, ll(f) && Zi(u);
    }
    function Lr(u, f, M) {
      var A = function() {
        ll(f) && Zi(u);
      };
      return M(A);
    }
    function ll(u) {
      var f = u.getSnapshot, M = u.value;
      try {
        var A = f();
        return !Eo(M, A);
      } catch {
        return !0;
      }
    }
    function Zi(u) {
      Tl(u, Hr, Vi);
    }
    function If(u) {
      var f = un();
      typeof u == "function" && (u = u()), f.memoizedState = f.baseState = u;
      var M = {
        pending: null,
        interleaved: null,
        lanes: sn,
        dispatch: null,
        lastRenderedReducer: Qn,
        lastRenderedState: u
      };
      f.queue = M;
      var A = M.dispatch = xb.bind(null, oa, M);
      return [f.memoizedState, A];
    }
    function Rg(u) {
      return Hs(Qn);
    }
    function k0(u) {
      return mt(Qn);
    }
    function Ag(u, f, M, A) {
      var z = {
        tag: u,
        create: f,
        destroy: M,
        deps: A,
        next: null
      }, W = oa.updateQueue;
      if (W === null)
        W = Hn(), oa.updateQueue = W, W.lastEffect = z.next = z;
      else {
        var ee = W.lastEffect;
        if (ee === null)
          W.lastEffect = z.next = z;
        else {
          var ae = ee.next;
          ee.next = z, z.next = ae, W.lastEffect = z;
        }
      }
      return z;
    }
    function I0(u) {
      var f = un();
      {
        var M = {
          current: u
        };
        return f.memoizedState = M, M;
      }
    }
    function B0(u) {
      var f = rn();
      return f.memoizedState;
    }
    function Ay(u, f, M, A) {
      var z = un(), W = A === void 0 ? null : A;
      oa.flags |= u, z.memoizedState = Ag(Aa | f, M, void 0, W);
    }
    function Dy(u, f, M, A) {
      var z = rn(), W = A === void 0 ? null : A, ee = void 0;
      if (Rs !== null) {
        var ae = Rs.memoizedState;
        if (ee = ae.destroy, W !== null) {
          var _e = ae.deps;
          if (le(W, _e)) {
            z.memoizedState = Ag(f, M, ee, W);
            return;
          }
        }
      }
      oa.flags |= u, z.memoizedState = Ag(Aa | f, M, ee, W);
    }
    function Nv(u, f) {
      return (oa.mode & _o) !== Mr ? Ay(rr | Bi | yn, bl, u, f) : Ay(Bi | yn, bl, u, f);
    }
    function Vu(u, f) {
      return Dy(Bi, bl, u, f);
    }
    function c1(u, f) {
      return Ay(cn, xp, u, f);
    }
    function H0(u, f) {
      return Dy(cn, xp, u, f);
    }
    function rm(u, f) {
      var M = cn;
      return M |= gn, (oa.mode & _o) !== Mr && (M |= Jn), Ay(M, Cs, u, f);
    }
    function Jr(u, f) {
      return Dy(cn, Cs, u, f);
    }
    function rS(u, f) {
      if (typeof f == "function") {
        var M = f, A = u();
        return M(A), function() {
          M(null);
        };
      } else if (f != null) {
        var z = f;
        z.hasOwnProperty("current") || g("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(z).join(", ") + "}");
        var W = u();
        return z.current = W, function() {
          z.current = null;
        };
      }
    }
    function ul(u, f, M) {
      typeof f != "function" && g("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", f !== null ? typeof f : "null");
      var A = M != null ? M.concat([u]) : null, z = cn;
      return z |= gn, (oa.mode & _o) !== Mr && (z |= Jn), Ay(z, Cs, rS.bind(null, f, u), A);
    }
    function As(u, f, M) {
      typeof f != "function" && g("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", f !== null ? typeof f : "null");
      var A = M != null ? M.concat([u]) : null;
      return Dy(cn, Cs, rS.bind(null, f, u), A);
    }
    function Ly(u, f) {
    }
    var Sd = Ly;
    function f1(u, f) {
      var M = un(), A = f === void 0 ? null : f;
      return M.memoizedState = [u, A], u;
    }
    function V0(u, f) {
      var M = rn(), A = f === void 0 ? null : f, z = M.memoizedState;
      if (z !== null && A !== null) {
        var W = z[1];
        if (le(A, W))
          return z[0];
      }
      return M.memoizedState = [u, A], u;
    }
    function G0(u, f) {
      var M = un(), A = f === void 0 ? null : f, z = u();
      return M.memoizedState = [z, A], z;
    }
    function W0(u, f) {
      var M = rn(), A = f === void 0 ? null : f, z = M.memoizedState;
      if (z !== null && A !== null) {
        var W = z[1];
        if (le(A, W))
          return z[0];
      }
      var ee = u();
      return M.memoizedState = [ee, A], ee;
    }
    function Dg(u) {
      var f = If(u), M = f[0], A = f[1];
      return Nv(function() {
        var z = Hu.transition;
        Hu.transition = {};
        try {
          A(u);
        } finally {
          Hu.transition = z;
        }
      }, [u]), M;
    }
    function im(u) {
      var f = Rg(), M = f[0], A = f[1];
      return Vu(function() {
        var z = Hu.transition;
        Hu.transition = {};
        try {
          A(u);
        } finally {
          Hu.transition = z;
        }
      }, [u]), M;
    }
    function j0(u) {
      var f = k0(), M = f[0], A = f[1];
      return Vu(function() {
        var z = Hu.transition;
        Hu.transition = {};
        try {
          A(u);
        } finally {
          Hu.transition = z;
        }
      }, [u]), M;
    }
    function Sp(u, f, M) {
      var A = il();
      Ns(Nu(A, ld)), u(!0);
      var z = Hu.transition;
      Hu.transition = {};
      var W = Hu.transition;
      Hu.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        u(!1), f();
      } finally {
        if (Ns(A), Hu.transition = z, z === null && W._updatedFibers) {
          var ee = W._updatedFibers.size;
          ee > 10 && p("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), W._updatedFibers.clear();
        }
      }
    }
    function Fv() {
      var u = If(!1), f = u[0], M = u[1], A = Sp.bind(null, M), z = un();
      return z.memoizedState = A, [f, A];
    }
    function Lg() {
      var u = Rg(), f = u[0], M = rn(), A = M.memoizedState;
      return [f, A];
    }
    function Vs() {
      var u = k0(), f = u[0], M = rn(), A = M.memoizedState;
      return [f, A];
    }
    var so = !1;
    function d1() {
      return so;
    }
    function Y0() {
      var u = un(), f = BS(), M = f.identifierPrefix, A;
      if (ha()) {
        var z = wy();
        A = ":" + M + "R" + z;
        var W = _p++;
        W > 0 && (A += "H" + W.toString(32)), A += ":";
      } else {
        var ee = Cg++;
        A = ":" + M + "r" + ee.toString(32) + ":";
      }
      return u.memoizedState = A, A;
    }
    function Py() {
      var u = rn(), f = u.memoizedState;
      return f;
    }
    function Km(u, f, M) {
      typeof arguments[3] == "function" && g("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var A = Xv(u), z = {
        lane: A,
        action: M,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (iS(u))
        aS(f, z);
      else {
        kv(u, f, z);
        var W = yc(), ee = Tl(u, A, W);
        ee !== null && $m(ee, f, A);
      }
      Oy(u, A);
    }
    function xb(u, f, M) {
      typeof arguments[3] == "function" && g("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var A = Xv(u), z = {
        lane: A,
        action: M,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (iS(u))
        aS(f, z);
      else {
        kv(u, f, z);
        var W = u.alternate;
        if (u.lanes === sn && (W === null || W.lanes === sn)) {
          var ee = f.lastRenderedReducer;
          if (ee !== null) {
            var ae;
            ae = zn.current, zn.current = Yc;
            try {
              var _e = f.lastRenderedState, Ue = ee(_e, M);
              if (z.hasEagerState = !0, z.eagerState = Ue, Eo(Ue, _e))
                return;
            } catch {
            } finally {
              zn.current = ae;
            }
          }
        }
        var We = yc(), St = Tl(u, A, We);
        St !== null && $m(St, f, A);
      }
      Oy(u, A);
    }
    function iS(u) {
      var f = u.alternate;
      return u === oa || f !== null && f === oa;
    }
    function aS(u, f) {
      Jm = nm = !0;
      var M = u.pending;
      M === null ? f.next = f : (f.next = M.next, M.next = f), u.pending = f;
    }
    function kv(u, f, M, A) {
      if (HS(u)) {
        var z = f.interleaved;
        z === null ? (M.next = M, ur(f)) : (M.next = z.next, z.next = M), f.interleaved = M;
      } else {
        var W = f.pending;
        W === null ? M.next = M : (M.next = W.next, W.next = M), f.pending = M;
      }
    }
    function $m(u, f, M) {
      if (gl(M)) {
        var A = f.lanes;
        A = ms(A, u.pendingLanes);
        var z = Ur(A, M);
        f.lanes = z, bs(u, z);
      }
    }
    function Oy(u, f, M) {
      Fc(u, f);
    }
    var X0 = {
      readContext: wn,
      useCallback: q,
      useContext: q,
      useEffect: q,
      useImperativeHandle: q,
      useInsertionEffect: q,
      useLayoutEffect: q,
      useMemo: q,
      useReducer: q,
      useRef: q,
      useState: q,
      useDebugValue: q,
      useDeferredValue: q,
      useTransition: q,
      useMutableSource: q,
      useSyncExternalStore: q,
      useId: q,
      unstable_isNewReconciler: O
    }, q0 = null, Uy = null, Ni = null, am = null, wd = null, Yc = null, zy = null;
    {
      var Q0 = function() {
        g("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, Nr = function() {
        g("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      q0 = {
        readContext: function(u) {
          return wn(u);
        },
        useCallback: function(u, f) {
          return jt = "useCallback", h(), P(f), f1(u, f);
        },
        useContext: function(u) {
          return jt = "useContext", h(), wn(u);
        },
        useEffect: function(u, f) {
          return jt = "useEffect", h(), P(f), Nv(u, f);
        },
        useImperativeHandle: function(u, f, M) {
          return jt = "useImperativeHandle", h(), P(M), ul(u, f, M);
        },
        useInsertionEffect: function(u, f) {
          return jt = "useInsertionEffect", h(), P(f), c1(u, f);
        },
        useLayoutEffect: function(u, f) {
          return jt = "useLayoutEffect", h(), P(f), rm(u, f);
        },
        useMemo: function(u, f) {
          jt = "useMemo", h(), P(f);
          var M = zn.current;
          zn.current = wd;
          try {
            return G0(u, f);
          } finally {
            zn.current = M;
          }
        },
        useReducer: function(u, f, M) {
          jt = "useReducer", h();
          var A = zn.current;
          zn.current = wd;
          try {
            return ir(u, f, M);
          } finally {
            zn.current = A;
          }
        },
        useRef: function(u) {
          return jt = "useRef", h(), I0(u);
        },
        useState: function(u) {
          jt = "useState", h();
          var f = zn.current;
          zn.current = wd;
          try {
            return If(u);
          } finally {
            zn.current = f;
          }
        },
        useDebugValue: function(u, f) {
          return jt = "useDebugValue", h(), void 0;
        },
        useDeferredValue: function(u) {
          return jt = "useDeferredValue", h(), Dg(u);
        },
        useTransition: function() {
          return jt = "useTransition", h(), Fv();
        },
        useMutableSource: function(u, f, M) {
          return jt = "useMutableSource", h(), void 0;
        },
        useSyncExternalStore: function(u, f, M) {
          return jt = "useSyncExternalStore", h(), _n(u, f, M);
        },
        useId: function() {
          return jt = "useId", h(), Y0();
        },
        unstable_isNewReconciler: O
      }, Uy = {
        readContext: function(u) {
          return wn(u);
        },
        useCallback: function(u, f) {
          return jt = "useCallback", E(), f1(u, f);
        },
        useContext: function(u) {
          return jt = "useContext", E(), wn(u);
        },
        useEffect: function(u, f) {
          return jt = "useEffect", E(), Nv(u, f);
        },
        useImperativeHandle: function(u, f, M) {
          return jt = "useImperativeHandle", E(), ul(u, f, M);
        },
        useInsertionEffect: function(u, f) {
          return jt = "useInsertionEffect", E(), c1(u, f);
        },
        useLayoutEffect: function(u, f) {
          return jt = "useLayoutEffect", E(), rm(u, f);
        },
        useMemo: function(u, f) {
          jt = "useMemo", E();
          var M = zn.current;
          zn.current = wd;
          try {
            return G0(u, f);
          } finally {
            zn.current = M;
          }
        },
        useReducer: function(u, f, M) {
          jt = "useReducer", E();
          var A = zn.current;
          zn.current = wd;
          try {
            return ir(u, f, M);
          } finally {
            zn.current = A;
          }
        },
        useRef: function(u) {
          return jt = "useRef", E(), I0(u);
        },
        useState: function(u) {
          jt = "useState", E();
          var f = zn.current;
          zn.current = wd;
          try {
            return If(u);
          } finally {
            zn.current = f;
          }
        },
        useDebugValue: function(u, f) {
          return jt = "useDebugValue", E(), void 0;
        },
        useDeferredValue: function(u) {
          return jt = "useDeferredValue", E(), Dg(u);
        },
        useTransition: function() {
          return jt = "useTransition", E(), Fv();
        },
        useMutableSource: function(u, f, M) {
          return jt = "useMutableSource", E(), void 0;
        },
        useSyncExternalStore: function(u, f, M) {
          return jt = "useSyncExternalStore", E(), _n(u, f, M);
        },
        useId: function() {
          return jt = "useId", E(), Y0();
        },
        unstable_isNewReconciler: O
      }, Ni = {
        readContext: function(u) {
          return wn(u);
        },
        useCallback: function(u, f) {
          return jt = "useCallback", E(), V0(u, f);
        },
        useContext: function(u) {
          return jt = "useContext", E(), wn(u);
        },
        useEffect: function(u, f) {
          return jt = "useEffect", E(), Vu(u, f);
        },
        useImperativeHandle: function(u, f, M) {
          return jt = "useImperativeHandle", E(), As(u, f, M);
        },
        useInsertionEffect: function(u, f) {
          return jt = "useInsertionEffect", E(), H0(u, f);
        },
        useLayoutEffect: function(u, f) {
          return jt = "useLayoutEffect", E(), Jr(u, f);
        },
        useMemo: function(u, f) {
          jt = "useMemo", E();
          var M = zn.current;
          zn.current = Yc;
          try {
            return W0(u, f);
          } finally {
            zn.current = M;
          }
        },
        useReducer: function(u, f, M) {
          jt = "useReducer", E();
          var A = zn.current;
          zn.current = Yc;
          try {
            return Hs(u, f, M);
          } finally {
            zn.current = A;
          }
        },
        useRef: function(u) {
          return jt = "useRef", E(), B0();
        },
        useState: function(u) {
          jt = "useState", E();
          var f = zn.current;
          zn.current = Yc;
          try {
            return Rg(u);
          } finally {
            zn.current = f;
          }
        },
        useDebugValue: function(u, f) {
          return jt = "useDebugValue", E(), Sd();
        },
        useDeferredValue: function(u) {
          return jt = "useDeferredValue", E(), im(u);
        },
        useTransition: function() {
          return jt = "useTransition", E(), Lg();
        },
        useMutableSource: function(u, f, M) {
          return jt = "useMutableSource", E(), void 0;
        },
        useSyncExternalStore: function(u, f, M) {
          return jt = "useSyncExternalStore", E(), ar(u, f);
        },
        useId: function() {
          return jt = "useId", E(), Py();
        },
        unstable_isNewReconciler: O
      }, am = {
        readContext: function(u) {
          return wn(u);
        },
        useCallback: function(u, f) {
          return jt = "useCallback", E(), V0(u, f);
        },
        useContext: function(u) {
          return jt = "useContext", E(), wn(u);
        },
        useEffect: function(u, f) {
          return jt = "useEffect", E(), Vu(u, f);
        },
        useImperativeHandle: function(u, f, M) {
          return jt = "useImperativeHandle", E(), As(u, f, M);
        },
        useInsertionEffect: function(u, f) {
          return jt = "useInsertionEffect", E(), H0(u, f);
        },
        useLayoutEffect: function(u, f) {
          return jt = "useLayoutEffect", E(), Jr(u, f);
        },
        useMemo: function(u, f) {
          jt = "useMemo", E();
          var M = zn.current;
          zn.current = zy;
          try {
            return W0(u, f);
          } finally {
            zn.current = M;
          }
        },
        useReducer: function(u, f, M) {
          jt = "useReducer", E();
          var A = zn.current;
          zn.current = zy;
          try {
            return mt(u, f, M);
          } finally {
            zn.current = A;
          }
        },
        useRef: function(u) {
          return jt = "useRef", E(), B0();
        },
        useState: function(u) {
          jt = "useState", E();
          var f = zn.current;
          zn.current = zy;
          try {
            return k0(u);
          } finally {
            zn.current = f;
          }
        },
        useDebugValue: function(u, f) {
          return jt = "useDebugValue", E(), Sd();
        },
        useDeferredValue: function(u) {
          return jt = "useDeferredValue", E(), j0(u);
        },
        useTransition: function() {
          return jt = "useTransition", E(), Vs();
        },
        useMutableSource: function(u, f, M) {
          return jt = "useMutableSource", E(), void 0;
        },
        useSyncExternalStore: function(u, f, M) {
          return jt = "useSyncExternalStore", E(), ar(u, f);
        },
        useId: function() {
          return jt = "useId", E(), Py();
        },
        unstable_isNewReconciler: O
      }, wd = {
        readContext: function(u) {
          return Q0(), wn(u);
        },
        useCallback: function(u, f) {
          return jt = "useCallback", Nr(), h(), f1(u, f);
        },
        useContext: function(u) {
          return jt = "useContext", Nr(), h(), wn(u);
        },
        useEffect: function(u, f) {
          return jt = "useEffect", Nr(), h(), Nv(u, f);
        },
        useImperativeHandle: function(u, f, M) {
          return jt = "useImperativeHandle", Nr(), h(), ul(u, f, M);
        },
        useInsertionEffect: function(u, f) {
          return jt = "useInsertionEffect", Nr(), h(), c1(u, f);
        },
        useLayoutEffect: function(u, f) {
          return jt = "useLayoutEffect", Nr(), h(), rm(u, f);
        },
        useMemo: function(u, f) {
          jt = "useMemo", Nr(), h();
          var M = zn.current;
          zn.current = wd;
          try {
            return G0(u, f);
          } finally {
            zn.current = M;
          }
        },
        useReducer: function(u, f, M) {
          jt = "useReducer", Nr(), h();
          var A = zn.current;
          zn.current = wd;
          try {
            return ir(u, f, M);
          } finally {
            zn.current = A;
          }
        },
        useRef: function(u) {
          return jt = "useRef", Nr(), h(), I0(u);
        },
        useState: function(u) {
          jt = "useState", Nr(), h();
          var f = zn.current;
          zn.current = wd;
          try {
            return If(u);
          } finally {
            zn.current = f;
          }
        },
        useDebugValue: function(u, f) {
          return jt = "useDebugValue", Nr(), h(), void 0;
        },
        useDeferredValue: function(u) {
          return jt = "useDeferredValue", Nr(), h(), Dg(u);
        },
        useTransition: function() {
          return jt = "useTransition", Nr(), h(), Fv();
        },
        useMutableSource: function(u, f, M) {
          return jt = "useMutableSource", Nr(), h(), void 0;
        },
        useSyncExternalStore: function(u, f, M) {
          return jt = "useSyncExternalStore", Nr(), h(), _n(u, f, M);
        },
        useId: function() {
          return jt = "useId", Nr(), h(), Y0();
        },
        unstable_isNewReconciler: O
      }, Yc = {
        readContext: function(u) {
          return Q0(), wn(u);
        },
        useCallback: function(u, f) {
          return jt = "useCallback", Nr(), E(), V0(u, f);
        },
        useContext: function(u) {
          return jt = "useContext", Nr(), E(), wn(u);
        },
        useEffect: function(u, f) {
          return jt = "useEffect", Nr(), E(), Vu(u, f);
        },
        useImperativeHandle: function(u, f, M) {
          return jt = "useImperativeHandle", Nr(), E(), As(u, f, M);
        },
        useInsertionEffect: function(u, f) {
          return jt = "useInsertionEffect", Nr(), E(), H0(u, f);
        },
        useLayoutEffect: function(u, f) {
          return jt = "useLayoutEffect", Nr(), E(), Jr(u, f);
        },
        useMemo: function(u, f) {
          jt = "useMemo", Nr(), E();
          var M = zn.current;
          zn.current = Yc;
          try {
            return W0(u, f);
          } finally {
            zn.current = M;
          }
        },
        useReducer: function(u, f, M) {
          jt = "useReducer", Nr(), E();
          var A = zn.current;
          zn.current = Yc;
          try {
            return Hs(u, f, M);
          } finally {
            zn.current = A;
          }
        },
        useRef: function(u) {
          return jt = "useRef", Nr(), E(), B0();
        },
        useState: function(u) {
          jt = "useState", Nr(), E();
          var f = zn.current;
          zn.current = Yc;
          try {
            return Rg(u);
          } finally {
            zn.current = f;
          }
        },
        useDebugValue: function(u, f) {
          return jt = "useDebugValue", Nr(), E(), Sd();
        },
        useDeferredValue: function(u) {
          return jt = "useDeferredValue", Nr(), E(), im(u);
        },
        useTransition: function() {
          return jt = "useTransition", Nr(), E(), Lg();
        },
        useMutableSource: function(u, f, M) {
          return jt = "useMutableSource", Nr(), E(), void 0;
        },
        useSyncExternalStore: function(u, f, M) {
          return jt = "useSyncExternalStore", Nr(), E(), ar(u, f);
        },
        useId: function() {
          return jt = "useId", Nr(), E(), Py();
        },
        unstable_isNewReconciler: O
      }, zy = {
        readContext: function(u) {
          return Q0(), wn(u);
        },
        useCallback: function(u, f) {
          return jt = "useCallback", Nr(), E(), V0(u, f);
        },
        useContext: function(u) {
          return jt = "useContext", Nr(), E(), wn(u);
        },
        useEffect: function(u, f) {
          return jt = "useEffect", Nr(), E(), Vu(u, f);
        },
        useImperativeHandle: function(u, f, M) {
          return jt = "useImperativeHandle", Nr(), E(), As(u, f, M);
        },
        useInsertionEffect: function(u, f) {
          return jt = "useInsertionEffect", Nr(), E(), H0(u, f);
        },
        useLayoutEffect: function(u, f) {
          return jt = "useLayoutEffect", Nr(), E(), Jr(u, f);
        },
        useMemo: function(u, f) {
          jt = "useMemo", Nr(), E();
          var M = zn.current;
          zn.current = Yc;
          try {
            return W0(u, f);
          } finally {
            zn.current = M;
          }
        },
        useReducer: function(u, f, M) {
          jt = "useReducer", Nr(), E();
          var A = zn.current;
          zn.current = Yc;
          try {
            return mt(u, f, M);
          } finally {
            zn.current = A;
          }
        },
        useRef: function(u) {
          return jt = "useRef", Nr(), E(), B0();
        },
        useState: function(u) {
          jt = "useState", Nr(), E();
          var f = zn.current;
          zn.current = Yc;
          try {
            return k0(u);
          } finally {
            zn.current = f;
          }
        },
        useDebugValue: function(u, f) {
          return jt = "useDebugValue", Nr(), E(), Sd();
        },
        useDeferredValue: function(u) {
          return jt = "useDeferredValue", Nr(), E(), j0(u);
        },
        useTransition: function() {
          return jt = "useTransition", Nr(), E(), Vs();
        },
        useMutableSource: function(u, f, M) {
          return jt = "useMutableSource", Nr(), E(), void 0;
        },
        useSyncExternalStore: function(u, f, M) {
          return jt = "useSyncExternalStore", Nr(), E(), ar(u, f);
        },
        useId: function() {
          return jt = "useId", Nr(), E(), Py();
        },
        unstable_isNewReconciler: O
      };
    }
    var bd = i.unstable_now, wp = 0, jr = -1, Uh = -1, Xc = -1, Ny = !1, Z0 = !1;
    function Da() {
      return Ny;
    }
    function Bf() {
      Z0 = !0;
    }
    function Pg() {
      Ny = !1, Z0 = !1;
    }
    function Iv() {
      Ny = Z0, Z0 = !1;
    }
    function sm() {
      return wp;
    }
    function h1() {
      wp = bd();
    }
    function om(u) {
      Uh = bd(), u.actualStartTime < 0 && (u.actualStartTime = bd());
    }
    function ev(u) {
      Uh = -1;
    }
    function Bv(u, f) {
      if (Uh >= 0) {
        var M = bd() - Uh;
        u.actualDuration += M, f && (u.selfBaseDuration = M), Uh = -1;
      }
    }
    function Hf(u) {
      if (jr >= 0) {
        var f = bd() - jr;
        jr = -1;
        for (var M = u.return; M !== null; ) {
          switch (M.tag) {
            case se:
              var A = M.stateNode;
              A.effectDuration += f;
              return;
            case fe:
              var z = M.stateNode;
              z.effectDuration += f;
              return;
          }
          M = M.return;
        }
      }
    }
    function Og(u) {
      if (Xc >= 0) {
        var f = bd() - Xc;
        Xc = -1;
        for (var M = u.return; M !== null; ) {
          switch (M.tag) {
            case se:
              var A = M.stateNode;
              A !== null && (A.passiveEffectDuration += f);
              return;
            case fe:
              var z = M.stateNode;
              z !== null && (z.passiveEffectDuration += f);
              return;
          }
          M = M.return;
        }
      }
    }
    function vc() {
      jr = bd();
    }
    function J0() {
      Xc = bd();
    }
    function Ug(u) {
      for (var f = u.child; f; )
        u.actualDuration += f.actualDuration, f = f.sibling;
    }
    function Fy(u, f) {
      return {
        value: u,
        source: f,
        stack: Lf(f)
      };
    }
    function sS(u, f) {
      return !0;
    }
    function p1(u, f) {
      try {
        var M = sS(u, f);
        if (M === !1)
          return;
        var A = f.value, z = f.source, W = f.stack, ee = W !== null ? W : "";
        if (A != null && A._suppressLogging) {
          if (u.tag === Y)
            return;
          console.error(A);
        }
        var ae = z ? wt(z) : null, _e = ae ? "The above error occurred in the <" + ae + "> component:" : "The above error occurred in one of your React components:", Ue;
        if (u.tag === se)
          Ue = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var We = wt(u) || "Anonymous";
          Ue = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + We + ".");
        }
        var St = _e + `
` + ee + `

` + ("" + Ue);
        console.error(St);
      } catch (It) {
        setTimeout(function() {
          throw It;
        });
      }
    }
    var m1 = typeof WeakMap == "function" ? WeakMap : Map;
    function ky(u, f, M) {
      var A = Er(Vi, M);
      A.tag = pt, A.payload = {
        element: null
      };
      var z = f.value;
      return A.callback = function() {
        fE(z), p1(u, f);
      }, A;
    }
    function tv(u, f, M) {
      var A = Er(Vi, M);
      A.tag = pt;
      var z = u.type.getDerivedStateFromError;
      if (typeof z == "function") {
        var W = f.value;
        A.payload = function() {
          return z(W);
        }, A.callback = function() {
          zT(u), p1(u, f);
        };
      }
      var ee = u.stateNode;
      return ee !== null && typeof ee.componentDidCatch == "function" && (A.callback = function() {
        zT(u), p1(u, f), typeof z != "function" && uE(this);
        var _e = f.value, Ue = f.stack;
        this.componentDidCatch(_e, {
          componentStack: Ue !== null ? Ue : ""
        }), typeof z != "function" && (Vr(u.lanes, Hr) || g("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", wt(u) || "Unknown"));
      }), A;
    }
    function v1(u, f, M) {
      var A = u.pingCache, z;
      if (A === null ? (A = u.pingCache = new m1(), z = /* @__PURE__ */ new Set(), A.set(f, z)) : (z = A.get(f), z === void 0 && (z = /* @__PURE__ */ new Set(), A.set(f, z))), !z.has(M)) {
        z.add(M);
        var W = JS.bind(null, u, f, M);
        ns && u0(u, M), f.then(W, W);
      }
    }
    function _b(u, f, M, A) {
      var z = u.updateQueue;
      if (z === null) {
        var W = /* @__PURE__ */ new Set();
        W.add(M), u.updateQueue = W;
      } else
        z.add(M);
    }
    function K0(u, f) {
      var M = u.tag;
      if ((u.mode & $i) === Mr && (M === te || M === ve || M === Ee)) {
        var A = u.alternate;
        A ? (u.updateQueue = A.updateQueue, u.memoizedState = A.memoizedState, u.lanes = A.lanes) : (u.updateQueue = null, u.memoizedState = null);
      }
    }
    function Jl(u) {
      var f = u;
      do {
        if (f.tag === he && em(f))
          return f;
        f = f.return;
      } while (f !== null);
      return null;
    }
    function qc(u, f, M, A, z) {
      if ((u.mode & $i) === Mr) {
        if (u === f)
          u.flags |= Ye;
        else {
          if (u.flags |= Bn, M.flags |= $t, M.flags &= ~(ot | Le), Ci && D) {
            var W = u.alternate;
            if (W === null) {
              var ee = u.child, ae = ee.child;
              if (ae !== null) {
                var _e = ae.memoizedProps.children, Ue = xo("hidden", _e);
                ae.pendingProps = Ue, ae.memoizedProps = Ue;
              }
            }
          }
          if (M.tag === Y) {
            var We = M.alternate;
            if (We === null)
              M.tag = Je;
            else {
              var St = Er(Vi, Hr);
              St.tag = vs, Ar(M, St);
            }
          }
          M.lanes = Ur(M.lanes, Hr);
        }
        return u;
      }
      return u.flags |= Ye, u.lanes = z, u;
    }
    function Sb(u, f, M, A, z) {
      if (M.flags |= Le, ns && u0(u, z), A !== null && typeof A == "object" && typeof A.then == "function") {
        var W = A;
        K0(M);
        var ee = Jl(f);
        if (ee !== null) {
          ee.flags &= ~Mi, qc(ee, f, M, u, z), ee.mode & $i && v1(u, W, z), _b(ee, u, W);
          return;
        } else {
          if (!Ia(z)) {
            v1(u, W, z), X1();
            return;
          }
          var ae = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          A = ae;
        }
      } else if (ha() && M.mode & $i) {
        Wm();
        var _e = Jl(f);
        if (_e !== null) {
          (_e.flags & Ye) === Pe && (_e.flags |= Mi), qc(_e, f, M, u, z), ao(A);
          return;
        }
      }
      MT(A), A = Fy(A, M);
      var Ue = f;
      do {
        switch (Ue.tag) {
          case se: {
            var We = A;
            Ue.flags |= Ye;
            var St = du(z);
            Ue.lanes = Ur(Ue.lanes, St);
            var It = ky(Ue, We, St);
            Zr(Ue, It);
            return;
          }
          case Y:
            var Yt = A, pn = Ue.type, Sn = Ue.stateNode;
            if ((Ue.flags & Bn) === Pe && (typeof pn.getDerivedStateFromError == "function" || Sn !== null && typeof Sn.componentDidCatch == "function" && !ZS(Sn))) {
              Ue.flags |= Ye;
              var Tr = du(z);
              Ue.lanes = Ur(Ue.lanes, Tr);
              var vi = tv(Ue, Yt, Tr);
              Zr(Ue, vi);
              return;
            }
            break;
        }
        Ue = Ue.return;
      } while (Ue !== null);
    }
    function wb() {
      return null;
    }
    function bp(u) {
      u.flags |= cn;
    }
    function g1(u) {
      u.flags |= yi, u.flags |= Rn;
    }
    function oS(u, f) {
      var M = u !== null && u.child === f.child;
      if (M)
        return !0;
      if ((f.flags & Or) !== Pe)
        return !1;
      for (var A = f.child; A !== null; ) {
        if ((A.flags & Yi) !== Pe || (A.subtreeFlags & Yi) !== Pe)
          return !1;
        A = A.sibling;
      }
      return !0;
    }
    var Iy, By, Hy, zg;
    if (No)
      Iy = function(u, f, M, A) {
        for (var z = f.child; z !== null; ) {
          if (z.tag === ue || z.tag === Me)
            Ll(u, z.stateNode);
          else if (z.tag !== ce) {
            if (z.child !== null) {
              z.child.return = z, z = z.child;
              continue;
            }
          }
          if (z === f)
            return;
          for (; z.sibling === null; ) {
            if (z.return === null || z.return === f)
              return;
            z = z.return;
          }
          z.sibling.return = z.return, z = z.sibling;
        }
      }, By = function(u, f) {
      }, Hy = function(u, f, M, A, z) {
        var W = u.memoizedProps;
        if (W !== A) {
          var ee = f.stateNode, ae = $p(), _e = Ps(ee, M, W, A, z, ae);
          f.updateQueue = _e, _e && bp(f);
        }
      }, zg = function(u, f, M, A) {
        M !== A && bp(f);
      };
    else if (Ci) {
      Iy = function(u, f, M, A) {
        for (var z = f.child; z !== null; ) {
          if (z.tag === ue) {
            var W = z.stateNode;
            if (M && A) {
              var ee = z.memoizedProps, ae = z.type;
              W = Ru(W, ae, ee, z);
            }
            Ll(u, W);
          } else if (z.tag === Me) {
            var _e = z.stateNode;
            if (M && A) {
              var Ue = z.memoizedProps;
              _e = Ul(_e, Ue, z);
            }
            Ll(u, _e);
          } else if (z.tag !== ce) {
            if (z.tag === tt && z.memoizedState !== null) {
              var We = z.child;
              We !== null && (We.return = z), Iy(u, z, !0, !0);
            } else if (z.child !== null) {
              z.child.return = z, z = z.child;
              continue;
            }
          }
          if (z = z, z === f)
            return;
          for (; z.sibling === null; ) {
            if (z.return === null || z.return === f)
              return;
            z = z.return;
          }
          z.sibling.return = z.return, z = z.sibling;
        }
      };
      var $0 = function(u, f, M, A) {
        for (var z = f.child; z !== null; ) {
          if (z.tag === ue) {
            var W = z.stateNode;
            if (M && A) {
              var ee = z.memoizedProps, ae = z.type;
              W = Ru(W, ae, ee, z);
            }
            uu(u, W);
          } else if (z.tag === Me) {
            var _e = z.stateNode;
            if (M && A) {
              var Ue = z.memoizedProps;
              _e = Ul(_e, Ue, z);
            }
            uu(u, _e);
          } else if (z.tag !== ce) {
            if (z.tag === tt && z.memoizedState !== null) {
              var We = z.child;
              We !== null && (We.return = z), $0(u, z, !0, !0);
            } else if (z.child !== null) {
              z.child.return = z, z = z.child;
              continue;
            }
          }
          if (z = z, z === f)
            return;
          for (; z.sibling === null; ) {
            if (z.return === null || z.return === f)
              return;
            z = z.return;
          }
          z.sibling.return = z.return, z = z.sibling;
        }
      };
      By = function(u, f) {
        var M = f.stateNode, A = oS(u, f);
        if (!A) {
          var z = M.containerInfo, W = xs(z);
          $0(W, f, !1, !1), M.pendingChildren = W, bp(f), Ua(z, W);
        }
      }, Hy = function(u, f, M, A, z) {
        var W = u.stateNode, ee = u.memoizedProps, ae = oS(u, f);
        if (ae && ee === A) {
          f.stateNode = W;
          return;
        }
        var _e = f.stateNode, Ue = $p(), We = null;
        if (ee !== A && (We = Ps(_e, M, ee, A, z, Ue)), ae && We === null) {
          f.stateNode = W;
          return;
        }
        var St = Oa(W, We, M, ee, A, f, ae, _e);
        Nd(St, M, A, z, Ue) && bp(f), f.stateNode = St, ae ? bp(f) : Iy(St, f, !1, !1);
      }, zg = function(u, f, M, A) {
        if (M !== A) {
          var z = Lh(), W = $p();
          f.stateNode = ou(A, z, W, f), bp(f);
        } else
          f.stateNode = u.stateNode;
      };
    } else
      By = function(u, f) {
      }, Hy = function(u, f, M, A, z) {
      }, zg = function(u, f, M, A) {
      };
    function Hv(u, f) {
      if (!ha())
        switch (u.tailMode) {
          case "hidden": {
            for (var M = u.tail, A = null; M !== null; )
              M.alternate !== null && (A = M), M = M.sibling;
            A === null ? u.tail = null : A.sibling = null;
            break;
          }
          case "collapsed": {
            for (var z = u.tail, W = null; z !== null; )
              z.alternate !== null && (W = z), z = z.sibling;
            W === null ? !f && u.tail !== null ? u.tail.sibling = null : u.tail = null : W.sibling = null;
            break;
          }
        }
    }
    function El(u) {
      var f = u.alternate !== null && u.alternate.child === u.child, M = sn, A = Pe;
      if (f) {
        if ((u.mode & Br) !== Mr) {
          for (var _e = u.selfBaseDuration, Ue = u.child; Ue !== null; )
            M = Ur(M, Ur(Ue.lanes, Ue.childLanes)), A |= Ue.subtreeFlags & en, A |= Ue.flags & en, _e += Ue.treeBaseDuration, Ue = Ue.sibling;
          u.treeBaseDuration = _e;
        } else
          for (var We = u.child; We !== null; )
            M = Ur(M, Ur(We.lanes, We.childLanes)), A |= We.subtreeFlags & en, A |= We.flags & en, We.return = u, We = We.sibling;
        u.subtreeFlags |= A;
      } else {
        if ((u.mode & Br) !== Mr) {
          for (var z = u.actualDuration, W = u.selfBaseDuration, ee = u.child; ee !== null; )
            M = Ur(M, Ur(ee.lanes, ee.childLanes)), A |= ee.subtreeFlags, A |= ee.flags, z += ee.actualDuration, W += ee.treeBaseDuration, ee = ee.sibling;
          u.actualDuration = z, u.treeBaseDuration = W;
        } else
          for (var ae = u.child; ae !== null; )
            M = Ur(M, Ur(ae.lanes, ae.childLanes)), A |= ae.subtreeFlags, A |= ae.flags, ae.return = u, ae = ae.sibling;
        u.subtreeFlags |= A;
      }
      return u.childLanes = M, f;
    }
    function y1(u, f, M) {
      var A = f.pendingProps;
      switch (Mv(f), f.tag) {
        case re:
        case Ve:
        case Ee:
        case te:
        case ve:
        case me:
        case De:
        case fe:
        case Re:
        case ye:
          return El(f), null;
        case Y: {
          var z = f.type;
          return ml(z) && _i(f), El(f), null;
        }
        case se: {
          var W = f.stateNode;
          if (Wc(f), Mc(f), Tg(), W.pendingContext && (W.context = W.pendingContext, W.pendingContext = null), u === null || u.child === null) {
            var ee = hp(f);
            if (ee)
              bp(f);
            else if (u !== null) {
              var ae = u.memoizedState;
              (!ae.isDehydrated || (f.flags & Mi) !== Pe) && (f.flags |= ii, pp());
            }
          }
          return By(u, f), El(f), null;
        }
        case ue: {
          Cy(f);
          var _e = Lh(), Ue = f.type;
          if (u !== null && f.stateNode != null)
            Hy(u, f, Ue, A, _e), u.ref !== f.ref && g1(f);
          else {
            if (!A) {
              if (f.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return El(f), null;
            }
            var We = $p(), St = hp(f);
            if (St)
              _g(f, _e, We) && bp(f);
            else {
              var It = Yf(Ue, A, _e, We, f);
              Iy(It, f, !1, !1), f.stateNode = It, Nd(It, Ue, A, _e, We) && bp(f);
            }
            f.ref !== null && g1(f);
          }
          return El(f), null;
        }
        case Me: {
          var Yt = A;
          if (u && f.stateNode != null) {
            var pn = u.memoizedProps;
            zg(u, f, pn, Yt);
          } else {
            if (typeof Yt != "string" && f.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var Sn = Lh(), Tr = $p(), vi = hp(f);
            vi ? Jp(f) && bp(f) : f.stateNode = ou(Yt, Sn, Tr, f);
          }
          return El(f), null;
        }
        case he: {
          Ph(f);
          var Pr = f.memoizedState;
          {
            if (qm() && (f.mode & $i) !== Mr && (f.flags & Bn) === Pe)
              return Cv(f), Gc(), f.flags |= Mi | Le | Ye, f;
            if (Pr !== null && Pr.dehydrated !== null) {
              var lo = hp(f);
              if (u === null) {
                if (!lo)
                  throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
                if ($d(f), El(f), (f.mode & Br) !== Mr) {
                  var uo = Pr !== null;
                  if (uo) {
                    var Ct = f.child;
                    Ct !== null && (f.treeBaseDuration -= Ct.treeBaseDuration);
                  }
                }
                return null;
              } else {
                if (Gc(), (f.flags & Bn) === Pe && (f.memoizedState = null), f.flags |= cn, El(f), (f.mode & Br) !== Mr) {
                  var Jt = Pr !== null;
                  if (Jt) {
                    var Mt = f.child;
                    Mt !== null && (f.treeBaseDuration -= Mt.treeBaseDuration);
                  }
                }
                return null;
              }
            }
            pp();
          }
          if ((f.flags & Bn) !== Pe)
            return f.lanes = M, (f.mode & Br) !== Mr && Ug(f), f;
          var En = Pr !== null, yr = !1;
          if (u === null)
            hp(f);
          else {
            var Nn = u.memoizedState;
            yr = Nn !== null;
          }
          if (En && !yr) {
            var ni = f.child;
            if (ni.flags |= ai, (f.mode & $i) !== Mr) {
              var wa = u === null && (f.memoizedProps.unstable_avoidThisFallback !== !0 || !I);
              wa || Ry(jc.current, F0) ? iE() : X1();
            }
          }
          var ys = f.updateQueue;
          if (ys !== null && (f.flags |= cn), El(f), (f.mode & Br) !== Mr && En) {
            var kn = f.child;
            kn !== null && (f.treeBaseDuration -= kn.treeBaseDuration);
          }
          return null;
        }
        case ce:
          return Wc(f), By(u, f), u === null && xr(f.stateNode.containerInfo), El(f), null;
        case He:
          var as = f.type._context;
          return $(as, f), El(f), null;
        case Je: {
          var ba = f.type;
          return ml(ba) && _i(f), El(f), null;
        }
        case Ne: {
          Ph(f);
          var Ei = f.memoizedState;
          if (Ei === null)
            return El(f), null;
          var Ao = (f.flags & Bn) !== Pe, co = Ei.rendering;
          if (co === null)
            if (Ao)
              Hv(Ei, !1);
            else {
              var rh = aE() && (u === null || (u.flags & Bn) === Pe);
              if (!rh)
                for (var wu = f.child; wu !== null; ) {
                  var ih = yp(wu);
                  if (ih !== null) {
                    Ao = !0, f.flags |= Bn, Hv(Ei, !1);
                    var Fh = ih.updateQueue;
                    return Fh !== null && (f.updateQueue = Fh, f.flags |= cn), f.subtreeFlags = Pe, My(f, M), Bu(f, Pv(jc.current, Zm)), f.child;
                  }
                  wu = wu.sibling;
                }
              Ei.tail !== null && da() > $b() && (f.flags |= Bn, Ao = !0, Hv(Ei, !1), f.lanes = od);
            }
          else {
            if (!Ao) {
              var hv = yp(co);
              if (hv !== null) {
                f.flags |= Bn, Ao = !0;
                var Lx = hv.updateQueue;
                if (Lx !== null && (f.updateQueue = Lx, f.flags |= cn), Hv(Ei, !0), Ei.tail === null && Ei.tailMode === "hidden" && !co.alternate && !ha())
                  return El(f), null;
              } else
                da() * 2 - Ei.renderingStartTime > $b() && M !== Gn && (f.flags |= Bn, Ao = !0, Hv(Ei, !1), f.lanes = od);
            }
            if (Ei.isBackwards)
              co.sibling = f.child, f.child = co;
            else {
              var p0 = Ei.last;
              p0 !== null ? p0.sibling = co : f.child = co, Ei.last = co;
            }
          }
          if (Ei.tail !== null) {
            var ah = Ei.tail;
            Ei.rendering = ah, Ei.tail = ah.sibling, Ei.renderingStartTime = da(), ah.sibling = null;
            var Qv = jc.current;
            return Ao ? Qv = Pv(Qv, Zm) : Qv = wl(Qv), Bu(f, Qv), ah;
          }
          return El(f), null;
        }
        case ct:
          break;
        case tt:
        case Tt: {
          Y1(f);
          var fw = f.memoizedState, s_ = fw !== null;
          if (u !== null) {
            var pv = u.memoizedState, DE = pv !== null;
            DE !== s_ && !H && (f.flags |= ai);
          }
          return !s_ || (f.mode & $i) === Mr ? El(f) : Vr(th, Gn) && (El(f), No && f.subtreeFlags & (At | cn) && (f.flags |= ai)), null;
        }
        case gt:
          return null;
        case ft:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + f.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    var lm = s.ReactCurrentOwner, Qc = !1, x1, Ng, nv, _1, ex, Vv, S1, Vy;
    x1 = {}, Ng = {}, nv = {}, _1 = {}, ex = {}, Vv = !1, S1 = {}, Vy = {};
    function Kl(u, f, M, A) {
      u === null ? f.child = Ey(f, null, M, A) : f.child = Ff(f, u.child, M, A);
    }
    function Gy(u, f, M, A) {
      f.child = Ff(f, u.child, null, A), f.child = Ff(f, null, M, A);
    }
    function Wy(u, f, M, A, z) {
      if (f.type !== f.elementType) {
        var W = M.propTypes;
        W && Io(
          W,
          A,
          "prop",
          st(M)
        );
      }
      var ee = M.render, ae = f.ref, _e, Ue;
      hn(f, z), Nc(f);
      {
        if (lm.current = f, no(!0), _e = Oe(u, f, ee, A, ae, z), Ue = Ge(), f.mode & Fa) {
          li(!0);
          try {
            _e = Oe(u, f, ee, A, ae, z), Ue = Ge();
          } finally {
            li(!1);
          }
        }
        no(!1);
      }
      return cc(), u !== null && !Qc ? (Dt(u, f, z), um(u, f, z)) : (ha() && Ue && Zl(f), f.flags |= Gt, Kl(u, f, _e, z), f.child);
    }
    function Fg(u, f, M, A, z) {
      if (u === null) {
        var W = M.type;
        if (Mx(W) && M.compare === null && M.defaultProps === void 0) {
          var ee = W;
          return ee = ey(W), f.tag = Ee, f.type = ee, C1(f, W), kg(u, f, ee, A, z);
        }
        {
          var ae = W.propTypes;
          ae && Io(
            ae,
            A,
            "prop",
            st(W)
          );
        }
        var _e = Tx(M.type, null, A, f, f.mode, z);
        return _e.ref = f.ref, _e.return = f, f.child = _e, _e;
      }
      {
        var Ue = M.type, We = Ue.propTypes;
        We && Io(
          We,
          A,
          "prop",
          st(Ue)
        );
      }
      var St = u.child, It = Qy(u, z);
      if (!It) {
        var Yt = St.memoizedProps, pn = M.compare;
        if (pn = pn !== null ? pn : aa, pn(Yt, A) && u.ref === f.ref)
          return um(u, f, z);
      }
      f.flags |= Gt;
      var Sn = la(St, A);
      return Sn.ref = f.ref, Sn.return = f, f.child = Sn, Sn;
    }
    function kg(u, f, M, A, z) {
      if (f.type !== f.elementType) {
        var W = f.elementType;
        if (W.$$typeof === oe) {
          var ee = W, ae = ee._payload, _e = ee._init;
          try {
            W = _e(ae);
          } catch {
            W = null;
          }
          var Ue = W && W.propTypes;
          Ue && Io(
            Ue,
            A,
            "prop",
            st(W)
          );
        }
      }
      if (u !== null) {
        var We = u.memoizedProps;
        if (aa(We, A) && u.ref === f.ref && f.type === u.type)
          if (Qc = !1, Qy(u, z))
            (u.flags & $t) !== Pe && (Qc = !0);
          else
            return f.lanes = u.lanes, um(u, f, z);
      }
      return cS(u, f, M, A, z);
    }
    function lS(u, f, M) {
      var A = f.pendingProps, z = A.children, W = u !== null ? u.memoizedState : null;
      if (A.mode === "hidden" || H)
        if ((f.mode & $i) === Mr) {
          var ee = {
            baseLanes: sn,
            cachePool: null
          };
          f.memoizedState = ee, vx(f, M);
        } else if (Vr(M, Gn)) {
          var St = {
            baseLanes: sn,
            cachePool: null
          };
          f.memoizedState = St;
          var It = W !== null ? W.baseLanes : M;
          vx(f, It);
        } else {
          var ae = null, _e;
          if (W !== null) {
            var Ue = W.baseLanes;
            _e = Ur(Ue, M);
          } else
            _e = M;
          f.lanes = f.childLanes = Gn;
          var We = {
            baseLanes: _e,
            cachePool: ae
          };
          return f.memoizedState = We, f.updateQueue = null, vx(f, _e), null;
        }
      else {
        var Yt;
        W !== null ? (Yt = Ur(W.baseLanes, M), f.memoizedState = null) : Yt = M, vx(f, Yt);
      }
      return Kl(u, f, z, M), f.child;
    }
    function w1(u, f, M) {
      var A = f.pendingProps;
      return Kl(u, f, A, M), f.child;
    }
    function b1(u, f, M) {
      var A = f.pendingProps.children;
      return Kl(u, f, A, M), f.child;
    }
    function bb(u, f, M) {
      {
        f.flags |= cn;
        {
          var A = f.stateNode;
          A.effectDuration = 0, A.passiveEffectDuration = 0;
        }
      }
      var z = f.pendingProps, W = z.children;
      return Kl(u, f, W, M), f.child;
    }
    function uS(u, f) {
      var M = f.ref;
      (u === null && M !== null || u !== null && u.ref !== M) && (f.flags |= yi, f.flags |= Rn);
    }
    function cS(u, f, M, A, z) {
      if (f.type !== f.elementType) {
        var W = M.propTypes;
        W && Io(
          W,
          A,
          "prop",
          st(M)
        );
      }
      var ee;
      {
        var ae = ds(f, M, !0);
        ee = Nl(f, ae);
      }
      var _e, Ue;
      hn(f, z), Nc(f);
      {
        if (lm.current = f, no(!0), _e = Oe(u, f, M, A, ee, z), Ue = Ge(), f.mode & Fa) {
          li(!0);
          try {
            _e = Oe(u, f, M, A, ee, z), Ue = Ge();
          } finally {
            li(!1);
          }
        }
        no(!1);
      }
      return cc(), u !== null && !Qc ? (Dt(u, f, z), um(u, f, z)) : (ha() && Ue && Zl(f), f.flags |= Gt, Kl(u, f, _e, z), f.child);
    }
    function fS(u, f, M, A, z) {
      {
        switch (ME(f)) {
          case !1: {
            var W = f.stateNode, ee = f.type, ae = new ee(f.memoizedProps, W.context), _e = ae.state;
            W.updater.enqueueSetState(W, _e, null);
            break;
          }
          case !0: {
            f.flags |= Bn, f.flags |= Ye;
            var Ue = new Error("Simulated error coming from DevTools"), We = du(z);
            f.lanes = Ur(f.lanes, We);
            var St = tv(f, Fy(Ue, f), We);
            Zr(f, St);
            break;
          }
        }
        if (f.type !== f.elementType) {
          var It = M.propTypes;
          It && Io(
            It,
            A,
            "prop",
            st(M)
          );
        }
      }
      var Yt;
      ml(M) ? (Yt = !0, Ca(f)) : Yt = !1, hn(f, z);
      var pn = f.stateNode, Sn;
      pn === null ? (u !== null && (u.alternate = null, f.alternate = null, f.flags |= At), Vm(f, M, A), op(f, M, A, z), Sn = !0) : u === null ? Sn = Gm(f, M, A, z) : Sn = Sy(u, f, M, A, z);
      var Tr = E1(u, f, M, Sn, Yt, z);
      {
        var vi = f.stateNode;
        Sn && vi.props !== A && (Vv || g("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", wt(f) || "a component"), Vv = !0);
      }
      return Tr;
    }
    function E1(u, f, M, A, z, W) {
      uS(u, f);
      var ee = (f.flags & Bn) !== Pe;
      if (!A && !ee)
        return z && Sh(f, M, !1), um(u, f, W);
      var ae = f.stateNode;
      lm.current = f;
      var _e;
      if (ee && typeof M.getDerivedStateFromError != "function")
        _e = null, ev();
      else {
        Nc(f);
        {
          if (no(!0), _e = ae.render(), f.mode & Fa) {
            li(!0);
            try {
              ae.render();
            } finally {
              li(!1);
            }
          }
          no(!1);
        }
        cc();
      }
      return f.flags |= Gt, u !== null && ee ? Gy(u, f, _e, W) : Kl(u, f, _e, W), f.memoizedState = ae.state, z && Sh(f, M, !0), f.child;
    }
    function dS(u) {
      var f = u.stateNode;
      f.pendingContext ? Lu(u, f.pendingContext, f.pendingContext !== f.context) : f.context && Lu(u, f.context, !1), Ty(u, f.containerInfo);
    }
    function Eb(u, f, M) {
      if (dS(f), u === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var A = f.pendingProps, z = f.memoizedState, W = z.element;
      Wr(u, f), md(f, A, null, M);
      var ee = f.memoizedState;
      f.stateNode;
      var ae = ee.element;
      if (fs && z.isDehydrated) {
        var _e = {
          element: ae,
          isDehydrated: !1,
          cache: ee.cache,
          transitions: ee.transitions
        }, Ue = f.updateQueue;
        if (Ue.baseState = _e, f.memoizedState = _e, f.flags & Mi) {
          var We = new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering.");
          return hS(u, f, ae, M, We);
        } else if (ae !== W) {
          var St = new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering.");
          return hS(u, f, ae, M, St);
        } else {
          ol(f);
          var It = Ey(f, null, ae, M);
          f.child = It;
          for (var Yt = It; Yt; )
            Yt.flags = Yt.flags & ~At | xi, Yt = Yt.sibling;
        }
      } else {
        if (Gc(), ae === W)
          return um(u, f, M);
        Kl(u, f, ae, M);
      }
      return f.child;
    }
    function hS(u, f, M, A, z) {
      return Gc(), ao(z), f.flags |= Mi, Kl(u, f, M, A), f.child;
    }
    function Mb(u, f, M) {
      Bs(f), u === null && xd(f);
      var A = f.type, z = f.pendingProps, W = u !== null ? u.memoizedProps : null, ee = z.children, ae = Ju(A, z);
      return ae ? ee = null : W !== null && Ju(A, W) && (f.flags |= Ii), uS(u, f), Kl(u, f, ee, M), f.child;
    }
    function M1(u, f) {
      return u === null && xd(f), null;
    }
    function Tb(u, f, M, A) {
      u !== null && (u.alternate = null, f.alternate = null, f.flags |= At);
      var z = f.pendingProps, W = M, ee = W._payload, ae = W._init, _e = ae(ee);
      f.type = _e;
      var Ue = f.tag = f0(_e), We = ti(_e, z), St;
      switch (Ue) {
        case te:
          return C1(f, _e), f.type = _e = ey(_e), St = cS(null, f, _e, We, A), St;
        case Y:
          return f.type = _e = mE(_e), St = fS(null, f, _e, We, A), St;
        case ve:
          return f.type = _e = uv(_e), St = Wy(null, f, _e, We, A), St;
        case ye: {
          if (f.type !== f.elementType) {
            var It = _e.propTypes;
            It && Io(
              It,
              We,
              "prop",
              st(_e)
            );
          }
          return St = Fg(
            null,
            f,
            _e,
            ti(_e.type, We),
            A
          ), St;
        }
      }
      var Yt = "";
      throw _e !== null && typeof _e == "object" && _e.$$typeof === oe && (Yt = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + _e + ". " + ("Lazy element type must resolve to a class or function." + Yt));
    }
    function Cb(u, f, M, A, z) {
      u !== null && (u.alternate = null, f.alternate = null, f.flags |= At), f.tag = Y;
      var W;
      return ml(M) ? (W = !0, Ca(f)) : W = !1, hn(f, z), Vm(f, M, A), op(f, M, A, z), E1(null, f, M, !0, W, z);
    }
    function T1(u, f, M, A) {
      u !== null && (u.alternate = null, f.alternate = null, f.flags |= At);
      var z = f.pendingProps, W;
      {
        var ee = ds(f, M, !1);
        W = Nl(f, ee);
      }
      hn(f, A);
      var ae, _e;
      Nc(f);
      {
        if (M.prototype && typeof M.prototype.render == "function") {
          var Ue = st(M) || "Unknown";
          x1[Ue] || (g("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", Ue, Ue), x1[Ue] = !0);
        }
        f.mode & Fa && Ql.recordLegacyContextWarning(f, null), no(!0), lm.current = f, ae = Oe(null, f, M, z, W, A), _e = Ge(), no(!1);
      }
      if (cc(), f.flags |= Gt, typeof ae == "object" && ae !== null && typeof ae.render == "function" && ae.$$typeof === void 0) {
        var We = st(M) || "Unknown";
        Ng[We] || (g("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", We, We, We), Ng[We] = !0);
      }
      if (typeof ae == "object" && ae !== null && typeof ae.render == "function" && ae.$$typeof === void 0) {
        {
          var St = st(M) || "Unknown";
          Ng[St] || (g("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", St, St, St), Ng[St] = !0);
        }
        f.tag = Y, f.memoizedState = null, f.updateQueue = null;
        var It = !1;
        return ml(M) ? (It = !0, Ca(f)) : It = !1, f.memoizedState = ae.state !== null && ae.state !== void 0 ? ae.state : null, jn(f), Ch(f, ae), op(f, M, z, A), E1(null, f, M, !0, It, A);
      } else {
        if (f.tag = te, f.mode & Fa) {
          li(!0);
          try {
            ae = Oe(null, f, M, z, W, A), _e = Ge();
          } finally {
            li(!1);
          }
        }
        return ha() && _e && Zl(f), Kl(null, f, ae, A), C1(f, M), f.child;
      }
    }
    function C1(u, f) {
      {
        if (f && f.childContextTypes && g("%s(...): childContextTypes cannot be defined on a function component.", f.displayName || f.name || "Component"), u.ref !== null) {
          var M = "", A = ip();
          A && (M += `

Check the render method of \`` + A + "`.");
          var z = A || "", W = u._debugSource;
          W && (z = W.fileName + ":" + W.lineNumber), ex[z] || (ex[z] = !0, g("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", M));
        }
        if (typeof f.getDerivedStateFromProps == "function") {
          var ee = st(f) || "Unknown";
          _1[ee] || (g("%s: Function components do not support getDerivedStateFromProps.", ee), _1[ee] = !0);
        }
        if (typeof f.contextType == "object" && f.contextType !== null) {
          var ae = st(f) || "Unknown";
          nv[ae] || (g("%s: Function components do not support contextType.", ae), nv[ae] = !0);
        }
      }
    }
    var Ig = {
      dehydrated: null,
      treeContext: null,
      retryLane: kr
    };
    function jy(u) {
      return {
        baseLanes: u,
        cachePool: wb()
      };
    }
    function pS(u, f) {
      var M = null;
      return {
        baseLanes: Ur(u.baseLanes, f),
        cachePool: M
      };
    }
    function Rb(u, f, M, A) {
      if (f !== null) {
        var z = f.memoizedState;
        if (z === null)
          return !1;
      }
      return Ry(u, Zm);
    }
    function mS(u, f) {
      return $s(u.childLanes, f);
    }
    function tx(u, f, M) {
      var A = f.pendingProps;
      CE(f) && (f.flags |= Bn);
      var z = jc.current, W = !1, ee = (f.flags & Bn) !== Pe;
      if (ee || Rb(z, u) ? (W = !0, f.flags &= ~Bn) : (u === null || u.memoizedState !== null) && (z = Mg(z, F0)), z = wl(z), Bu(f, z), u === null) {
        xd(f);
        {
          var ae = f.memoizedState;
          if (ae !== null) {
            var _e = ae.dehydrated;
            if (_e !== null)
              return A1(f, _e);
          }
        }
        var Ue = A.children, We = A.fallback;
        if (W) {
          var St = vS(f, Ue, We, M), It = f.child;
          return It.memoizedState = jy(M), f.memoizedState = Ig, St;
        } else
          return Yy(f, Ue);
      } else {
        var Yt = u.memoizedState;
        if (Yt !== null) {
          {
            var pn = Yt.dehydrated;
            if (pn !== null)
              if (ee) {
                if (f.flags & Mi)
                  return f.flags &= ~Mi, rx(u, f, M, new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
                if (f.memoizedState !== null)
                  return f.child = u.child, f.flags |= Bn, null;
                var Sn = A.children, Tr = A.fallback, vi = Ab(u, f, Sn, Tr, M), Pr = f.child;
                return Pr.memoizedState = jy(M), f.memoizedState = Ig, vi;
              } else
                return Vf(u, f, pn, Yt, M);
          }
          if (W) {
            var lo = A.fallback, uo = A.children, Ct = nx(u, f, uo, lo, M), Jt = f.child, Mt = u.child.memoizedState;
            return Jt.memoizedState = Mt === null ? jy(M) : pS(Mt, M), Jt.childLanes = mS(u, M), f.memoizedState = Ig, Ct;
          } else {
            var En = A.children, yr = yS(u, f, En, M);
            return f.memoizedState = null, yr;
          }
        } else if (W) {
          var Nn = A.fallback, ni = A.children, wa = nx(u, f, ni, Nn, M), ys = f.child, kn = u.child.memoizedState;
          return ys.memoizedState = kn === null ? jy(M) : pS(kn, M), ys.childLanes = mS(u, M), f.memoizedState = Ig, wa;
        } else {
          var as = A.children, ba = yS(u, f, as, M);
          return f.memoizedState = null, ba;
        }
      }
    }
    function Yy(u, f, M) {
      var A = u.mode, z = {
        mode: "visible",
        children: f
      }, W = R1(z, A);
      return W.return = u, u.child = W, W;
    }
    function vS(u, f, M, A) {
      var z = u.mode, W = u.child, ee = {
        mode: "hidden",
        children: f
      }, ae, _e;
      return (z & $i) === Mr && W !== null ? (ae = W, ae.childLanes = sn, ae.pendingProps = ee, u.mode & Br && (ae.actualDuration = 0, ae.actualStartTime = -1, ae.selfBaseDuration = 0, ae.treeBaseDuration = 0), _e = Rp(M, z, A, null)) : (ae = R1(ee, z), _e = Rp(M, z, A, null)), ae.return = u, _e.return = u, ae.sibling = _e, u.child = ae, _e;
    }
    function R1(u, f, M) {
      return Nh(u, f, sn, null);
    }
    function gS(u, f) {
      return la(u, f);
    }
    function yS(u, f, M, A) {
      var z = u.child, W = z.sibling, ee = gS(z, {
        mode: "visible",
        children: M
      });
      if ((f.mode & $i) === Mr && (ee.lanes = A), ee.return = f, ee.sibling = null, W !== null) {
        var ae = f.deletions;
        ae === null ? (f.deletions = [W], f.flags |= Or) : ae.push(W);
      }
      return f.child = ee, ee;
    }
    function nx(u, f, M, A, z) {
      var W = f.mode, ee = u.child, ae = ee.sibling, _e = {
        mode: "hidden",
        children: M
      }, Ue;
      if ((W & $i) === Mr && f.child !== ee) {
        var We = f.child;
        Ue = We, Ue.childLanes = sn, Ue.pendingProps = _e, f.mode & Br && (Ue.actualDuration = 0, Ue.actualStartTime = -1, Ue.selfBaseDuration = ee.selfBaseDuration, Ue.treeBaseDuration = ee.treeBaseDuration), f.deletions = null;
      } else
        Ue = gS(ee, _e), Ue.subtreeFlags = ee.subtreeFlags & en;
      var St;
      return ae !== null ? St = la(ae, A) : (St = Rp(A, W, z, null), St.flags |= At), St.return = f, Ue.return = f, Ue.sibling = St, f.child = Ue, St;
    }
    function rx(u, f, M, A) {
      A !== null && ao(A), Ff(f, u.child, null, M);
      var z = f.pendingProps, W = z.children, ee = Yy(f, W);
      return ee.flags |= At, f.memoizedState = null, ee;
    }
    function Ab(u, f, M, A, z) {
      var W = f.mode, ee = {
        mode: "visible",
        children: M
      }, ae = R1(ee, W), _e = Rp(A, W, z, null);
      return _e.flags |= At, ae.return = f, _e.return = f, ae.sibling = _e, f.child = ae, (f.mode & $i) !== Mr && Ff(f, u.child, null, z), _e;
    }
    function A1(u, f, M) {
      return (u.mode & $i) === Mr ? (g("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), u.lanes = Hr) : va(f) ? u.lanes = ac : u.lanes = Gn, null;
    }
    function Vf(u, f, M, A, z) {
      if (Vc(), (f.mode & $i) === Mr)
        return rx(
          u,
          f,
          z,
          null
        );
      if (va(M))
        return rx(
          u,
          f,
          z,
          new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.")
        );
      var W = Vr(z, u.childLanes);
      if (Qc || W) {
        var ee = BS();
        if (ee !== null) {
          var ae = yl(ee, z);
          if (ae !== kr && ae !== A.retryLane) {
            A.retryLane = ae;
            var _e = Vi;
            Tl(u, ae, _e);
          }
        }
        return X1(), rx(u, f, z, new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
      } else if (_s(M)) {
        f.flags |= Bn, f.child = u.child;
        var Ue = AT.bind(null, u);
        return Zs(M, Ue), null;
      } else {
        jm(f, M, A.treeContext);
        var We = f.pendingProps, St = We.children, It = Yy(f, St);
        return It.flags |= xi, It;
      }
    }
    function ix(u, f, M) {
      u.lanes = Ur(u.lanes, f);
      var A = u.alternate;
      A !== null && (A.lanes = Ur(A.lanes, f)), Ae(u.return, f, M);
    }
    function Db(u, f, M) {
      for (var A = f; A !== null; ) {
        if (A.tag === he) {
          var z = A.memoizedState;
          z !== null && ix(A, M, u);
        } else if (A.tag === Ne)
          ix(A, M, u);
        else if (A.child !== null) {
          A.child.return = A, A = A.child;
          continue;
        }
        if (A === u)
          return;
        for (; A.sibling === null; ) {
          if (A.return === null || A.return === u)
            return;
          A = A.return;
        }
        A.sibling.return = A.return, A = A.sibling;
      }
    }
    function Lb(u) {
      for (var f = u, M = null; f !== null; ) {
        var A = f.alternate;
        A !== null && yp(A) === null && (M = f), f = f.sibling;
      }
      return M;
    }
    function Pb(u) {
      if (u !== void 0 && u !== "forwards" && u !== "backwards" && u !== "together" && !S1[u])
        if (S1[u] = !0, typeof u == "string")
          switch (u.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              g('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', u, u.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              g('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', u, u.toLowerCase());
              break;
            }
            default:
              g('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', u);
              break;
          }
        else
          g('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', u);
    }
    function Ob(u, f) {
      u !== void 0 && !Vy[u] && (u !== "collapsed" && u !== "hidden" ? (Vy[u] = !0, g('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', u)) : f !== "forwards" && f !== "backwards" && (Vy[u] = !0, g('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', u)));
    }
    function ax(u, f) {
      {
        var M = Ti(u), A = !M && typeof pe(u) == "function";
        if (M || A) {
          var z = M ? "array" : "iterable";
          return g("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", z, f, z), !1;
        }
      }
      return !0;
    }
    function Ub(u, f) {
      if ((f === "forwards" || f === "backwards") && u !== void 0 && u !== null && u !== !1)
        if (Ti(u)) {
          for (var M = 0; M < u.length; M++)
            if (!ax(u[M], M))
              return;
        } else {
          var A = pe(u);
          if (typeof A == "function") {
            var z = A.call(u);
            if (z)
              for (var W = z.next(), ee = 0; !W.done; W = z.next()) {
                if (!ax(W.value, ee))
                  return;
                ee++;
              }
          } else
            g('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', f);
        }
    }
    function Xy(u, f, M, A, z) {
      var W = u.memoizedState;
      W === null ? u.memoizedState = {
        isBackwards: f,
        rendering: null,
        renderingStartTime: 0,
        last: A,
        tail: M,
        tailMode: z
      } : (W.isBackwards = f, W.rendering = null, W.renderingStartTime = 0, W.last = A, W.tail = M, W.tailMode = z);
    }
    function D1(u, f, M) {
      var A = f.pendingProps, z = A.revealOrder, W = A.tail, ee = A.children;
      Pb(z), Ob(W, z), Ub(ee, z), Kl(u, f, ee, M);
      var ae = jc.current, _e = Ry(ae, Zm);
      if (_e)
        ae = Pv(ae, Zm), f.flags |= Bn;
      else {
        var Ue = u !== null && (u.flags & Bn) !== Pe;
        Ue && Db(f, f.child, M), ae = wl(ae);
      }
      if (Bu(f, ae), (f.mode & $i) === Mr)
        f.memoizedState = null;
      else
        switch (z) {
          case "forwards": {
            var We = Lb(f.child), St;
            We === null ? (St = f.child, f.child = null) : (St = We.sibling, We.sibling = null), Xy(
              f,
              !1,
              St,
              We,
              W
            );
            break;
          }
          case "backwards": {
            var It = null, Yt = f.child;
            for (f.child = null; Yt !== null; ) {
              var pn = Yt.alternate;
              if (pn !== null && yp(pn) === null) {
                f.child = Yt;
                break;
              }
              var Sn = Yt.sibling;
              Yt.sibling = It, It = Yt, Yt = Sn;
            }
            Xy(
              f,
              !0,
              It,
              null,
              W
            );
            break;
          }
          case "together": {
            Xy(
              f,
              !1,
              null,
              null,
              void 0
            );
            break;
          }
          default:
            f.memoizedState = null;
        }
      return f.child;
    }
    function L1(u, f, M) {
      Ty(f, f.stateNode.containerInfo);
      var A = f.pendingProps;
      return u === null ? f.child = Ff(f, null, A, M) : Kl(u, f, A, M), f.child;
    }
    var xS = !1;
    function zb(u, f, M) {
      var A = f.type, z = A._context, W = f.pendingProps, ee = f.memoizedProps, ae = W.value;
      {
        "value" in W || xS || (xS = !0, g("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var _e = f.type.propTypes;
        _e && Io(_e, W, "prop", "Context.Provider");
      }
      if (X(f, z, ae), ee !== null) {
        var Ue = ee.value;
        if (Eo(Ue, ae)) {
          if (ee.children === W.children && !$a())
            return um(u, f, M);
        } else
          $e(f, z, M);
      }
      var We = W.children;
      return Kl(u, f, We, M), f.child;
    }
    var Bg = !1;
    function qy(u, f, M) {
      var A = f.type;
      A._context === void 0 ? A !== A.Consumer && (Bg || (Bg = !0, g("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : A = A._context;
      var z = f.pendingProps, W = z.children;
      typeof W != "function" && g("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), hn(f, M);
      var ee = wn(A);
      Nc(f);
      var ae;
      return lm.current = f, no(!0), ae = W(ee), no(!1), cc(), f.flags |= Gt, Kl(u, f, ae, M), f.child;
    }
    function sx() {
      Qc = !0;
    }
    function um(u, f, M) {
      return u !== null && (f.dependencies = u.dependencies), ev(), gx(f.lanes), Vr(M, f.childLanes) ? (bg(u, f), f.child) : null;
    }
    function P1(u, f, M) {
      {
        var A = f.return;
        if (A === null)
          throw new Error("Cannot swap the root fiber.");
        if (u.alternate = null, f.alternate = null, M.index = f.index, M.sibling = f.sibling, M.return = f.return, M.ref = f.ref, f === A.child)
          A.child = M;
        else {
          var z = A.child;
          if (z === null)
            throw new Error("Expected parent to have a child.");
          for (; z.sibling !== f; )
            if (z = z.sibling, z === null)
              throw new Error("Expected to find the previous sibling.");
          z.sibling = M;
        }
        var W = A.deletions;
        return W === null ? (A.deletions = [u], A.flags |= Or) : W.push(u), M.flags |= At, M;
      }
    }
    function Qy(u, f) {
      var M = u.lanes;
      return !!Vr(M, f);
    }
    function Nb(u, f, M) {
      switch (f.tag) {
        case se:
          dS(f), f.stateNode, Gc();
          break;
        case ue:
          Bs(f);
          break;
        case Y: {
          var A = f.type;
          ml(A) && Ca(f);
          break;
        }
        case ce:
          Ty(f, f.stateNode.containerInfo);
          break;
        case He: {
          var z = f.memoizedProps.value, W = f.type._context;
          X(f, W, z);
          break;
        }
        case fe:
          {
            var ee = Vr(M, f.childLanes);
            ee && (f.flags |= cn);
            {
              var ae = f.stateNode;
              ae.effectDuration = 0, ae.passiveEffectDuration = 0;
            }
          }
          break;
        case he: {
          var _e = f.memoizedState;
          if (_e !== null) {
            if (_e.dehydrated !== null)
              return Bu(f, wl(jc.current)), f.flags |= Bn, null;
            var Ue = f.child, We = Ue.childLanes;
            if (Vr(M, We))
              return tx(u, f, M);
            Bu(f, wl(jc.current));
            var St = um(u, f, M);
            return St !== null ? St.sibling : null;
          } else
            Bu(f, wl(jc.current));
          break;
        }
        case Ne: {
          var It = (u.flags & Bn) !== Pe, Yt = Vr(M, f.childLanes);
          if (It) {
            if (Yt)
              return D1(u, f, M);
            f.flags |= Bn;
          }
          var pn = f.memoizedState;
          if (pn !== null && (pn.rendering = null, pn.tail = null, pn.lastEffect = null), Bu(f, jc.current), Yt)
            break;
          return null;
        }
        case tt:
        case Tt:
          return f.lanes = sn, lS(u, f, M);
      }
      return um(u, f, M);
    }
    function _S(u, f, M) {
      if (f._debugNeedsRemount && u !== null)
        return P1(u, f, Tx(f.type, f.key, f.pendingProps, f._debugOwner || null, f.mode, f.lanes));
      if (u !== null) {
        var A = u.memoizedProps, z = f.pendingProps;
        if (A !== z || $a() || f.type !== u.type)
          Qc = !0;
        else {
          var W = Qy(u, M);
          if (!W && (f.flags & Bn) === Pe)
            return Qc = !1, Nb(u, f, M);
          (u.flags & $t) !== Pe ? Qc = !0 : Qc = !1;
        }
      } else if (Qc = !1, ha() && vd(f)) {
        var ee = f.index, ae = Nf();
        yg(f, ae, ee);
      }
      switch (f.lanes = sn, f.tag) {
        case re:
          return T1(u, f, f.type, M);
        case Ve: {
          var _e = f.elementType;
          return Tb(u, f, _e, M);
        }
        case te: {
          var Ue = f.type, We = f.pendingProps, St = f.elementType === Ue ? We : ti(Ue, We);
          return cS(u, f, Ue, St, M);
        }
        case Y: {
          var It = f.type, Yt = f.pendingProps, pn = f.elementType === It ? Yt : ti(It, Yt);
          return fS(u, f, It, pn, M);
        }
        case se:
          return Eb(u, f, M);
        case ue:
          return Mb(u, f, M);
        case Me:
          return M1(u, f);
        case he:
          return tx(u, f, M);
        case ce:
          return L1(u, f, M);
        case ve: {
          var Sn = f.type, Tr = f.pendingProps, vi = f.elementType === Sn ? Tr : ti(Sn, Tr);
          return Wy(u, f, Sn, vi, M);
        }
        case me:
          return w1(u, f, M);
        case De:
          return b1(u, f, M);
        case fe:
          return bb(u, f, M);
        case He:
          return zb(u, f, M);
        case Re:
          return qy(u, f, M);
        case ye: {
          var Pr = f.type, lo = f.pendingProps, uo = ti(Pr, lo);
          if (f.type !== f.elementType) {
            var Ct = Pr.propTypes;
            Ct && Io(
              Ct,
              uo,
              "prop",
              st(Pr)
            );
          }
          return uo = ti(Pr.type, uo), Fg(u, f, Pr, uo, M);
        }
        case Ee:
          return kg(u, f, f.type, f.pendingProps, M);
        case Je: {
          var Jt = f.type, Mt = f.pendingProps, En = f.elementType === Jt ? Mt : ti(Jt, Mt);
          return Cb(u, f, Jt, En, M);
        }
        case Ne:
          return D1(u, f, M);
        case ct:
          break;
        case tt:
          return lS(u, f, M);
      }
      throw new Error("Unknown unit of work tag (" + f.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function Fb(u, f, M) {
      switch (Mv(f), f.tag) {
        case Y: {
          var A = f.type;
          ml(A) && _i(f);
          var z = f.flags;
          return z & Ye ? (f.flags = z & ~Ye | Bn, (f.mode & Br) !== Mr && Ug(f), f) : null;
        }
        case se: {
          Wc(f), Mc(f), Tg();
          var W = f.flags;
          return (W & Ye) !== Pe && (W & Bn) === Pe ? (f.flags = W & ~Ye | Bn, f) : null;
        }
        case ue:
          return Cy(f), null;
        case he: {
          Ph(f);
          {
            var ee = f.memoizedState;
            if (ee !== null && ee.dehydrated !== null) {
              if (f.alternate === null)
                throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
              Gc();
            }
          }
          var ae = f.flags;
          return ae & Ye ? (f.flags = ae & ~Ye | Bn, (f.mode & Br) !== Mr && Ug(f), f) : null;
        }
        case Ne:
          return Ph(f), null;
        case ce:
          return Wc(f), null;
        case He:
          var _e = f.type._context;
          return $(_e, f), null;
        case tt:
        case Tt:
          return Y1(f), null;
        case gt:
          return null;
        default:
          return null;
      }
    }
    function O1(u, f, M) {
      switch (Mv(f), f.tag) {
        case Y: {
          var A = f.type.childContextTypes;
          A != null && _i(f);
          break;
        }
        case se: {
          Wc(f), Mc(f), Tg();
          break;
        }
        case ue: {
          Cy(f);
          break;
        }
        case ce:
          Wc(f);
          break;
        case he:
          Ph(f);
          break;
        case Ne:
          Ph(f);
          break;
        case He:
          var z = f.type._context;
          $(z, f);
          break;
        case tt:
        case Tt:
          Y1(f);
          break;
      }
    }
    function SS(u, f, M, A, z, W, ee, ae, _e) {
      var Ue = Array.prototype.slice.call(arguments, 3);
      try {
        f.apply(M, Ue);
      } catch (We) {
        this.onError(We);
      }
    }
    var wS = SS;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var U1 = document.createElement("react");
      wS = function(f, M, A, z, W, ee, ae, _e, Ue) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var We = document.createEvent("Event"), St = !1, It = !0, Yt = window.event, pn = Object.getOwnPropertyDescriptor(window, "event");
        function Sn() {
          U1.removeEventListener(Jt, vi, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = Yt);
        }
        var Tr = Array.prototype.slice.call(arguments, 3);
        function vi() {
          St = !0, Sn(), M.apply(A, Tr), It = !1;
        }
        var Pr, lo = !1, uo = !1;
        function Ct(Mt) {
          if (Pr = Mt.error, lo = !0, Pr === null && Mt.colno === 0 && Mt.lineno === 0 && (uo = !0), Mt.defaultPrevented && Pr != null && typeof Pr == "object")
            try {
              Pr._suppressLogging = !0;
            } catch {
            }
        }
        var Jt = "react-" + (f || "invokeguardedcallback");
        if (window.addEventListener("error", Ct), U1.addEventListener(Jt, vi, !1), We.initEvent(Jt, !1, !1), U1.dispatchEvent(We), pn && Object.defineProperty(window, "event", pn), St && It && (lo ? uo && (Pr = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : Pr = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(Pr)), window.removeEventListener("error", Ct), !St)
          return Sn(), SS.apply(this, arguments);
      };
    }
    var kb = wS, Zy = !1, ox = null, Ib = {
      onError: function(u) {
        Zy = !0, ox = u;
      }
    };
    function bS(u, f, M, A, z, W, ee, ae, _e) {
      Zy = !1, ox = null, kb.apply(Ib, arguments);
    }
    function Bb() {
      return Zy;
    }
    function ES() {
      if (Zy) {
        var u = ox;
        return Zy = !1, ox = null, u;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    var MS = null;
    MS = /* @__PURE__ */ new Set();
    var lx = !1, rv = !1, Hb = typeof WeakSet == "function" ? WeakSet : Set, Vn = null, Hg = null, zh = null;
    function v(u) {
      bS(null, function() {
        throw u;
      }), ES();
    }
    var b = function(u, f) {
      if (f.props = u.memoizedProps, f.state = u.memoizedState, u.mode & Br)
        try {
          vc(), f.componentWillUnmount();
        } finally {
          Hf(u);
        }
      else
        f.componentWillUnmount();
    };
    function N(u, f) {
      try {
        dr(Cs, u);
      } catch (M) {
        v(M), tu(u, f, M);
      }
    }
    function Z(u, f, M) {
      try {
        b(u, M);
      } catch (A) {
        v(A), tu(u, f, A);
      }
    }
    function ie(u, f, M) {
      try {
        M.componentDidMount();
      } catch (A) {
        v(A), tu(u, f, A);
      }
    }
    function be(u, f) {
      try {
        Gu(u);
      } catch (M) {
        v(M), tu(u, f, M);
      }
    }
    function ke(u, f) {
      var M = u.ref;
      if (M !== null)
        if (typeof M == "function") {
          var A;
          try {
            if (Q && K && u.mode & Br)
              try {
                vc(), A = M(null);
              } finally {
                Hf(u);
              }
            else
              A = M(null);
          } catch (z) {
            v(z), tu(u, f, z);
          }
          typeof A == "function" && g("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", wt(u));
        } else
          M.current = null;
    }
    function je(u, f, M) {
      try {
        M();
      } catch (A) {
        v(A), tu(u, f, A);
      }
    }
    var lt = !1;
    function nn(u, f) {
      Dl(u.containerInfo), Vn = f, Kt();
      var M = lt;
      return lt = !1, M;
    }
    function Kt() {
      for (; Vn !== null; ) {
        var u = Vn, f = u.child;
        (u.subtreeFlags & wr) !== Pe && f !== null ? (Tp(f, u), Vn = f) : on();
      }
    }
    function on() {
      for (; Vn !== null; ) {
        var u = Vn;
        bi(u);
        try {
          Cn(u);
        } catch (M) {
          v(M), tu(u, u.return, M);
        }
        Ms();
        var f = u.sibling;
        if (f !== null) {
          Tp(f, u.return), Vn = f;
          return;
        }
        Vn = u.return;
      }
    }
    function Cn(u) {
      var f = u.alternate, M = u.flags;
      if ((M & ii) !== Pe) {
        switch (bi(u), u.tag) {
          case te:
          case ve:
          case Ee:
            break;
          case Y: {
            if (f !== null) {
              var A = f.memoizedProps, z = f.memoizedState, W = u.stateNode;
              u.type === u.elementType && !Vv && (W.props !== u.memoizedProps && g("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", wt(u) || "instance"), W.state !== u.memoizedState && g("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", wt(u) || "instance"));
              var ee = W.getSnapshotBeforeUpdate(u.elementType === u.type ? A : ti(u.type, A), z);
              {
                var ae = MS;
                ee === void 0 && !ae.has(u.type) && (ae.add(u.type), g("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", wt(u)));
              }
              W.__reactInternalSnapshotBeforeUpdate = ee;
            }
            break;
          }
          case se: {
            if (No) {
              var _e = u.stateNode;
              Cu(_e.containerInfo);
            }
            break;
          }
          case ue:
          case Me:
          case ce:
          case Je:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        Ms();
      }
    }
    function On(u, f, M) {
      var A = f.updateQueue, z = A !== null ? A.lastEffect : null;
      if (z !== null) {
        var W = z.next, ee = W;
        do {
          if ((ee.tag & u) === u) {
            var ae = ee.destroy;
            ee.destroy = void 0, ae !== void 0 && ((u & bl) !== mc ? al(f) : (u & Cs) !== mc && Cf(f), je(f, M, ae), (u & bl) !== mc ? Bm() : (u & Cs) !== mc && Wl());
          }
          ee = ee.next;
        } while (ee !== W);
      }
    }
    function dr(u, f) {
      var M = f.updateQueue, A = M !== null ? M.lastEffect : null;
      if (A !== null) {
        var z = A.next, W = z;
        do {
          if ((W.tag & u) === u) {
            (u & bl) !== mc ? Qd(f) : (u & Cs) !== mc && Tf(f);
            var ee = W.create;
            W.destroy = ee(), (u & bl) !== mc ? cd() : (u & Cs) !== mc && Zd();
            {
              var ae = W.destroy;
              if (ae !== void 0 && typeof ae != "function") {
                var _e = void 0;
                (W.tag & Cs) !== Pe ? _e = "useLayoutEffect" : (W.tag & xp) !== Pe ? _e = "useInsertionEffect" : _e = "useEffect";
                var Ue = void 0;
                ae === null ? Ue = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof ae.then == "function" ? Ue = `

It looks like you wrote ` + _e + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + _e + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : Ue = " You returned: " + ae, g("%s must not return anything besides a function, which is used for clean-up.%s", _e, Ue);
              }
            }
          }
          W = W.next;
        } while (W !== z);
      }
    }
    function mi(u, f) {
      if ((f.flags & cn) !== Pe)
        switch (f.tag) {
          case fe: {
            var M = f.stateNode.passiveEffectDuration, A = f.memoizedProps, z = A.id, W = A.onPostCommit, ee = sm(), ae = f.alternate === null ? "mount" : "update";
            Da() && (ae = "nested-update"), typeof W == "function" && W(z, ae, M, ee);
            var _e = f.return;
            e:
              for (; _e !== null; ) {
                switch (_e.tag) {
                  case se:
                    var Ue = _e.stateNode;
                    Ue.passiveEffectDuration += M;
                    break e;
                  case fe:
                    var We = _e.stateNode;
                    We.passiveEffectDuration += M;
                    break e;
                }
                _e = _e.return;
              }
            break;
          }
        }
    }
    function Fr(u, f, M, A) {
      if ((M.flags & La) !== Pe)
        switch (M.tag) {
          case te:
          case ve:
          case Ee: {
            if (!rv)
              if (M.mode & Br)
                try {
                  vc(), dr(Cs | Aa, M);
                } finally {
                  Hf(M);
                }
              else
                dr(Cs | Aa, M);
            break;
          }
          case Y: {
            var z = M.stateNode;
            if (M.flags & cn && !rv)
              if (f === null)
                if (M.type === M.elementType && !Vv && (z.props !== M.memoizedProps && g("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", wt(M) || "instance"), z.state !== M.memoizedState && g("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", wt(M) || "instance")), M.mode & Br)
                  try {
                    vc(), z.componentDidMount();
                  } finally {
                    Hf(M);
                  }
                else
                  z.componentDidMount();
              else {
                var W = M.elementType === M.type ? f.memoizedProps : ti(M.type, f.memoizedProps), ee = f.memoizedState;
                if (M.type === M.elementType && !Vv && (z.props !== M.memoizedProps && g("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", wt(M) || "instance"), z.state !== M.memoizedState && g("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", wt(M) || "instance")), M.mode & Br)
                  try {
                    vc(), z.componentDidUpdate(W, ee, z.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    Hf(M);
                  }
                else
                  z.componentDidUpdate(W, ee, z.__reactInternalSnapshotBeforeUpdate);
              }
            var ae = M.updateQueue;
            ae !== null && (M.type === M.elementType && !Vv && (z.props !== M.memoizedProps && g("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", wt(M) || "instance"), z.state !== M.memoizedState && g("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", wt(M) || "instance")), Hm(M, ae, z));
            break;
          }
          case se: {
            var _e = M.updateQueue;
            if (_e !== null) {
              var Ue = null;
              if (M.child !== null)
                switch (M.child.tag) {
                  case ue:
                    Ue = Uo(M.child.stateNode);
                    break;
                  case Y:
                    Ue = M.child.stateNode;
                    break;
                }
              Hm(M, _e, Ue);
            }
            break;
          }
          case ue: {
            var We = M.stateNode;
            if (f === null && M.flags & cn) {
              var St = M.type, It = M.memoizedProps;
              Hi(We, St, It, M);
            }
            break;
          }
          case Me:
            break;
          case ce:
            break;
          case fe: {
            {
              var Yt = M.memoizedProps, pn = Yt.onCommit, Sn = Yt.onRender, Tr = M.stateNode.effectDuration, vi = sm(), Pr = f === null ? "mount" : "update";
              Da() && (Pr = "nested-update"), typeof Sn == "function" && Sn(M.memoizedProps.id, Pr, M.actualDuration, M.treeBaseDuration, M.actualStartTime, vi);
              {
                typeof pn == "function" && pn(M.memoizedProps.id, Pr, Tr, vi), fR(M);
                var lo = M.return;
                e:
                  for (; lo !== null; ) {
                    switch (lo.tag) {
                      case se:
                        var uo = lo.stateNode;
                        uo.effectDuration += Tr;
                        break e;
                      case fe:
                        var Ct = lo.stateNode;
                        Ct.effectDuration += Tr;
                        break e;
                    }
                    lo = lo.return;
                  }
              }
            }
            break;
          }
          case he: {
            TS(u, M);
            break;
          }
          case Ne:
          case Je:
          case ct:
          case tt:
          case Tt:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      rv || M.flags & yi && Gu(M);
    }
    function Fi(u) {
      switch (u.tag) {
        case te:
        case ve:
        case Ee: {
          if (u.mode & Br)
            try {
              vc(), N(u, u.return);
            } finally {
              Hf(u);
            }
          else
            N(u, u.return);
          break;
        }
        case Y: {
          var f = u.stateNode;
          typeof f.componentDidMount == "function" && ie(u, u.return, f), be(u, u.return);
          break;
        }
        case ue: {
          be(u, u.return);
          break;
        }
      }
    }
    function Ji(u, f) {
      var M = null;
      if (No)
        for (var A = u; ; ) {
          if (A.tag === ue) {
            if (M === null) {
              M = A;
              var z = A.stateNode;
              f ? Zf(z) : Jf(A.stateNode, A.memoizedProps);
            }
          } else if (A.tag === Me) {
            if (M === null) {
              var W = A.stateNode;
              f ? ko(W) : Ki(W, A.memoizedProps);
            }
          } else if (!((A.tag === tt || A.tag === Tt) && A.memoizedState !== null && A !== u)) {
            if (A.child !== null) {
              A.child.return = A, A = A.child;
              continue;
            }
          }
          if (A === u)
            return;
          for (; A.sibling === null; ) {
            if (A.return === null || A.return === u)
              return;
            M === A && (M = null), A = A.return;
          }
          M === A && (M = null), A.sibling.return = A.return, A = A.sibling;
        }
    }
    function Gu(u) {
      var f = u.ref;
      if (f !== null) {
        var M = u.stateNode, A;
        switch (u.tag) {
          case ue:
            A = Uo(M);
            break;
          default:
            A = M;
        }
        if (typeof f == "function") {
          var z;
          if (u.mode & Br)
            try {
              vc(), z = f(A);
            } finally {
              Hf(u);
            }
          else
            z = f(A);
          typeof z == "function" && g("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", wt(u));
        } else
          f.hasOwnProperty("current") || g("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", wt(u)), f.current = A;
      }
    }
    function Gs(u) {
      var f = u.ref;
      if (f !== null)
        if (typeof f == "function")
          if (u.mode & Br)
            try {
              vc(), f(null);
            } finally {
              Hf(u);
            }
          else
            f(null);
        else
          f.current = null;
    }
    function gc(u, f, M) {
      switch (Ba(f), f.tag) {
        case te:
        case ve:
        case ye:
        case Ee: {
          var A = f.updateQueue;
          if (A !== null) {
            var z = A.lastEffect;
            if (z !== null) {
              var W = z.next, ee = W;
              do {
                var ae = ee, _e = ae.destroy, Ue = ae.tag;
                _e !== void 0 && ((Ue & xp) !== mc ? je(f, M, _e) : (Ue & Cs) !== mc && (Cf(f), f.mode & Br ? (vc(), je(f, M, _e), Hf(f)) : je(f, M, _e), Wl())), ee = ee.next;
              } while (ee !== W);
            }
          }
          return;
        }
        case Y: {
          ke(f, M);
          var We = f.stateNode;
          typeof We.componentWillUnmount == "function" && Z(f, M, We);
          return;
        }
        case ue: {
          ke(f, M);
          return;
        }
        case ce: {
          No ? Gb(u, f, M) : Ci && ju(f);
          return;
        }
        case rt:
          return;
        case ct:
          return;
      }
    }
    function Ws(u, f, M) {
      for (var A = f; ; ) {
        if (gc(u, A, M), A.child !== null && (!No || A.tag !== ce)) {
          A.child.return = A, A = A.child;
          continue;
        }
        if (A === f)
          return;
        for (; A.sibling === null; ) {
          if (A.return === null || A.return === f)
            return;
          A = A.return;
        }
        A.sibling.return = A.return, A = A.sibling;
      }
    }
    function $l(u) {
      var f = u.alternate;
      f !== null && (f.return = null), u.return = null;
    }
    function Wu(u) {
      var f = u.alternate;
      f !== null && (u.alternate = null, Wu(f));
      {
        if (u.child = null, u.deletions = null, u.sibling = null, u.tag === ue) {
          var M = u.stateNode;
          M !== null && ua(M);
        }
        u.stateNode = null, u._debugOwner = null, u.return = null, u.dependencies = null, u.memoizedProps = null, u.memoizedState = null, u.pendingProps = null, u.stateNode = null, u.updateQueue = null;
      }
    }
    function ju(u) {
      if (!!Ci) {
        var f = u.stateNode, M = f.containerInfo, A = xs(M);
        bc(M, A);
      }
    }
    function Gf(u) {
      if (!!Ci) {
        switch (u.tag) {
          case Y:
          case ue:
          case Me:
            return;
          case se:
          case ce: {
            var f = u.stateNode, M = f.containerInfo, A = f.pendingChildren;
            bc(M, A);
            return;
          }
        }
        throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function Vb(u) {
      for (var f = u.return; f !== null; ) {
        if (eh(f))
          return f;
        f = f.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function eh(u) {
      return u.tag === ue || u.tag === se || u.tag === ce;
    }
    function iv(u) {
      var f = u;
      e:
        for (; ; ) {
          for (; f.sibling === null; ) {
            if (f.return === null || eh(f.return))
              return null;
            f = f.return;
          }
          for (f.sibling.return = f.return, f = f.sibling; f.tag !== ue && f.tag !== Me && f.tag !== rt; ) {
            if (f.flags & At || f.child === null || f.tag === ce)
              continue e;
            f.child.return = f, f = f.child;
          }
          if (!(f.flags & At))
            return f.stateNode;
        }
    }
    function cm(u) {
      if (!!No) {
        var f = Vb(u);
        switch (f.tag) {
          case ue: {
            var M = f.stateNode;
            f.flags & Ii && (Qf(M), f.flags &= ~Ii);
            var A = iv(u);
            Vg(u, A, M);
            break;
          }
          case se:
          case ce: {
            var z = f.stateNode.containerInfo, W = iv(u);
            z1(u, W, z);
            break;
          }
          default:
            throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
        }
      }
    }
    function z1(u, f, M) {
      var A = u.tag, z = A === ue || A === Me;
      if (z) {
        var W = u.stateNode;
        f ? Os(M, W, f) : mf(M, W);
      } else if (A !== ce) {
        var ee = u.child;
        if (ee !== null) {
          z1(ee, f, M);
          for (var ae = ee.sibling; ae !== null; )
            z1(ae, f, M), ae = ae.sibling;
        }
      }
    }
    function Vg(u, f, M) {
      var A = u.tag, z = A === ue || A === Me;
      if (z) {
        var W = u.stateNode;
        f ? Fo(M, W, f) : pf(M, W);
      } else if (A !== ce) {
        var ee = u.child;
        if (ee !== null) {
          Vg(ee, f, M);
          for (var ae = ee.sibling; ae !== null; )
            Vg(ae, f, M), ae = ae.sibling;
        }
      }
    }
    function Gb(u, f, M) {
      for (var A = f, z = !1, W, ee; ; ) {
        if (!z) {
          var ae = A.return;
          e:
            for (; ; ) {
              if (ae === null)
                throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
              var _e = ae.stateNode;
              switch (ae.tag) {
                case ue:
                  W = _e, ee = !1;
                  break e;
                case se:
                  W = _e.containerInfo, ee = !0;
                  break e;
                case ce:
                  W = _e.containerInfo, ee = !0;
                  break e;
              }
              ae = ae.return;
            }
          z = !0;
        }
        if (A.tag === ue || A.tag === Me)
          Ws(u, A, M), ee ? Ol(W, A.stateNode) : wc(W, A.stateNode);
        else if (A.tag === rt)
          ee ? Um(W, A.stateNode) : Om(W, A.stateNode);
        else if (A.tag === ce) {
          if (A.child !== null) {
            W = A.stateNode.containerInfo, ee = !0, A.child.return = A, A = A.child;
            continue;
          }
        } else if (gc(u, A, M), A.child !== null) {
          A.child.return = A, A = A.child;
          continue;
        }
        if (A === f)
          return;
        for (; A.sibling === null; ) {
          if (A.return === null || A.return === f)
            return;
          A = A.return, A.tag === ce && (z = !1);
        }
        A.sibling.return = A.return, A = A.sibling;
      }
    }
    function ux(u, f, M) {
      No ? Gb(u, f, M) : Ws(u, f, M), $l(f);
    }
    function cx(u, f) {
      if (!No) {
        switch (f.tag) {
          case te:
          case ve:
          case ye:
          case Ee: {
            if (On(xp | Aa, f, f.return), dr(xp | Aa, f), f.mode & Br)
              try {
                vc(), On(Cs | Aa, f, f.return);
              } finally {
                Hf(f);
              }
            else
              On(Cs | Aa, f, f.return);
            return;
          }
          case fe:
            return;
          case he: {
            fm(f), fx(f);
            return;
          }
          case Ne: {
            fx(f);
            return;
          }
          case se: {
            if (fs && u !== null) {
              var M = u.memoizedState;
              if (M.isDehydrated) {
                var A = f.stateNode;
                $h(A.containerInfo);
              }
            }
            break;
          }
          case tt:
          case Tt:
            return;
        }
        Gf(f);
        return;
      }
      switch (f.tag) {
        case te:
        case ve:
        case ye:
        case Ee: {
          if (On(xp | Aa, f, f.return), dr(xp | Aa, f), f.mode & Br)
            try {
              vc(), On(Cs | Aa, f, f.return);
            } finally {
              Hf(f);
            }
          else
            On(Cs | Aa, f, f.return);
          return;
        }
        case Y:
          return;
        case ue: {
          var z = f.stateNode;
          if (z != null) {
            var W = f.memoizedProps, ee = u !== null ? u.memoizedProps : W, ae = f.type, _e = f.updateQueue;
            f.updateQueue = null, _e !== null && Ri(z, _e, ae, ee, W, f);
          }
          return;
        }
        case Me: {
          if (f.stateNode === null)
            throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
          var Ue = f.stateNode, We = f.memoizedProps, St = u !== null ? u.memoizedProps : We;
          lu(Ue, St, We);
          return;
        }
        case se: {
          if (fs && u !== null) {
            var It = u.memoizedState;
            if (It.isDehydrated) {
              var Yt = f.stateNode;
              $h(Yt.containerInfo);
            }
          }
          return;
        }
        case fe:
          return;
        case he: {
          fm(f), fx(f);
          return;
        }
        case Ne: {
          fx(f);
          return;
        }
        case Je:
          return;
      }
      throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
    }
    function fm(u) {
      u.memoizedState;
    }
    function TS(u, f) {
      if (!!fs) {
        var M = f.memoizedState;
        if (M === null) {
          var A = f.alternate;
          if (A !== null) {
            var z = A.memoizedState;
            if (z !== null) {
              var W = z.dehydrated;
              W !== null && Pm(W);
            }
          }
        }
      }
    }
    function fx(u) {
      var f = u.updateQueue;
      if (f !== null) {
        u.updateQueue = null;
        var M = u.stateNode;
        M === null && (M = u.stateNode = new Hb()), f.forEach(function(A) {
          var z = DT.bind(null, u, A);
          if (!M.has(A)) {
            if (M.add(A), ns)
              if (Hg !== null && zh !== null)
                u0(zh, Hg);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            A.then(z, z);
          }
        });
      }
    }
    function oT(u) {
      !No || Qf(u.stateNode);
    }
    function lT(u, f, M) {
      Hg = M, zh = u, Vn = f, CS(u, M), Hg = null, zh = null;
    }
    function CS(u, f) {
      for (; Vn !== null; ) {
        var M = Vn, A = M.deletions;
        if (A !== null)
          for (var z = 0; z < A.length; z++) {
            var W = A[z];
            try {
              ux(u, W, M);
            } catch (ae) {
              v(ae), tu(W, M, ae);
            }
          }
        var ee = M.child;
        (M.subtreeFlags & Yi) !== Pe && ee !== null ? (Tp(ee, M), Vn = ee) : uT(u, f);
      }
    }
    function uT(u, f) {
      for (; Vn !== null; ) {
        var M = Vn;
        bi(M);
        try {
          iR(M, u, f);
        } catch (z) {
          v(z), tu(M, M.return, z);
        }
        Ms();
        var A = M.sibling;
        if (A !== null) {
          Tp(A, M.return), Vn = A;
          return;
        }
        Vn = M.return;
      }
    }
    function iR(u, f, M) {
      var A = u.flags;
      if (A & Ii && oT(u), A & yi) {
        var z = u.alternate;
        z !== null && Gs(z);
      }
      if (A & ai)
        switch (u.tag) {
          case he: {
            var W = u.memoizedState, ee = W !== null;
            if (ee) {
              var ae = u.alternate, _e = ae !== null && ae.memoizedState !== null;
              _e || QS();
            }
            break;
          }
          case tt: {
            var Ue = u.memoizedState, We = Ue !== null, St = u.alternate, It = St !== null && St.memoizedState !== null, Yt = u;
            No && Ji(Yt, We);
            {
              if (We && !It && (Yt.mode & $i) !== Mr) {
                Vn = Yt;
                for (var pn = Yt.child; pn !== null; )
                  Vn = pn, Wb(pn), pn = pn.sibling;
              }
              break;
            }
          }
        }
      var Sn = A & (At | cn | xi);
      switch (Sn) {
        case At: {
          cm(u), u.flags &= ~At;
          break;
        }
        case ki: {
          cm(u), u.flags &= ~At;
          var Tr = u.alternate;
          cx(Tr, u);
          break;
        }
        case xi: {
          u.flags &= ~xi;
          break;
        }
        case $r: {
          u.flags &= ~xi;
          var vi = u.alternate;
          cx(vi, u);
          break;
        }
        case cn: {
          var Pr = u.alternate;
          cx(Pr, u);
          break;
        }
      }
    }
    function Gg(u, f, M) {
      Hg = M, zh = f, Vn = u, N1(u, f, M), Hg = null, zh = null;
    }
    function N1(u, f, M) {
      for (var A = (u.mode & $i) !== Mr; Vn !== null; ) {
        var z = Vn, W = z.child;
        if (z.tag === tt && A) {
          var ee = z.memoizedState !== null, ae = ee || lx;
          if (ae) {
            dm(u, f, M);
            continue;
          } else {
            var _e = z.alternate, Ue = _e !== null && _e.memoizedState !== null, We = Ue || rv, St = lx, It = rv;
            lx = ae, rv = We, rv && !It && (Vn = z, cT(z));
            for (var Yt = W; Yt !== null; )
              Vn = Yt, N1(
                Yt,
                f,
                M
              ), Yt = Yt.sibling;
            Vn = z, lx = St, rv = It, dm(u, f, M);
            continue;
          }
        }
        (z.subtreeFlags & La) !== Pe && W !== null ? (Tp(W, z), Vn = W) : dm(u, f, M);
      }
    }
    function dm(u, f, M) {
      for (; Vn !== null; ) {
        var A = Vn;
        if ((A.flags & La) !== Pe) {
          var z = A.alternate;
          bi(A);
          try {
            Fr(f, z, A, M);
          } catch (ee) {
            v(ee), tu(A, A.return, ee);
          }
          Ms();
        }
        if (A === u) {
          Vn = null;
          return;
        }
        var W = A.sibling;
        if (W !== null) {
          Tp(W, A.return), Vn = W;
          return;
        }
        Vn = A.return;
      }
    }
    function Wb(u) {
      for (; Vn !== null; ) {
        var f = Vn, M = f.child;
        switch (f.tag) {
          case te:
          case ve:
          case ye:
          case Ee: {
            if (f.mode & Br)
              try {
                vc(), On(Cs, f, f.return);
              } finally {
                Hf(f);
              }
            else
              On(Cs, f, f.return);
            break;
          }
          case Y: {
            ke(f, f.return);
            var A = f.stateNode;
            typeof A.componentWillUnmount == "function" && Z(f, f.return, A);
            break;
          }
          case ue: {
            ke(f, f.return);
            break;
          }
          case tt: {
            var z = f.memoizedState !== null;
            if (z) {
              RS(u);
              continue;
            }
            break;
          }
        }
        M !== null ? (M.return = f, Vn = M) : RS(u);
      }
    }
    function RS(u) {
      for (; Vn !== null; ) {
        var f = Vn;
        if (f === u) {
          Vn = null;
          return;
        }
        var M = f.sibling;
        if (M !== null) {
          M.return = f.return, Vn = M;
          return;
        }
        Vn = f.return;
      }
    }
    function cT(u) {
      for (; Vn !== null; ) {
        var f = Vn, M = f.child;
        if (f.tag === tt) {
          var A = f.memoizedState !== null;
          if (A) {
            fT(u);
            continue;
          }
        }
        M !== null ? (M.return = f, Vn = M) : fT(u);
      }
    }
    function fT(u) {
      for (; Vn !== null; ) {
        var f = Vn;
        bi(f);
        try {
          Fi(f);
        } catch (A) {
          v(A), tu(f, f.return, A);
        }
        if (Ms(), f === u) {
          Vn = null;
          return;
        }
        var M = f.sibling;
        if (M !== null) {
          M.return = f.return, Vn = M;
          return;
        }
        Vn = f.return;
      }
    }
    function dT(u, f) {
      Vn = f, Wg(f, u);
    }
    function Wg(u, f) {
      for (; Vn !== null; ) {
        var M = Vn, A = M.child;
        (M.subtreeFlags & qs) !== Pe && A !== null ? (Tp(A, M), Vn = A) : dx(u, f);
      }
    }
    function dx(u, f) {
      for (; Vn !== null; ) {
        var M = Vn;
        if ((M.flags & Bi) !== Pe) {
          bi(M);
          try {
            hx(f, M);
          } catch (z) {
            v(z), tu(M, M.return, z);
          }
          Ms();
        }
        if (M === u) {
          Vn = null;
          return;
        }
        var A = M.sibling;
        if (A !== null) {
          Tp(A, M.return), Vn = A;
          return;
        }
        Vn = M.return;
      }
    }
    function hx(u, f) {
      switch (f.tag) {
        case te:
        case ve:
        case Ee: {
          if (f.mode & Br) {
            J0();
            try {
              dr(bl | Aa, f);
            } finally {
              Og(f);
            }
          } else
            dr(bl | Aa, f);
          break;
        }
      }
    }
    function AS(u) {
      Vn = u, DS();
    }
    function DS() {
      for (; Vn !== null; ) {
        var u = Vn, f = u.child;
        if ((Vn.flags & Or) !== Pe) {
          var M = u.deletions;
          if (M !== null) {
            for (var A = 0; A < M.length; A++) {
              var z = M[A];
              Vn = z, Jy(z, u);
            }
            {
              var W = u.alternate;
              if (W !== null) {
                var ee = W.child;
                if (ee !== null) {
                  W.child = null;
                  do {
                    var ae = ee.sibling;
                    ee.sibling = null, ee = ae;
                  } while (ee !== null);
                }
              }
            }
            Vn = u;
          }
        }
        (u.subtreeFlags & qs) !== Pe && f !== null ? (Tp(f, u), Vn = f) : Ep();
      }
    }
    function Ep() {
      for (; Vn !== null; ) {
        var u = Vn;
        (u.flags & Bi) !== Pe && (bi(u), Mp(u), Ms());
        var f = u.sibling;
        if (f !== null) {
          Tp(f, u.return), Vn = f;
          return;
        }
        Vn = u.return;
      }
    }
    function Mp(u) {
      switch (u.tag) {
        case te:
        case ve:
        case Ee: {
          u.mode & Br ? (J0(), On(bl | Aa, u, u.return), Og(u)) : On(bl | Aa, u, u.return);
          break;
        }
      }
    }
    function Jy(u, f) {
      for (; Vn !== null; ) {
        var M = Vn;
        bi(M), Wv(M, f), Ms();
        var A = M.child;
        A !== null ? (Tp(A, M), Vn = A) : Gv(u);
      }
    }
    function Gv(u) {
      for (; Vn !== null; ) {
        var f = Vn, M = f.sibling, A = f.return;
        if (Wu(f), f === u) {
          Vn = null;
          return;
        }
        if (M !== null) {
          Tp(M, A), Vn = M;
          return;
        }
        Vn = A;
      }
    }
    function Wv(u, f) {
      switch (u.tag) {
        case te:
        case ve:
        case Ee: {
          u.mode & Br ? (J0(), On(bl, u, f), Og(u)) : On(bl, u, f);
          break;
        }
      }
    }
    var hT = !1;
    function Tp(u, f) {
      !hT && u.return !== f && (hT = !0, g("Internal React error: Return pointer is inconsistent with parent.")), u.return = f;
    }
    function aR(u) {
      switch (u.tag) {
        case te:
        case ve:
        case Ee: {
          try {
            dr(Cs | Aa, u);
          } catch (M) {
            v(M), tu(u, u.return, M);
          }
          break;
        }
        case Y: {
          var f = u.stateNode;
          try {
            f.componentDidMount();
          } catch (M) {
            v(M), tu(u, u.return, M);
          }
          break;
        }
      }
    }
    function Ky(u) {
      switch (u.tag) {
        case te:
        case ve:
        case Ee: {
          try {
            dr(bl | Aa, u);
          } catch (f) {
            v(f), tu(u, u.return, f);
          }
          break;
        }
      }
    }
    function pT(u) {
      switch (u.tag) {
        case te:
        case ve:
        case Ee: {
          try {
            On(Cs | Aa, u, u.return);
          } catch (M) {
            v(M), tu(u, u.return, M);
          }
          break;
        }
        case Y: {
          var f = u.stateNode;
          typeof f.componentWillUnmount == "function" && Z(u, u.return, f);
          break;
        }
      }
    }
    function jb(u) {
      switch (u.tag) {
        case te:
        case ve:
        case Ee:
          try {
            On(bl | Aa, u, u.return);
          } catch (f) {
            v(f), tu(u, u.return, f);
          }
      }
    }
    var $y = 0, LS = 1, px = 2, PS = 3, OS = 4;
    if (typeof Symbol == "function" && Symbol.for) {
      var hm = Symbol.for;
      $y = hm("selector.component"), LS = hm("selector.has_pseudo_class"), px = hm("selector.role"), PS = hm("selector.test_id"), OS = hm("selector.text");
    }
    function Zc(u) {
      return {
        $$typeof: $y,
        value: u
      };
    }
    function Cp(u) {
      return {
        $$typeof: LS,
        value: u
      };
    }
    function pm(u) {
      return {
        $$typeof: px,
        value: u
      };
    }
    function e0(u) {
      return {
        $$typeof: OS,
        value: u
      };
    }
    function jg(u) {
      return {
        $$typeof: PS,
        value: u
      };
    }
    function Yb(u) {
      var f = qf(u);
      if (f != null) {
        if (typeof f.memoizedProps["data-testname"] != "string")
          throw new Error("Invalid host root specified. Should be either a React container or a node with a testname attribute.");
        return f;
      } else {
        var M = Ka(u);
        if (M === null)
          throw new Error("Could not find React container within specified host subtree.");
        return M.stateNode.current;
      }
    }
    function US(u, f) {
      switch (f.$$typeof) {
        case $y:
          if (u.type === f.value)
            return !0;
          break;
        case LS:
          return sR(u, f.value);
        case px:
          if (u.tag === ue) {
            var M = u.stateNode;
            if (Qa(M, f.value))
              return !0;
          }
          break;
        case OS:
          if (u.tag === ue || u.tag === Me) {
            var A = Lm(u);
            if (A !== null && A.indexOf(f.value) >= 0)
              return !0;
          }
          break;
        case PS:
          if (u.tag === ue) {
            var z = u.memoizedProps["data-testname"];
            if (typeof z == "string" && z.toLowerCase() === f.value.toLowerCase())
              return !0;
          }
          break;
        default:
          throw new Error("Invalid selector type specified.");
      }
      return !1;
    }
    function Xb(u) {
      switch (u.$$typeof) {
        case $y:
          var f = st(u.value) || "Unknown";
          return "<" + f + ">";
        case LS:
          return ":has(" + (Xb(u) || "") + ")";
        case px:
          return '[role="' + u.value + '"]';
        case OS:
          return '"' + u.value + '"';
        case PS:
          return '[data-testname="' + u.value + '"]';
        default:
          throw new Error("Invalid selector type specified.");
      }
    }
    function mT(u, f) {
      for (var M = [], A = [u, 0], z = 0; z < A.length; ) {
        var W = A[z++], ee = A[z++], ae = f[ee];
        if (!(W.tag === ue && hi(W))) {
          for (; ae != null && US(W, ae); )
            ee++, ae = f[ee];
          if (ee === f.length)
            M.push(W);
          else
            for (var _e = W.child; _e !== null; )
              A.push(_e, ee), _e = _e.sibling;
        }
      }
      return M;
    }
    function sR(u, f) {
      for (var M = [u, 0], A = 0; A < M.length; ) {
        var z = M[A++], W = M[A++], ee = f[W];
        if (!(z.tag === ue && hi(z))) {
          for (; ee != null && US(z, ee); )
            W++, ee = f[W];
          if (W === f.length)
            return !0;
          for (var ae = z.child; ae !== null; )
            M.push(ae, W), ae = ae.sibling;
        }
      }
      return !1;
    }
    function F1(u, f) {
      if (!yo)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var M = Yb(u), A = mT(M, f), z = [], W = Array.from(A), ee = 0; ee < W.length; ) {
        var ae = W[ee++];
        if (ae.tag === ue) {
          if (hi(ae))
            continue;
          z.push(ae.stateNode);
        } else
          for (var _e = ae.child; _e !== null; )
            W.push(_e), _e = _e.sibling;
      }
      return z;
    }
    function vT(u, f) {
      if (!yo)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var M = Yb(u), A = 0, z = [], W = [M, 0], ee = 0; ee < W.length; ) {
        var ae = W[ee++], _e = W[ee++], Ue = f[_e];
        if (!(ae.tag === ue && hi(ae)) && (US(ae, Ue) && (z.push(Xb(Ue)), _e++, _e > A && (A = _e)), _e < f.length))
          for (var We = ae.child; We !== null; )
            W.push(We, _e), We = We.sibling;
      }
      if (A < f.length) {
        for (var St = [], It = A; It < f.length; It++)
          St.push(Xb(f[It]));
        return `findAllNodes was able to match part of the selector:
` + ("  " + z.join(" > ") + `

`) + `No matching component was found for:
` + ("  " + St.join(" > "));
      }
      return null;
    }
    function qb(u, f) {
      if (!yo)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var M = F1(u, f), A = [], z = 0; z < M.length; z++)
        A.push(Xi(M[z]));
      for (var W = A.length - 1; W > 0; W--)
        for (var ee = A[W], ae = ee.x, _e = ae + ee.width, Ue = ee.y, We = Ue + ee.height, St = W - 1; St >= 0; St--)
          if (W !== St) {
            var It = A[St], Yt = It.x, pn = Yt + It.width, Sn = It.y, Tr = Sn + It.height;
            if (ae >= Yt && Ue >= Sn && _e <= pn && We <= Tr) {
              A.splice(W, 1);
              break;
            } else if (ae === Yt && ee.width === It.width && !(Tr < Ue) && !(Sn > We)) {
              Sn > Ue && (It.height += Sn - Ue, It.y = Ue), Tr < We && (It.height = We - Sn), A.splice(W, 1);
              break;
            } else if (Ue === Sn && ee.height === It.height && !(pn < ae) && !(Yt > _e)) {
              Yt > ae && (It.width += Yt - ae, It.x = ae), pn < _e && (It.width = _e - Yt), A.splice(W, 1);
              break;
            }
          }
      return A;
    }
    function gT(u, f) {
      if (!yo)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var M = Yb(u), A = mT(M, f), z = Array.from(A), W = 0; W < z.length; ) {
        var ee = z[W++];
        if (!hi(ee)) {
          if (ee.tag === ue) {
            var ae = ee.stateNode;
            if (Sc(ae))
              return !0;
          }
          for (var _e = ee.child; _e !== null; )
            z.push(_e), _e = _e.sibling;
        }
      }
      return !1;
    }
    var k1 = [];
    function Qb() {
      yo && k1.forEach(function(u) {
        return u();
      });
    }
    function Zb(u, f, M, A) {
      if (!yo)
        throw new Error("Test selector API is not supported by this renderer.");
      var z = F1(u, f), W = hl(z, M, A), ee = W.disconnect, ae = W.observe, _e = W.unobserve, Ue = function() {
        var We = F1(u, f);
        z.forEach(function(St) {
          We.indexOf(St) < 0 && _e(St);
        }), We.forEach(function(St) {
          z.indexOf(St) < 0 && ae(St);
        });
      };
      return k1.push(Ue), {
        disconnect: function() {
          var We = k1.indexOf(Ue);
          We >= 0 && k1.splice(We, 1), ee();
        }
      };
    }
    var Jb = s.ReactCurrentActQueue;
    function oR(u) {
      {
        var f = typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0, M = typeof jest < "u";
        return Xf && M && f !== !1;
      }
    }
    function yT() {
      {
        var u = typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0;
        return !u && Jb.current !== null && g("The current testing environment is not configured to support act(...)"), u;
      }
    }
    var lR = Math.ceil, Kb = s.ReactCurrentDispatcher, zS = s.ReactCurrentOwner, oo = s.ReactCurrentBatchConfig, mm = s.ReactCurrentActQueue, eu = 0, Yg = 1, Jc = 2, js = 4, vm = 0, I1 = 1, t0 = 2, NS = 3, Ed = 4, xT = 5, jv = 6, ci = eu, Su = null, Ys = null, cl = sn, th = sn, n0 = Mn(sn), Ro = vm, Xg = null, B1 = sn, Md = sn, mx = sn, r0 = null, Kc = null, qg = 0, FS = 500, H1 = 1 / 0, kS = 500;
    function i0() {
      H1 = da() + kS;
    }
    function $b() {
      return H1;
    }
    var V1 = !1, G1 = null, Qg = null, a0 = !1, Yv = null, av = sn, Ml = [], s0 = 50, o0 = 0, eE = null, _T = 50, IS = 0, W1 = Vi, $c = sn;
    function BS() {
      return Su;
    }
    function yc() {
      return (ci & (Jc | js)) !== eu ? da() : (W1 !== Vi || (W1 = da()), W1);
    }
    function Xv(u) {
      var f = u.mode;
      if ((f & $i) === Mr)
        return Hr;
      if ((ci & Jc) !== eu && cl !== sn)
        return du(cl);
      var M = Df() !== Af;
      if (M) {
        if (oo.transition !== null) {
          var A = oo.transition;
          A._updatedFibers || (A._updatedFibers = /* @__PURE__ */ new Set()), A._updatedFibers.add(u);
        }
        return $c === kr && ($c = wo()), $c;
      }
      var z = il();
      if (z !== kr)
        return z;
      var W = Tu();
      return W;
    }
    function ST(u) {
      var f = u.mode;
      return (f & $i) === Mr ? Hr : tp();
    }
    function Tl(u, f, M) {
      LT();
      var A = l0(u, f);
      return A === null ? null : (bo(A, f, M), (ci & Jc) !== sn && A === Su ? wx(u) : (ns && ga(A, u, f), UT(u), A === Su && ((ci & Jc) === eu && (Md = Ur(Md, f)), Ro === Ed && ov(A, cl)), ef(A, M), f === Hr && ci === eu && (u.mode & $i) === Mr && !mm.isBatchingLegacy && (i0(), Ha())), A);
    }
    function tE(u, f, M) {
      var A = u.current;
      A.lanes = f, bo(u, f, M), ef(u, M);
    }
    function l0(u, f) {
      u.lanes = Ur(u.lanes, f);
      var M = u.alternate;
      M !== null && (M.lanes = Ur(M.lanes, f)), M === null && (u.flags & (At | xi)) !== Pe && _x(u);
      for (var A = u, z = u.return; z !== null; )
        z.childLanes = Ur(z.childLanes, f), M = z.alternate, M !== null ? M.childLanes = Ur(M.childLanes, f) : (z.flags & (At | xi)) !== Pe && _x(u), A = z, z = z.return;
      if (A.tag === se) {
        var W = A.stateNode;
        return W;
      } else
        return null;
    }
    function HS(u, f) {
      return Su !== null && (u.mode & $i) !== Mr && (ci & Jc) === eu;
    }
    function ef(u, f) {
      var M = u.callbackNode;
      ps(u, f);
      var A = zi(u, u === Su ? cl : sn);
      if (A === sn) {
        M !== null && OT(M), u.callbackNode = null, u.callbackPriority = kr;
        return;
      }
      var z = lc(A), W = u.callbackPriority;
      if (W === z && !(mm.current !== null && M !== $S)) {
        M == null && W !== Hr && g("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      M != null && OT(M);
      var ee;
      if (z === Hr)
        u.tag === Tc ? (mm.isBatchingLegacy !== null && (mm.didScheduleLegacyUpdate = !0), kc(wT.bind(null, u))) : lr(wT.bind(null, u)), Cr ? mm.current !== null ? mm.current.push(Yo) : dl(function() {
          ci === eu && Yo();
        }) : bx(Gi, Yo), ee = null;
      else {
        var ae;
        switch (Vl(A)) {
          case zs:
            ae = Gi;
            break;
          case ld:
            ae = bn;
            break;
          case Hl:
            ae = Qi;
            break;
          case Go:
            ae = ya;
            break;
          default:
            ae = Qi;
            break;
        }
        ee = bx(ae, VS.bind(null, u));
      }
      u.callbackPriority = z, u.callbackNode = ee;
    }
    function VS(u, f) {
      if (Pg(), W1 = Vi, $c = sn, (ci & (Jc | js)) !== eu)
        throw new Error("Should not already be working.");
      var M = u.callbackNode, A = lv();
      if (A && u.callbackNode !== M)
        return null;
      var z = zi(u, u === Su ? cl : sn);
      if (z === sn)
        return null;
      var W = !Vo(u, z) && !bv(u, z) && !f, ee = W ? cR(u, z) : yx(u, z);
      if (ee !== vm) {
        if (ee === t0) {
          var ae = kl(u);
          ae !== sn && (z = ae, ee = GS(u, ae));
        }
        if (ee === I1) {
          var _e = Xg;
          throw qv(u, sn), ov(u, z), ef(u, da()), _e;
        }
        if (ee === jv)
          ov(u, z);
        else {
          var Ue = !Vo(u, z), We = u.current.alternate;
          if (Ue && !WS(We)) {
            if (ee = yx(u, z), ee === t0) {
              var St = kl(u);
              St !== sn && (z = St, ee = GS(u, St));
            }
            if (ee === I1) {
              var It = Xg;
              throw qv(u, sn), ov(u, z), ef(u, da()), It;
            }
          }
          u.finishedWork = We, u.finishedLanes = z, Zg(u, ee, z);
        }
      }
      return ef(u, da()), u.callbackNode === M ? VS.bind(null, u) : null;
    }
    function GS(u, f) {
      var M = r0;
      if (Di(u)) {
        var A = qv(u, f);
        A.flags |= Mi, Za(u.containerInfo);
      }
      var z = yx(u, f);
      if (z !== t0) {
        var W = Kc;
        Kc = M, W !== null && sv(W);
      }
      return z;
    }
    function sv(u) {
      Kc === null ? Kc = u : Kc.push.apply(Kc, u);
    }
    function Zg(u, f, M) {
      switch (f) {
        case vm:
        case I1:
          throw new Error("Root did not complete. This is a bug in React.");
        case t0: {
          Jg(u, Kc);
          break;
        }
        case NS: {
          if (ov(u, M), bf(M) && !pE()) {
            var A = qg + FS - da();
            if (A > 10) {
              var z = zi(u, sn);
              if (z !== sn)
                break;
              var W = u.suspendedLanes;
              if (!uc(W, M)) {
                yc(), Eh(u, W);
                break;
              }
              u.timeoutHandle = Jh(Jg.bind(null, u, Kc), A);
              break;
            }
          }
          Jg(u, Kc);
          break;
        }
        case Ed: {
          if (ov(u, M), jd(M))
            break;
          if (!pE()) {
            var ee = Oc(u, M), ae = ee, _e = da() - ae, Ue = xx(_e) - _e;
            if (Ue > 10) {
              u.timeoutHandle = Jh(Jg.bind(null, u, Kc), Ue);
              break;
            }
          }
          Jg(u, Kc);
          break;
        }
        case xT: {
          Jg(u, Kc);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function WS(u) {
      for (var f = u; ; ) {
        if (f.flags & Te) {
          var M = f.updateQueue;
          if (M !== null) {
            var A = M.stores;
            if (A !== null)
              for (var z = 0; z < A.length; z++) {
                var W = A[z], ee = W.getSnapshot, ae = W.value;
                try {
                  if (!Eo(ee(), ae))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var _e = f.child;
        if (f.subtreeFlags & Te && _e !== null) {
          _e.return = f, f = _e;
          continue;
        }
        if (f === u)
          return !0;
        for (; f.sibling === null; ) {
          if (f.return === null || f.return === u)
            return !0;
          f = f.return;
        }
        f.sibling.return = f.return, f = f.sibling;
      }
      return !0;
    }
    function ov(u, f) {
      f = $s(f, mx), f = $s(f, Md), Im(u, f);
    }
    function wT(u) {
      if (Iv(), (ci & (Jc | js)) !== eu)
        throw new Error("Should not already be working.");
      lv();
      var f = zi(u, sn);
      if (!Vr(f, Hr))
        return ef(u, da()), null;
      var M = yx(u, f);
      if (u.tag !== Tc && M === t0) {
        var A = kl(u);
        A !== sn && (f = A, M = GS(u, A));
      }
      if (M === I1) {
        var z = Xg;
        throw qv(u, sn), ov(u, f), ef(u, da()), z;
      }
      if (M === jv)
        throw new Error("Root did not complete. This is a bug in React.");
      var W = u.current.alternate;
      return u.finishedWork = W, u.finishedLanes = f, Jg(u, Kc), ef(u, da()), null;
    }
    function jS(u, f) {
      f !== sn && (bs(u, Ur(f, Hr)), ef(u, da()), (ci & (Jc | js)) === eu && (i0(), Yo()));
    }
    function uR(u) {
      var f = il(), M = oo.transition;
      try {
        return oo.transition = null, Ns(Hl), u();
      } finally {
        Ns(f), oo.transition = M;
      }
    }
    function bT(u, f) {
      var M = ci;
      ci |= Yg;
      try {
        return u(f);
      } finally {
        ci = M, ci === eu && !mm.isBatchingLegacy && (i0(), Ha());
      }
    }
    function YS(u, f, M, A, z) {
      var W = il(), ee = oo.transition;
      try {
        return oo.transition = null, Ns(zs), u(f, M, A, z);
      } finally {
        Ns(W), oo.transition = ee, ci === eu && i0();
      }
    }
    function j1(u) {
      Yv !== null && Yv.tag === Tc && (ci & (Jc | js)) === eu && lv();
      var f = ci;
      ci |= Yg;
      var M = oo.transition, A = il();
      try {
        return oo.transition = null, Ns(zs), u ? u() : void 0;
      } finally {
        Ns(A), oo.transition = M, ci = f, (ci & (Jc | js)) === eu && Yo();
      }
    }
    function nE() {
      return (ci & (Jc | js)) !== eu;
    }
    function ET(u) {
      var f = ci;
      ci |= Yg;
      var M = oo.transition, A = il();
      try {
        oo.transition = null, Ns(zs), u();
      } finally {
        Ns(A), oo.transition = M, ci = f, ci === eu && (i0(), Yo());
      }
    }
    function vx(u, f) {
      or(n0, th, u), th = Ur(th, f);
    }
    function Y1(u) {
      th = n0.current, $n(n0, u);
    }
    function qv(u, f) {
      u.finishedWork = null, u.finishedLanes = sn;
      var M = u.timeoutHandle;
      if (M !== ei && (u.timeoutHandle = ei, Pl(M)), Ys !== null)
        for (var A = Ys.return; A !== null; ) {
          var z = A.alternate;
          O1(z, A), A = A.return;
        }
      Su = u;
      var W = la(u.current, null);
      return Ys = W, cl = th = f, Ro = vm, Xg = null, B1 = sn, Md = sn, mx = sn, r0 = null, Kc = null, Sa(), Ql.discardPendingWarnings(), W;
    }
    function XS(u, f) {
      do {
        var M = Ys;
        try {
          if (x(), fn(), Ms(), zS.current = null, M === null || M.return === null) {
            Ro = I1, Xg = f, Ys = null;
            return;
          }
          if (Q && M.mode & Br && Bv(M, !0), B)
            if (cc(), f !== null && typeof f == "object" && typeof f.then == "function") {
              var A = f;
              fd(M, A, cl);
            } else
              jl(M, f, cl);
          Sb(u, M.return, M, f, cl), RT(M);
        } catch (z) {
          f = z, Ys === M && M !== null ? (M = M.return, Ys = M) : M = Ys;
          continue;
        }
        return;
      } while (!0);
    }
    function qS() {
      var u = Kb.current;
      return Kb.current = X0, u === null ? X0 : u;
    }
    function rE(u) {
      Kb.current = u;
    }
    function QS() {
      qg = da();
    }
    function gx(u) {
      B1 = Ur(u, B1);
    }
    function iE() {
      Ro === vm && (Ro = NS);
    }
    function X1() {
      (Ro === vm || Ro === NS || Ro === t0) && (Ro = Ed), Su !== null && (Il(B1) || Il(Md)) && ov(Su, cl);
    }
    function MT(u) {
      Ro !== Ed && (Ro = t0), r0 === null ? r0 = [u] : r0.push(u);
    }
    function aE() {
      return Ro === vm;
    }
    function yx(u, f) {
      var M = ci;
      ci |= Jc;
      var A = qS();
      if (Su !== u || cl !== f) {
        if (ns) {
          var z = u.memoizedUpdaters;
          z.size > 0 && (u0(u, cl), z.clear()), hu(u, f);
        }
        qv(u, f);
      }
      Gr(f);
      do
        try {
          TT();
          break;
        } catch (W) {
          XS(u, W);
        }
      while (!0);
      if (x(), ci = M, rE(A), Ys !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return ui(), Su = null, cl = sn, Ro;
    }
    function TT() {
      for (; Ys !== null; )
        sE(Ys);
    }
    function cR(u, f) {
      var M = ci;
      ci |= Jc;
      var A = qS();
      if (Su !== u || cl !== f) {
        if (ns) {
          var z = u.memoizedUpdaters;
          z.size > 0 && (u0(u, cl), z.clear()), hu(u, f);
        }
        i0(), qv(u, f);
      }
      Gr(f);
      do
        try {
          CT();
          break;
        } catch (W) {
          XS(u, W);
        }
      while (!0);
      return x(), rE(A), ci = M, Ys !== null ? (fr(), vm) : (ui(), Su = null, cl = sn, Ro);
    }
    function CT() {
      for (; Ys !== null && !eo(); )
        sE(Ys);
    }
    function sE(u) {
      var f = u.alternate;
      bi(u);
      var M;
      (u.mode & Br) !== Mr ? (om(u), M = Sx(f, u, th), Bv(u, !0)) : M = Sx(f, u, th), Ms(), u.memoizedProps = u.pendingProps, M === null ? RT(u) : Ys = M, zS.current = null;
    }
    function RT(u) {
      var f = u;
      do {
        var M = f.alternate, A = f.return;
        if ((f.flags & Le) === Pe) {
          bi(f);
          var z = void 0;
          if ((f.mode & Br) === Mr ? z = y1(M, f, th) : (om(f), z = y1(M, f, th), Bv(f, !1)), Ms(), z !== null) {
            Ys = z;
            return;
          }
        } else {
          var W = Fb(M, f);
          if (W !== null) {
            W.flags &= de, Ys = W;
            return;
          }
          if ((f.mode & Br) !== Mr) {
            Bv(f, !1);
            for (var ee = f.actualDuration, ae = f.child; ae !== null; )
              ee += ae.actualDuration, ae = ae.sibling;
            f.actualDuration = ee;
          }
          if (A !== null)
            A.flags |= Le, A.subtreeFlags = Pe, A.deletions = null;
          else {
            Ro = jv, Ys = null;
            return;
          }
        }
        var _e = f.sibling;
        if (_e !== null) {
          Ys = _e;
          return;
        }
        f = A, Ys = f;
      } while (f !== null);
      Ro === vm && (Ro = xT);
    }
    function Jg(u, f) {
      var M = il(), A = oo.transition;
      try {
        oo.transition = null, Ns(zs), oE(u, f, M);
      } finally {
        oo.transition = A, Ns(M);
      }
      return null;
    }
    function oE(u, f, M) {
      do
        lv();
      while (Yv !== null);
      if (dR(), (ci & (Jc | js)) !== eu)
        throw new Error("Should not already be working.");
      var A = u.finishedWork, z = u.finishedLanes;
      if (Es(z), A === null)
        return qd(), null;
      if (z === sn && g("root.finishedLanes should not be empty during a commit. This is a bug in React."), u.finishedWork = null, u.finishedLanes = sn, A === u.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      u.callbackNode = null, u.callbackPriority = kr;
      var W = Ur(A.lanes, A.childLanes);
      zu(u, W), u === Su && (Su = null, Ys = null, cl = sn), ((A.subtreeFlags & qs) !== Pe || (A.flags & qs) !== Pe) && (a0 || (a0 = !0, bx(Qi, function() {
        return lv(), null;
      })));
      var ee = (A.subtreeFlags & (wr | Yi | La | qs)) !== Pe, ae = (A.flags & (wr | Yi | La | qs)) !== Pe;
      if (ee || ae) {
        var _e = oo.transition;
        oo.transition = null;
        var Ue = il();
        Ns(zs);
        var We = ci;
        ci |= js, zS.current = null, nn(u, A), h1(), lT(u, A, z), vo(u.containerInfo), u.current = A, Yl(z), Gg(A, u, z), Mh(), Xd(), ci = We, Ns(Ue), oo.transition = _e;
      } else
        u.current = A, h1();
      var St = a0;
      if (a0 && (a0 = !1, Yv = u, av = z), W = u.pendingLanes, W === sn && (Qg = null), St || PT(u.current, !1), Qr(A.stateNode, M), ns && u.memoizedUpdaters.clear(), Qb(), ef(u, da()), f !== null)
        for (var It = u.onRecoverableError, Yt = 0; Yt < f.length; Yt++) {
          var pn = f[Yt];
          It(pn);
        }
      if (V1) {
        V1 = !1;
        var Sn = G1;
        throw G1 = null, Sn;
      }
      return Vr(av, Hr) && u.tag !== Tc && lv(), W = u.pendingLanes, Vr(W, Hr) ? (Bf(), u === eE ? o0++ : (o0 = 0, eE = u)) : o0 = 0, Yo(), qd(), null;
    }
    function lv() {
      if (Yv !== null) {
        var u = Vl(av), f = Wp(Hl, u), M = oo.transition, A = il();
        try {
          return oo.transition = null, Ns(f), lE();
        } finally {
          Ns(A), oo.transition = M;
        }
      }
      return !1;
    }
    function fR(u) {
      Ml.push(u), a0 || (a0 = !0, bx(Qi, function() {
        return lv(), null;
      }));
    }
    function lE() {
      if (Yv === null)
        return !1;
      var u = Yv, f = av;
      if (Yv = null, av = sn, (ci & (Jc | js)) !== eu)
        throw new Error("Cannot flush passive effects while already rendering.");
      fc(f);
      var M = ci;
      ci |= js, AS(u.current), dT(u, u.current);
      {
        var A = Ml;
        Ml = [];
        for (var z = 0; z < A.length; z++) {
          var W = A[z];
          mi(u, W);
        }
      }
      hr(), PT(u.current, !0), ci = M, Yo(), IS = Yv === null ? 0 : IS + 1, Ra(u);
      {
        var ee = u.current.stateNode;
        ee.effectDuration = 0, ee.passiveEffectDuration = 0;
      }
      return !0;
    }
    function ZS(u) {
      return Qg !== null && Qg.has(u);
    }
    function uE(u) {
      Qg === null ? Qg = /* @__PURE__ */ new Set([u]) : Qg.add(u);
    }
    function cE(u) {
      V1 || (V1 = !0, G1 = u);
    }
    var fE = cE;
    function dE(u, f, M) {
      var A = Fy(M, f), z = ky(u, A, Hr);
      Ar(u, z);
      var W = yc(), ee = l0(u, Hr);
      ee !== null && (bo(ee, Hr, W), ef(ee, W));
    }
    function tu(u, f, M) {
      if (u.tag === se) {
        dE(u, u, M);
        return;
      }
      var A = null;
      for (A = f; A !== null; ) {
        if (A.tag === se) {
          dE(A, u, M);
          return;
        } else if (A.tag === Y) {
          var z = A.type, W = A.stateNode;
          if (typeof z.getDerivedStateFromError == "function" || typeof W.componentDidCatch == "function" && !ZS(W)) {
            var ee = Fy(M, u), ae = tv(A, ee, Hr);
            Ar(A, ae);
            var _e = yc(), Ue = l0(A, Hr);
            Ue !== null && (bo(Ue, Hr, _e), ef(Ue, _e));
            return;
          }
        }
        A = A.return;
      }
      g(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, M);
    }
    function JS(u, f, M) {
      var A = u.pingCache;
      A !== null && A.delete(f);
      var z = yc();
      Eh(u, M), Z1(u), Su === u && uc(cl, M) && (Ro === Ed || Ro === NS && bf(cl) && da() - qg < FS ? qv(u, sn) : mx = Ur(mx, M)), ef(u, z);
    }
    function q1(u, f) {
      f === kr && (f = ST(u));
      var M = yc(), A = l0(u, f);
      A !== null && (bo(A, f, M), ef(A, M));
    }
    function AT(u) {
      var f = u.memoizedState, M = kr;
      f !== null && (M = f.retryLane), q1(u, M);
    }
    function DT(u, f) {
      var M = kr, A;
      switch (u.tag) {
        case he:
          A = u.stateNode;
          var z = u.memoizedState;
          z !== null && (M = z.retryLane);
          break;
        case Ne:
          A = u.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      A !== null && A.delete(f), q1(u, M);
    }
    function xx(u) {
      return u < 120 ? 120 : u < 480 ? 480 : u < 1080 ? 1080 : u < 1920 ? 1920 : u < 3e3 ? 3e3 : u < 4320 ? 4320 : lR(u / 1960) * 1960;
    }
    function LT() {
      if (o0 > s0)
        throw o0 = 0, eE = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      IS > _T && (IS = 0, g("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function dR() {
      Ql.flushLegacyContextWarning(), Ql.flushPendingUnsafeLifecycleWarnings();
    }
    function PT(u, f) {
      bi(u), Kg(u, Jn, pT), f && Kg(u, rr, jb), Kg(u, Jn, aR), f && Kg(u, rr, Ky), Ms();
    }
    function Kg(u, f, M) {
      for (var A = u, z = null; A !== null; ) {
        var W = A.subtreeFlags & f;
        A !== z && A.child !== null && W !== Pe ? A = A.child : ((A.flags & f) !== Pe && M(A), A.sibling !== null ? A = A.sibling : A = z = A.return);
      }
    }
    var gm = null;
    function _x(u) {
      {
        if ((ci & Jc) !== eu || !(u.mode & $i))
          return;
        var f = u.tag;
        if (f !== re && f !== se && f !== Y && f !== te && f !== ve && f !== ye && f !== Ee)
          return;
        var M = wt(u) || "ReactComponent";
        if (gm !== null) {
          if (gm.has(M))
            return;
          gm.add(M);
        } else
          gm = /* @__PURE__ */ new Set([M]);
        var A = to;
        try {
          bi(u), g("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          A ? bi(u) : Ms();
        }
      }
    }
    var Sx;
    {
      var KS = null;
      Sx = function(u, f, M) {
        var A = h0(KS, f);
        try {
          return _S(u, f, M);
        } catch (W) {
          if (W !== null && typeof W == "object" && typeof W.then == "function")
            throw W;
          if (x(), fn(), O1(u, f), h0(f, A), f.mode & Br && om(f), bS(null, _S, null, u, f, M), Bb()) {
            var z = ES();
            typeof z == "object" && z !== null && z._suppressLogging && typeof W == "object" && W !== null && !W._suppressLogging && (W._suppressLogging = !0);
          }
          throw W;
        }
      };
    }
    var hE = !1, Q1;
    Q1 = /* @__PURE__ */ new Set();
    function wx(u) {
      if (ql && !d1())
        switch (u.tag) {
          case te:
          case ve:
          case Ee: {
            var f = Ys && wt(Ys) || "Unknown", M = f;
            if (!Q1.has(M)) {
              Q1.add(M);
              var A = wt(u) || "Unknown";
              g("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", A, f, f);
            }
            break;
          }
          case Y: {
            hE || (g("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), hE = !0);
            break;
          }
        }
    }
    function u0(u, f) {
      if (ns) {
        var M = u.memoizedUpdaters;
        M.forEach(function(A) {
          ga(u, A, f);
        });
      }
    }
    var $S = {};
    function bx(u, f) {
      {
        var M = mm.current;
        return M !== null ? (M.push(f), $S) : np(u, f);
      }
    }
    function OT(u) {
      if (u !== $S)
        return Ef(u);
    }
    function pE() {
      return mm.current !== null;
    }
    function UT(u) {
      {
        if (u.mode & $i) {
          if (!yT())
            return;
        } else if (!oR() || ci !== eu || u.tag !== te && u.tag !== ve && u.tag !== Ee)
          return;
        if (mm.current === null) {
          var f = to;
          try {
            bi(u), g(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, wt(u));
          } finally {
            f ? bi(u) : Ms();
          }
        }
      }
    }
    function Z1(u) {
      u.tag !== Tc && yT() && mm.current === null && g(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    var Cl = null, $g = null, Ex = function(u) {
      Cl = u;
    };
    function ey(u) {
      {
        if (Cl === null)
          return u;
        var f = Cl(u);
        return f === void 0 ? u : f.current;
      }
    }
    function mE(u) {
      return ey(u);
    }
    function uv(u) {
      {
        if (Cl === null)
          return u;
        var f = Cl(u);
        if (f === void 0) {
          if (u != null && typeof u.render == "function") {
            var M = ey(u.render);
            if (u.render !== M) {
              var A = {
                $$typeof: Nt,
                render: M
              };
              return u.displayName !== void 0 && (A.displayName = u.displayName), A;
            }
          }
          return u;
        }
        return f.current;
      }
    }
    function c0(u, f) {
      {
        if (Cl === null)
          return !1;
        var M = u.elementType, A = f.type, z = !1, W = typeof A == "object" && A !== null ? A.$$typeof : null;
        switch (u.tag) {
          case Y: {
            typeof A == "function" && (z = !0);
            break;
          }
          case te: {
            (typeof A == "function" || W === oe) && (z = !0);
            break;
          }
          case ve: {
            (W === Nt || W === oe) && (z = !0);
            break;
          }
          case ye:
          case Ee: {
            (W === we || W === oe) && (z = !0);
            break;
          }
          default:
            return !1;
        }
        if (z) {
          var ee = Cl(M);
          if (ee !== void 0 && ee === Cl(A))
            return !0;
        }
        return !1;
      }
    }
    function zT(u) {
      {
        if (Cl === null || typeof WeakSet != "function")
          return;
        $g === null && ($g = /* @__PURE__ */ new WeakSet()), $g.add(u);
      }
    }
    var ew = function(u, f) {
      {
        if (Cl === null)
          return;
        var M = f.staleFamilies, A = f.updatedFamilies;
        lv(), j1(function() {
          nu(u.current, A, M);
        });
      }
    }, nh = function(u, f) {
      {
        if (u.context !== er)
          return;
        lv(), j1(function() {
          nw(f, u, null, null);
        });
      }
    };
    function nu(u, f, M) {
      {
        var A = u.alternate, z = u.child, W = u.sibling, ee = u.tag, ae = u.type, _e = null;
        switch (ee) {
          case te:
          case Ee:
          case Y:
            _e = ae;
            break;
          case ve:
            _e = ae.render;
            break;
        }
        if (Cl === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var Ue = !1, We = !1;
        if (_e !== null) {
          var St = Cl(_e);
          St !== void 0 && (M.has(St) ? We = !0 : f.has(St) && (ee === Y ? We = !0 : Ue = !0));
        }
        $g !== null && ($g.has(u) || A !== null && $g.has(A)) && (We = !0), We && (u._debugNeedsRemount = !0), (We || Ue) && Tl(u, Hr, Vi), z !== null && !We && nu(z, f, M), W !== null && nu(W, f, M);
      }
    }
    var cv = function(u, f) {
      {
        var M = /* @__PURE__ */ new Set(), A = new Set(f.map(function(z) {
          return z.current;
        }));
        return ru(u.current, A, M), M;
      }
    };
    function ru(u, f, M) {
      {
        var A = u.child, z = u.sibling, W = u.tag, ee = u.type, ae = null;
        switch (W) {
          case te:
          case Ee:
          case Y:
            ae = ee;
            break;
          case ve:
            ae = ee.render;
            break;
        }
        var _e = !1;
        ae !== null && f.has(ae) && (_e = !0), _e ? tf(u, M) : A !== null && ru(A, f, M), z !== null && ru(z, f, M);
      }
    }
    function tf(u, f) {
      {
        var M = vE(u, f);
        if (M)
          return;
        for (var A = u; ; ) {
          switch (A.tag) {
            case ue:
              f.add(A.stateNode);
              return;
            case ce:
              f.add(A.stateNode.containerInfo);
              return;
            case se:
              f.add(A.stateNode.containerInfo);
              return;
          }
          if (A.return === null)
            throw new Error("Expected to reach root first.");
          A = A.return;
        }
      }
    }
    function vE(u, f) {
      for (var M = u, A = !1; ; ) {
        if (M.tag === ue)
          A = !0, f.add(M.stateNode);
        else if (M.child !== null) {
          M.child.return = M, M = M.child;
          continue;
        }
        if (M === u)
          return A;
        for (; M.sibling === null; ) {
          if (M.return === null || M.return === u)
            return A;
          M = M.return;
        }
        M.sibling.return = M.return, M = M.sibling;
      }
      return !1;
    }
    var J1;
    {
      J1 = !1;
      try {
        var NT = Object.preventExtensions({});
      } catch {
        J1 = !0;
      }
    }
    function Yn(u, f, M, A) {
      this.tag = u, this.key = M, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = f, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = A, this.flags = Pe, this.subtreeFlags = Pe, this.deletions = null, this.lanes = sn, this.childLanes = sn, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !J1 && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var nf = function(u, f, M, A) {
      return new Yn(u, f, M, A);
    };
    function K1(u) {
      var f = u.prototype;
      return !!(f && f.isReactComponent);
    }
    function Mx(u) {
      return typeof u == "function" && !K1(u) && u.defaultProps === void 0;
    }
    function f0(u) {
      if (typeof u == "function")
        return K1(u) ? Y : te;
      if (u != null) {
        var f = u.$$typeof;
        if (f === Nt)
          return ve;
        if (f === we)
          return ye;
      }
      return re;
    }
    function la(u, f) {
      var M = u.alternate;
      M === null ? (M = nf(u.tag, f, u.key, u.mode), M.elementType = u.elementType, M.type = u.type, M.stateNode = u.stateNode, M._debugSource = u._debugSource, M._debugOwner = u._debugOwner, M._debugHookTypes = u._debugHookTypes, M.alternate = u, u.alternate = M) : (M.pendingProps = f, M.type = u.type, M.flags = Pe, M.subtreeFlags = Pe, M.deletions = null, M.actualDuration = 0, M.actualStartTime = -1), M.flags = u.flags & en, M.childLanes = u.childLanes, M.lanes = u.lanes, M.child = u.child, M.memoizedProps = u.memoizedProps, M.memoizedState = u.memoizedState, M.updateQueue = u.updateQueue;
      var A = u.dependencies;
      switch (M.dependencies = A === null ? null : {
        lanes: A.lanes,
        firstContext: A.firstContext
      }, M.sibling = u.sibling, M.index = u.index, M.ref = u.ref, M.selfBaseDuration = u.selfBaseDuration, M.treeBaseDuration = u.treeBaseDuration, M._debugNeedsRemount = u._debugNeedsRemount, M.tag) {
        case re:
        case te:
        case Ee:
          M.type = ey(u.type);
          break;
        case Y:
          M.type = mE(u.type);
          break;
        case ve:
          M.type = uv(u.type);
          break;
      }
      return M;
    }
    function Yu(u, f) {
      u.flags &= en | At;
      var M = u.alternate;
      if (M === null)
        u.childLanes = sn, u.lanes = f, u.child = null, u.subtreeFlags = Pe, u.memoizedProps = null, u.memoizedState = null, u.updateQueue = null, u.dependencies = null, u.stateNode = null, u.selfBaseDuration = 0, u.treeBaseDuration = 0;
      else {
        u.childLanes = M.childLanes, u.lanes = M.lanes, u.child = M.child, u.subtreeFlags = Pe, u.deletions = null, u.memoizedProps = M.memoizedProps, u.memoizedState = M.memoizedState, u.updateQueue = M.updateQueue, u.type = M.type;
        var A = M.dependencies;
        u.dependencies = A === null ? null : {
          lanes: A.lanes,
          firstContext: A.firstContext
        }, u.selfBaseDuration = M.selfBaseDuration, u.treeBaseDuration = M.treeBaseDuration;
      }
      return u;
    }
    function Xu(u, f, M) {
      var A;
      return u === Cc ? (A = $i, f === !0 && (A |= Fa, A |= _o)) : A = Mr, ns && (A |= Br), nf(se, null, null, A);
    }
    function Tx(u, f, M, A, z, W) {
      var ee = re, ae = u;
      if (typeof u == "function")
        K1(u) ? (ee = Y, ae = mE(ae)) : ae = ey(ae);
      else if (typeof u == "string")
        ee = ue;
      else {
        e:
          switch (u) {
            case dt:
              return Rp(M.children, z, W, f);
            case ht:
              ee = De, z |= Fa, (z & $i) !== Mr && (z |= _o);
              break;
            case xt:
              return hR(M, z, W, f);
            case Zt:
              return pR(M, z, W, f);
            case Rt:
              return tn(M, z, W, f);
            case Ft:
              return Nh(M, z, W, f);
            case Ot:
            case Qe:
            case Wt:
            case it:
            case ut:
            default: {
              if (typeof u == "object" && u !== null)
                switch (u.$$typeof) {
                  case Vt:
                    ee = He;
                    break e;
                  case yt:
                    ee = Re;
                    break e;
                  case Nt:
                    ee = ve, ae = uv(ae);
                    break e;
                  case we:
                    ee = ye;
                    break e;
                  case oe:
                    ee = Ve, ae = null;
                    break e;
                }
              var _e = "";
              {
                (u === void 0 || typeof u == "object" && u !== null && Object.keys(u).length === 0) && (_e += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
                var Ue = A ? wt(A) : null;
                Ue && (_e += `

Check the render method of \`` + Ue + "`.");
              }
              throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (u == null ? u : typeof u) + "." + _e));
            }
          }
      }
      var We = nf(ee, M, f, z);
      return We.elementType = u, We.type = ae, We.lanes = W, We._debugOwner = A, We;
    }
    function d0(u, f, M) {
      var A = null;
      A = u._owner;
      var z = u.type, W = u.key, ee = u.props, ae = Tx(z, W, ee, A, f, M);
      return ae._debugSource = u._source, ae._debugOwner = u._owner, ae;
    }
    function Rp(u, f, M, A) {
      var z = nf(me, u, A, f);
      return z.lanes = M, z;
    }
    function hR(u, f, M, A) {
      typeof u.id != "string" && g('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof u.id);
      var z = nf(fe, u, A, f | Br);
      return z.elementType = xt, z.lanes = M, z.stateNode = {
        effectDuration: 0,
        passiveEffectDuration: 0
      }, z;
    }
    function pR(u, f, M, A) {
      var z = nf(he, u, A, f);
      return z.elementType = Zt, z.lanes = M, z;
    }
    function tn(u, f, M, A) {
      var z = nf(Ne, u, A, f);
      return z.elementType = Rt, z.lanes = M, z;
    }
    function Nh(u, f, M, A) {
      var z = nf(tt, u, A, f);
      z.elementType = Ft, z.lanes = M;
      var W = {};
      return z.stateNode = W, z;
    }
    function fv(u, f, M) {
      var A = nf(Me, u, null, f);
      return A.lanes = M, A;
    }
    function gE() {
      var u = nf(ue, null, null, Mr);
      return u.elementType = "DELETED", u;
    }
    function Wa(u) {
      var f = nf(rt, null, null, Mr);
      return f.stateNode = u, f;
    }
    function Dn(u, f, M) {
      var A = u.children !== null ? u.children : [], z = nf(ce, A, u.key, f);
      return z.lanes = M, z.stateNode = {
        containerInfo: u.containerInfo,
        pendingChildren: null,
        implementation: u.implementation
      }, z;
    }
    function h0(u, f) {
      return u === null && (u = nf(re, null, null, Mr)), u.tag = f.tag, u.key = f.key, u.elementType = f.elementType, u.type = f.type, u.stateNode = f.stateNode, u.return = f.return, u.child = f.child, u.sibling = f.sibling, u.index = f.index, u.ref = f.ref, u.pendingProps = f.pendingProps, u.memoizedProps = f.memoizedProps, u.updateQueue = f.updateQueue, u.memoizedState = f.memoizedState, u.dependencies = f.dependencies, u.mode = f.mode, u.flags = f.flags, u.subtreeFlags = f.subtreeFlags, u.deletions = f.deletions, u.lanes = f.lanes, u.childLanes = f.childLanes, u.alternate = f.alternate, u.actualDuration = f.actualDuration, u.actualStartTime = f.actualStartTime, u.selfBaseDuration = f.selfBaseDuration, u.treeBaseDuration = f.treeBaseDuration, u._debugSource = f._debugSource, u._debugOwner = f._debugOwner, u._debugNeedsRemount = f._debugNeedsRemount, u._debugHookTypes = f._debugHookTypes, u;
    }
    function mR(u, f, M, A, z) {
      this.tag = f, this.containerInfo = u, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = ei, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = kr, this.eventTimes = Bl(sn), this.expirationTimes = Bl(Vi), this.pendingLanes = sn, this.suspendedLanes = sn, this.pingedLanes = sn, this.expiredLanes = sn, this.mutableReadLanes = sn, this.finishedLanes = sn, this.entangledLanes = sn, this.entanglements = Bl(sn), this.identifierPrefix = A, this.onRecoverableError = z, fs && (this.mutableSourceEagerHydrationData = null), this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var W = this.pendingUpdatersLaneMap = [], ee = 0; ee < id; ee++)
          W.push(/* @__PURE__ */ new Set());
      }
      switch (f) {
        case Cc:
          this._debugRootType = M ? "hydrateRoot()" : "createRoot()";
          break;
        case Tc:
          this._debugRootType = M ? "hydrate()" : "render()";
          break;
      }
    }
    function rf(u, f, M, A, z, W, ee, ae, _e, Ue) {
      var We = new mR(u, f, M, ae, _e), St = Xu(f, W);
      We.current = St, St.stateNode = We;
      {
        var It = {
          element: A,
          isDehydrated: M,
          cache: null,
          transitions: null
        };
        St.memoizedState = It;
      }
      return jn(St), We;
    }
    var yE = "18.0.0-fc46dba67-20220329";
    function Cx(u, f, M) {
      var A = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return yu(A), {
        $$typeof: qe,
        key: A == null ? null : "" + A,
        children: u,
        containerInfo: f,
        implementation: M
      };
    }
    var ty, tw;
    ty = !1, tw = {};
    function xE(u) {
      if (!u)
        return er;
      var f = T(u), M = Gp(f);
      if (f.tag === Y) {
        var A = f.type;
        if (ml(A))
          return vl(f, A, M);
      }
      return M;
    }
    function dv(u) {
      var f = T(u);
      if (f === void 0) {
        if (typeof u.render == "function")
          throw new Error("Unable to find node on an unmounted component.");
        var M = Object.keys(u).join(",");
        throw new Error("Argument appears to not be a ReactComponent. Keys: " + M);
      }
      var A = cs(f);
      return A === null ? null : A.stateNode;
    }
    function Ap(u, f) {
      {
        var M = T(u);
        if (M === void 0) {
          if (typeof u.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var A = Object.keys(u).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + A);
        }
        var z = cs(M);
        if (z === null)
          return null;
        if (z.mode & Fa) {
          var W = wt(M) || "Component";
          if (!tw[W]) {
            tw[W] = !0;
            var ee = to;
            try {
              bi(z), M.mode & Fa ? g("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", f, f, W) : g("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", f, f, W);
            } finally {
              ee ? bi(ee) : Ms();
            }
          }
        }
        return z.stateNode;
      }
    }
    function FT(u, f, M, A, z, W, ee, ae) {
      var _e = !1, Ue = null;
      return rf(u, f, _e, Ue, M, A, z, W, ee);
    }
    function _E(u, f, M, A, z, W, ee, ae, _e, Ue) {
      var We = !0, St = rf(M, A, We, u, z, W, ee, ae, _e);
      St.context = xE(null);
      var It = St.current, Yt = yc(), pn = Xv(It), Sn = Er(Yt, pn);
      return Sn.callback = f != null ? f : null, Ar(It, Sn), tE(St, pn, Yt), St;
    }
    function nw(u, f, M, A) {
      _a(f, u);
      var z = f.current, W = yc(), ee = Xv(z);
      Fs(ee);
      var ae = xE(M);
      f.context === null ? f.context = ae : f.pendingContext = ae, ql && to !== null && !ty && (ty = !0, g(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, wt(to) || "Unknown"));
      var _e = Er(W, ee);
      _e.payload = {
        element: u
      }, A = A === void 0 ? null : A, A !== null && (typeof A != "function" && g("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", A), _e.callback = A), Ar(z, _e);
      var Ue = Tl(z, ee, W);
      return Ue !== null && Va(Ue, z, ee), ee;
    }
    function SE(u) {
      var f = u.current;
      if (!f.child)
        return null;
      switch (f.child.tag) {
        case ue:
          return Uo(f.child.stateNode);
        default:
          return f.child.stateNode;
      }
    }
    function wE(u) {
      switch (u.tag) {
        case se:
          var f = u.stateNode;
          if (Di(f)) {
            var M = es(f);
            jS(f, M);
          }
          break;
        case he:
          var A = yc();
          j1(function() {
            return Tl(u, Hr, A);
          });
          var z = Hr;
          kT(u, z);
          break;
      }
    }
    function vR(u, f) {
      var M = u.memoizedState;
      M !== null && M.dehydrated !== null && (M.retryLane = vn(M.retryLane, f));
    }
    function kT(u, f) {
      vR(u, f);
      var M = u.alternate;
      M && vR(M, f);
    }
    function bE(u) {
      if (u.tag === he) {
        var f = yc(), M = xe;
        Tl(u, M, f), kT(u, M);
      }
    }
    function rw(u) {
      if (u.tag === he) {
        var f = yc(), M = Xv(u);
        Tl(u, M, f), kT(u, M);
      }
    }
    function IT(u) {
      var f = di(u);
      return f === null ? null : f.stateNode;
    }
    var EE = function(u) {
      return null;
    };
    function ME(u) {
      return EE(u);
    }
    var TE = function(u) {
      return !1;
    };
    function CE(u) {
      return TE(u);
    }
    var $1 = null, iw = null, aw = null, Rx = null, sw = null, e_ = null, Ax = null, t_ = null, n_ = null;
    {
      var Dx = function(u, f, M) {
        var A = f[M], z = Ti(u) ? u.slice() : w({}, u);
        return M + 1 === f.length ? (Ti(z) ? z.splice(A, 1) : delete z[A], z) : (z[A] = Dx(u[A], f, M + 1), z);
      }, ow = function(u, f) {
        return Dx(u, f, 0);
      }, r_ = function(u, f, M, A) {
        var z = f[A], W = Ti(u) ? u.slice() : w({}, u);
        if (A + 1 === f.length) {
          var ee = M[A];
          W[ee] = W[z], Ti(W) ? W.splice(z, 1) : delete W[z];
        } else
          W[z] = r_(
            u[z],
            f,
            M,
            A + 1
          );
        return W;
      }, lw = function(u, f, M) {
        if (f.length !== M.length) {
          p("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var A = 0; A < M.length - 1; A++)
            if (f[A] !== M[A]) {
              p("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return r_(u, f, M, 0);
      }, i_ = function(u, f, M, A) {
        if (M >= f.length)
          return A;
        var z = f[M], W = Ti(u) ? u.slice() : w({}, u);
        return W[z] = i_(u[z], f, M + 1, A), W;
      }, RE = function(u, f, M) {
        return i_(u, f, 0, M);
      }, a_ = function(u, f) {
        for (var M = u.memoizedState; M !== null && f > 0; )
          M = M.next, f--;
        return M;
      };
      $1 = function(u, f, M, A) {
        var z = a_(u, f);
        if (z !== null) {
          var W = RE(z.memoizedState, M, A);
          z.memoizedState = W, z.baseState = W, u.memoizedProps = w({}, u.memoizedProps), Tl(u, Hr, Vi);
        }
      }, iw = function(u, f, M) {
        var A = a_(u, f);
        if (A !== null) {
          var z = ow(A.memoizedState, M);
          A.memoizedState = z, A.baseState = z, u.memoizedProps = w({}, u.memoizedProps), Tl(u, Hr, Vi);
        }
      }, aw = function(u, f, M, A) {
        var z = a_(u, f);
        if (z !== null) {
          var W = lw(z.memoizedState, M, A);
          z.memoizedState = W, z.baseState = W, u.memoizedProps = w({}, u.memoizedProps), Tl(u, Hr, Vi);
        }
      }, Rx = function(u, f, M) {
        u.pendingProps = RE(u.memoizedProps, f, M), u.alternate && (u.alternate.pendingProps = u.pendingProps), Tl(u, Hr, Vi);
      }, sw = function(u, f) {
        u.pendingProps = ow(u.memoizedProps, f), u.alternate && (u.alternate.pendingProps = u.pendingProps), Tl(u, Hr, Vi);
      }, e_ = function(u, f, M) {
        u.pendingProps = lw(u.memoizedProps, f, M), u.alternate && (u.alternate.pendingProps = u.pendingProps), Tl(u, Hr, Vi);
      }, Ax = function(u) {
        Tl(u, Hr, Vi);
      }, t_ = function(u) {
        EE = u;
      }, n_ = function(u) {
        TE = u;
      };
    }
    function uw(u) {
      var f = cs(u);
      return f === null ? null : f.stateNode;
    }
    function gR(u) {
      return null;
    }
    function cw() {
      return to;
    }
    function AE(u) {
      var f = u.findFiberByHostInstance, M = s.ReactCurrentDispatcher;
      return Mf({
        bundleType: u.bundleType,
        version: u.version,
        rendererPackageName: u.rendererPackageName,
        rendererConfig: u.rendererConfig,
        overrideHookState: $1,
        overrideHookStateDeletePath: iw,
        overrideHookStateRenamePath: aw,
        overrideProps: Rx,
        overridePropsDeletePath: sw,
        overridePropsRenamePath: e_,
        setErrorHandler: t_,
        setSuspenseHandler: n_,
        scheduleUpdate: Ax,
        currentDispatcherRef: M,
        findHostInstanceByFiber: uw,
        findFiberByHostInstance: f || gR,
        findHostInstancesForRefresh: cv,
        scheduleRefresh: ew,
        scheduleRoot: nh,
        setRefreshHandler: Ex,
        getCurrentFiber: cw,
        reconcilerVersion: yE
      });
    }
    return t.attemptContinuousHydration = bE, t.attemptHydrationAtCurrentPriority = rw, t.attemptSynchronousHydration = wE, t.batchedUpdates = bT, t.createComponentSelector = Zc, t.createContainer = FT, t.createHasPseudoClassSelector = Cp, t.createHydrationContainer = _E, t.createPortal = Cx, t.createRoleSelector = pm, t.createTestNameSelector = jg, t.createTextSelector = e0, t.deferredUpdates = uR, t.discreteUpdates = YS, t.findAllNodes = F1, t.findBoundingRects = qb, t.findHostInstance = dv, t.findHostInstanceWithNoPortals = IT, t.findHostInstanceWithWarning = Ap, t.flushControlled = ET, t.flushPassiveEffects = lv, t.flushSync = j1, t.focusWithin = gT, t.getCurrentUpdatePriority = il, t.getFindAllNodesFailureDescription = vT, t.getPublicRootInstance = SE, t.injectIntoDevTools = AE, t.isAlreadyRendering = nE, t.observeVisibleRects = Zb, t.registerMutableSourceForHydration = Uv, t.runWithPriority = fa, t.shouldError = ME, t.shouldSuspend = CE, t.updateContainer = nw, t;
  })), lD.exports;
}
(function(a) {
  process.env.NODE_ENV === "production" ? a.exports = C9() : a.exports = R9();
})(Pk);
const A9 = /* @__PURE__ */ Lk(Pk.exports);
function D9(a, e, t = (r, i) => r === i) {
  if (a === e)
    return !0;
  if (!a || !e)
    return !1;
  const r = a.length;
  if (e.length !== r)
    return !1;
  for (let i = 0; i < r; i++)
    if (!t(a[i], e[i]))
      return !1;
  return !0;
}
const q2 = [];
function L9(a, e, t = !1, r = {}) {
  for (const s of q2)
    if (D9(e, s.keys, s.equal)) {
      if (t)
        return;
      if (Object.prototype.hasOwnProperty.call(s, "error"))
        throw s.error;
      if (Object.prototype.hasOwnProperty.call(s, "response"))
        return s.response;
      if (!t)
        throw s.promise;
    }
  const i = {
    keys: e,
    equal: r.equal,
    promise: a(...e).then((s) => i.response = s).then(() => {
      r.lifespan && r.lifespan > 0 && setTimeout(() => {
        const s = q2.indexOf(i);
        s !== -1 && q2.splice(s, 1);
      }, r.lifespan);
    }).catch((s) => i.error = s)
  };
  if (q2.push(i), !t)
    throw i.promise;
}
const P9 = (a, e, t) => L9(a, e, !1, t);
var eR = { exports: {} }, aM = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var oz;
function O9() {
  if (oz)
    return aM;
  oz = 1;
  var a = ph, e = Symbol.for("react.element"), t = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, i = a.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, s = { key: !0, ref: !0, __self: !0, __source: !0 };
  function l(d, p, g) {
    var _, w = {}, T = null, R = null;
    g !== void 0 && (T = "" + g), p.key !== void 0 && (T = "" + p.key), p.ref !== void 0 && (R = p.ref);
    for (_ in p)
      r.call(p, _) && !s.hasOwnProperty(_) && (w[_] = p[_]);
    if (d && d.defaultProps)
      for (_ in p = d.defaultProps, p)
        w[_] === void 0 && (w[_] = p[_]);
    return { $$typeof: e, type: d, key: T, ref: R, props: w, _owner: i.current };
  }
  return aM.Fragment = t, aM.jsx = l, aM.jsxs = l, aM;
}
var sM = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var lz;
function U9() {
  return lz || (lz = 1, process.env.NODE_ENV !== "production" && function() {
    var a = ph, e = Symbol.for("react.element"), t = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), l = Symbol.for("react.provider"), d = Symbol.for("react.context"), p = Symbol.for("react.forward_ref"), g = Symbol.for("react.suspense"), _ = Symbol.for("react.suspense_list"), w = Symbol.for("react.memo"), T = Symbol.for("react.lazy"), R = Symbol.for("react.offscreen"), D = Symbol.iterator, O = "@@iterator";
    function U(de) {
      if (de === null || typeof de != "object")
        return null;
      var Le = D && de[D] || de[O];
      return typeof Le == "function" ? Le : null;
    }
    var H = a.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function I(de) {
      {
        for (var Le = arguments.length, Ye = new Array(Le > 1 ? Le - 1 : 0), $t = 1; $t < Le; $t++)
          Ye[$t - 1] = arguments[$t];
        G("error", de, Ye);
      }
    }
    function G(de, Le, Ye) {
      {
        var $t = H.ReactDebugCurrentFrame, mn = $t.getStackAddendum();
        mn !== "" && (Le += "%s", Ye = Ye.concat([mn]));
        var Rn = Ye.map(function(gn) {
          return String(gn);
        });
        Rn.unshift("Warning: " + Le), Function.prototype.apply.call(console[de], console, Rn);
      }
    }
    var B = !1, Q = !1, K = !1, te = !1, Y = !1, re;
    re = Symbol.for("react.module.reference");
    function se(de) {
      return !!(typeof de == "string" || typeof de == "function" || de === r || de === s || Y || de === i || de === g || de === _ || te || de === R || B || Q || K || typeof de == "object" && de !== null && (de.$$typeof === T || de.$$typeof === w || de.$$typeof === l || de.$$typeof === d || de.$$typeof === p || de.$$typeof === re || de.getModuleId !== void 0));
    }
    function ce(de, Le, Ye) {
      var $t = de.displayName;
      if ($t)
        return $t;
      var mn = Le.displayName || Le.name || "";
      return mn !== "" ? Ye + "(" + mn + ")" : Ye;
    }
    function ue(de) {
      return de.displayName || "Context";
    }
    function Me(de) {
      if (de == null)
        return null;
      if (typeof de.tag == "number" && I("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof de == "function")
        return de.displayName || de.name || null;
      if (typeof de == "string")
        return de;
      switch (de) {
        case r:
          return "Fragment";
        case t:
          return "Portal";
        case s:
          return "Profiler";
        case i:
          return "StrictMode";
        case g:
          return "Suspense";
        case _:
          return "SuspenseList";
      }
      if (typeof de == "object")
        switch (de.$$typeof) {
          case d:
            var Le = de;
            return ue(Le) + ".Consumer";
          case l:
            var Ye = de;
            return ue(Ye._context) + ".Provider";
          case p:
            return ce(de, de.render, "ForwardRef");
          case w:
            var $t = de.displayName || null;
            return $t !== null ? $t : Me(de.type) || "Memo";
          case T: {
            var mn = de, Rn = mn._payload, gn = mn._init;
            try {
              return Me(gn(Rn));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var me = Object.assign, De = 0, Re, He, ve, fe, he, ye, Ee;
    function Ve() {
    }
    Ve.__reactDisabledLog = !0;
    function Je() {
      {
        if (De === 0) {
          Re = console.log, He = console.info, ve = console.warn, fe = console.error, he = console.group, ye = console.groupCollapsed, Ee = console.groupEnd;
          var de = {
            configurable: !0,
            enumerable: !0,
            value: Ve,
            writable: !0
          };
          Object.defineProperties(console, {
            info: de,
            log: de,
            warn: de,
            error: de,
            group: de,
            groupCollapsed: de,
            groupEnd: de
          });
        }
        De++;
      }
    }
    function rt() {
      {
        if (De--, De === 0) {
          var de = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: me({}, de, {
              value: Re
            }),
            info: me({}, de, {
              value: He
            }),
            warn: me({}, de, {
              value: ve
            }),
            error: me({}, de, {
              value: fe
            }),
            group: me({}, de, {
              value: he
            }),
            groupCollapsed: me({}, de, {
              value: ye
            }),
            groupEnd: me({}, de, {
              value: Ee
            })
          });
        }
        De < 0 && I("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Ne = H.ReactCurrentDispatcher, ct;
    function tt(de, Le, Ye) {
      {
        if (ct === void 0)
          try {
            throw Error();
          } catch (mn) {
            var $t = mn.stack.trim().match(/\n( *(at )?)/);
            ct = $t && $t[1] || "";
          }
        return `
` + ct + de;
      }
    }
    var Tt = !1, gt;
    {
      var ft = typeof WeakMap == "function" ? WeakMap : Map;
      gt = new ft();
    }
    function Ie(de, Le) {
      if (!de || Tt)
        return "";
      {
        var Ye = gt.get(de);
        if (Ye !== void 0)
          return Ye;
      }
      var $t;
      Tt = !0;
      var mn = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Rn;
      Rn = Ne.current, Ne.current = null, Je();
      try {
        if (Le) {
          var gn = function() {
            throw Error();
          };
          if (Object.defineProperty(gn.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(gn, []);
            } catch (en) {
              $t = en;
            }
            Reflect.construct(de, [], gn);
          } else {
            try {
              gn.call();
            } catch (en) {
              $t = en;
            }
            de.call(gn.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (en) {
            $t = en;
          }
          de();
        }
      } catch (en) {
        if (en && $t && typeof en.stack == "string") {
          for (var yn = en.stack.split(`
`), Jn = $t.stack.split(`
`), rr = yn.length - 1, wr = Jn.length - 1; rr >= 1 && wr >= 0 && yn[rr] !== Jn[wr]; )
            wr--;
          for (; rr >= 1 && wr >= 0; rr--, wr--)
            if (yn[rr] !== Jn[wr]) {
              if (rr !== 1 || wr !== 1)
                do
                  if (rr--, wr--, wr < 0 || yn[rr] !== Jn[wr]) {
                    var Yi = `
` + yn[rr].replace(" at new ", " at ");
                    return de.displayName && Yi.includes("<anonymous>") && (Yi = Yi.replace("<anonymous>", de.displayName)), typeof de == "function" && gt.set(de, Yi), Yi;
                  }
                while (rr >= 1 && wr >= 0);
              break;
            }
        }
      } finally {
        Tt = !1, Ne.current = Rn, rt(), Error.prepareStackTrace = mn;
      }
      var La = de ? de.displayName || de.name : "", qs = La ? tt(La) : "";
      return typeof de == "function" && gt.set(de, qs), qs;
    }
    function qe(de, Le, Ye) {
      return Ie(de, !1);
    }
    function dt(de) {
      var Le = de.prototype;
      return !!(Le && Le.isReactComponent);
    }
    function ht(de, Le, Ye) {
      if (de == null)
        return "";
      if (typeof de == "function")
        return Ie(de, dt(de));
      if (typeof de == "string")
        return tt(de);
      switch (de) {
        case g:
          return tt("Suspense");
        case _:
          return tt("SuspenseList");
      }
      if (typeof de == "object")
        switch (de.$$typeof) {
          case p:
            return qe(de.render);
          case w:
            return ht(de.type, Le, Ye);
          case T: {
            var $t = de, mn = $t._payload, Rn = $t._init;
            try {
              return ht(Rn(mn), Le, Ye);
            } catch {
            }
          }
        }
      return "";
    }
    var xt = Object.prototype.hasOwnProperty, Vt = {}, yt = H.ReactDebugCurrentFrame;
    function Nt(de) {
      if (de) {
        var Le = de._owner, Ye = ht(de.type, de._source, Le ? Le.type : null);
        yt.setExtraStackFrame(Ye);
      } else
        yt.setExtraStackFrame(null);
    }
    function Zt(de, Le, Ye, $t, mn) {
      {
        var Rn = Function.call.bind(xt);
        for (var gn in de)
          if (Rn(de, gn)) {
            var yn = void 0;
            try {
              if (typeof de[gn] != "function") {
                var Jn = Error(($t || "React class") + ": " + Ye + " type `" + gn + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof de[gn] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Jn.name = "Invariant Violation", Jn;
              }
              yn = de[gn](Le, gn, $t, Ye, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (rr) {
              yn = rr;
            }
            yn && !(yn instanceof Error) && (Nt(mn), I("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", $t || "React class", Ye, gn, typeof yn), Nt(null)), yn instanceof Error && !(yn.message in Vt) && (Vt[yn.message] = !0, Nt(mn), I("Failed %s type: %s", Ye, yn.message), Nt(null));
          }
      }
    }
    var Rt = Array.isArray;
    function we(de) {
      return Rt(de);
    }
    function oe(de) {
      {
        var Le = typeof Symbol == "function" && Symbol.toStringTag, Ye = Le && de[Symbol.toStringTag] || de.constructor.name || "Object";
        return Ye;
      }
    }
    function Qe(de) {
      try {
        return ut(de), !1;
      } catch {
        return !0;
      }
    }
    function ut(de) {
      return "" + de;
    }
    function Ft(de) {
      if (Qe(de))
        return I("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", oe(de)), ut(de);
    }
    var Ot = H.ReactCurrentOwner, Wt = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, it, an, Be;
    Be = {};
    function pe(de) {
      if (xt.call(de, "ref")) {
        var Le = Object.getOwnPropertyDescriptor(de, "ref").get;
        if (Le && Le.isReactWarning)
          return !1;
      }
      return de.ref !== void 0;
    }
    function Fe(de) {
      if (xt.call(de, "key")) {
        var Le = Object.getOwnPropertyDescriptor(de, "key").get;
        if (Le && Le.isReactWarning)
          return !1;
      }
      return de.key !== void 0;
    }
    function at(de, Le) {
      if (typeof de.ref == "string" && Ot.current && Le && Ot.current.stateNode !== Le) {
        var Ye = Me(Ot.current.type);
        Be[Ye] || (I('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', Me(Ot.current.type), de.ref), Be[Ye] = !0);
      }
    }
    function st(de, Le) {
      {
        var Ye = function() {
          it || (it = !0, I("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Le));
        };
        Ye.isReactWarning = !0, Object.defineProperty(de, "key", {
          get: Ye,
          configurable: !0
        });
      }
    }
    function dn(de, Le) {
      {
        var Ye = function() {
          an || (an = !0, I("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Le));
        };
        Ye.isReactWarning = !0, Object.defineProperty(de, "ref", {
          get: Ye,
          configurable: !0
        });
      }
    }
    var ze = function(de, Le, Ye, $t, mn, Rn, gn) {
      var yn = {
        $$typeof: e,
        type: de,
        key: Le,
        ref: Ye,
        props: gn,
        _owner: Rn
      };
      return yn._store = {}, Object.defineProperty(yn._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(yn, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: $t
      }), Object.defineProperty(yn, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: mn
      }), Object.freeze && (Object.freeze(yn.props), Object.freeze(yn)), yn;
    };
    function wt(de, Le, Ye, $t, mn) {
      {
        var Rn, gn = {}, yn = null, Jn = null;
        Ye !== void 0 && (Ft(Ye), yn = "" + Ye), Fe(Le) && (Ft(Le.key), yn = "" + Le.key), pe(Le) && (Jn = Le.ref, at(Le, mn));
        for (Rn in Le)
          xt.call(Le, Rn) && !Wt.hasOwnProperty(Rn) && (gn[Rn] = Le[Rn]);
        if (de && de.defaultProps) {
          var rr = de.defaultProps;
          for (Rn in rr)
            gn[Rn] === void 0 && (gn[Rn] = rr[Rn]);
        }
        if (yn || Jn) {
          var wr = typeof de == "function" ? de.displayName || de.name || "Unknown" : de;
          yn && st(gn, wr), Jn && dn(gn, wr);
        }
        return ze(de, yn, Jn, mn, $t, Ot.current, gn);
      }
    }
    var Pe = H.ReactCurrentOwner, Gt = H.ReactDebugCurrentFrame;
    function At(de) {
      if (de) {
        var Le = de._owner, Ye = ht(de.type, de._source, Le ? Le.type : null);
        Gt.setExtraStackFrame(Ye);
      } else
        Gt.setExtraStackFrame(null);
    }
    var cn;
    cn = !1;
    function ki(de) {
      return typeof de == "object" && de !== null && de.$$typeof === e;
    }
    function Or() {
      {
        if (Pe.current) {
          var de = Me(Pe.current.type);
          if (de)
            return `

Check the render method of \`` + de + "`.";
        }
        return "";
      }
    }
    function Ii(de) {
      {
        if (de !== void 0) {
          var Le = de.fileName.replace(/^.*[\\\/]/, ""), Ye = de.lineNumber;
          return `

Check your code at ` + Le + ":" + Ye + ".";
        }
        return "";
      }
    }
    var Ir = {};
    function Bn(de) {
      {
        var Le = Or();
        if (!Le) {
          var Ye = typeof de == "string" ? de : de.displayName || de.name;
          Ye && (Le = `

Check the top-level render call using <` + Ye + ">.");
        }
        return Le;
      }
    }
    function Mi(de, Le) {
      {
        if (!de._store || de._store.validated || de.key != null)
          return;
        de._store.validated = !0;
        var Ye = Bn(Le);
        if (Ir[Ye])
          return;
        Ir[Ye] = !0;
        var $t = "";
        de && de._owner && de._owner !== Pe.current && ($t = " It was passed a child from " + Me(de._owner.type) + "."), At(de), I('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Ye, $t), At(null);
      }
    }
    function yi(de, Le) {
      {
        if (typeof de != "object")
          return;
        if (we(de))
          for (var Ye = 0; Ye < de.length; Ye++) {
            var $t = de[Ye];
            ki($t) && Mi($t, Le);
          }
        else if (ki(de))
          de._store && (de._store.validated = !0);
        else if (de) {
          var mn = U(de);
          if (typeof mn == "function" && mn !== de.entries)
            for (var Rn = mn.call(de), gn; !(gn = Rn.next()).done; )
              ki(gn.value) && Mi(gn.value, Le);
        }
      }
    }
    function ii(de) {
      {
        var Le = de.type;
        if (Le == null || typeof Le == "string")
          return;
        var Ye;
        if (typeof Le == "function")
          Ye = Le.propTypes;
        else if (typeof Le == "object" && (Le.$$typeof === p || Le.$$typeof === w))
          Ye = Le.propTypes;
        else
          return;
        if (Ye) {
          var $t = Me(Le);
          Zt(Ye, de.props, "prop", $t, de);
        } else if (Le.PropTypes !== void 0 && !cn) {
          cn = !0;
          var mn = Me(Le);
          I("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", mn || "Unknown");
        }
        typeof Le.getDefaultProps == "function" && !Le.getDefaultProps.isReactClassApproved && I("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Bi(de) {
      {
        for (var Le = Object.keys(de.props), Ye = 0; Ye < Le.length; Ye++) {
          var $t = Le[Ye];
          if ($t !== "children" && $t !== "key") {
            At(de), I("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", $t), At(null);
            break;
          }
        }
        de.ref !== null && (At(de), I("Invalid attribute `ref` supplied to `React.Fragment`."), At(null));
      }
    }
    function xi(de, Le, Ye, $t, mn, Rn) {
      {
        var gn = se(de);
        if (!gn) {
          var yn = "";
          (de === void 0 || typeof de == "object" && de !== null && Object.keys(de).length === 0) && (yn += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Jn = Ii(mn);
          Jn ? yn += Jn : yn += Or();
          var rr;
          de === null ? rr = "null" : we(de) ? rr = "array" : de !== void 0 && de.$$typeof === e ? (rr = "<" + (Me(de.type) || "Unknown") + " />", yn = " Did you accidentally export a JSX literal instead of a component?") : rr = typeof de, I("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", rr, yn);
        }
        var wr = wt(de, Le, Ye, mn, Rn);
        if (wr == null)
          return wr;
        if (gn) {
          var Yi = Le.children;
          if (Yi !== void 0)
            if ($t)
              if (we(Yi)) {
                for (var La = 0; La < Yi.length; La++)
                  yi(Yi[La], de);
                Object.freeze && Object.freeze(Yi);
              } else
                I("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              yi(Yi, de);
        }
        return de === r ? Bi(wr) : ii(wr), wr;
      }
    }
    function $r(de, Le, Ye) {
      return xi(de, Le, Ye, !0);
    }
    function ai(de, Le, Ye) {
      return xi(de, Le, Ye, !1);
    }
    var Te = ai, ot = $r;
    sM.Fragment = r, sM.jsx = Te, sM.jsxs = ot;
  }()), sM;
}
(function(a) {
  process.env.NODE_ENV === "production" ? a.exports = O9() : a.exports = U9();
})(eR);
const rT = eR.exports.Fragment, ln = eR.exports.jsx, _c = eR.exports.jsxs, wL = {}, z9 = (a) => void Object.assign(wL, a);
function N9(a, e) {
  function t(_, {
    args: w = [],
    attach: T,
    ...R
  }, D) {
    let O = `${_[0].toUpperCase()}${_.slice(1)}`, U;
    if (_ === "primitive") {
      if (R.object === void 0)
        throw new Error("R3F: Primitives without 'object' are invalid!");
      const H = R.object;
      U = Hw(H, {
        type: _,
        root: D,
        attach: T,
        primitive: !0
      });
    } else {
      const H = wL[O];
      if (!H)
        throw new Error(`R3F: ${O} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);
      if (!Array.isArray(w))
        throw new Error("R3F: The args prop must be an array!");
      U = Hw(new H(...w), {
        type: _,
        root: D,
        attach: T,
        memoizedProps: {
          args: w
        }
      });
    }
    return U.__r3f.attach === void 0 && (U instanceof oi ? U.__r3f.attach = "geometry" : U instanceof hf && (U.__r3f.attach = "material")), O !== "inject" && cD(U, R), U;
  }
  function r(_, w) {
    let T = !1;
    if (w) {
      var R, D;
      (R = w.__r3f) != null && R.attach ? uD(_, w, w.__r3f.attach) : w.isObject3D && _.isObject3D && (_.add(w), T = !0), T || (D = _.__r3f) == null || D.objects.push(w), w.__r3f || Hw(w, {}), w.__r3f.parent = _, T3(w), Vw(w);
    }
  }
  function i(_, w, T) {
    let R = !1;
    if (w) {
      var D, O;
      if ((D = w.__r3f) != null && D.attach)
        uD(_, w, w.__r3f.attach);
      else if (w.isObject3D && _.isObject3D) {
        w.parent = _, w.dispatchEvent({
          type: "added"
        });
        const U = _.children.filter((I) => I !== w), H = U.indexOf(T);
        _.children = [...U.slice(0, H), w, ...U.slice(H)], R = !0;
      }
      R || (O = _.__r3f) == null || O.objects.push(w), w.__r3f || Hw(w, {}), w.__r3f.parent = _, T3(w), Vw(w);
    }
  }
  function s(_, w, T = !1) {
    _ && [..._].forEach((R) => l(w, R, T));
  }
  function l(_, w, T) {
    if (w) {
      var R, D, O;
      if (w.__r3f && (w.__r3f.parent = null), (R = _.__r3f) != null && R.objects && (_.__r3f.objects = _.__r3f.objects.filter((B) => B !== w)), (D = w.__r3f) != null && D.attach)
        hz(_, w, w.__r3f.attach);
      else if (w.isObject3D && _.isObject3D) {
        var U;
        _.remove(w), (U = w.__r3f) != null && U.root && G9(w.__r3f.root, w);
      }
      const I = (O = w.__r3f) == null ? void 0 : O.primitive, G = T === void 0 ? w.dispose !== null && !I : T;
      if (!I) {
        var H;
        s((H = w.__r3f) == null ? void 0 : H.objects, w, G), s(w.children, w, G);
      }
      w.__r3f && (delete w.__r3f.root, delete w.__r3f.objects, delete w.__r3f.handlers, delete w.__r3f.memoizedProps, I || delete w.__r3f), G && w.dispose && w.type !== "Scene" && YM.exports.unstable_scheduleCallback(YM.exports.unstable_IdlePriority, () => {
        try {
          w.dispose();
        } catch {
        }
      }), Vw(_);
    }
  }
  function d(_, w, T, R) {
    var D;
    const O = (D = _.__r3f) == null ? void 0 : D.parent;
    if (!O)
      return;
    const U = t(w, T, _.__r3f.root);
    if (_.children) {
      for (const H of _.children)
        H.__r3f && r(U, H);
      _.children = _.children.filter((H) => !H.__r3f);
    }
    _.__r3f.objects.forEach((H) => r(U, H)), _.__r3f.objects = [], _.__r3f.autoRemovedBeforeAppend || l(O, _), U.parent && (U.__r3f.autoRemovedBeforeAppend = !0), r(O, U), U.raycast && U.__r3f.eventCount && U.__r3f.root.getState().internal.interaction.push(U), [R, R.alternate].forEach((H) => {
      H !== null && (H.stateNode = U, H.ref && (typeof H.ref == "function" ? H.ref(U) : H.ref.current = U));
    });
  }
  const p = () => console.warn("Text is not allowed in the R3F tree! This could be stray whitespace or characters.");
  return {
    reconciler: A9({
      createInstance: t,
      removeChild: l,
      appendChild: r,
      appendInitialChild: r,
      insertBefore: i,
      supportsMutation: !0,
      isPrimaryRenderer: !1,
      supportsPersistence: !1,
      supportsHydration: !1,
      noTimeout: -1,
      appendChildToContainer: (_, w) => {
        if (!w)
          return;
        const T = _.getState().scene;
        !T.__r3f || (T.__r3f.root = _, r(T, w));
      },
      removeChildFromContainer: (_, w) => {
        !w || l(_.getState().scene, w);
      },
      insertInContainerBefore: (_, w, T) => {
        if (!w || !T)
          return;
        const R = _.getState().scene;
        !R.__r3f || i(R, w, T);
      },
      getRootHostContext: () => null,
      getChildHostContext: (_) => _,
      finalizeInitialChildren(_) {
        var w;
        const T = (w = _ == null ? void 0 : _.__r3f) != null ? w : {};
        return Boolean(T.handlers);
      },
      prepareUpdate(_, w, T, R) {
        if (_.__r3f.primitive && R.object && R.object !== _)
          return [!0];
        {
          const {
            args: D = [],
            children: O,
            ...U
          } = R, {
            args: H = [],
            children: I,
            ...G
          } = T;
          if (!Array.isArray(D))
            throw new Error("R3F: the args prop must be an array!");
          if (D.some((Q, K) => Q !== H[K]))
            return [!0];
          const B = Ik(_, U, G, !0);
          return B.changes.length ? [!1, B] : null;
        }
      },
      commitUpdate(_, [w, T], R, D, O, U) {
        w ? d(_, R, O, U) : cD(_, T);
      },
      commitMount(_, w, T, R) {
        var D;
        const O = (D = _.__r3f) != null ? D : {};
        _.raycast && O.handlers && O.eventCount && _.__r3f.root.getState().internal.interaction.push(_);
      },
      getPublicInstance: (_) => _,
      prepareForCommit: () => null,
      preparePortalMount: (_) => Hw(_.getState().scene),
      resetAfterCommit: () => {
      },
      shouldSetTextContent: () => !1,
      clearContainer: () => !1,
      hideInstance(_) {
        var w;
        const {
          attach: T,
          parent: R
        } = (w = _.__r3f) != null ? w : {};
        T && R && hz(R, _, T), _.isObject3D && (_.visible = !1), Vw(_);
      },
      unhideInstance(_, w) {
        var T;
        const {
          attach: R,
          parent: D
        } = (T = _.__r3f) != null ? T : {};
        R && D && uD(D, _, R), (_.isObject3D && w.visible == null || w.visible) && (_.visible = !0), Vw(_);
      },
      createTextInstance: p,
      hideTextInstance: p,
      unhideTextInstance: p,
      getCurrentEventPriority: () => e ? e() : I_.exports.DefaultEventPriority,
      beforeActiveInstanceBlur: () => {
      },
      afterActiveInstanceBlur: () => {
      },
      detachDeletedInstance: () => {
      },
      now: typeof performance < "u" && Al.fun(performance.now) ? performance.now : Al.fun(Date.now) ? Date.now : () => 0,
      scheduleTimeout: Al.fun(setTimeout) ? setTimeout : void 0,
      cancelTimeout: Al.fun(clearTimeout) ? clearTimeout : void 0
    }),
    applyProps: cD
  };
}
var uz, cz;
const Ok = () => {
  var a;
  return (a = wL.ColorManagement) != null ? a : null;
}, Uk = (a) => a && a.isOrthographicCamera, F9 = (a) => a && a.hasOwnProperty("current"), iT = typeof window < "u" && ((uz = window.document) != null && uz.createElement || ((cz = window.navigator) == null ? void 0 : cz.product) === "ReactNative") ? Ln.useLayoutEffect : Ln.useEffect;
function zk(a) {
  const e = Ln.useRef(a);
  return iT(() => void (e.current = a), [a]), e;
}
function k9({
  set: a
}) {
  return iT(() => (a(new Promise(() => null)), () => a(!1)), [a]), null;
}
class Nk extends Ln.Component {
  constructor(...e) {
    super(...e), this.state = {
      error: !1
    };
  }
  componentDidCatch(e) {
    this.props.set(e);
  }
  render() {
    return this.state.error ? null : this.props.children;
  }
}
Nk.getDerivedStateFromError = () => ({
  error: !0
});
const Fk = "__default", fz = /* @__PURE__ */ new Map(), I9 = (a) => a && !!a.memoized && !!a.changes;
function kk(a) {
  const e = typeof window < "u" ? window.devicePixelRatio : 1;
  return Array.isArray(a) ? Math.min(Math.max(a[0], e), a[1]) : a;
}
const oM = (a) => {
  var e;
  return (e = a.__r3f) == null ? void 0 : e.root.getState();
}, Al = {
  obj: (a) => a === Object(a) && !Al.arr(a) && typeof a != "function",
  fun: (a) => typeof a == "function",
  str: (a) => typeof a == "string",
  num: (a) => typeof a == "number",
  boo: (a) => typeof a == "boolean",
  und: (a) => a === void 0,
  arr: (a) => Array.isArray(a),
  equ(a, e, {
    arrays: t = "shallow",
    objects: r = "reference",
    strict: i = !0
  } = {}) {
    if (typeof a != typeof e || !!a != !!e)
      return !1;
    if (Al.str(a) || Al.num(a))
      return a === e;
    const s = Al.obj(a);
    if (s && r === "reference")
      return a === e;
    const l = Al.arr(a);
    if (l && t === "reference")
      return a === e;
    if ((l || s) && a === e)
      return !0;
    let d;
    for (d in a)
      if (!(d in e))
        return !1;
    if (s && t === "shallow" && r === "shallow") {
      for (d in i ? e : a)
        if (!Al.equ(a[d], e[d], {
          strict: i,
          objects: "reference"
        }))
          return !1;
    } else
      for (d in i ? e : a)
        if (a[d] !== e[d])
          return !1;
    if (Al.und(d)) {
      if (l && a.length === 0 && e.length === 0 || s && Object.keys(a).length === 0 && Object.keys(e).length === 0)
        return !0;
      if (a !== e)
        return !1;
    }
    return !0;
  }
};
function B9(a) {
  a.dispose && a.type !== "Scene" && a.dispose();
  for (const e in a)
    e.dispose == null || e.dispose(), delete a[e];
}
function Hw(a, e) {
  const t = a;
  return (e != null && e.primitive || !t.__r3f) && (t.__r3f = {
    type: "",
    root: null,
    previousAttach: null,
    memoizedProps: {},
    eventCount: 0,
    handlers: {},
    objects: [],
    parent: null,
    ...e
  }), a;
}
function M3(a, e) {
  let t = a;
  if (e.includes("-")) {
    const r = e.split("-"), i = r.pop();
    return t = r.reduce((s, l) => s[l], a), {
      target: t,
      key: i
    };
  } else
    return {
      target: t,
      key: e
    };
}
const dz = /-\d+$/;
function uD(a, e, t) {
  if (Al.str(t)) {
    if (dz.test(t)) {
      const s = t.replace(dz, ""), {
        target: l,
        key: d
      } = M3(a, s);
      Array.isArray(l[d]) || (l[d] = []);
    }
    const {
      target: r,
      key: i
    } = M3(a, t);
    e.__r3f.previousAttach = r[i], r[i] = e;
  } else
    e.__r3f.previousAttach = t(a, e);
}
function hz(a, e, t) {
  var r, i;
  if (Al.str(t)) {
    const {
      target: s,
      key: l
    } = M3(a, t), d = e.__r3f.previousAttach;
    d === void 0 ? delete s[l] : s[l] = d;
  } else
    (r = e.__r3f) == null || r.previousAttach == null || r.previousAttach(a, e);
  (i = e.__r3f) == null || delete i.previousAttach;
}
function Ik(a, {
  children: e,
  key: t,
  ref: r,
  ...i
}, {
  children: s,
  key: l,
  ref: d,
  ...p
} = {}, g = !1) {
  var _;
  const w = (_ = a == null ? void 0 : a.__r3f) != null ? _ : {}, T = Object.entries(i), R = [];
  if (g) {
    const O = Object.keys(p);
    for (let U = 0; U < O.length; U++)
      i.hasOwnProperty(O[U]) || T.unshift([O[U], Fk + "remove"]);
  }
  T.forEach(([O, U]) => {
    var H;
    if ((H = a.__r3f) != null && H.primitive && O === "object" || Al.equ(U, p[O]))
      return;
    if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(O))
      return R.push([O, U, !0, []]);
    let I = [];
    O.includes("-") && (I = O.split("-")), R.push([O, U, !1, I]);
    for (const G in i) {
      const B = i[G];
      G.startsWith(`${O}-`) && R.push([G, B, !1, G.split("-")]);
    }
  });
  const D = {
    ...i
  };
  return w.memoizedProps && w.memoizedProps.args && (D.args = w.memoizedProps.args), w.memoizedProps && w.memoizedProps.attach && (D.attach = w.memoizedProps.attach), {
    memoized: D,
    changes: R
  };
}
function cD(a, e) {
  var t, r, i;
  const s = (t = a.__r3f) != null ? t : {}, l = s.root, d = (r = l == null || l.getState == null ? void 0 : l.getState()) != null ? r : {}, {
    memoized: p,
    changes: g
  } = I9(e) ? e : Ik(a, e), _ = s.eventCount;
  a.__r3f && (a.__r3f.memoizedProps = p);
  for (let T = 0; T < g.length; T++) {
    let [R, D, O, U] = g[T], H = a, I = H[R];
    if (U.length && (I = U.reduce((G, B) => G[B], a), !(I && I.set))) {
      const [G, ...B] = U.reverse();
      H = B.reverse().reduce((Q, K) => Q[K], a), R = G;
    }
    if (D === Fk + "remove")
      if (H.constructor) {
        let G = fz.get(H.constructor);
        G || (G = new H.constructor(), fz.set(H.constructor, G)), D = G[R];
      } else
        D = 0;
    if (O)
      D ? s.handlers[R] = D : delete s.handlers[R], s.eventCount = Object.keys(s.handlers).length;
    else if (I && I.set && (I.copy || I instanceof G_)) {
      if (Array.isArray(D))
        I.fromArray ? I.fromArray(D) : I.set(...D);
      else if (I.copy && D && D.constructor && I.constructor === D.constructor)
        I.copy(D);
      else if (D !== void 0) {
        const G = I instanceof Un;
        !G && I.setScalar ? I.setScalar(D) : I instanceof G_ && D instanceof G_ ? I.mask = D.mask : I.set(D), !Ok() && !d.linear && G && I.convertSRGBToLinear();
      }
    } else
      H[R] = D, !d.linear && H[R] instanceof su && H[R].format === zp && H[R].type === df && (H[R].encoding = gi);
    Vw(a);
  }
  if (s.parent && d.internal && a.raycast && _ !== s.eventCount) {
    const T = d.internal.interaction.indexOf(a);
    T > -1 && d.internal.interaction.splice(T, 1), s.eventCount && d.internal.interaction.push(a);
  }
  return !(g.length === 1 && g[0][0] === "onUpdate") && g.length && (i = a.__r3f) != null && i.parent && T3(a), a;
}
function Vw(a) {
  var e, t;
  const r = (e = a.__r3f) == null || (t = e.root) == null || t.getState == null ? void 0 : t.getState();
  r && r.internal.frames === 0 && r.invalidate();
}
function T3(a) {
  a.onUpdate == null || a.onUpdate(a);
}
function H9(a, e) {
  a.manual || (Uk(a) ? (a.left = e.width / -2, a.right = e.width / 2, a.top = e.height / 2, a.bottom = e.height / -2) : a.aspect = e.width / e.height, a.updateProjectionMatrix(), a.updateMatrixWorld());
}
function Q2(a) {
  return (a.eventObject || a.object).uuid + "/" + a.index + a.instanceId;
}
function V9() {
  var a;
  const e = typeof self < "u" && self || typeof window < "u" && window;
  if (!e)
    return I_.exports.DefaultEventPriority;
  switch ((a = e.event) == null ? void 0 : a.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
      return I_.exports.DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
      return I_.exports.ContinuousEventPriority;
    default:
      return I_.exports.DefaultEventPriority;
  }
}
function Bk(a, e, t, r) {
  const i = t.get(e);
  i && (t.delete(e), t.size === 0 && (a.delete(r), i.target.releasePointerCapture(r)));
}
function G9(a, e) {
  const {
    internal: t
  } = a.getState();
  t.interaction = t.interaction.filter((r) => r !== e), t.initialHits = t.initialHits.filter((r) => r !== e), t.hovered.forEach((r, i) => {
    (r.eventObject === e || r.object === e) && t.hovered.delete(i);
  }), t.capturedMap.forEach((r, i) => {
    Bk(t.capturedMap, e, r, i);
  });
}
function W9(a) {
  function e(p) {
    const {
      internal: g
    } = a.getState(), _ = p.offsetX - g.initialClick[0], w = p.offsetY - g.initialClick[1];
    return Math.round(Math.sqrt(_ * _ + w * w));
  }
  function t(p) {
    return p.filter((g) => ["Move", "Over", "Enter", "Out", "Leave"].some((_) => {
      var w;
      return (w = g.__r3f) == null ? void 0 : w.handlers["onPointer" + _];
    }));
  }
  function r(p, g) {
    const _ = a.getState(), w = /* @__PURE__ */ new Set(), T = [], R = g ? g(_.internal.interaction) : _.internal.interaction;
    for (let H = 0; H < R.length; H++) {
      const I = oM(R[H]);
      I && (I.raycaster.camera = void 0);
    }
    _.previousRoot || _.events.compute == null || _.events.compute(p, _);
    function D(H) {
      const I = oM(H);
      if (!I || !I.events.enabled || I.raycaster.camera === null)
        return [];
      if (I.raycaster.camera === void 0) {
        var G;
        I.events.compute == null || I.events.compute(p, I, (G = I.previousRoot) == null ? void 0 : G.getState()), I.raycaster.camera === void 0 && (I.raycaster.camera = null);
      }
      return I.raycaster.camera ? I.raycaster.intersectObject(H, !0) : [];
    }
    let O = R.flatMap(D).sort((H, I) => {
      const G = oM(H.object), B = oM(I.object);
      return !G || !B ? H.distance - I.distance : B.events.priority - G.events.priority || H.distance - I.distance;
    }).filter((H) => {
      const I = Q2(H);
      return w.has(I) ? !1 : (w.add(I), !0);
    });
    _.events.filter && (O = _.events.filter(O, _));
    for (const H of O) {
      let I = H.object;
      for (; I; ) {
        var U;
        (U = I.__r3f) != null && U.eventCount && T.push({
          ...H,
          eventObject: I
        }), I = I.parent;
      }
    }
    if ("pointerId" in p && _.internal.capturedMap.has(p.pointerId))
      for (let H of _.internal.capturedMap.get(p.pointerId).values())
        w.has(Q2(H.intersection)) || T.push(H.intersection);
    return T;
  }
  function i(p, g, _, w) {
    const T = a.getState();
    if (p.length) {
      const R = {
        stopped: !1
      };
      for (const D of p) {
        const O = oM(D.object) || T, {
          raycaster: U,
          pointer: H,
          camera: I,
          internal: G
        } = O, B = new ge(H.x, H.y, 0).unproject(I), Q = (se) => {
          var ce, ue;
          return (ce = (ue = G.capturedMap.get(se)) == null ? void 0 : ue.has(D.eventObject)) != null ? ce : !1;
        }, K = (se) => {
          const ce = {
            intersection: D,
            target: g.target
          };
          G.capturedMap.has(se) ? G.capturedMap.get(se).set(D.eventObject, ce) : G.capturedMap.set(se, /* @__PURE__ */ new Map([[D.eventObject, ce]])), g.target.setPointerCapture(se);
        }, te = (se) => {
          const ce = G.capturedMap.get(se);
          ce && Bk(G.capturedMap, D.eventObject, ce, se);
        };
        let Y = {};
        for (let se in g) {
          let ce = g[se];
          typeof ce != "function" && (Y[se] = ce);
        }
        let re = {
          ...D,
          ...Y,
          pointer: H,
          intersections: p,
          stopped: R.stopped,
          delta: _,
          unprojectedPoint: B,
          ray: U.ray,
          camera: I,
          stopPropagation() {
            const se = "pointerId" in g && G.capturedMap.get(g.pointerId);
            if ((!se || se.has(D.eventObject)) && (re.stopped = R.stopped = !0, G.hovered.size && Array.from(G.hovered.values()).find((ce) => ce.eventObject === D.eventObject))) {
              const ce = p.slice(0, p.indexOf(D));
              s([...ce, D]);
            }
          },
          target: {
            hasPointerCapture: Q,
            setPointerCapture: K,
            releasePointerCapture: te
          },
          currentTarget: {
            hasPointerCapture: Q,
            setPointerCapture: K,
            releasePointerCapture: te
          },
          nativeEvent: g
        };
        if (w(re), R.stopped === !0)
          break;
      }
    }
    return p;
  }
  function s(p) {
    const {
      internal: g
    } = a.getState();
    for (const _ of g.hovered.values())
      if (!p.length || !p.find((w) => w.object === _.object && w.index === _.index && w.instanceId === _.instanceId)) {
        const T = _.eventObject.__r3f, R = T == null ? void 0 : T.handlers;
        if (g.hovered.delete(Q2(_)), T != null && T.eventCount) {
          const D = {
            ..._,
            intersections: p
          };
          R.onPointerOut == null || R.onPointerOut(D), R.onPointerLeave == null || R.onPointerLeave(D);
        }
      }
  }
  function l(p, g) {
    for (let _ = 0; _ < g.length; _++) {
      const w = g[_].__r3f;
      w == null || w.handlers.onPointerMissed == null || w.handlers.onPointerMissed(p);
    }
  }
  function d(p) {
    switch (p) {
      case "onPointerLeave":
      case "onPointerCancel":
        return () => s([]);
      case "onLostPointerCapture":
        return (g) => {
          const {
            internal: _
          } = a.getState();
          "pointerId" in g && _.capturedMap.has(g.pointerId) && requestAnimationFrame(() => {
            _.capturedMap.has(g.pointerId) && (_.capturedMap.delete(g.pointerId), s([]));
          });
        };
    }
    return function(_) {
      const {
        onPointerMissed: w,
        internal: T
      } = a.getState();
      T.lastEvent.current = _;
      const R = p === "onPointerMove", D = p === "onClick" || p === "onContextMenu" || p === "onDoubleClick", U = r(_, R ? t : void 0), H = D ? e(_) : 0;
      p === "onPointerDown" && (T.initialClick = [_.offsetX, _.offsetY], T.initialHits = U.map((G) => G.eventObject)), D && !U.length && H <= 2 && (l(_, T.interaction), w && w(_)), R && s(U);
      function I(G) {
        const B = G.eventObject, Q = B.__r3f, K = Q == null ? void 0 : Q.handlers;
        if (!!(Q != null && Q.eventCount))
          if (R) {
            if (K.onPointerOver || K.onPointerEnter || K.onPointerOut || K.onPointerLeave) {
              const te = Q2(G), Y = T.hovered.get(te);
              Y ? Y.stopped && G.stopPropagation() : (T.hovered.set(te, G), K.onPointerOver == null || K.onPointerOver(G), K.onPointerEnter == null || K.onPointerEnter(G));
            }
            K.onPointerMove == null || K.onPointerMove(G);
          } else {
            const te = K[p];
            te ? (!D || T.initialHits.includes(B)) && (l(_, T.interaction.filter((Y) => !T.initialHits.includes(Y))), te(G)) : D && T.initialHits.includes(B) && l(_, T.interaction.filter((Y) => !T.initialHits.includes(Y)));
          }
      }
      i(U, _, H, I);
    };
  }
  return {
    handlePointer: d
  };
}
const Hk = (a) => !!(a != null && a.render), Vk = /* @__PURE__ */ Ln.createContext(null), j9 = (a, e) => {
  const t = E9((d, p) => {
    const g = new ge(), _ = new ge(), w = new ge();
    function T(H = p().camera, I = _, G = p().size) {
      const {
        width: B,
        height: Q,
        top: K,
        left: te
      } = G, Y = B / Q;
      I instanceof ge ? w.copy(I) : w.set(...I);
      const re = H.getWorldPosition(g).distanceTo(w);
      if (Uk(H))
        return {
          width: B / H.zoom,
          height: Q / H.zoom,
          top: K,
          left: te,
          factor: 1,
          distance: re,
          aspect: Y
        };
      {
        const se = H.fov * Math.PI / 180, ce = 2 * Math.tan(se / 2) * re, ue = ce * (B / Q);
        return {
          width: ue,
          height: ce,
          top: K,
          left: te,
          factor: B / ue,
          distance: re,
          aspect: Y
        };
      }
    }
    let R;
    const D = (H) => d((I) => ({
      performance: {
        ...I.performance,
        current: H
      }
    })), O = new zt();
    return {
      set: d,
      get: p,
      gl: null,
      camera: null,
      raycaster: null,
      events: {
        priority: 1,
        enabled: !0,
        connected: !1
      },
      xr: null,
      invalidate: (H = 1) => a(p(), H),
      advance: (H, I) => e(H, I, p()),
      legacy: !1,
      linear: !1,
      flat: !1,
      scene: Hw(new NM()),
      controls: null,
      clock: new gL(),
      pointer: O,
      mouse: O,
      frameloop: "always",
      onPointerMissed: void 0,
      performance: {
        current: 1,
        min: 0.5,
        max: 1,
        debounce: 200,
        regress: () => {
          const H = p();
          R && clearTimeout(R), H.performance.current !== H.performance.min && D(H.performance.min), R = setTimeout(() => D(p().performance.max), H.performance.debounce);
        }
      },
      size: {
        width: 0,
        height: 0,
        top: 0,
        left: 0,
        updateStyle: !1
      },
      viewport: {
        initialDpr: 0,
        dpr: 0,
        width: 0,
        height: 0,
        top: 0,
        left: 0,
        aspect: 0,
        distance: 0,
        factor: 0,
        getCurrentViewport: T
      },
      setEvents: (H) => d((I) => ({
        ...I,
        events: {
          ...I.events,
          ...H
        }
      })),
      setSize: (H, I, G, B, Q) => {
        const K = p().camera, te = {
          width: H,
          height: I,
          top: B || 0,
          left: Q || 0,
          updateStyle: G
        };
        d((Y) => ({
          size: te,
          viewport: {
            ...Y.viewport,
            ...T(K, _, te)
          }
        }));
      },
      setDpr: (H) => d((I) => {
        const G = kk(H);
        return {
          viewport: {
            ...I.viewport,
            dpr: G,
            initialDpr: I.viewport.initialDpr || G
          }
        };
      }),
      setFrameloop: (H = "always") => {
        const I = p().clock;
        I.stop(), I.elapsedTime = 0, H !== "never" && (I.start(), I.elapsedTime = 0), d(() => ({
          frameloop: H
        }));
      },
      previousRoot: void 0,
      internal: {
        active: !1,
        priority: 0,
        frames: 0,
        lastEvent: /* @__PURE__ */ Ln.createRef(),
        interaction: [],
        hovered: /* @__PURE__ */ new Map(),
        subscribers: [],
        initialClick: [0, 0],
        initialHits: [],
        capturedMap: /* @__PURE__ */ new Map(),
        subscribe: (H, I, G) => {
          const B = p().internal;
          return B.priority = B.priority + (I > 0 ? 1 : 0), B.subscribers.push({
            ref: H,
            priority: I,
            store: G
          }), B.subscribers = B.subscribers.sort((Q, K) => Q.priority - K.priority), () => {
            const Q = p().internal;
            Q != null && Q.subscribers && (Q.priority = Q.priority - (I > 0 ? 1 : 0), Q.subscribers = Q.subscribers.filter((K) => K.ref !== H));
          };
        }
      }
    };
  }), r = t.getState();
  let i = r.size, s = r.viewport.dpr, l = r.camera;
  return t.subscribe(() => {
    const {
      camera: d,
      size: p,
      viewport: g,
      gl: _,
      set: w
    } = t.getState();
    if (p !== i || g.dpr !== s) {
      var T;
      i = p, s = g.dpr, H9(d, p), _.setPixelRatio(g.dpr);
      const R = (T = p.updateStyle) != null ? T : typeof HTMLCanvasElement < "u" && _.domElement instanceof HTMLCanvasElement;
      _.setSize(p.width, p.height, R);
    }
    d !== l && (l = d, w((R) => ({
      viewport: {
        ...R.viewport,
        ...R.viewport.getCurrentViewport(d)
      }
    })));
  }), t.subscribe((d) => a(d)), t;
};
let Z2, Y9 = /* @__PURE__ */ new Set(), X9 = /* @__PURE__ */ new Set(), q9 = /* @__PURE__ */ new Set();
function fD(a, e) {
  if (!!a.size)
    for (const {
      callback: t
    } of a.values())
      t(e);
}
function lM(a, e) {
  switch (a) {
    case "before":
      return fD(Y9, e);
    case "after":
      return fD(X9, e);
    case "tail":
      return fD(q9, e);
  }
}
let dD, hD;
function pD(a, e, t) {
  let r = e.clock.getDelta();
  for (e.frameloop === "never" && typeof a == "number" && (r = a - e.clock.elapsedTime, e.clock.oldTime = e.clock.elapsedTime, e.clock.elapsedTime = a), dD = e.internal.subscribers, Z2 = 0; Z2 < dD.length; Z2++)
    hD = dD[Z2], hD.ref.current(hD.store.getState(), r, t);
  return !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera), e.internal.frames = Math.max(0, e.internal.frames - 1), e.frameloop === "always" ? 1 : e.internal.frames;
}
function Q9(a) {
  let e = !1, t, r, i;
  function s(p) {
    r = requestAnimationFrame(s), e = !0, t = 0, lM("before", p);
    for (const _ of a.values()) {
      var g;
      i = _.store.getState(), i.internal.active && (i.frameloop === "always" || i.internal.frames > 0) && !((g = i.gl.xr) != null && g.isPresenting) && (t += pD(p, i));
    }
    if (lM("after", p), t === 0)
      return lM("tail", p), e = !1, cancelAnimationFrame(r);
  }
  function l(p, g = 1) {
    var _;
    if (!p)
      return a.forEach((w) => l(w.store.getState()), g);
    (_ = p.gl.xr) != null && _.isPresenting || !p.internal.active || p.frameloop === "never" || (p.internal.frames = Math.min(60, p.internal.frames + g), e || (e = !0, requestAnimationFrame(s)));
  }
  function d(p, g = !0, _, w) {
    if (g && lM("before", p), _)
      pD(p, _, w);
    else
      for (const T of a.values())
        pD(p, T.store.getState());
    g && lM("after", p);
  }
  return {
    loop: s,
    invalidate: l,
    advance: d
  };
}
function Gk() {
  const a = Ln.useContext(Vk);
  if (!a)
    throw new Error("R3F: Hooks can only be used within the Canvas component!");
  return a;
}
function jf(a = (t) => t, e) {
  return Gk()(a, e);
}
function Am(a, e = 0) {
  const t = Gk(), r = t.getState().internal.subscribe, i = zk(a);
  return iT(() => r(i, e, t), [e, r, t]), null;
}
const cb = /* @__PURE__ */ new Map(), {
  invalidate: pz,
  advance: mz
} = Q9(cb), {
  reconciler: AC,
  applyProps: J2
} = N9(cb, V9), Iw = {
  objects: "shallow",
  strict: !1
}, Z9 = (a, e) => {
  const t = typeof a == "function" ? a(e) : a;
  return Hk(t) ? t : new $3({
    powerPreference: "high-performance",
    canvas: e,
    antialias: !0,
    alpha: !0,
    ...a
  });
};
function J9(a, e) {
  if (e)
    return e;
  if (typeof HTMLCanvasElement < "u" && a instanceof HTMLCanvasElement && a.parentElement) {
    const {
      width: t,
      height: r,
      top: i,
      left: s
    } = a.parentElement.getBoundingClientRect();
    return {
      width: t,
      height: r,
      top: i,
      left: s
    };
  } else if (typeof OffscreenCanvas < "u" && a instanceof OffscreenCanvas)
    return {
      width: a.width,
      height: a.height,
      top: 0,
      left: 0
    };
  return {
    width: 0,
    height: 0,
    top: 0,
    left: 0
  };
}
function K9(a) {
  const e = cb.get(a), t = e == null ? void 0 : e.fiber, r = e == null ? void 0 : e.store;
  e && console.warn("R3F.createRoot should only be called once!");
  const i = typeof reportError == "function" ? reportError : console.error, s = r || j9(pz, mz), l = t || AC.createContainer(s, I_.exports.ConcurrentRoot, null, !1, null, "", i, null);
  e || cb.set(a, {
    fiber: l,
    store: s
  });
  let d, p = !1, g;
  return {
    configure(_ = {}) {
      let {
        gl: w,
        size: T,
        events: R,
        onCreated: D,
        shadows: O = !1,
        linear: U = !1,
        flat: H = !1,
        legacy: I = !1,
        orthographic: G = !1,
        frameloop: B = "always",
        dpr: Q = [1, 2],
        performance: K,
        raycaster: te,
        camera: Y,
        onPointerMissed: re
      } = _, se = s.getState(), ce = se.gl;
      se.gl || se.set({
        gl: ce = Z9(w, a)
      });
      let ue = se.raycaster;
      ue || se.set({
        raycaster: ue = new _L()
      });
      const {
        params: Me,
        ...me
      } = te || {};
      if (Al.equ(me, ue, Iw) || J2(ue, {
        ...me
      }), Al.equ(Me, ue.params, Iw) || J2(ue, {
        params: {
          ...ue.params,
          ...Me
        }
      }), !se.camera || se.camera === g && !Al.equ(g, Y, Iw)) {
        g = Y;
        const he = Y instanceof pb, ye = he ? Y : G ? new dy(0, 0, 0, 0, 0.1, 1e3) : new ho(75, 0, 0.1, 1e3);
        he || (ye.position.z = 5, Y && J2(ye, Y), !se.camera && !(Y != null && Y.rotation) && ye.lookAt(0, 0, 0)), se.set({
          camera: ye
        });
      }
      if (!se.xr) {
        const he = (Ve, Je) => {
          const rt = s.getState();
          rt.frameloop !== "never" && mz(Ve, !0, rt, Je);
        }, ye = () => {
          const Ve = s.getState();
          Ve.gl.xr.enabled = Ve.gl.xr.isPresenting, Ve.gl.xr.setAnimationLoop(Ve.gl.xr.isPresenting ? he : null), Ve.gl.xr.isPresenting || pz(Ve);
        }, Ee = {
          connect() {
            const Ve = s.getState().gl;
            Ve.xr.addEventListener("sessionstart", ye), Ve.xr.addEventListener("sessionend", ye);
          },
          disconnect() {
            const Ve = s.getState().gl;
            Ve.xr.removeEventListener("sessionstart", ye), Ve.xr.removeEventListener("sessionend", ye);
          }
        };
        ce.xr && Ee.connect(), se.set({
          xr: Ee
        });
      }
      if (ce.shadowMap) {
        const he = ce.shadowMap.enabled, ye = ce.shadowMap.type;
        if (ce.shadowMap.enabled = !!O, Al.boo(O))
          ce.shadowMap.type = _M;
        else if (Al.str(O)) {
          var De;
          const Ee = {
            basic: FN,
            percentage: UC,
            soft: _M,
            variance: U_
          };
          ce.shadowMap.type = (De = Ee[O]) != null ? De : _M;
        } else
          Al.obj(O) && Object.assign(ce.shadowMap, O);
        (he !== ce.shadowMap.enabled || ye !== ce.shadowMap.type) && (ce.shadowMap.needsUpdate = !0);
      }
      const Re = Ok();
      Re && ("enabled" in Re ? Re.enabled = !I : "legacyMode" in Re && (Re.legacyMode = I));
      const He = U ? wv : gi, ve = H ? og : G3;
      ce.outputEncoding !== He && (ce.outputEncoding = He), ce.toneMapping !== ve && (ce.toneMapping = ve), se.legacy !== I && se.set(() => ({
        legacy: I
      })), se.linear !== U && se.set(() => ({
        linear: U
      })), se.flat !== H && se.set(() => ({
        flat: H
      })), w && !Al.fun(w) && !Hk(w) && !Al.equ(w, ce, Iw) && J2(ce, w), R && !se.events.handlers && se.set({
        events: R(s)
      });
      const fe = J9(a, T);
      return Al.equ(fe, se.size, Iw) || se.setSize(fe.width, fe.height, fe.updateStyle, fe.top, fe.left), Q && se.viewport.dpr !== kk(Q) && se.setDpr(Q), se.frameloop !== B && se.setFrameloop(B), se.onPointerMissed || se.set({
        onPointerMissed: re
      }), K && !Al.equ(K, se.performance, Iw) && se.set((he) => ({
        performance: {
          ...he.performance,
          ...K
        }
      })), d = D, p = !0, this;
    },
    render(_) {
      return p || this.configure(), AC.updateContainer(
        /* @__PURE__ */ ln($9, {
          store: s,
          children: _,
          onCreated: d,
          rootElement: a
        }),
        l,
        null,
        () => {
        }
      ), s;
    },
    unmount() {
      Wk(a);
    }
  };
}
function $9({
  store: a,
  children: e,
  onCreated: t,
  rootElement: r
}) {
  return iT(() => {
    const i = a.getState();
    i.set((s) => ({
      internal: {
        ...s.internal,
        active: !0
      }
    })), t && t(i), a.getState().events.connected || i.events.connect == null || i.events.connect(r);
  }, []), /* @__PURE__ */ Ln.createElement(Vk.Provider, {
    value: a
  }, e);
}
function Wk(a, e) {
  const t = cb.get(a), r = t == null ? void 0 : t.fiber;
  if (r) {
    const i = t == null ? void 0 : t.store.getState();
    i && (i.internal.active = !1), AC.updateContainer(null, r, null, () => {
      i && setTimeout(() => {
        try {
          var s, l, d, p;
          i.events.disconnect == null || i.events.disconnect(), (s = i.gl) == null || (l = s.renderLists) == null || l.dispose == null || l.dispose(), (d = i.gl) == null || d.forceContextLoss == null || d.forceContextLoss(), (p = i.gl) != null && p.xr && i.xr.disconnect(), B9(i), cb.delete(a), e && e(a);
        } catch {
        }
      }, 500);
    });
  }
}
AC.injectIntoDevTools({
  bundleType: process.env.NODE_ENV === "production" ? 0 : 1,
  rendererPackageName: "@react-three/fiber",
  version: Ln.version
});
function C3() {
  return C3 = Object.assign ? Object.assign.bind() : function(a) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        Object.prototype.hasOwnProperty.call(t, r) && (a[r] = t[r]);
    }
    return a;
  }, C3.apply(this, arguments);
}
function R3(a, e, t) {
  var r, i, s, l, d;
  e == null && (e = 100);
  function p() {
    var _ = Date.now() - l;
    _ < e && _ >= 0 ? r = setTimeout(p, e - _) : (r = null, t || (d = a.apply(s, i), s = i = null));
  }
  var g = function() {
    s = this, i = arguments, l = Date.now();
    var _ = t && !r;
    return r || (r = setTimeout(p, e)), _ && (d = a.apply(s, i), s = i = null), d;
  };
  return g.clear = function() {
    r && (clearTimeout(r), r = null);
  }, g.flush = function() {
    r && (d = a.apply(s, i), s = i = null, clearTimeout(r), r = null);
  }, g;
}
R3.debounce = R3;
var vz = R3;
function ej(a) {
  let {
    debounce: e,
    scroll: t,
    polyfill: r,
    offsetSize: i
  } = a === void 0 ? {
    debounce: 0,
    scroll: !1,
    offsetSize: !1
  } : a;
  const s = r || (typeof window > "u" ? class {
  } : window.ResizeObserver);
  if (!s)
    throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");
  const [l, d] = O_({
    left: 0,
    top: 0,
    width: 0,
    height: 0,
    bottom: 0,
    right: 0,
    x: 0,
    y: 0
  }), p = Xs({
    element: null,
    scrollContainers: null,
    resizeObserver: null,
    lastBounds: l
  }), g = e ? typeof e == "number" ? e : e.scroll : null, _ = e ? typeof e == "number" ? e : e.resize : null, w = Xs(!1);
  hh(() => (w.current = !0, () => void (w.current = !1)));
  const [T, R, D] = Qw(() => {
    const I = () => {
      if (!p.current.element)
        return;
      const {
        left: G,
        top: B,
        width: Q,
        height: K,
        bottom: te,
        right: Y,
        x: re,
        y: se
      } = p.current.element.getBoundingClientRect(), ce = {
        left: G,
        top: B,
        width: Q,
        height: K,
        bottom: te,
        right: Y,
        x: re,
        y: se
      };
      p.current.element instanceof HTMLElement && i && (ce.height = p.current.element.offsetHeight, ce.width = p.current.element.offsetWidth), Object.freeze(ce), w.current && !ij(p.current.lastBounds, ce) && d(p.current.lastBounds = ce);
    };
    return [I, _ ? vz(I, _) : I, g ? vz(I, g) : I];
  }, [d, i, g, _]);
  function O() {
    p.current.scrollContainers && (p.current.scrollContainers.forEach((I) => I.removeEventListener("scroll", D, !0)), p.current.scrollContainers = null), p.current.resizeObserver && (p.current.resizeObserver.disconnect(), p.current.resizeObserver = null);
  }
  function U() {
    !p.current.element || (p.current.resizeObserver = new s(D), p.current.resizeObserver.observe(p.current.element), t && p.current.scrollContainers && p.current.scrollContainers.forEach((I) => I.addEventListener("scroll", D, {
      capture: !0,
      passive: !0
    })));
  }
  const H = (I) => {
    !I || I === p.current.element || (O(), p.current.element = I, p.current.scrollContainers = jk(I), U());
  };
  return nj(D, Boolean(t)), tj(R), hh(() => {
    O(), U();
  }, [t, D, R]), hh(() => O, []), [H, l, T];
}
function tj(a) {
  hh(() => {
    const e = a;
    return window.addEventListener("resize", e), () => void window.removeEventListener("resize", e);
  }, [a]);
}
function nj(a, e) {
  hh(() => {
    if (e) {
      const t = a;
      return window.addEventListener("scroll", t, {
        capture: !0,
        passive: !0
      }), () => void window.removeEventListener("scroll", t, !0);
    }
  }, [a, e]);
}
function jk(a) {
  const e = [];
  if (!a || a === document.body)
    return e;
  const {
    overflow: t,
    overflowX: r,
    overflowY: i
  } = window.getComputedStyle(a);
  return [t, r, i].some((s) => s === "auto" || s === "scroll") && e.push(a), [...e, ...jk(a.parentElement)];
}
const rj = ["x", "y", "top", "bottom", "left", "right", "width", "height"], ij = (a, e) => rj.every((t) => a[t] === e[t]);
var aj = Object.defineProperty, sj = Object.defineProperties, oj = Object.getOwnPropertyDescriptors, gz = Object.getOwnPropertySymbols, lj = Object.prototype.hasOwnProperty, uj = Object.prototype.propertyIsEnumerable, yz = (a, e, t) => e in a ? aj(a, e, {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: t
}) : a[e] = t, xz = (a, e) => {
  for (var t in e || (e = {}))
    lj.call(e, t) && yz(a, t, e[t]);
  if (gz)
    for (var t of gz(e))
      uj.call(e, t) && yz(a, t, e[t]);
  return a;
}, cj = (a, e) => sj(a, oj(e)), _z;
function Yk(a, e, t) {
  if (!a)
    return;
  if (t(a) === !0)
    return a;
  let r = e ? a.return : a.child;
  for (; r; ) {
    const i = Yk(r, e, t);
    if (i)
      return i;
    r = e ? null : r.sibling;
  }
}
function Xk(a) {
  try {
    return Object.defineProperties(a, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {
        }
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {
        }
      }
    });
  } catch {
    return a;
  }
}
const bL = Xk(Ln.createContext(null));
class qk extends Ln.Component {
  render() {
    return /* @__PURE__ */ ln(bL.Provider, {
      value: this._reactInternals,
      children: this.props.children
    });
  }
}
const {
  ReactCurrentOwner: Sz,
  ReactCurrentDispatcher: wz
} = (_z = Ln.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) != null ? _z : {};
function fj() {
  const a = Ln.useContext(bL), e = Ln.useId();
  return Ln.useMemo(() => {
    var r;
    return (r = Sz == null ? void 0 : Sz.current) != null ? r : Yk(a, !1, (i) => {
      let s = i.memoizedState;
      for (; s; ) {
        if (s.memoizedState === e)
          return !0;
        s = s.next;
      }
    });
  }, [a, e]);
}
function dj() {
  var a, e;
  const t = fj(), [r] = Ln.useState(() => /* @__PURE__ */ new Map());
  r.clear();
  let i = t;
  for (; i; ) {
    const s = (a = i.type) == null ? void 0 : a._context;
    s && s !== bL && !r.has(s) && r.set(s, (e = wz == null ? void 0 : wz.current) == null ? void 0 : e.readContext(Xk(s))), i = i.return;
  }
  return Ln.useMemo(() => Array.from(r.keys()).reduce((s, l) => (d) => /* @__PURE__ */ Ln.createElement(s, null, /* @__PURE__ */ Ln.createElement(l.Provider, cj(xz({}, d), {
    value: r.get(l)
  }))), (s) => /* @__PURE__ */ ln(qk, {
    ...xz({}, s)
  })), [r]);
}
const mD = {
  onClick: ["click", !1],
  onContextMenu: ["contextmenu", !1],
  onDoubleClick: ["dblclick", !1],
  onWheel: ["wheel", !0],
  onPointerDown: ["pointerdown", !0],
  onPointerUp: ["pointerup", !0],
  onPointerLeave: ["pointerleave", !0],
  onPointerMove: ["pointermove", !0],
  onPointerCancel: ["pointercancel", !0],
  onLostPointerCapture: ["lostpointercapture", !0]
};
function hj(a) {
  const {
    handlePointer: e
  } = W9(a);
  return {
    priority: 1,
    enabled: !0,
    compute(t, r, i) {
      r.pointer.set(t.offsetX / r.size.width * 2 - 1, -(t.offsetY / r.size.height) * 2 + 1), r.raycaster.setFromCamera(r.pointer, r.camera);
    },
    connected: void 0,
    handlers: Object.keys(mD).reduce((t, r) => ({
      ...t,
      [r]: e(r)
    }), {}),
    update: () => {
      var t;
      const {
        events: r,
        internal: i
      } = a.getState();
      (t = i.lastEvent) != null && t.current && r.handlers && r.handlers.onPointerMove(i.lastEvent.current);
    },
    connect: (t) => {
      var r;
      const {
        set: i,
        events: s
      } = a.getState();
      s.disconnect == null || s.disconnect(), i((l) => ({
        events: {
          ...l.events,
          connected: t
        }
      })), Object.entries((r = s.handlers) != null ? r : []).forEach(([l, d]) => {
        const [p, g] = mD[l];
        t.addEventListener(p, d, {
          passive: g
        });
      });
    },
    disconnect: () => {
      const {
        set: t,
        events: r
      } = a.getState();
      if (r.connected) {
        var i;
        Object.entries((i = r.handlers) != null ? i : []).forEach(([s, l]) => {
          if (r && r.connected instanceof HTMLElement) {
            const [d] = mD[s];
            r.connected.removeEventListener(d, l);
          }
        }), t((s) => ({
          events: {
            ...s.events,
            connected: void 0
          }
        }));
      }
    }
  };
}
const pj = /* @__PURE__ */ Ln.forwardRef(function({
  children: e,
  fallback: t,
  resize: r,
  style: i,
  gl: s,
  events: l = hj,
  eventSource: d,
  eventPrefix: p,
  shadows: g,
  linear: _,
  flat: w,
  legacy: T,
  orthographic: R,
  frameloop: D,
  dpr: O,
  performance: U,
  raycaster: H,
  camera: I,
  onPointerMissed: G,
  onCreated: B,
  ...Q
}, K) {
  Ln.useMemo(() => z9(x9), []);
  const te = dj(), [Y, re] = ej({
    scroll: !0,
    debounce: {
      scroll: 50,
      resize: 0
    },
    ...r
  }), se = Ln.useRef(null), ce = Ln.useRef(null);
  Ln.useImperativeHandle(K, () => se.current);
  const ue = zk(G), [Me, me] = Ln.useState(!1), [De, Re] = Ln.useState(!1);
  if (Me)
    throw Me;
  if (De)
    throw De;
  const He = Ln.useRef(null);
  return iT(() => {
    const fe = se.current;
    re.width > 0 && re.height > 0 && fe && (He.current || (He.current = K9(fe)), He.current.configure({
      gl: s,
      events: l,
      shadows: g,
      linear: _,
      flat: w,
      legacy: T,
      orthographic: R,
      frameloop: D,
      dpr: O,
      performance: U,
      raycaster: H,
      camera: I,
      size: re,
      onPointerMissed: (...he) => ue.current == null ? void 0 : ue.current(...he),
      onCreated: (he) => {
        he.events.connect == null || he.events.connect(d ? F9(d) ? d.current : d : ce.current), p && he.setEvents({
          compute: (ye, Ee) => {
            const Ve = ye[p + "X"], Je = ye[p + "Y"];
            Ee.pointer.set(Ve / Ee.size.width * 2 - 1, -(Je / Ee.size.height) * 2 + 1), Ee.raycaster.setFromCamera(Ee.pointer, Ee.camera);
          }
        }), B == null || B(he);
      }
    }), He.current.render(
      /* @__PURE__ */ ln(te, {
        children: /* @__PURE__ */ ln(Nk, {
          set: Re,
          children: /* @__PURE__ */ ln(Ln.Suspense, {
            fallback: /* @__PURE__ */ ln(k9, {
              set: me
            }),
            children: e
          })
        })
      })
    ));
  }), Ln.useEffect(() => {
    const fe = se.current;
    if (fe)
      return () => Wk(fe);
  }, []), /* @__PURE__ */ ln("div", {
    ref: ce,
    style: {
      position: "relative",
      width: "100%",
      height: "100%",
      overflow: "hidden",
      pointerEvents: d ? "none" : "auto",
      ...i
    },
    ...Q,
    children: /* @__PURE__ */ ln("div", {
      ref: Y,
      style: {
        width: "100%",
        height: "100%"
      },
      children: /* @__PURE__ */ ln("canvas", {
        ref: se,
        style: {
          display: "block"
        },
        children: t
      })
    })
  });
}), Qk = /* @__PURE__ */ Ln.forwardRef(function(e, t) {
  return /* @__PURE__ */ ln(qk, {
    children: /* @__PURE__ */ ln(pj, {
      ...e,
      ref: t
    })
  });
});
var Zk = { exports: {} }, Pp = {}, vD = { exports: {} }, gD = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var bz;
function mj() {
  return bz || (bz = 1, function(a) {
    function e(ve, fe) {
      var he = ve.length;
      ve.push(fe);
      e:
        for (; 0 < he; ) {
          var ye = he - 1 >>> 1, Ee = ve[ye];
          if (0 < i(Ee, fe))
            ve[ye] = fe, ve[he] = Ee, he = ye;
          else
            break e;
        }
    }
    function t(ve) {
      return ve.length === 0 ? null : ve[0];
    }
    function r(ve) {
      if (ve.length === 0)
        return null;
      var fe = ve[0], he = ve.pop();
      if (he !== fe) {
        ve[0] = he;
        e:
          for (var ye = 0, Ee = ve.length, Ve = Ee >>> 1; ye < Ve; ) {
            var Je = 2 * (ye + 1) - 1, rt = ve[Je], Ne = Je + 1, ct = ve[Ne];
            if (0 > i(rt, he))
              Ne < Ee && 0 > i(ct, rt) ? (ve[ye] = ct, ve[Ne] = he, ye = Ne) : (ve[ye] = rt, ve[Je] = he, ye = Je);
            else if (Ne < Ee && 0 > i(ct, he))
              ve[ye] = ct, ve[Ne] = he, ye = Ne;
            else
              break e;
          }
      }
      return fe;
    }
    function i(ve, fe) {
      var he = ve.sortIndex - fe.sortIndex;
      return he !== 0 ? he : ve.id - fe.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var s = performance;
      a.unstable_now = function() {
        return s.now();
      };
    } else {
      var l = Date, d = l.now();
      a.unstable_now = function() {
        return l.now() - d;
      };
    }
    var p = [], g = [], _ = 1, w = null, T = 3, R = !1, D = !1, O = !1, U = typeof setTimeout == "function" ? setTimeout : null, H = typeof clearTimeout == "function" ? clearTimeout : null, I = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function G(ve) {
      for (var fe = t(g); fe !== null; ) {
        if (fe.callback === null)
          r(g);
        else if (fe.startTime <= ve)
          r(g), fe.sortIndex = fe.expirationTime, e(p, fe);
        else
          break;
        fe = t(g);
      }
    }
    function B(ve) {
      if (O = !1, G(ve), !D)
        if (t(p) !== null)
          D = !0, Re(Q);
        else {
          var fe = t(g);
          fe !== null && He(B, fe.startTime - ve);
        }
    }
    function Q(ve, fe) {
      D = !1, O && (O = !1, H(Y), Y = -1), R = !0;
      var he = T;
      try {
        for (G(fe), w = t(p); w !== null && (!(w.expirationTime > fe) || ve && !ce()); ) {
          var ye = w.callback;
          if (typeof ye == "function") {
            w.callback = null, T = w.priorityLevel;
            var Ee = ye(w.expirationTime <= fe);
            fe = a.unstable_now(), typeof Ee == "function" ? w.callback = Ee : w === t(p) && r(p), G(fe);
          } else
            r(p);
          w = t(p);
        }
        if (w !== null)
          var Ve = !0;
        else {
          var Je = t(g);
          Je !== null && He(B, Je.startTime - fe), Ve = !1;
        }
        return Ve;
      } finally {
        w = null, T = he, R = !1;
      }
    }
    var K = !1, te = null, Y = -1, re = 5, se = -1;
    function ce() {
      return !(a.unstable_now() - se < re);
    }
    function ue() {
      if (te !== null) {
        var ve = a.unstable_now();
        se = ve;
        var fe = !0;
        try {
          fe = te(!0, ve);
        } finally {
          fe ? Me() : (K = !1, te = null);
        }
      } else
        K = !1;
    }
    var Me;
    if (typeof I == "function")
      Me = function() {
        I(ue);
      };
    else if (typeof MessageChannel < "u") {
      var me = new MessageChannel(), De = me.port2;
      me.port1.onmessage = ue, Me = function() {
        De.postMessage(null);
      };
    } else
      Me = function() {
        U(ue, 0);
      };
    function Re(ve) {
      te = ve, K || (K = !0, Me());
    }
    function He(ve, fe) {
      Y = U(function() {
        ve(a.unstable_now());
      }, fe);
    }
    a.unstable_IdlePriority = 5, a.unstable_ImmediatePriority = 1, a.unstable_LowPriority = 4, a.unstable_NormalPriority = 3, a.unstable_Profiling = null, a.unstable_UserBlockingPriority = 2, a.unstable_cancelCallback = function(ve) {
      ve.callback = null;
    }, a.unstable_continueExecution = function() {
      D || R || (D = !0, Re(Q));
    }, a.unstable_forceFrameRate = function(ve) {
      0 > ve || 125 < ve ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : re = 0 < ve ? Math.floor(1e3 / ve) : 5;
    }, a.unstable_getCurrentPriorityLevel = function() {
      return T;
    }, a.unstable_getFirstCallbackNode = function() {
      return t(p);
    }, a.unstable_next = function(ve) {
      switch (T) {
        case 1:
        case 2:
        case 3:
          var fe = 3;
          break;
        default:
          fe = T;
      }
      var he = T;
      T = fe;
      try {
        return ve();
      } finally {
        T = he;
      }
    }, a.unstable_pauseExecution = function() {
    }, a.unstable_requestPaint = function() {
    }, a.unstable_runWithPriority = function(ve, fe) {
      switch (ve) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          ve = 3;
      }
      var he = T;
      T = ve;
      try {
        return fe();
      } finally {
        T = he;
      }
    }, a.unstable_scheduleCallback = function(ve, fe, he) {
      var ye = a.unstable_now();
      switch (typeof he == "object" && he !== null ? (he = he.delay, he = typeof he == "number" && 0 < he ? ye + he : ye) : he = ye, ve) {
        case 1:
          var Ee = -1;
          break;
        case 2:
          Ee = 250;
          break;
        case 5:
          Ee = 1073741823;
          break;
        case 4:
          Ee = 1e4;
          break;
        default:
          Ee = 5e3;
      }
      return Ee = he + Ee, ve = { id: _++, callback: fe, priorityLevel: ve, startTime: he, expirationTime: Ee, sortIndex: -1 }, he > ye ? (ve.sortIndex = he, e(g, ve), t(p) === null && ve === t(g) && (O ? (H(Y), Y = -1) : O = !0, He(B, he - ye))) : (ve.sortIndex = Ee, e(p, ve), D || R || (D = !0, Re(Q))), ve;
    }, a.unstable_shouldYield = ce, a.unstable_wrapCallback = function(ve) {
      var fe = T;
      return function() {
        var he = T;
        T = fe;
        try {
          return ve.apply(this, arguments);
        } finally {
          T = he;
        }
      };
    };
  }(gD)), gD;
}
var yD = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Ez;
function vj() {
  return Ez || (Ez = 1, function(a) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var e = !1, t = !1, r = 5;
      function i(Be, pe) {
        var Fe = Be.length;
        Be.push(pe), d(Be, pe, Fe);
      }
      function s(Be) {
        return Be.length === 0 ? null : Be[0];
      }
      function l(Be) {
        if (Be.length === 0)
          return null;
        var pe = Be[0], Fe = Be.pop();
        return Fe !== pe && (Be[0] = Fe, p(Be, Fe, 0)), pe;
      }
      function d(Be, pe, Fe) {
        for (var at = Fe; at > 0; ) {
          var st = at - 1 >>> 1, dn = Be[st];
          if (g(dn, pe) > 0)
            Be[st] = pe, Be[at] = dn, at = st;
          else
            return;
        }
      }
      function p(Be, pe, Fe) {
        for (var at = Fe, st = Be.length, dn = st >>> 1; at < dn; ) {
          var ze = (at + 1) * 2 - 1, wt = Be[ze], Pe = ze + 1, Gt = Be[Pe];
          if (g(wt, pe) < 0)
            Pe < st && g(Gt, wt) < 0 ? (Be[at] = Gt, Be[Pe] = pe, at = Pe) : (Be[at] = wt, Be[ze] = pe, at = ze);
          else if (Pe < st && g(Gt, pe) < 0)
            Be[at] = Gt, Be[Pe] = pe, at = Pe;
          else
            return;
        }
      }
      function g(Be, pe) {
        var Fe = Be.sortIndex - pe.sortIndex;
        return Fe !== 0 ? Fe : Be.id - pe.id;
      }
      var _ = 1, w = 2, T = 3, R = 4, D = 5;
      function O(Be, pe) {
      }
      var U = typeof performance == "object" && typeof performance.now == "function";
      if (U) {
        var H = performance;
        a.unstable_now = function() {
          return H.now();
        };
      } else {
        var I = Date, G = I.now();
        a.unstable_now = function() {
          return I.now() - G;
        };
      }
      var B = 1073741823, Q = -1, K = 250, te = 5e3, Y = 1e4, re = B, se = [], ce = [], ue = 1, Me = null, me = T, De = !1, Re = !1, He = !1, ve = typeof setTimeout == "function" ? setTimeout : null, fe = typeof clearTimeout == "function" ? clearTimeout : null, he = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function ye(Be) {
        for (var pe = s(ce); pe !== null; ) {
          if (pe.callback === null)
            l(ce);
          else if (pe.startTime <= Be)
            l(ce), pe.sortIndex = pe.expirationTime, i(se, pe);
          else
            return;
          pe = s(ce);
        }
      }
      function Ee(Be) {
        if (He = !1, ye(Be), !Re)
          if (s(se) !== null)
            Re = !0, Ft(Ve);
          else {
            var pe = s(ce);
            pe !== null && Ot(Ee, pe.startTime - Be);
          }
      }
      function Ve(Be, pe) {
        Re = !1, He && (He = !1, Wt()), De = !0;
        var Fe = me;
        try {
          var at;
          if (!t)
            return Je(Be, pe);
        } finally {
          Me = null, me = Fe, De = !1;
        }
      }
      function Je(Be, pe) {
        var Fe = pe;
        for (ye(Fe), Me = s(se); Me !== null && !e && !(Me.expirationTime > Fe && (!Be || Nt())); ) {
          var at = Me.callback;
          if (typeof at == "function") {
            Me.callback = null, me = Me.priorityLevel;
            var st = Me.expirationTime <= Fe, dn = at(st);
            Fe = a.unstable_now(), typeof dn == "function" ? Me.callback = dn : Me === s(se) && l(se), ye(Fe);
          } else
            l(se);
          Me = s(se);
        }
        if (Me !== null)
          return !0;
        var ze = s(ce);
        return ze !== null && Ot(Ee, ze.startTime - Fe), !1;
      }
      function rt(Be, pe) {
        switch (Be) {
          case _:
          case w:
          case T:
          case R:
          case D:
            break;
          default:
            Be = T;
        }
        var Fe = me;
        me = Be;
        try {
          return pe();
        } finally {
          me = Fe;
        }
      }
      function Ne(Be) {
        var pe;
        switch (me) {
          case _:
          case w:
          case T:
            pe = T;
            break;
          default:
            pe = me;
            break;
        }
        var Fe = me;
        me = pe;
        try {
          return Be();
        } finally {
          me = Fe;
        }
      }
      function ct(Be) {
        var pe = me;
        return function() {
          var Fe = me;
          me = pe;
          try {
            return Be.apply(this, arguments);
          } finally {
            me = Fe;
          }
        };
      }
      function tt(Be, pe, Fe) {
        var at = a.unstable_now(), st;
        if (typeof Fe == "object" && Fe !== null) {
          var dn = Fe.delay;
          typeof dn == "number" && dn > 0 ? st = at + dn : st = at;
        } else
          st = at;
        var ze;
        switch (Be) {
          case _:
            ze = Q;
            break;
          case w:
            ze = K;
            break;
          case D:
            ze = re;
            break;
          case R:
            ze = Y;
            break;
          case T:
          default:
            ze = te;
            break;
        }
        var wt = st + ze, Pe = {
          id: ue++,
          callback: pe,
          priorityLevel: Be,
          startTime: st,
          expirationTime: wt,
          sortIndex: -1
        };
        return st > at ? (Pe.sortIndex = st, i(ce, Pe), s(se) === null && Pe === s(ce) && (He ? Wt() : He = !0, Ot(Ee, st - at))) : (Pe.sortIndex = wt, i(se, Pe), !Re && !De && (Re = !0, Ft(Ve))), Pe;
      }
      function Tt() {
      }
      function gt() {
        !Re && !De && (Re = !0, Ft(Ve));
      }
      function ft() {
        return s(se);
      }
      function Ie(Be) {
        Be.callback = null;
      }
      function qe() {
        return me;
      }
      var dt = !1, ht = null, xt = -1, Vt = r, yt = -1;
      function Nt() {
        var Be = a.unstable_now() - yt;
        return !(Be < Vt);
      }
      function Zt() {
      }
      function Rt(Be) {
        if (Be < 0 || Be > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        Be > 0 ? Vt = Math.floor(1e3 / Be) : Vt = r;
      }
      var we = function() {
        if (ht !== null) {
          var Be = a.unstable_now();
          yt = Be;
          var pe = !0, Fe = !0;
          try {
            Fe = ht(pe, Be);
          } finally {
            Fe ? oe() : (dt = !1, ht = null);
          }
        } else
          dt = !1;
      }, oe;
      if (typeof he == "function")
        oe = function() {
          he(we);
        };
      else if (typeof MessageChannel < "u") {
        var Qe = new MessageChannel(), ut = Qe.port2;
        Qe.port1.onmessage = we, oe = function() {
          ut.postMessage(null);
        };
      } else
        oe = function() {
          ve(we, 0);
        };
      function Ft(Be) {
        ht = Be, dt || (dt = !0, oe());
      }
      function Ot(Be, pe) {
        xt = ve(function() {
          Be(a.unstable_now());
        }, pe);
      }
      function Wt() {
        fe(xt), xt = -1;
      }
      var it = Zt, an = null;
      a.unstable_IdlePriority = D, a.unstable_ImmediatePriority = _, a.unstable_LowPriority = R, a.unstable_NormalPriority = T, a.unstable_Profiling = an, a.unstable_UserBlockingPriority = w, a.unstable_cancelCallback = Ie, a.unstable_continueExecution = gt, a.unstable_forceFrameRate = Rt, a.unstable_getCurrentPriorityLevel = qe, a.unstable_getFirstCallbackNode = ft, a.unstable_next = Ne, a.unstable_pauseExecution = Tt, a.unstable_requestPaint = it, a.unstable_runWithPriority = rt, a.unstable_scheduleCallback = tt, a.unstable_shouldYield = Nt, a.unstable_wrapCallback = ct, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(yD)), yD;
}
var Mz;
function Jk() {
  return Mz || (Mz = 1, function(a) {
    process.env.NODE_ENV === "production" ? a.exports = mj() : a.exports = vj();
  }(vD)), vD.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Tz;
function gj() {
  if (Tz)
    return Pp;
  Tz = 1;
  var a = ph, e = Jk();
  function t(c) {
    for (var h = "https://reactjs.org/docs/error-decoder.html?invariant=" + c, E = 1; E < arguments.length; E++)
      h += "&args[]=" + encodeURIComponent(arguments[E]);
    return "Minified React error #" + c + "; visit " + h + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var r = /* @__PURE__ */ new Set(), i = {};
  function s(c, h) {
    l(c, h), l(c + "Capture", h);
  }
  function l(c, h) {
    for (i[c] = h, c = 0; c < h.length; c++)
      r.add(h[c]);
  }
  var d = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), p = Object.prototype.hasOwnProperty, g = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, _ = {}, w = {};
  function T(c) {
    return p.call(w, c) ? !0 : p.call(_, c) ? !1 : g.test(c) ? w[c] = !0 : (_[c] = !0, !1);
  }
  function R(c, h, E, P) {
    if (E !== null && E.type === 0)
      return !1;
    switch (typeof h) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return P ? !1 : E !== null ? !E.acceptsBooleans : (c = c.toLowerCase().slice(0, 5), c !== "data-" && c !== "aria-");
      default:
        return !1;
    }
  }
  function D(c, h, E, P) {
    if (h === null || typeof h > "u" || R(c, h, E, P))
      return !0;
    if (P)
      return !1;
    if (E !== null)
      switch (E.type) {
        case 3:
          return !h;
        case 4:
          return h === !1;
        case 5:
          return isNaN(h);
        case 6:
          return isNaN(h) || 1 > h;
      }
    return !1;
  }
  function O(c, h, E, P, V, q, le) {
    this.acceptsBooleans = h === 2 || h === 3 || h === 4, this.attributeName = P, this.attributeNamespace = V, this.mustUseProperty = E, this.propertyName = c, this.type = h, this.sanitizeURL = q, this.removeEmptyString = le;
  }
  var U = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(c) {
    U[c] = new O(c, 0, !1, c, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(c) {
    var h = c[0];
    U[h] = new O(h, 1, !1, c[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(c) {
    U[c] = new O(c, 2, !1, c.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(c) {
    U[c] = new O(c, 2, !1, c, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(c) {
    U[c] = new O(c, 3, !1, c.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(c) {
    U[c] = new O(c, 3, !0, c, null, !1, !1);
  }), ["capture", "download"].forEach(function(c) {
    U[c] = new O(c, 4, !1, c, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(c) {
    U[c] = new O(c, 6, !1, c, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(c) {
    U[c] = new O(c, 5, !1, c.toLowerCase(), null, !1, !1);
  });
  var H = /[\-:]([a-z])/g;
  function I(c) {
    return c[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(c) {
    var h = c.replace(
      H,
      I
    );
    U[h] = new O(h, 1, !1, c, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(c) {
    var h = c.replace(H, I);
    U[h] = new O(h, 1, !1, c, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(c) {
    var h = c.replace(H, I);
    U[h] = new O(h, 1, !1, c, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(c) {
    U[c] = new O(c, 1, !1, c.toLowerCase(), null, !1, !1);
  }), U.xlinkHref = new O("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(c) {
    U[c] = new O(c, 1, !1, c.toLowerCase(), null, !0, !0);
  });
  function G(c, h, E, P) {
    var V = U.hasOwnProperty(h) ? U[h] : null;
    (V !== null ? V.type !== 0 : P || !(2 < h.length) || h[0] !== "o" && h[0] !== "O" || h[1] !== "n" && h[1] !== "N") && (D(h, E, V, P) && (E = null), P || V === null ? T(h) && (E === null ? c.removeAttribute(h) : c.setAttribute(h, "" + E)) : V.mustUseProperty ? c[V.propertyName] = E === null ? V.type === 3 ? !1 : "" : E : (h = V.attributeName, P = V.attributeNamespace, E === null ? c.removeAttribute(h) : (V = V.type, E = V === 3 || V === 4 && E === !0 ? "" : "" + E, P ? c.setAttributeNS(P, h, E) : c.setAttribute(h, E))));
  }
  var B = a.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, Q = Symbol.for("react.element"), K = Symbol.for("react.portal"), te = Symbol.for("react.fragment"), Y = Symbol.for("react.strict_mode"), re = Symbol.for("react.profiler"), se = Symbol.for("react.provider"), ce = Symbol.for("react.context"), ue = Symbol.for("react.forward_ref"), Me = Symbol.for("react.suspense"), me = Symbol.for("react.suspense_list"), De = Symbol.for("react.memo"), Re = Symbol.for("react.lazy"), He = Symbol.for("react.offscreen"), ve = Symbol.iterator;
  function fe(c) {
    return c === null || typeof c != "object" ? null : (c = ve && c[ve] || c["@@iterator"], typeof c == "function" ? c : null);
  }
  var he = Object.assign, ye;
  function Ee(c) {
    if (ye === void 0)
      try {
        throw Error();
      } catch (E) {
        var h = E.stack.trim().match(/\n( *(at )?)/);
        ye = h && h[1] || "";
      }
    return `
` + ye + c;
  }
  var Ve = !1;
  function Je(c, h) {
    if (!c || Ve)
      return "";
    Ve = !0;
    var E = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (h)
        if (h = function() {
          throw Error();
        }, Object.defineProperty(h.prototype, "props", { set: function() {
          throw Error();
        } }), typeof Reflect == "object" && Reflect.construct) {
          try {
            Reflect.construct(h, []);
          } catch (Dt) {
            var P = Dt;
          }
          Reflect.construct(c, [], h);
        } else {
          try {
            h.call();
          } catch (Dt) {
            P = Dt;
          }
          c.call(h.prototype);
        }
      else {
        try {
          throw Error();
        } catch (Dt) {
          P = Dt;
        }
        c();
      }
    } catch (Dt) {
      if (Dt && P && typeof Dt.stack == "string") {
        for (var V = Dt.stack.split(`
`), q = P.stack.split(`
`), le = V.length - 1, Oe = q.length - 1; 1 <= le && 0 <= Oe && V[le] !== q[Oe]; )
          Oe--;
        for (; 1 <= le && 0 <= Oe; le--, Oe--)
          if (V[le] !== q[Oe]) {
            if (le !== 1 || Oe !== 1)
              do
                if (le--, Oe--, 0 > Oe || V[le] !== q[Oe]) {
                  var Ge = `
` + V[le].replace(" at new ", " at ");
                  return c.displayName && Ge.includes("<anonymous>") && (Ge = Ge.replace("<anonymous>", c.displayName)), Ge;
                }
              while (1 <= le && 0 <= Oe);
            break;
          }
      }
    } finally {
      Ve = !1, Error.prepareStackTrace = E;
    }
    return (c = c ? c.displayName || c.name : "") ? Ee(c) : "";
  }
  function rt(c) {
    switch (c.tag) {
      case 5:
        return Ee(c.type);
      case 16:
        return Ee("Lazy");
      case 13:
        return Ee("Suspense");
      case 19:
        return Ee("SuspenseList");
      case 0:
      case 2:
      case 15:
        return c = Je(c.type, !1), c;
      case 11:
        return c = Je(c.type.render, !1), c;
      case 1:
        return c = Je(c.type, !0), c;
      default:
        return "";
    }
  }
  function Ne(c) {
    if (c == null)
      return null;
    if (typeof c == "function")
      return c.displayName || c.name || null;
    if (typeof c == "string")
      return c;
    switch (c) {
      case te:
        return "Fragment";
      case K:
        return "Portal";
      case re:
        return "Profiler";
      case Y:
        return "StrictMode";
      case Me:
        return "Suspense";
      case me:
        return "SuspenseList";
    }
    if (typeof c == "object")
      switch (c.$$typeof) {
        case ce:
          return (c.displayName || "Context") + ".Consumer";
        case se:
          return (c._context.displayName || "Context") + ".Provider";
        case ue:
          var h = c.render;
          return c = c.displayName, c || (c = h.displayName || h.name || "", c = c !== "" ? "ForwardRef(" + c + ")" : "ForwardRef"), c;
        case De:
          return h = c.displayName || null, h !== null ? h : Ne(c.type) || "Memo";
        case Re:
          h = c._payload, c = c._init;
          try {
            return Ne(c(h));
          } catch {
          }
      }
    return null;
  }
  function ct(c) {
    var h = c.type;
    switch (c.tag) {
      case 24:
        return "Cache";
      case 9:
        return (h.displayName || "Context") + ".Consumer";
      case 10:
        return (h._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return c = h.render, c = c.displayName || c.name || "", h.displayName || (c !== "" ? "ForwardRef(" + c + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return h;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Ne(h);
      case 8:
        return h === Y ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof h == "function")
          return h.displayName || h.name || null;
        if (typeof h == "string")
          return h;
    }
    return null;
  }
  function tt(c) {
    switch (typeof c) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return c;
      case "object":
        return c;
      default:
        return "";
    }
  }
  function Tt(c) {
    var h = c.type;
    return (c = c.nodeName) && c.toLowerCase() === "input" && (h === "checkbox" || h === "radio");
  }
  function gt(c) {
    var h = Tt(c) ? "checked" : "value", E = Object.getOwnPropertyDescriptor(c.constructor.prototype, h), P = "" + c[h];
    if (!c.hasOwnProperty(h) && typeof E < "u" && typeof E.get == "function" && typeof E.set == "function") {
      var V = E.get, q = E.set;
      return Object.defineProperty(c, h, { configurable: !0, get: function() {
        return V.call(this);
      }, set: function(le) {
        P = "" + le, q.call(this, le);
      } }), Object.defineProperty(c, h, { enumerable: E.enumerable }), { getValue: function() {
        return P;
      }, setValue: function(le) {
        P = "" + le;
      }, stopTracking: function() {
        c._valueTracker = null, delete c[h];
      } };
    }
  }
  function ft(c) {
    c._valueTracker || (c._valueTracker = gt(c));
  }
  function Ie(c) {
    if (!c)
      return !1;
    var h = c._valueTracker;
    if (!h)
      return !0;
    var E = h.getValue(), P = "";
    return c && (P = Tt(c) ? c.checked ? "true" : "false" : c.value), c = P, c !== E ? (h.setValue(c), !0) : !1;
  }
  function qe(c) {
    if (c = c || (typeof document < "u" ? document : void 0), typeof c > "u")
      return null;
    try {
      return c.activeElement || c.body;
    } catch {
      return c.body;
    }
  }
  function dt(c, h) {
    var E = h.checked;
    return he({}, h, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: E != null ? E : c._wrapperState.initialChecked });
  }
  function ht(c, h) {
    var E = h.defaultValue == null ? "" : h.defaultValue, P = h.checked != null ? h.checked : h.defaultChecked;
    E = tt(h.value != null ? h.value : E), c._wrapperState = { initialChecked: P, initialValue: E, controlled: h.type === "checkbox" || h.type === "radio" ? h.checked != null : h.value != null };
  }
  function xt(c, h) {
    h = h.checked, h != null && G(c, "checked", h, !1);
  }
  function Vt(c, h) {
    xt(c, h);
    var E = tt(h.value), P = h.type;
    if (E != null)
      P === "number" ? (E === 0 && c.value === "" || c.value != E) && (c.value = "" + E) : c.value !== "" + E && (c.value = "" + E);
    else if (P === "submit" || P === "reset") {
      c.removeAttribute("value");
      return;
    }
    h.hasOwnProperty("value") ? Nt(c, h.type, E) : h.hasOwnProperty("defaultValue") && Nt(c, h.type, tt(h.defaultValue)), h.checked == null && h.defaultChecked != null && (c.defaultChecked = !!h.defaultChecked);
  }
  function yt(c, h, E) {
    if (h.hasOwnProperty("value") || h.hasOwnProperty("defaultValue")) {
      var P = h.type;
      if (!(P !== "submit" && P !== "reset" || h.value !== void 0 && h.value !== null))
        return;
      h = "" + c._wrapperState.initialValue, E || h === c.value || (c.value = h), c.defaultValue = h;
    }
    E = c.name, E !== "" && (c.name = ""), c.defaultChecked = !!c._wrapperState.initialChecked, E !== "" && (c.name = E);
  }
  function Nt(c, h, E) {
    (h !== "number" || qe(c.ownerDocument) !== c) && (E == null ? c.defaultValue = "" + c._wrapperState.initialValue : c.defaultValue !== "" + E && (c.defaultValue = "" + E));
  }
  var Zt = Array.isArray;
  function Rt(c, h, E, P) {
    if (c = c.options, h) {
      h = {};
      for (var V = 0; V < E.length; V++)
        h["$" + E[V]] = !0;
      for (E = 0; E < c.length; E++)
        V = h.hasOwnProperty("$" + c[E].value), c[E].selected !== V && (c[E].selected = V), V && P && (c[E].defaultSelected = !0);
    } else {
      for (E = "" + tt(E), h = null, V = 0; V < c.length; V++) {
        if (c[V].value === E) {
          c[V].selected = !0, P && (c[V].defaultSelected = !0);
          return;
        }
        h !== null || c[V].disabled || (h = c[V]);
      }
      h !== null && (h.selected = !0);
    }
  }
  function we(c, h) {
    if (h.dangerouslySetInnerHTML != null)
      throw Error(t(91));
    return he({}, h, { value: void 0, defaultValue: void 0, children: "" + c._wrapperState.initialValue });
  }
  function oe(c, h) {
    var E = h.value;
    if (E == null) {
      if (E = h.children, h = h.defaultValue, E != null) {
        if (h != null)
          throw Error(t(92));
        if (Zt(E)) {
          if (1 < E.length)
            throw Error(t(93));
          E = E[0];
        }
        h = E;
      }
      h == null && (h = ""), E = h;
    }
    c._wrapperState = { initialValue: tt(E) };
  }
  function Qe(c, h) {
    var E = tt(h.value), P = tt(h.defaultValue);
    E != null && (E = "" + E, E !== c.value && (c.value = E), h.defaultValue == null && c.defaultValue !== E && (c.defaultValue = E)), P != null && (c.defaultValue = "" + P);
  }
  function ut(c) {
    var h = c.textContent;
    h === c._wrapperState.initialValue && h !== "" && h !== null && (c.value = h);
  }
  function Ft(c) {
    switch (c) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function Ot(c, h) {
    return c == null || c === "http://www.w3.org/1999/xhtml" ? Ft(h) : c === "http://www.w3.org/2000/svg" && h === "foreignObject" ? "http://www.w3.org/1999/xhtml" : c;
  }
  var Wt, it = function(c) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(h, E, P, V) {
      MSApp.execUnsafeLocalFunction(function() {
        return c(h, E, P, V);
      });
    } : c;
  }(function(c, h) {
    if (c.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in c)
      c.innerHTML = h;
    else {
      for (Wt = Wt || document.createElement("div"), Wt.innerHTML = "<svg>" + h.valueOf().toString() + "</svg>", h = Wt.firstChild; c.firstChild; )
        c.removeChild(c.firstChild);
      for (; h.firstChild; )
        c.appendChild(h.firstChild);
    }
  });
  function an(c, h) {
    if (h) {
      var E = c.firstChild;
      if (E && E === c.lastChild && E.nodeType === 3) {
        E.nodeValue = h;
        return;
      }
    }
    c.textContent = h;
  }
  var Be = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, pe = ["Webkit", "ms", "Moz", "O"];
  Object.keys(Be).forEach(function(c) {
    pe.forEach(function(h) {
      h = h + c.charAt(0).toUpperCase() + c.substring(1), Be[h] = Be[c];
    });
  });
  function Fe(c, h, E) {
    return h == null || typeof h == "boolean" || h === "" ? "" : E || typeof h != "number" || h === 0 || Be.hasOwnProperty(c) && Be[c] ? ("" + h).trim() : h + "px";
  }
  function at(c, h) {
    c = c.style;
    for (var E in h)
      if (h.hasOwnProperty(E)) {
        var P = E.indexOf("--") === 0, V = Fe(E, h[E], P);
        E === "float" && (E = "cssFloat"), P ? c.setProperty(E, V) : c[E] = V;
      }
  }
  var st = he({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
  function dn(c, h) {
    if (h) {
      if (st[c] && (h.children != null || h.dangerouslySetInnerHTML != null))
        throw Error(t(137, c));
      if (h.dangerouslySetInnerHTML != null) {
        if (h.children != null)
          throw Error(t(60));
        if (typeof h.dangerouslySetInnerHTML != "object" || !("__html" in h.dangerouslySetInnerHTML))
          throw Error(t(61));
      }
      if (h.style != null && typeof h.style != "object")
        throw Error(t(62));
    }
  }
  function ze(c, h) {
    if (c.indexOf("-") === -1)
      return typeof h.is == "string";
    switch (c) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var wt = null;
  function Pe(c) {
    return c = c.target || c.srcElement || window, c.correspondingUseElement && (c = c.correspondingUseElement), c.nodeType === 3 ? c.parentNode : c;
  }
  var Gt = null, At = null, cn = null;
  function ki(c) {
    if (c = ka(c)) {
      if (typeof Gt != "function")
        throw Error(t(280));
      var h = c.stateNode;
      h && (h = vr(h), Gt(c.stateNode, c.type, h));
    }
  }
  function Or(c) {
    At ? cn ? cn.push(c) : cn = [c] : At = c;
  }
  function Ii() {
    if (At) {
      var c = At, h = cn;
      if (cn = At = null, ki(c), h)
        for (c = 0; c < h.length; c++)
          ki(h[c]);
    }
  }
  function Ir(c, h) {
    return c(h);
  }
  function Bn() {
  }
  var Mi = !1;
  function yi(c, h, E) {
    if (Mi)
      return c(h, E);
    Mi = !0;
    try {
      return Ir(c, h, E);
    } finally {
      Mi = !1, (At !== null || cn !== null) && (Bn(), Ii());
    }
  }
  function ii(c, h) {
    var E = c.stateNode;
    if (E === null)
      return null;
    var P = vr(E);
    if (P === null)
      return null;
    E = P[h];
    e:
      switch (h) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (P = !P.disabled) || (c = c.type, P = !(c === "button" || c === "input" || c === "select" || c === "textarea")), c = !P;
          break e;
        default:
          c = !1;
      }
    if (c)
      return null;
    if (E && typeof E != "function")
      throw Error(t(231, h, typeof E));
    return E;
  }
  var Bi = !1;
  if (d)
    try {
      var xi = {};
      Object.defineProperty(xi, "passive", { get: function() {
        Bi = !0;
      } }), window.addEventListener("test", xi, xi), window.removeEventListener("test", xi, xi);
    } catch {
      Bi = !1;
    }
  function $r(c, h, E, P, V, q, le, Oe, Ge) {
    var Dt = Array.prototype.slice.call(arguments, 3);
    try {
      h.apply(E, Dt);
    } catch (fn) {
      this.onError(fn);
    }
  }
  var ai = !1, Te = null, ot = !1, de = null, Le = { onError: function(c) {
    ai = !0, Te = c;
  } };
  function Ye(c, h, E, P, V, q, le, Oe, Ge) {
    ai = !1, Te = null, $r.apply(Le, arguments);
  }
  function $t(c, h, E, P, V, q, le, Oe, Ge) {
    if (Ye.apply(this, arguments), ai) {
      if (ai) {
        var Dt = Te;
        ai = !1, Te = null;
      } else
        throw Error(t(198));
      ot || (ot = !0, de = Dt);
    }
  }
  function mn(c) {
    var h = c, E = c;
    if (c.alternate)
      for (; h.return; )
        h = h.return;
    else {
      c = h;
      do
        h = c, (h.flags & 4098) !== 0 && (E = h.return), c = h.return;
      while (c);
    }
    return h.tag === 3 ? E : null;
  }
  function Rn(c) {
    if (c.tag === 13) {
      var h = c.memoizedState;
      if (h === null && (c = c.alternate, c !== null && (h = c.memoizedState)), h !== null)
        return h.dehydrated;
    }
    return null;
  }
  function gn(c) {
    if (mn(c) !== c)
      throw Error(t(188));
  }
  function yn(c) {
    var h = c.alternate;
    if (!h) {
      if (h = mn(c), h === null)
        throw Error(t(188));
      return h !== c ? null : c;
    }
    for (var E = c, P = h; ; ) {
      var V = E.return;
      if (V === null)
        break;
      var q = V.alternate;
      if (q === null) {
        if (P = V.return, P !== null) {
          E = P;
          continue;
        }
        break;
      }
      if (V.child === q.child) {
        for (q = V.child; q; ) {
          if (q === E)
            return gn(V), c;
          if (q === P)
            return gn(V), h;
          q = q.sibling;
        }
        throw Error(t(188));
      }
      if (E.return !== P.return)
        E = V, P = q;
      else {
        for (var le = !1, Oe = V.child; Oe; ) {
          if (Oe === E) {
            le = !0, E = V, P = q;
            break;
          }
          if (Oe === P) {
            le = !0, P = V, E = q;
            break;
          }
          Oe = Oe.sibling;
        }
        if (!le) {
          for (Oe = q.child; Oe; ) {
            if (Oe === E) {
              le = !0, E = q, P = V;
              break;
            }
            if (Oe === P) {
              le = !0, P = q, E = V;
              break;
            }
            Oe = Oe.sibling;
          }
          if (!le)
            throw Error(t(189));
        }
      }
      if (E.alternate !== P)
        throw Error(t(190));
    }
    if (E.tag !== 3)
      throw Error(t(188));
    return E.stateNode.current === E ? c : h;
  }
  function Jn(c) {
    return c = yn(c), c !== null ? rr(c) : null;
  }
  function rr(c) {
    if (c.tag === 5 || c.tag === 6)
      return c;
    for (c = c.child; c !== null; ) {
      var h = rr(c);
      if (h !== null)
        return h;
      c = c.sibling;
    }
    return null;
  }
  var wr = e.unstable_scheduleCallback, Yi = e.unstable_cancelCallback, La = e.unstable_shouldYield, qs = e.unstable_requestPaint, en = e.unstable_now, Xr = e.unstable_getCurrentPriorityLevel, us = e.unstable_ImmediatePriority, qn = e.unstable_UserBlockingPriority, qa = e.unstable_NormalPriority, mo = e.unstable_LowPriority, Ls = e.unstable_IdlePriority, cs = null, mr = null;
  function di(c) {
    if (mr && typeof mr.onCommitFiberRoot == "function")
      try {
        mr.onCommitFiberRoot(cs, c, void 0, (c.current.flags & 128) === 128);
      } catch {
      }
  }
  var Ea = Math.clz32 ? Math.clz32 : Uo, Si = Math.log, Ti = Math.LN2;
  function Uo(c) {
    return c >>>= 0, c === 0 ? 32 : 31 - (Si(c) / Ti | 0) | 0;
  }
  var zo = 64, Pa = 4194304;
  function Dl(c) {
    switch (c & -c) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return c & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return c & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return c;
    }
  }
  function vo(c, h) {
    var E = c.pendingLanes;
    if (E === 0)
      return 0;
    var P = 0, V = c.suspendedLanes, q = c.pingedLanes, le = E & 268435455;
    if (le !== 0) {
      var Oe = le & ~V;
      Oe !== 0 ? P = Dl(Oe) : (q &= le, q !== 0 && (P = Dl(q)));
    } else
      le = E & ~V, le !== 0 ? P = Dl(le) : q !== 0 && (P = Dl(q));
    if (P === 0)
      return 0;
    if (h !== 0 && h !== P && (h & V) === 0 && (V = P & -P, q = h & -h, V >= q || V === 16 && (q & 4194240) !== 0))
      return h;
    if ((P & 4) !== 0 && (P |= E & 16), h = c.entangledLanes, h !== 0)
      for (c = c.entanglements, h &= P; 0 < h; )
        E = 31 - Ea(h), V = 1 << E, P |= c[E], h &= ~V;
    return P;
  }
  function Yf(c, h) {
    switch (c) {
      case 1:
      case 2:
      case 4:
        return h + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return h + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function Ll(c, h) {
    for (var E = c.suspendedLanes, P = c.pingedLanes, V = c.expirationTimes, q = c.pendingLanes; 0 < q; ) {
      var le = 31 - Ea(q), Oe = 1 << le, Ge = V[le];
      Ge === -1 ? ((Oe & E) === 0 || (Oe & P) !== 0) && (V[le] = Yf(Oe, h)) : Ge <= h && (c.expiredLanes |= Oe), q &= ~Oe;
    }
  }
  function Nd(c) {
    return c = c.pendingLanes & -1073741825, c !== 0 ? c : c & 1073741824 ? 1073741824 : 0;
  }
  function Ps() {
    var c = zo;
    return zo <<= 1, (zo & 4194240) === 0 && (zo = 64), c;
  }
  function Ju(c) {
    for (var h = [], E = 0; 31 > E; E++)
      h.push(c);
    return h;
  }
  function ou(c, h, E) {
    c.pendingLanes |= h, h !== 536870912 && (c.suspendedLanes = 0, c.pingedLanes = 0), c = c.eventTimes, h = 31 - Ea(h), c[h] = E;
  }
  function Jh(c, h) {
    var E = c.pendingLanes & ~h;
    c.pendingLanes = h, c.suspendedLanes = 0, c.pingedLanes = 0, c.expiredLanes &= h, c.mutableReadLanes &= h, c.entangledLanes &= h, h = c.entanglements;
    var P = c.eventTimes;
    for (c = c.expirationTimes; 0 < E; ) {
      var V = 31 - Ea(E), q = 1 << V;
      h[V] = 0, P[V] = -1, c[V] = -1, E &= ~q;
    }
  }
  function Pl(c, h) {
    var E = c.entangledLanes |= h;
    for (c = c.entanglements; E; ) {
      var P = 31 - Ea(E), V = 1 << P;
      V & h | c[P] & h && (c[P] |= h), E &= ~V;
    }
  }
  var ei = 0;
  function go(c) {
    return c &= -c, 1 < c ? 4 < c ? (c & 268435455) !== 0 ? 16 : 536870912 : 4 : 1;
  }
  var Xf, No, Ci, fs, qf, xr = !1, Tu = [], ua = null, Cr = null, dl = null, yo = /* @__PURE__ */ new Map(), Ka = /* @__PURE__ */ new Map(), Xi = [], Lm = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function hi(c, h) {
    switch (c) {
      case "focusin":
      case "focusout":
        ua = null;
        break;
      case "dragenter":
      case "dragleave":
        Cr = null;
        break;
      case "mouseover":
      case "mouseout":
        dl = null;
        break;
      case "pointerover":
      case "pointerout":
        yo.delete(h.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Ka.delete(h.pointerId);
    }
  }
  function Qa(c, h, E, P, V, q) {
    return c === null || c.nativeEvent !== q ? (c = { blockedOn: h, domEventName: E, eventSystemFlags: P, nativeEvent: q, targetContainers: [V] }, h !== null && (h = ka(h), h !== null && No(h)), c) : (c.eventSystemFlags |= P, h = c.targetContainers, V !== null && h.indexOf(V) === -1 && h.push(V), c);
  }
  function Sc(c, h, E, P, V) {
    switch (h) {
      case "focusin":
        return ua = Qa(ua, c, h, E, P, V), !0;
      case "dragenter":
        return Cr = Qa(Cr, c, h, E, P, V), !0;
      case "mouseover":
        return dl = Qa(dl, c, h, E, P, V), !0;
      case "pointerover":
        var q = V.pointerId;
        return yo.set(q, Qa(yo.get(q) || null, c, h, E, P, V)), !0;
      case "gotpointercapture":
        return q = V.pointerId, Ka.set(q, Qa(Ka.get(q) || null, c, h, E, P, V)), !0;
    }
    return !1;
  }
  function hl(c) {
    var h = Ks(c.target);
    if (h !== null) {
      var E = mn(h);
      if (E !== null) {
        if (h = E.tag, h === 13) {
          if (h = Rn(E), h !== null) {
            c.blockedOn = h, qf(c.priority, function() {
              Ci(E);
            });
            return;
          }
        } else if (h === 3 && E.stateNode.current.memoizedState.isDehydrated) {
          c.blockedOn = E.tag === 3 ? E.stateNode.containerInfo : null;
          return;
        }
      }
    }
    c.blockedOn = null;
  }
  function pf(c) {
    if (c.blockedOn !== null)
      return !1;
    for (var h = c.targetContainers; 0 < h.length; ) {
      var E = ko(c.domEventName, c.eventSystemFlags, h[0], c.nativeEvent);
      if (E === null) {
        E = c.nativeEvent;
        var P = new E.constructor(E.type, E);
        wt = P, E.target.dispatchEvent(P), wt = null;
      } else
        return h = ka(E), h !== null && No(h), c.blockedOn = E, !1;
      h.shift();
    }
    return !0;
  }
  function mf(c, h, E) {
    pf(c) && E.delete(h);
  }
  function lu() {
    xr = !1, ua !== null && pf(ua) && (ua = null), Cr !== null && pf(Cr) && (Cr = null), dl !== null && pf(dl) && (dl = null), yo.forEach(mf), Ka.forEach(mf);
  }
  function Hi(c, h) {
    c.blockedOn === h && (c.blockedOn = null, xr || (xr = !0, e.unstable_scheduleCallback(e.unstable_NormalPriority, lu)));
  }
  function Ri(c) {
    function h(V) {
      return Hi(V, c);
    }
    if (0 < Tu.length) {
      Hi(Tu[0], c);
      for (var E = 1; E < Tu.length; E++) {
        var P = Tu[E];
        P.blockedOn === c && (P.blockedOn = null);
      }
    }
    for (ua !== null && Hi(ua, c), Cr !== null && Hi(Cr, c), dl !== null && Hi(dl, c), yo.forEach(h), Ka.forEach(h), E = 0; E < Xi.length; E++)
      P = Xi[E], P.blockedOn === c && (P.blockedOn = null);
    for (; 0 < Xi.length && (E = Xi[0], E.blockedOn === null); )
      hl(E), E.blockedOn === null && Xi.shift();
  }
  var Fo = B.ReactCurrentBatchConfig, Os = !0;
  function wc(c, h, E, P) {
    var V = ei, q = Fo.transition;
    Fo.transition = null;
    try {
      ei = 1, Qf(c, h, E, P);
    } finally {
      ei = V, Fo.transition = q;
    }
  }
  function Ol(c, h, E, P) {
    var V = ei, q = Fo.transition;
    Fo.transition = null;
    try {
      ei = 4, Qf(c, h, E, P);
    } finally {
      ei = V, Fo.transition = q;
    }
  }
  function Qf(c, h, E, P) {
    if (Os) {
      var V = ko(c, h, E, P);
      if (V === null)
        Pu(c, h, P, Zf, E), hi(c, P);
      else if (Sc(V, c, h, E, P))
        P.stopPropagation();
      else if (hi(c, P), h & 4 && -1 < Lm.indexOf(c)) {
        for (; V !== null; ) {
          var q = ka(V);
          if (q !== null && Xf(q), q = ko(c, h, E, P), q === null && Pu(c, h, P, Zf, E), q === V)
            break;
          V = q;
        }
        V !== null && P.stopPropagation();
      } else
        Pu(c, h, P, null, E);
    }
  }
  var Zf = null;
  function ko(c, h, E, P) {
    if (Zf = null, c = Pe(P), c = Ks(c), c !== null)
      if (h = mn(c), h === null)
        c = null;
      else if (E = h.tag, E === 13) {
        if (c = Rn(h), c !== null)
          return c;
        c = null;
      } else if (E === 3) {
        if (h.stateNode.current.memoizedState.isDehydrated)
          return h.tag === 3 ? h.stateNode.containerInfo : null;
        c = null;
      } else
        h !== c && (c = null);
    return Zf = c, null;
  }
  function Jf(c) {
    switch (c) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (Xr()) {
          case us:
            return 1;
          case qn:
            return 4;
          case qa:
          case mo:
            return 16;
          case Ls:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var Ki = null, Cu = null, Oa = null;
  function xs() {
    if (Oa)
      return Oa;
    var c, h = Cu, E = h.length, P, V = "value" in Ki ? Ki.value : Ki.textContent, q = V.length;
    for (c = 0; c < E && h[c] === V[c]; c++)
      ;
    var le = E - c;
    for (P = 1; P <= le && h[E - P] === V[q - P]; P++)
      ;
    return Oa = V.slice(c, 1 < P ? 1 - P : void 0);
  }
  function uu(c) {
    var h = c.keyCode;
    return "charCode" in c ? (c = c.charCode, c === 0 && h === 13 && (c = 13)) : c = h, c === 10 && (c = 13), 32 <= c || c === 13 ? c : 0;
  }
  function Ua() {
    return !0;
  }
  function bc() {
    return !1;
  }
  function xo(c) {
    function h(E, P, V, q, le) {
      this._reactName = E, this._targetInst = V, this.type = P, this.nativeEvent = q, this.target = le, this.currentTarget = null;
      for (var Oe in c)
        c.hasOwnProperty(Oe) && (E = c[Oe], this[Oe] = E ? E(q) : q[Oe]);
      return this.isDefaultPrevented = (q.defaultPrevented != null ? q.defaultPrevented : q.returnValue === !1) ? Ua : bc, this.isPropagationStopped = bc, this;
    }
    return he(h.prototype, { preventDefault: function() {
      this.defaultPrevented = !0;
      var E = this.nativeEvent;
      E && (E.preventDefault ? E.preventDefault() : typeof E.returnValue != "unknown" && (E.returnValue = !1), this.isDefaultPrevented = Ua);
    }, stopPropagation: function() {
      var E = this.nativeEvent;
      E && (E.stopPropagation ? E.stopPropagation() : typeof E.cancelBubble != "unknown" && (E.cancelBubble = !0), this.isPropagationStopped = Ua);
    }, persist: function() {
    }, isPersistent: Ua }), h;
  }
  var Ru = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(c) {
    return c.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, Ul = xo(Ru), za = he({}, Ru, { view: 0, detail: 0 }), Qs = xo(za), qr, _s, va, Zs = he({}, za, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Fd, button: 0, buttons: 0, relatedTarget: function(c) {
    return c.relatedTarget === void 0 ? c.fromElement === c.srcElement ? c.toElement : c.fromElement : c.relatedTarget;
  }, movementX: function(c) {
    return "movementX" in c ? c.movementX : (c !== va && (va && c.type === "mousemove" ? (qr = c.screenX - va.screenX, _s = c.screenY - va.screenY) : _s = qr = 0, va = c), qr);
  }, movementY: function(c) {
    return "movementY" in c ? c.movementY : _s;
  } }), Kf = xo(Zs), el = he({}, Zs, { dataTransfer: 0 }), Ku = xo(el), Kh = he({}, za, { relatedTarget: 0 }), qi = xo(Kh), Au = he({}, Ru, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Fp = xo(Au), pg = he({}, Ru, { clipboardData: function(c) {
    return "clipboardData" in c ? c.clipboardData : window.clipboardData;
  } }), $h = xo(pg), Pm = he({}, Ru, { data: 0 }), Om = xo(Pm), Um = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, zm = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, gh = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function $u(c) {
    var h = this.nativeEvent;
    return h.getModifierState ? h.getModifierState(c) : (c = gh[c]) ? !!h[c] : !1;
  }
  function Fd() {
    return $u;
  }
  var Du = he({}, za, { key: function(c) {
    if (c.key) {
      var h = Um[c.key] || c.key;
      if (h !== "Unidentified")
        return h;
    }
    return c.type === "keypress" ? (c = uu(c), c === 13 ? "Enter" : String.fromCharCode(c)) : c.type === "keydown" || c.type === "keyup" ? zm[c.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Fd, charCode: function(c) {
    return c.type === "keypress" ? uu(c) : 0;
  }, keyCode: function(c) {
    return c.type === "keydown" || c.type === "keyup" ? c.keyCode : 0;
  }, which: function(c) {
    return c.type === "keypress" ? uu(c) : c.type === "keydown" || c.type === "keyup" ? c.keyCode : 0;
  } }), kp = xo(Du), pl = he({}, Zs, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), tl = xo(pl), vf = he({}, za, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Fd }), $f = xo(vf), cu = he({}, Ru, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), gf = xo(cu), zl = he({}, Zs, {
    deltaX: function(c) {
      return "deltaX" in c ? c.deltaX : "wheelDeltaX" in c ? -c.wheelDeltaX : 0;
    },
    deltaY: function(c) {
      return "deltaY" in c ? c.deltaY : "wheelDeltaY" in c ? -c.wheelDeltaY : "wheelDelta" in c ? -c.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), ec = xo(zl), Oi = [9, 13, 27, 32], Za = d && "CompositionEvent" in window, Ma = null;
  d && "documentMode" in document && (Ma = document.documentMode);
  var ca = d && "TextEvent" in window && !Ma, kd = d && (!Za || Ma && 8 < Ma && 11 >= Ma), nl = String.fromCharCode(32), Nm = !1;
  function Fm(c, h) {
    switch (c) {
      case "keyup":
        return Oi.indexOf(h.keyCode) !== -1;
      case "keydown":
        return h.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function yh(c) {
    return c = c.detail, typeof c == "object" && "data" in c ? c.data : null;
  }
  var ed = !1;
  function Id(c, h) {
    switch (c) {
      case "compositionend":
        return yh(h);
      case "keypress":
        return h.which !== 32 ? null : (Nm = !0, nl);
      case "textInput":
        return c = h.data, c === nl && Nm ? null : c;
      default:
        return null;
    }
  }
  function Ip(c, h) {
    if (ed)
      return c === "compositionend" || !Za && Fm(c, h) ? (c = xs(), Oa = Cu = Ki = null, ed = !1, c) : null;
    switch (c) {
      case "paste":
        return null;
      case "keypress":
        if (!(h.ctrlKey || h.altKey || h.metaKey) || h.ctrlKey && h.altKey) {
          if (h.char && 1 < h.char.length)
            return h.char;
          if (h.which)
            return String.fromCharCode(h.which);
        }
        return null;
      case "compositionend":
        return kd && h.locale !== "ko" ? null : h.data;
      default:
        return null;
    }
  }
  var xh = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
  function Bd(c) {
    var h = c && c.nodeName && c.nodeName.toLowerCase();
    return h === "input" ? !!xh[c.type] : h === "textarea";
  }
  function td(c, h, E, P) {
    Or(P), h = _f(h, "onChange"), 0 < h.length && (E = new Ul("onChange", "change", null, E, P), c.push({ event: E, listeners: h }));
  }
  var Ss = null, tc = null;
  function yf(c) {
    sn(c, 0);
  }
  function Ec(c) {
    var h = Gn(c);
    if (Ie(h))
      return c;
  }
  function Bp(c, h) {
    if (c === "change")
      return h;
  }
  var nc = !1;
  if (d) {
    var Na;
    if (d) {
      var Hd = "oninput" in document;
      if (!Hd) {
        var nd = document.createElement("div");
        nd.setAttribute("oninput", "return;"), Hd = typeof nd.oninput == "function";
      }
      Na = Hd;
    } else
      Na = !1;
    nc = Na && (!document.documentMode || 9 < document.documentMode);
  }
  function rc() {
    Ss && (Ss.detachEvent("onpropertychange", Hp), tc = Ss = null);
  }
  function Hp(c) {
    if (c.propertyName === "value" && Ec(tc)) {
      var h = [];
      td(h, tc, c, Pe(c)), yi(yf, h);
    }
  }
  function _h(c, h, E) {
    c === "focusin" ? (rc(), Ss = h, tc = E, Ss.attachEvent("onpropertychange", Hp)) : c === "focusout" && rc();
  }
  function Vp(c) {
    if (c === "selectionchange" || c === "keyup" || c === "keydown")
      return Ec(tc);
  }
  function Io(c, h) {
    if (c === "click")
      return Ec(h);
  }
  function Xe(c, h) {
    if (c === "input" || c === "change")
      return Ec(h);
  }
  function Bt(c, h) {
    return c === h && (c !== 0 || 1 / c === 1 / h) || c !== c && h !== h;
  }
  var vt = typeof Object.is == "function" ? Object.is : Bt;
  function Mn(c, h) {
    if (vt(c, h))
      return !0;
    if (typeof c != "object" || c === null || typeof h != "object" || h === null)
      return !1;
    var E = Object.keys(c), P = Object.keys(h);
    if (E.length !== P.length)
      return !1;
    for (P = 0; P < E.length; P++) {
      var V = E[P];
      if (!p.call(h, V) || !vt(c[V], h[V]))
        return !1;
    }
    return !0;
  }
  function $n(c) {
    for (; c && c.firstChild; )
      c = c.firstChild;
    return c;
  }
  function or(c, h) {
    var E = $n(c);
    c = 0;
    for (var P; E; ) {
      if (E.nodeType === 3) {
        if (P = c + E.textContent.length, c <= h && P >= h)
          return { node: E, offset: h - c };
        c = P;
      }
      e: {
        for (; E; ) {
          if (E.nextSibling) {
            E = E.nextSibling;
            break e;
          }
          E = E.parentNode;
        }
        E = void 0;
      }
      E = $n(E);
    }
  }
  function Ta(c, h) {
    return c && h ? c === h ? !0 : c && c.nodeType === 3 ? !1 : h && h.nodeType === 3 ? Ta(c, h.parentNode) : "contains" in c ? c.contains(h) : c.compareDocumentPosition ? !!(c.compareDocumentPosition(h) & 16) : !1 : !1;
  }
  function er() {
    for (var c = window, h = qe(); h instanceof c.HTMLIFrameElement; ) {
      try {
        var E = typeof h.contentWindow.location.href == "string";
      } catch {
        E = !1;
      }
      if (E)
        c = h.contentWindow;
      else
        break;
      h = qe(c.document);
    }
    return h;
  }
  function Ui(c) {
    var h = c && c.nodeName && c.nodeName.toLowerCase();
    return h && (h === "input" && (c.type === "text" || c.type === "search" || c.type === "tel" || c.type === "url" || c.type === "password") || h === "textarea" || c.contentEditable === "true");
  }
  function ia(c) {
    var h = er(), E = c.focusedElem, P = c.selectionRange;
    if (h !== E && E && E.ownerDocument && Ta(E.ownerDocument.documentElement, E)) {
      if (P !== null && Ui(E)) {
        if (h = P.start, c = P.end, c === void 0 && (c = h), "selectionStart" in E)
          E.selectionStart = h, E.selectionEnd = Math.min(c, E.value.length);
        else if (c = (h = E.ownerDocument || document) && h.defaultView || window, c.getSelection) {
          c = c.getSelection();
          var V = E.textContent.length, q = Math.min(P.start, V);
          P = P.end === void 0 ? q : Math.min(P.end, V), !c.extend && q > P && (V = P, P = q, q = V), V = or(E, q);
          var le = or(
            E,
            P
          );
          V && le && (c.rangeCount !== 1 || c.anchorNode !== V.node || c.anchorOffset !== V.offset || c.focusNode !== le.node || c.focusOffset !== le.offset) && (h = h.createRange(), h.setStart(V.node, V.offset), c.removeAllRanges(), q > P ? (c.addRange(h), c.extend(le.node, le.offset)) : (h.setEnd(le.node, le.offset), c.addRange(h)));
        }
      }
      for (h = [], c = E; c = c.parentNode; )
        c.nodeType === 1 && h.push({ element: c, left: c.scrollLeft, top: c.scrollTop });
      for (typeof E.focus == "function" && E.focus(), E = 0; E < h.length; E++)
        c = h[E], c.element.scrollLeft = c.left, c.element.scrollTop = c.top;
    }
  }
  var Bo = d && "documentMode" in document && 11 >= document.documentMode, ds = null, Vd = null, Nl = null, $a = !1;
  function ml(c, h, E) {
    var P = E.window === E ? E.document : E.nodeType === 9 ? E : E.ownerDocument;
    $a || ds == null || ds !== qe(P) || (P = ds, "selectionStart" in P && Ui(P) ? P = { start: P.selectionStart, end: P.selectionEnd } : (P = (P.ownerDocument && P.ownerDocument.defaultView || window).getSelection(), P = { anchorNode: P.anchorNode, anchorOffset: P.anchorOffset, focusNode: P.focusNode, focusOffset: P.focusOffset }), Nl && Mn(Nl, P) || (Nl = P, P = _f(Vd, "onSelect"), 0 < P.length && (h = new Ul("onSelect", "select", null, h, E), c.push({ event: h, listeners: P }), h.target = ds)));
  }
  function _i(c, h) {
    var E = {};
    return E[c.toLowerCase()] = h.toLowerCase(), E["Webkit" + c] = "webkit" + h, E["Moz" + c] = "moz" + h, E;
  }
  var Mc = { animationend: _i("Animation", "AnimationEnd"), animationiteration: _i("Animation", "AnimationIteration"), animationstart: _i("Animation", "AnimationStart"), transitionend: _i("Transition", "TransitionEnd") }, Lu = {}, vl = {};
  d && (vl = document.createElement("div").style, "AnimationEvent" in window || (delete Mc.animationend.animation, delete Mc.animationiteration.animation, delete Mc.animationstart.animation), "TransitionEvent" in window || delete Mc.transitionend.transition);
  function Ca(c) {
    if (Lu[c])
      return Lu[c];
    if (!Mc[c])
      return c;
    var h = Mc[c], E;
    for (E in h)
      if (h.hasOwnProperty(E) && E in vl)
        return Lu[c] = h[E];
    return c;
  }
  var Sh = Ca("animationend"), Gp = Ca("animationiteration"), Tc = Ca("animationstart"), Cc = Ca("transitionend"), Mr = /* @__PURE__ */ new Map(), $i = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function Br(c, h) {
    Mr.set(c, h), s(h, [c]);
  }
  for (var Fa = 0; Fa < $i.length; Fa++) {
    var _o = $i[Fa], rd = _o.toLowerCase(), wh = _o[0].toUpperCase() + _o.slice(1);
    Br(rd, "on" + wh);
  }
  Br(Sh, "onAnimationEnd"), Br(Gp, "onAnimationIteration"), Br(Tc, "onAnimationStart"), Br("dblclick", "onDoubleClick"), Br("focusin", "onFocus"), Br("focusout", "onBlur"), Br(Cc, "onTransitionEnd"), l("onMouseEnter", ["mouseout", "mouseover"]), l("onMouseLeave", ["mouseout", "mouseover"]), l("onPointerEnter", ["pointerout", "pointerover"]), l("onPointerLeave", ["pointerout", "pointerover"]), s("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), s("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), s("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), s("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), s("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), s("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var ic = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), xf = new Set("cancel close invalid load scroll toggle".split(" ").concat(ic));
  function id(c, h, E) {
    var P = c.type || "unknown-event";
    c.currentTarget = E, $t(P, h, void 0, c), c.currentTarget = null;
  }
  function sn(c, h) {
    h = (h & 4) !== 0;
    for (var E = 0; E < c.length; E++) {
      var P = c[E], V = P.event;
      P = P.listeners;
      e: {
        var q = void 0;
        if (h)
          for (var le = P.length - 1; 0 <= le; le--) {
            var Oe = P[le], Ge = Oe.instance, Dt = Oe.currentTarget;
            if (Oe = Oe.listener, Ge !== q && V.isPropagationStopped())
              break e;
            id(V, Oe, Dt), q = Ge;
          }
        else
          for (le = 0; le < P.length; le++) {
            if (Oe = P[le], Ge = Oe.instance, Dt = Oe.currentTarget, Oe = Oe.listener, Ge !== q && V.isPropagationStopped())
              break e;
            id(V, Oe, Dt), q = Ge;
          }
      }
    }
    if (ot)
      throw c = de, ot = !1, de = null, c;
  }
  function kr(c, h) {
    var E = h[od];
    E === void 0 && (E = h[od] = /* @__PURE__ */ new Set());
    var P = c + "__bubble";
    E.has(P) || (ac(h, c, 2, !1), E.add(P));
  }
  function Hr(c, h, E) {
    var P = 0;
    h && (P |= 4), ac(E, c, P, h);
  }
  var Ho = "_reactListening" + Math.random().toString(36).slice(2);
  function rl(c) {
    if (!c[Ho]) {
      c[Ho] = !0, r.forEach(function(E) {
        E !== "selectionchange" && (xf.has(E) || Hr(E, !1, c), Hr(E, !0, c));
      });
      var h = c.nodeType === 9 ? c : c.ownerDocument;
      h === null || h[Ho] || (h[Ho] = !0, Hr("selectionchange", !1, h));
    }
  }
  function ac(c, h, E, P) {
    switch (Jf(h)) {
      case 1:
        var V = wc;
        break;
      case 4:
        V = Ol;
        break;
      default:
        V = Qf;
    }
    E = V.bind(null, h, E, c), V = void 0, !Bi || h !== "touchstart" && h !== "touchmove" && h !== "wheel" || (V = !0), P ? V !== void 0 ? c.addEventListener(h, E, { capture: !0, passive: V }) : c.addEventListener(h, E, !0) : V !== void 0 ? c.addEventListener(h, E, { passive: V }) : c.addEventListener(h, E, !1);
  }
  function Pu(c, h, E, P, V) {
    var q = P;
    if ((h & 1) === 0 && (h & 2) === 0 && P !== null)
      e:
        for (; ; ) {
          if (P === null)
            return;
          var le = P.tag;
          if (le === 3 || le === 4) {
            var Oe = P.stateNode.containerInfo;
            if (Oe === V || Oe.nodeType === 8 && Oe.parentNode === V)
              break;
            if (le === 4)
              for (le = P.return; le !== null; ) {
                var Ge = le.tag;
                if ((Ge === 3 || Ge === 4) && (Ge = le.stateNode.containerInfo, Ge === V || Ge.nodeType === 8 && Ge.parentNode === V))
                  return;
                le = le.return;
              }
            for (; Oe !== null; ) {
              if (le = Ks(Oe), le === null)
                return;
              if (Ge = le.tag, Ge === 5 || Ge === 6) {
                P = q = le;
                continue e;
              }
              Oe = Oe.parentNode;
            }
          }
          P = P.return;
        }
    yi(function() {
      var Dt = q, fn = Pe(E), un = [];
      e: {
        var rn = Mr.get(c);
        if (rn !== void 0) {
          var Hn = Ul, Qn = c;
          switch (c) {
            case "keypress":
              if (uu(E) === 0)
                break e;
            case "keydown":
            case "keyup":
              Hn = kp;
              break;
            case "focusin":
              Qn = "focus", Hn = qi;
              break;
            case "focusout":
              Qn = "blur", Hn = qi;
              break;
            case "beforeblur":
            case "afterblur":
              Hn = qi;
              break;
            case "click":
              if (E.button === 2)
                break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              Hn = Kf;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              Hn = Ku;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              Hn = $f;
              break;
            case Sh:
            case Gp:
            case Tc:
              Hn = Fp;
              break;
            case Cc:
              Hn = gf;
              break;
            case "scroll":
              Hn = Qs;
              break;
            case "wheel":
              Hn = ec;
              break;
            case "copy":
            case "cut":
            case "paste":
              Hn = $h;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              Hn = tl;
          }
          var ir = (h & 4) !== 0, Hs = !ir && c === "scroll", mt = ir ? rn !== null ? rn + "Capture" : null : rn;
          ir = [];
          for (var Ke = Dt, _t; Ke !== null; ) {
            _t = Ke;
            var _n = _t.stateNode;
            if (_t.tag === 5 && _n !== null && (_t = _n, mt !== null && (_n = ii(Ke, mt), _n != null && ir.push(Rc(Ke, _n, _t)))), Hs)
              break;
            Ke = Ke.return;
          }
          0 < ir.length && (rn = new Hn(rn, Qn, null, E, fn), un.push({ event: rn, listeners: ir }));
        }
      }
      if ((h & 7) === 0) {
        e: {
          if (rn = c === "mouseover" || c === "pointerover", Hn = c === "mouseout" || c === "pointerout", rn && E !== wt && (Qn = E.relatedTarget || E.fromElement) && (Ks(Qn) || Qn[So]))
            break e;
          if ((Hn || rn) && (rn = fn.window === fn ? fn : (rn = fn.ownerDocument) ? rn.defaultView || rn.parentWindow : window, Hn ? (Qn = E.relatedTarget || E.toElement, Hn = Dt, Qn = Qn ? Ks(Qn) : null, Qn !== null && (Hs = mn(Qn), Qn !== Hs || Qn.tag !== 5 && Qn.tag !== 6) && (Qn = null)) : (Hn = null, Qn = Dt), Hn !== Qn)) {
            if (ir = Kf, _n = "onMouseLeave", mt = "onMouseEnter", Ke = "mouse", (c === "pointerout" || c === "pointerover") && (ir = tl, _n = "onPointerLeave", mt = "onPointerEnter", Ke = "pointer"), Hs = Hn == null ? rn : Gn(Hn), _t = Qn == null ? rn : Gn(Qn), rn = new ir(_n, Ke + "leave", Hn, E, fn), rn.target = Hs, rn.relatedTarget = _t, _n = null, Ks(fn) === Dt && (ir = new ir(mt, Ke + "enter", Qn, E, fn), ir.target = _t, ir.relatedTarget = Hs, _n = ir), Hs = _n, Hn && Qn)
              t: {
                for (ir = Hn, mt = Qn, Ke = 0, _t = ir; _t; _t = sc(_t))
                  Ke++;
                for (_t = 0, _n = mt; _n; _n = sc(_n))
                  _t++;
                for (; 0 < Ke - _t; )
                  ir = sc(ir), Ke--;
                for (; 0 < _t - Ke; )
                  mt = sc(mt), _t--;
                for (; Ke--; ) {
                  if (ir === mt || mt !== null && ir === mt.alternate)
                    break t;
                  ir = sc(ir), mt = sc(mt);
                }
                ir = null;
              }
            else
              ir = null;
            Hn !== null && hs(un, rn, Hn, ir, !1), Qn !== null && Hs !== null && hs(un, Hs, Qn, ir, !0);
          }
        }
        e: {
          if (rn = Dt ? Gn(Dt) : window, Hn = rn.nodeName && rn.nodeName.toLowerCase(), Hn === "select" || Hn === "input" && rn.type === "file")
            var ar = Bp;
          else if (Bd(rn))
            if (nc)
              ar = Xe;
            else {
              ar = Vp;
              var Zn = _h;
            }
          else
            (Hn = rn.nodeName) && Hn.toLowerCase() === "input" && (rn.type === "checkbox" || rn.type === "radio") && (ar = Io);
          if (ar && (ar = ar(c, Dt))) {
            td(un, ar, E, fn);
            break e;
          }
          Zn && Zn(c, rn, Dt), c === "focusout" && (Zn = rn._wrapperState) && Zn.controlled && rn.type === "number" && Nt(rn, "number", rn.value);
        }
        switch (Zn = Dt ? Gn(Dt) : window, c) {
          case "focusin":
            (Bd(Zn) || Zn.contentEditable === "true") && (ds = Zn, Vd = Dt, Nl = null);
            break;
          case "focusout":
            Nl = Vd = ds = null;
            break;
          case "mousedown":
            $a = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            $a = !1, ml(un, E, fn);
            break;
          case "selectionchange":
            if (Bo)
              break;
          case "keydown":
          case "keyup":
            ml(un, E, fn);
        }
        var pr;
        if (Za)
          e: {
            switch (c) {
              case "compositionstart":
                var Lr = "onCompositionStart";
                break e;
              case "compositionend":
                Lr = "onCompositionEnd";
                break e;
              case "compositionupdate":
                Lr = "onCompositionUpdate";
                break e;
            }
            Lr = void 0;
          }
        else
          ed ? Fm(c, E) && (Lr = "onCompositionEnd") : c === "keydown" && E.keyCode === 229 && (Lr = "onCompositionStart");
        Lr && (kd && E.locale !== "ko" && (ed || Lr !== "onCompositionStart" ? Lr === "onCompositionEnd" && ed && (pr = xs()) : (Ki = fn, Cu = "value" in Ki ? Ki.value : Ki.textContent, ed = !0)), Zn = _f(Dt, Lr), 0 < Zn.length && (Lr = new Om(Lr, c, null, E, fn), un.push({ event: Lr, listeners: Zn }), pr ? Lr.data = pr : (pr = yh(E), pr !== null && (Lr.data = pr)))), (pr = ca ? Id(c, E) : Ip(c, E)) && (Dt = _f(Dt, "onBeforeInput"), 0 < Dt.length && (fn = new Om("onBeforeInput", "beforeinput", null, E, fn), un.push({ event: fn, listeners: Dt }), fn.data = pr));
      }
      sn(un, h);
    });
  }
  function Rc(c, h, E) {
    return { instance: c, listener: h, currentTarget: E };
  }
  function _f(c, h) {
    for (var E = h + "Capture", P = []; c !== null; ) {
      var V = c, q = V.stateNode;
      V.tag === 5 && q !== null && (V = q, q = ii(c, E), q != null && P.unshift(Rc(c, q, V)), q = ii(c, h), q != null && P.push(Rc(c, q, V))), c = c.return;
    }
    return P;
  }
  function sc(c) {
    if (c === null)
      return null;
    do
      c = c.return;
    while (c && c.tag !== 5);
    return c || null;
  }
  function hs(c, h, E, P, V) {
    for (var q = h._reactName, le = []; E !== null && E !== P; ) {
      var Oe = E, Ge = Oe.alternate, Dt = Oe.stateNode;
      if (Ge !== null && Ge === P)
        break;
      Oe.tag === 5 && Dt !== null && (Oe = Dt, V ? (Ge = ii(E, q), Ge != null && le.unshift(Rc(E, Ge, Oe))) : V || (Ge = ii(E, q), Ge != null && le.push(Rc(E, Ge, Oe)))), E = E.return;
    }
    le.length !== 0 && c.push({ event: h, listeners: le });
  }
  var Js = /\r\n?/g, km = /\u0000|\uFFFD/g;
  function ep(c) {
    return (typeof c == "string" ? c : "" + c).replace(Js, `
`).replace(km, "");
  }
  function Gd(c, h, E) {
    if (h = ep(h), ep(c) !== h && E)
      throw Error(t(425));
  }
  function bh() {
  }
  var Sf = null, Ou = null;
  function ad(c, h) {
    return c === "textarea" || c === "noscript" || typeof h.children == "string" || typeof h.children == "number" || typeof h.dangerouslySetInnerHTML == "object" && h.dangerouslySetInnerHTML !== null && h.dangerouslySetInnerHTML.__html != null;
  }
  var fu = typeof setTimeout == "function" ? setTimeout : void 0, wf = typeof clearTimeout == "function" ? clearTimeout : void 0, Ac = typeof Promise == "function" ? Promise : void 0, Wd = typeof queueMicrotask == "function" ? queueMicrotask : typeof Ac < "u" ? function(c) {
    return Ac.resolve(null).then(c).catch(sd);
  } : fu;
  function sd(c) {
    setTimeout(function() {
      throw c;
    });
  }
  function Dc(c, h) {
    var E = h, P = 0;
    do {
      var V = E.nextSibling;
      if (c.removeChild(E), V && V.nodeType === 8)
        if (E = V.data, E === "/$") {
          if (P === 0) {
            c.removeChild(V), Ri(h);
            return;
          }
          P--;
        } else
          E !== "$" && E !== "$?" && E !== "$!" || P++;
      E = V;
    } while (E);
    Ri(h);
  }
  function Fl(c) {
    for (; c != null; c = c.nextSibling) {
      var h = c.nodeType;
      if (h === 1 || h === 3)
        break;
      if (h === 8) {
        if (h = c.data, h === "$" || h === "$!" || h === "$?")
          break;
        if (h === "/$")
          return null;
      }
    }
    return c;
  }
  function Lc(c) {
    c = c.previousSibling;
    for (var h = 0; c; ) {
      if (c.nodeType === 8) {
        var E = c.data;
        if (E === "$" || E === "$!" || E === "$?") {
          if (h === 0)
            return c;
          h--;
        } else
          E === "/$" && h++;
      }
      c = c.previousSibling;
    }
    return null;
  }
  var Pc = Math.random().toString(36).slice(2), Us = "__reactFiber$" + Pc, Uu = "__reactProps$" + Pc, So = "__reactContainer$" + Pc, od = "__reactEvents$" + Pc, xe = "__reactListeners$" + Pc, oc = "__reactHandles$" + Pc;
  function Ks(c) {
    var h = c[Us];
    if (h)
      return h;
    for (var E = c.parentNode; E; ) {
      if (h = E[So] || E[Us]) {
        if (E = h.alternate, h.child !== null || E !== null && E.child !== null)
          for (c = Lc(c); c !== null; ) {
            if (E = c[Us])
              return E;
            c = Lc(c);
          }
        return h;
      }
      c = E, E = c.parentNode;
    }
    return null;
  }
  function ka(c) {
    return c = c[Us] || c[So], !c || c.tag !== 5 && c.tag !== 6 && c.tag !== 13 && c.tag !== 3 ? null : c;
  }
  function Gn(c) {
    if (c.tag === 5 || c.tag === 6)
      return c.stateNode;
    throw Error(t(33));
  }
  function vr(c) {
    return c[Uu] || null;
  }
  var Vi = [], si = -1;
  function Wn(c) {
    return { current: c };
  }
  function wi(c) {
    0 > si || (c.current = Vi[si], Vi[si] = null, si--);
  }
  function zi(c, h) {
    si++, Vi[si] = c.current, c.current = h;
  }
  var Oc = {}, Rr = Wn(Oc), ps = Wn(!1), es = Oc;
  function kl(c, h) {
    var E = c.type.contextTypes;
    if (!E)
      return Oc;
    var P = c.stateNode;
    if (P && P.__reactInternalMemoizedUnmaskedChildContext === h)
      return P.__reactInternalMemoizedMaskedChildContext;
    var V = {}, q;
    for (q in E)
      V[q] = h[q];
    return P && (c = c.stateNode, c.__reactInternalMemoizedUnmaskedChildContext = h, c.__reactInternalMemoizedMaskedChildContext = V), V;
  }
  function Ia(c) {
    return c = c.childContextTypes, c != null;
  }
  function Il() {
    wi(ps), wi(Rr);
  }
  function bf(c, h, E) {
    if (Rr.current !== Oc)
      throw Error(t(168));
    zi(Rr, h), zi(ps, E);
  }
  function jd(c, h, E) {
    var P = c.stateNode;
    if (h = h.childContextTypes, typeof P.getChildContext != "function")
      return E;
    P = P.getChildContext();
    for (var V in P)
      if (!(V in h))
        throw Error(t(108, ct(c) || "Unknown", V));
    return he({}, E, P);
  }
  function Vo(c) {
    return c = (c = c.stateNode) && c.__reactInternalMemoizedMergedChildContext || Oc, es = Rr.current, zi(Rr, c), zi(ps, ps.current), !0;
  }
  function bv(c, h, E) {
    var P = c.stateNode;
    if (!P)
      throw Error(t(169));
    E ? (c = jd(c, h, es), P.__reactInternalMemoizedMergedChildContext = c, wi(ps), wi(Rr), zi(Rr, c)) : wi(ps), zi(ps, E);
  }
  var gl = null, wo = !1, tp = !1;
  function lc(c) {
    gl === null ? gl = [c] : gl.push(c);
  }
  function du(c) {
    wo = !0, lc(c);
  }
  function ws() {
    if (!tp && gl !== null) {
      tp = !0;
      var c = 0, h = ei;
      try {
        var E = gl;
        for (ei = 1; c < E.length; c++) {
          var P = E[c];
          do
            P = P(!0);
          while (P !== null);
        }
        gl = null, wo = !1;
      } catch (V) {
        throw gl !== null && (gl = gl.slice(c + 1)), wr(us, ws), V;
      } finally {
        ei = h, tp = !1;
      }
    }
    return null;
  }
  var Uc = [], Vr = 0, uc = null, Ur = 0, $s = [], ms = 0, zc = null, vn = 1, Bl = "";
  function bo(c, h) {
    Uc[Vr++] = Ur, Uc[Vr++] = uc, uc = c, Ur = h;
  }
  function Im(c, h, E) {
    $s[ms++] = vn, $s[ms++] = Bl, $s[ms++] = zc, zc = c;
    var P = vn;
    c = Bl;
    var V = 32 - Ea(P) - 1;
    P &= ~(1 << V), E += 1;
    var q = 32 - Ea(h) + V;
    if (30 < q) {
      var le = V - V % 5;
      q = (P & (1 << le) - 1).toString(32), P >>= le, V -= le, vn = 1 << 32 - Ea(h) + V | E << V | P, Bl = q + c;
    } else
      vn = 1 << q | E << V | P, Bl = c;
  }
  function Eh(c) {
    c.return !== null && (bo(c, 1), Im(c, 1, 0));
  }
  function zu(c) {
    for (; c === uc; )
      uc = Uc[--Vr], Uc[Vr] = null, Ur = Uc[--Vr], Uc[Vr] = null;
    for (; c === zc; )
      zc = $s[--ms], $s[ms] = null, Bl = $s[--ms], $s[ms] = null, vn = $s[--ms], $s[ms] = null;
  }
  var bs = null, yl = null, ga = !1, hu = null;
  function zs(c, h) {
    var E = wl(5, null, null, 0);
    E.elementType = "DELETED", E.stateNode = h, E.return = c, h = c.deletions, h === null ? (c.deletions = [E], c.flags |= 16) : h.push(E);
  }
  function ld(c, h) {
    switch (c.tag) {
      case 5:
        var E = c.type;
        return h = h.nodeType !== 1 || E.toLowerCase() !== h.nodeName.toLowerCase() ? null : h, h !== null ? (c.stateNode = h, bs = c, yl = Fl(h.firstChild), !0) : !1;
      case 6:
        return h = c.pendingProps === "" || h.nodeType !== 3 ? null : h, h !== null ? (c.stateNode = h, bs = c, yl = null, !0) : !1;
      case 13:
        return h = h.nodeType !== 8 ? null : h, h !== null ? (E = zc !== null ? { id: vn, overflow: Bl } : null, c.memoizedState = { dehydrated: h, treeContext: E, retryLane: 1073741824 }, E = wl(18, null, null, 0), E.stateNode = h, E.return = c, c.child = E, bs = c, yl = null, !0) : !1;
      default:
        return !1;
    }
  }
  function Hl(c) {
    return (c.mode & 1) !== 0 && (c.flags & 128) === 0;
  }
  function Go(c) {
    if (ga) {
      var h = yl;
      if (h) {
        var E = h;
        if (!ld(c, h)) {
          if (Hl(c))
            throw Error(t(418));
          h = Fl(E.nextSibling);
          var P = bs;
          h && ld(c, h) ? zs(P, E) : (c.flags = c.flags & -4097 | 2, ga = !1, bs = c);
        }
      } else {
        if (Hl(c))
          throw Error(t(418));
        c.flags = c.flags & -4097 | 2, ga = !1, bs = c;
      }
    }
  }
  function Yd(c) {
    for (c = c.return; c !== null && c.tag !== 5 && c.tag !== 3 && c.tag !== 13; )
      c = c.return;
    bs = c;
  }
  function il(c) {
    if (c !== bs)
      return !1;
    if (!ga)
      return Yd(c), ga = !0, !1;
    var h;
    if ((h = c.tag !== 3) && !(h = c.tag !== 5) && (h = c.type, h = h !== "head" && h !== "body" && !ad(c.type, c.memoizedProps)), h && (h = yl)) {
      if (Hl(c))
        throw Ns(), Error(t(418));
      for (; h; )
        zs(c, h), h = Fl(h.nextSibling);
    }
    if (Yd(c), c.tag === 13) {
      if (c = c.memoizedState, c = c !== null ? c.dehydrated : null, !c)
        throw Error(t(317));
      e: {
        for (c = c.nextSibling, h = 0; c; ) {
          if (c.nodeType === 8) {
            var E = c.data;
            if (E === "/$") {
              if (h === 0) {
                yl = Fl(c.nextSibling);
                break e;
              }
              h--;
            } else
              E !== "$" && E !== "$!" && E !== "$?" || h++;
          }
          c = c.nextSibling;
        }
        yl = null;
      }
    } else
      yl = bs ? Fl(c.stateNode.nextSibling) : null;
    return !0;
  }
  function Ns() {
    for (var c = yl; c; )
      c = Fl(c.nextSibling);
  }
  function fa() {
    yl = bs = null, ga = !1;
  }
  function Nu(c) {
    hu === null ? hu = [c] : hu.push(c);
  }
  var Wp = B.ReactCurrentBatchConfig;
  function pu(c, h) {
    if (c && c.defaultProps) {
      h = he({}, h), c = c.defaultProps;
      for (var E in c)
        h[E] === void 0 && (h[E] = c[E]);
      return h;
    }
    return h;
  }
  var Vl = Wn(null), np = null, Ef = null, eo = null;
  function Xd() {
    eo = Ef = np = null;
  }
  function da(c) {
    var h = Vl.current;
    wi(Vl), c._currentValue = h;
  }
  function Gi(c, h, E) {
    for (; c !== null; ) {
      var P = c.alternate;
      if ((c.childLanes & h) !== h ? (c.childLanes |= h, P !== null && (P.childLanes |= h)) : P !== null && (P.childLanes & h) !== h && (P.childLanes |= h), c === E)
        break;
      c = c.return;
    }
  }
  function bn(c, h) {
    np = c, eo = Ef = null, c = c.dependencies, c !== null && c.firstContext !== null && ((c.lanes & h) !== 0 && (Tn = !0), c.firstContext = null);
  }
  function Qi(c) {
    var h = c._currentValue;
    if (eo !== c)
      if (c = { context: c, memoizedValue: h, next: null }, Ef === null) {
        if (np === null)
          throw Error(t(308));
        Ef = c, np.dependencies = { lanes: 0, firstContext: c };
      } else
        Ef = Ef.next = c;
    return h;
  }
  var ya = null;
  function rp(c) {
    ya === null ? ya = [c] : ya.push(c);
  }
  function Wo(c, h, E, P) {
    var V = h.interleaved;
    return V === null ? (E.next = E, rp(h)) : (E.next = V.next, V.next = E), h.interleaved = E, jo(c, P);
  }
  function jo(c, h) {
    c.lanes |= h;
    var E = c.alternate;
    for (E !== null && (E.lanes |= h), E = c, c = c.return; c !== null; )
      c.childLanes |= h, E = c.alternate, E !== null && (E.childLanes |= h), E = c, c = c.return;
    return E.tag === 3 ? E.stateNode : null;
  }
  var ts = !1;
  function An(c) {
    c.updateQueue = { baseState: c.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function xa(c, h) {
    c = c.updateQueue, h.updateQueue === c && (h.updateQueue = { baseState: c.baseState, firstBaseUpdate: c.firstBaseUpdate, lastBaseUpdate: c.lastBaseUpdate, shared: c.shared, effects: c.effects });
  }
  function ns(c, h) {
    return { eventTime: c, lane: h, tag: 0, payload: null, callback: null, next: null };
  }
  function Mf(c, h, E) {
    var P = c.updateQueue;
    if (P === null)
      return null;
    if (P = P.shared, (zr & 2) !== 0) {
      var V = P.pending;
      return V === null ? h.next = h : (h.next = V.next, V.next = h), P.pending = h, jo(c, E);
    }
    return V = P.interleaved, V === null ? (h.next = h, rp(P)) : (h.next = V.next, V.next = h), P.interleaved = h, jo(c, E);
  }
  function _a(c, h, E) {
    if (h = h.updateQueue, h !== null && (h = h.shared, (E & 4194240) !== 0)) {
      var P = h.lanes;
      P &= c.pendingLanes, E |= P, h.lanes = E, Pl(c, E);
    }
  }
  function Qr(c, h) {
    var E = c.updateQueue, P = c.alternate;
    if (P !== null && (P = P.updateQueue, E === P)) {
      var V = null, q = null;
      if (E = E.firstBaseUpdate, E !== null) {
        do {
          var le = { eventTime: E.eventTime, lane: E.lane, tag: E.tag, payload: E.payload, callback: E.callback, next: null };
          q === null ? V = q = le : q = q.next = le, E = E.next;
        } while (E !== null);
        q === null ? V = q = h : q = q.next = h;
      } else
        V = q = h;
      E = { baseState: P.baseState, firstBaseUpdate: V, lastBaseUpdate: q, shared: P.shared, effects: P.effects }, c.updateQueue = E;
      return;
    }
    c = E.lastBaseUpdate, c === null ? E.firstBaseUpdate = h : c.next = h, E.lastBaseUpdate = h;
  }
  function Ra(c, h, E, P) {
    var V = c.updateQueue;
    ts = !1;
    var q = V.firstBaseUpdate, le = V.lastBaseUpdate, Oe = V.shared.pending;
    if (Oe !== null) {
      V.shared.pending = null;
      var Ge = Oe, Dt = Ge.next;
      Ge.next = null, le === null ? q = Dt : le.next = Dt, le = Ge;
      var fn = c.alternate;
      fn !== null && (fn = fn.updateQueue, Oe = fn.lastBaseUpdate, Oe !== le && (Oe === null ? fn.firstBaseUpdate = Dt : Oe.next = Dt, fn.lastBaseUpdate = Ge));
    }
    if (q !== null) {
      var un = V.baseState;
      le = 0, fn = Dt = Ge = null, Oe = q;
      do {
        var rn = Oe.lane, Hn = Oe.eventTime;
        if ((P & rn) === rn) {
          fn !== null && (fn = fn.next = {
            eventTime: Hn,
            lane: 0,
            tag: Oe.tag,
            payload: Oe.payload,
            callback: Oe.callback,
            next: null
          });
          e: {
            var Qn = c, ir = Oe;
            switch (rn = h, Hn = E, ir.tag) {
              case 1:
                if (Qn = ir.payload, typeof Qn == "function") {
                  un = Qn.call(Hn, un, rn);
                  break e;
                }
                un = Qn;
                break e;
              case 3:
                Qn.flags = Qn.flags & -65537 | 128;
              case 0:
                if (Qn = ir.payload, rn = typeof Qn == "function" ? Qn.call(Hn, un, rn) : Qn, rn == null)
                  break e;
                un = he({}, un, rn);
                break e;
              case 2:
                ts = !0;
            }
          }
          Oe.callback !== null && Oe.lane !== 0 && (c.flags |= 64, rn = V.effects, rn === null ? V.effects = [Oe] : rn.push(Oe));
        } else
          Hn = { eventTime: Hn, lane: rn, tag: Oe.tag, payload: Oe.payload, callback: Oe.callback, next: null }, fn === null ? (Dt = fn = Hn, Ge = un) : fn = fn.next = Hn, le |= rn;
        if (Oe = Oe.next, Oe === null) {
          if (Oe = V.shared.pending, Oe === null)
            break;
          rn = Oe, Oe = rn.next, rn.next = null, V.lastBaseUpdate = rn, V.shared.pending = null;
        }
      } while (1);
      if (fn === null && (Ge = un), V.baseState = Ge, V.firstBaseUpdate = Dt, V.lastBaseUpdate = fn, h = V.shared.interleaved, h !== null) {
        V = h;
        do
          le |= V.lane, V = V.next;
        while (V !== h);
      } else
        q === null && (V.shared.lanes = 0);
      yd |= le, c.lanes = le, c.memoizedState = un;
    }
  }
  function Ba(c, h, E) {
    if (c = h.effects, h.effects = null, c !== null)
      for (h = 0; h < c.length; h++) {
        var P = c[h], V = P.callback;
        if (V !== null) {
          if (P.callback = null, P = E, typeof V != "function")
            throw Error(t(191, V));
          V.call(P);
        }
      }
  }
  var li = new a.Component().refs;
  function Gl(c, h, E, P) {
    h = c.memoizedState, E = E(P, h), E = E == null ? h : he({}, h, E), c.memoizedState = E, c.lanes === 0 && (c.updateQueue.baseState = E);
  }
  var ud = { isMounted: function(c) {
    return (c = c._reactInternals) ? mn(c) === c : !1;
  }, enqueueSetState: function(c, h, E) {
    c = c._reactInternals;
    var P = ha(), V = ao(c), q = ns(P, V);
    q.payload = h, E != null && (q.callback = E), h = Mf(c, q, V), h !== null && (Sl(h, c, V, P), _a(h, c, V));
  }, enqueueReplaceState: function(c, h, E) {
    c = c._reactInternals;
    var P = ha(), V = ao(c), q = ns(P, V);
    q.tag = 1, q.payload = h, E != null && (q.callback = E), h = Mf(c, q, V), h !== null && (Sl(h, c, V, P), _a(h, c, V));
  }, enqueueForceUpdate: function(c, h) {
    c = c._reactInternals;
    var E = ha(), P = ao(c), V = ns(E, P);
    V.tag = 2, h != null && (V.callback = h), h = Mf(c, V, P), h !== null && (Sl(h, c, P, E), _a(h, c, P));
  } };
  function Es(c, h, E, P, V, q, le) {
    return c = c.stateNode, typeof c.shouldComponentUpdate == "function" ? c.shouldComponentUpdate(P, q, le) : h.prototype && h.prototype.isPureReactComponent ? !Mn(E, P) || !Mn(V, q) : !0;
  }
  function qd(c, h, E) {
    var P = !1, V = Oc, q = h.contextType;
    return typeof q == "object" && q !== null ? q = Qi(q) : (V = Ia(h) ? es : Rr.current, P = h.contextTypes, q = (P = P != null) ? kl(c, V) : Oc), h = new h(E, q), c.memoizedState = h.state !== null && h.state !== void 0 ? h.state : null, h.updater = ud, c.stateNode = h, h._reactInternals = c, P && (c = c.stateNode, c.__reactInternalMemoizedUnmaskedChildContext = V, c.__reactInternalMemoizedMaskedChildContext = q), h;
  }
  function Nc(c, h, E, P) {
    c = h.state, typeof h.componentWillReceiveProps == "function" && h.componentWillReceiveProps(E, P), typeof h.UNSAFE_componentWillReceiveProps == "function" && h.UNSAFE_componentWillReceiveProps(E, P), h.state !== c && ud.enqueueReplaceState(h, h.state, null);
  }
  function cc(c, h, E, P) {
    var V = c.stateNode;
    V.props = E, V.state = c.memoizedState, V.refs = li, An(c);
    var q = h.contextType;
    typeof q == "object" && q !== null ? V.context = Qi(q) : (q = Ia(h) ? es : Rr.current, V.context = kl(c, q)), V.state = c.memoizedState, q = h.getDerivedStateFromProps, typeof q == "function" && (Gl(c, h, q, E), V.state = c.memoizedState), typeof h.getDerivedStateFromProps == "function" || typeof V.getSnapshotBeforeUpdate == "function" || typeof V.UNSAFE_componentWillMount != "function" && typeof V.componentWillMount != "function" || (h = V.state, typeof V.componentWillMount == "function" && V.componentWillMount(), typeof V.UNSAFE_componentWillMount == "function" && V.UNSAFE_componentWillMount(), h !== V.state && ud.enqueueReplaceState(V, V.state, null), Ra(c, E, V, P), V.state = c.memoizedState), typeof V.componentDidMount == "function" && (c.flags |= 4194308);
  }
  function Qd(c, h, E) {
    if (c = E.ref, c !== null && typeof c != "function" && typeof c != "object") {
      if (E._owner) {
        if (E = E._owner, E) {
          if (E.tag !== 1)
            throw Error(t(309));
          var P = E.stateNode;
        }
        if (!P)
          throw Error(t(147, c));
        var V = P, q = "" + c;
        return h !== null && h.ref !== null && typeof h.ref == "function" && h.ref._stringRef === q ? h.ref : (h = function(le) {
          var Oe = V.refs;
          Oe === li && (Oe = V.refs = {}), le === null ? delete Oe[q] : Oe[q] = le;
        }, h._stringRef = q, h);
      }
      if (typeof c != "string")
        throw Error(t(284));
      if (!E._owner)
        throw Error(t(290, c));
    }
    return c;
  }
  function cd(c, h) {
    throw c = Object.prototype.toString.call(h), Error(t(31, c === "[object Object]" ? "object with keys {" + Object.keys(h).join(", ") + "}" : c));
  }
  function al(c) {
    var h = c._init;
    return h(c._payload);
  }
  function Bm(c) {
    function h(mt, Ke) {
      if (c) {
        var _t = mt.deletions;
        _t === null ? (mt.deletions = [Ke], mt.flags |= 16) : _t.push(Ke);
      }
    }
    function E(mt, Ke) {
      if (!c)
        return null;
      for (; Ke !== null; )
        h(mt, Ke), Ke = Ke.sibling;
      return null;
    }
    function P(mt, Ke) {
      for (mt = /* @__PURE__ */ new Map(); Ke !== null; )
        Ke.key !== null ? mt.set(Ke.key, Ke) : mt.set(Ke.index, Ke), Ke = Ke.sibling;
      return mt;
    }
    function V(mt, Ke) {
      return mt = Bu(mt, Ke), mt.index = 0, mt.sibling = null, mt;
    }
    function q(mt, Ke, _t) {
      return mt.index = _t, c ? (_t = mt.alternate, _t !== null ? (_t = _t.index, _t < Ke ? (mt.flags |= 2, Ke) : _t) : (mt.flags |= 2, Ke)) : (mt.flags |= 1048576, Ke);
    }
    function le(mt) {
      return c && mt.alternate === null && (mt.flags |= 2), mt;
    }
    function Oe(mt, Ke, _t, _n) {
      return Ke === null || Ke.tag !== 6 ? (Ke = mc(_t, mt.mode, _n), Ke.return = mt, Ke) : (Ke = V(Ke, _t), Ke.return = mt, Ke);
    }
    function Ge(mt, Ke, _t, _n) {
      var ar = _t.type;
      return ar === te ? fn(mt, Ke, _t.props.children, _n, _t.key) : Ke !== null && (Ke.elementType === ar || typeof ar == "object" && ar !== null && ar.$$typeof === Re && al(ar) === Ke.type) ? (_n = V(Ke, _t.props), _n.ref = Qd(mt, Ke, _t), _n.return = mt, _n) : (_n = Ph(_t.type, _t.key, _t.props, null, mt.mode, _n), _n.ref = Qd(mt, Ke, _t), _n.return = mt, _n);
    }
    function Dt(mt, Ke, _t, _n) {
      return Ke === null || Ke.tag !== 4 || Ke.stateNode.containerInfo !== _t.containerInfo || Ke.stateNode.implementation !== _t.implementation ? (Ke = Aa(_t, mt.mode, _n), Ke.return = mt, Ke) : (Ke = V(Ke, _t.children || []), Ke.return = mt, Ke);
    }
    function fn(mt, Ke, _t, _n, ar) {
      return Ke === null || Ke.tag !== 7 ? (Ke = em(_t, mt.mode, _n, ar), Ke.return = mt, Ke) : (Ke = V(Ke, _t), Ke.return = mt, Ke);
    }
    function un(mt, Ke, _t) {
      if (typeof Ke == "string" && Ke !== "" || typeof Ke == "number")
        return Ke = mc("" + Ke, mt.mode, _t), Ke.return = mt, Ke;
      if (typeof Ke == "object" && Ke !== null) {
        switch (Ke.$$typeof) {
          case Q:
            return _t = Ph(Ke.type, Ke.key, Ke.props, null, mt.mode, _t), _t.ref = Qd(mt, null, Ke), _t.return = mt, _t;
          case K:
            return Ke = Aa(Ke, mt.mode, _t), Ke.return = mt, Ke;
          case Re:
            var _n = Ke._init;
            return un(mt, _n(Ke._payload), _t);
        }
        if (Zt(Ke) || fe(Ke))
          return Ke = em(Ke, mt.mode, _t, null), Ke.return = mt, Ke;
        cd(mt, Ke);
      }
      return null;
    }
    function rn(mt, Ke, _t, _n) {
      var ar = Ke !== null ? Ke.key : null;
      if (typeof _t == "string" && _t !== "" || typeof _t == "number")
        return ar !== null ? null : Oe(mt, Ke, "" + _t, _n);
      if (typeof _t == "object" && _t !== null) {
        switch (_t.$$typeof) {
          case Q:
            return _t.key === ar ? Ge(mt, Ke, _t, _n) : null;
          case K:
            return _t.key === ar ? Dt(mt, Ke, _t, _n) : null;
          case Re:
            return ar = _t._init, rn(
              mt,
              Ke,
              ar(_t._payload),
              _n
            );
        }
        if (Zt(_t) || fe(_t))
          return ar !== null ? null : fn(mt, Ke, _t, _n, null);
        cd(mt, _t);
      }
      return null;
    }
    function Hn(mt, Ke, _t, _n, ar) {
      if (typeof _n == "string" && _n !== "" || typeof _n == "number")
        return mt = mt.get(_t) || null, Oe(Ke, mt, "" + _n, ar);
      if (typeof _n == "object" && _n !== null) {
        switch (_n.$$typeof) {
          case Q:
            return mt = mt.get(_n.key === null ? _t : _n.key) || null, Ge(Ke, mt, _n, ar);
          case K:
            return mt = mt.get(_n.key === null ? _t : _n.key) || null, Dt(Ke, mt, _n, ar);
          case Re:
            var Zn = _n._init;
            return Hn(mt, Ke, _t, Zn(_n._payload), ar);
        }
        if (Zt(_n) || fe(_n))
          return mt = mt.get(_t) || null, fn(Ke, mt, _n, ar, null);
        cd(Ke, _n);
      }
      return null;
    }
    function Qn(mt, Ke, _t, _n) {
      for (var ar = null, Zn = null, pr = Ke, Lr = Ke = 0, ll = null; pr !== null && Lr < _t.length; Lr++) {
        pr.index > Lr ? (ll = pr, pr = null) : ll = pr.sibling;
        var Zi = rn(mt, pr, _t[Lr], _n);
        if (Zi === null) {
          pr === null && (pr = ll);
          break;
        }
        c && pr && Zi.alternate === null && h(mt, pr), Ke = q(Zi, Ke, Lr), Zn === null ? ar = Zi : Zn.sibling = Zi, Zn = Zi, pr = ll;
      }
      if (Lr === _t.length)
        return E(mt, pr), ga && bo(mt, Lr), ar;
      if (pr === null) {
        for (; Lr < _t.length; Lr++)
          pr = un(mt, _t[Lr], _n), pr !== null && (Ke = q(pr, Ke, Lr), Zn === null ? ar = pr : Zn.sibling = pr, Zn = pr);
        return ga && bo(mt, Lr), ar;
      }
      for (pr = P(mt, pr); Lr < _t.length; Lr++)
        ll = Hn(pr, mt, Lr, _t[Lr], _n), ll !== null && (c && ll.alternate !== null && pr.delete(ll.key === null ? Lr : ll.key), Ke = q(ll, Ke, Lr), Zn === null ? ar = ll : Zn.sibling = ll, Zn = ll);
      return c && pr.forEach(function(If) {
        return h(mt, If);
      }), ga && bo(mt, Lr), ar;
    }
    function ir(mt, Ke, _t, _n) {
      var ar = fe(_t);
      if (typeof ar != "function")
        throw Error(t(150));
      if (_t = ar.call(_t), _t == null)
        throw Error(t(151));
      for (var Zn = ar = null, pr = Ke, Lr = Ke = 0, ll = null, Zi = _t.next(); pr !== null && !Zi.done; Lr++, Zi = _t.next()) {
        pr.index > Lr ? (ll = pr, pr = null) : ll = pr.sibling;
        var If = rn(mt, pr, Zi.value, _n);
        if (If === null) {
          pr === null && (pr = ll);
          break;
        }
        c && pr && If.alternate === null && h(mt, pr), Ke = q(If, Ke, Lr), Zn === null ? ar = If : Zn.sibling = If, Zn = If, pr = ll;
      }
      if (Zi.done)
        return E(
          mt,
          pr
        ), ga && bo(mt, Lr), ar;
      if (pr === null) {
        for (; !Zi.done; Lr++, Zi = _t.next())
          Zi = un(mt, Zi.value, _n), Zi !== null && (Ke = q(Zi, Ke, Lr), Zn === null ? ar = Zi : Zn.sibling = Zi, Zn = Zi);
        return ga && bo(mt, Lr), ar;
      }
      for (pr = P(mt, pr); !Zi.done; Lr++, Zi = _t.next())
        Zi = Hn(pr, mt, Lr, Zi.value, _n), Zi !== null && (c && Zi.alternate !== null && pr.delete(Zi.key === null ? Lr : Zi.key), Ke = q(Zi, Ke, Lr), Zn === null ? ar = Zi : Zn.sibling = Zi, Zn = Zi);
      return c && pr.forEach(function(Rg) {
        return h(mt, Rg);
      }), ga && bo(mt, Lr), ar;
    }
    function Hs(mt, Ke, _t, _n) {
      if (typeof _t == "object" && _t !== null && _t.type === te && _t.key === null && (_t = _t.props.children), typeof _t == "object" && _t !== null) {
        switch (_t.$$typeof) {
          case Q:
            e: {
              for (var ar = _t.key, Zn = Ke; Zn !== null; ) {
                if (Zn.key === ar) {
                  if (ar = _t.type, ar === te) {
                    if (Zn.tag === 7) {
                      E(mt, Zn.sibling), Ke = V(Zn, _t.props.children), Ke.return = mt, mt = Ke;
                      break e;
                    }
                  } else if (Zn.elementType === ar || typeof ar == "object" && ar !== null && ar.$$typeof === Re && al(ar) === Zn.type) {
                    E(mt, Zn.sibling), Ke = V(Zn, _t.props), Ke.ref = Qd(mt, Zn, _t), Ke.return = mt, mt = Ke;
                    break e;
                  }
                  E(mt, Zn);
                  break;
                } else
                  h(mt, Zn);
                Zn = Zn.sibling;
              }
              _t.type === te ? (Ke = em(_t.props.children, mt.mode, _n, _t.key), Ke.return = mt, mt = Ke) : (_n = Ph(_t.type, _t.key, _t.props, null, mt.mode, _n), _n.ref = Qd(mt, Ke, _t), _n.return = mt, mt = _n);
            }
            return le(mt);
          case K:
            e: {
              for (Zn = _t.key; Ke !== null; ) {
                if (Ke.key === Zn)
                  if (Ke.tag === 4 && Ke.stateNode.containerInfo === _t.containerInfo && Ke.stateNode.implementation === _t.implementation) {
                    E(mt, Ke.sibling), Ke = V(Ke, _t.children || []), Ke.return = mt, mt = Ke;
                    break e;
                  } else {
                    E(mt, Ke);
                    break;
                  }
                else
                  h(mt, Ke);
                Ke = Ke.sibling;
              }
              Ke = Aa(_t, mt.mode, _n), Ke.return = mt, mt = Ke;
            }
            return le(mt);
          case Re:
            return Zn = _t._init, Hs(mt, Ke, Zn(_t._payload), _n);
        }
        if (Zt(_t))
          return Qn(mt, Ke, _t, _n);
        if (fe(_t))
          return ir(mt, Ke, _t, _n);
        cd(mt, _t);
      }
      return typeof _t == "string" && _t !== "" || typeof _t == "number" ? (_t = "" + _t, Ke !== null && Ke.tag === 6 ? (E(mt, Ke.sibling), Ke = V(Ke, _t), Ke.return = mt, mt = Ke) : (E(mt, Ke), Ke = mc(_t, mt.mode, _n), Ke.return = mt, mt = Ke), le(mt)) : E(mt, Ke);
    }
    return Hs;
  }
  var Tf = Bm(!0), Zd = Bm(!1), Cf = {}, Wl = Wn(Cf), jl = Wn(Cf), fd = Wn(Cf);
  function Yl(c) {
    if (c === Cf)
      throw Error(t(174));
    return c;
  }
  function Mh(c, h) {
    switch (zi(fd, h), zi(jl, c), zi(Wl, Cf), c = h.nodeType, c) {
      case 9:
      case 11:
        h = (h = h.documentElement) ? h.namespaceURI : Ot(null, "");
        break;
      default:
        c = c === 8 ? h.parentNode : h, h = c.namespaceURI || null, c = c.tagName, h = Ot(h, c);
    }
    wi(Wl), zi(Wl, h);
  }
  function fc() {
    wi(Wl), wi(jl), wi(fd);
  }
  function hr(c) {
    Yl(fd.current);
    var h = Yl(Wl.current), E = Ot(h, c.type);
    h !== E && (zi(jl, c), zi(Wl, E));
  }
  function Gr(c) {
    jl.current === c && (wi(Wl), wi(jl));
  }
  var fr = Wn(0);
  function ui(c) {
    for (var h = c; h !== null; ) {
      if (h.tag === 13) {
        var E = h.memoizedState;
        if (E !== null && (E = E.dehydrated, E === null || E.data === "$?" || E.data === "$!"))
          return h;
      } else if (h.tag === 19 && h.memoizedProps.revealOrder !== void 0) {
        if ((h.flags & 128) !== 0)
          return h;
      } else if (h.child !== null) {
        h.child.return = h, h = h.child;
        continue;
      }
      if (h === c)
        break;
      for (; h.sibling === null; ) {
        if (h.return === null || h.return === c)
          return null;
        h = h.return;
      }
      h.sibling.return = h.return, h = h.sibling;
    }
    return null;
  }
  var Fs = [];
  function Xl() {
    for (var c = 0; c < Fs.length; c++)
      Fs[c]._workInProgressVersionPrimary = null;
    Fs.length = 0;
  }
  var Fc = B.ReactCurrentDispatcher, _r = B.ReactCurrentBatchConfig, Eo = 0, Ai = null, Ht = null, pi = null, lr = !1, kc = !1, Ha = 0, Yo = 0;
  function Di() {
    throw Error(t(321));
  }
  function Rf(c, h) {
    if (h === null)
      return !1;
    for (var E = 0; E < h.length && E < c.length; E++)
      if (!vt(c[E], h[E]))
        return !1;
    return !0;
  }
  function Af(c, h, E, P, V, q) {
    if (Eo = q, Ai = h, h.memoizedState = null, h.updateQueue = null, h.lanes = 0, Fc.current = c === null || c.memoizedState === null ? x : L, c = E(P, V), kc) {
      q = 0;
      do {
        if (kc = !1, Ha = 0, 25 <= q)
          throw Error(t(301));
        q += 1, pi = Ht = null, h.updateQueue = null, Fc.current = k, c = E(P, V);
      } while (kc);
    }
    if (Fc.current = y, h = Ht !== null && Ht.next !== null, Eo = 0, pi = Ht = Ai = null, lr = !1, h)
      throw Error(t(300));
    return c;
  }
  function Df() {
    var c = Ha !== 0;
    return Ha = 0, c;
  }
  function aa() {
    var c = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return pi === null ? Ai.memoizedState = pi = c : pi = pi.next = c, pi;
  }
  function ks() {
    if (Ht === null) {
      var c = Ai.alternate;
      c = c !== null ? c.memoizedState : null;
    } else
      c = Ht.next;
    var h = pi === null ? Ai.memoizedState : pi.next;
    if (h !== null)
      pi = h, Ht = c;
    else {
      if (c === null)
        throw Error(t(310));
      Ht = c, c = { memoizedState: Ht.memoizedState, baseState: Ht.baseState, baseQueue: Ht.baseQueue, queue: Ht.queue, next: null }, pi === null ? Ai.memoizedState = pi = c : pi = pi.next = c;
    }
    return pi;
  }
  function Lf(c, h) {
    return typeof h == "function" ? h(c) : h;
  }
  function Jd(c) {
    var h = ks(), E = h.queue;
    if (E === null)
      throw Error(t(311));
    E.lastRenderedReducer = c;
    var P = Ht, V = P.baseQueue, q = E.pending;
    if (q !== null) {
      if (V !== null) {
        var le = V.next;
        V.next = q.next, q.next = le;
      }
      P.baseQueue = V = q, E.pending = null;
    }
    if (V !== null) {
      q = V.next, P = P.baseState;
      var Oe = le = null, Ge = null, Dt = q;
      do {
        var fn = Dt.lane;
        if ((Eo & fn) === fn)
          Ge !== null && (Ge = Ge.next = { lane: 0, action: Dt.action, hasEagerState: Dt.hasEagerState, eagerState: Dt.eagerState, next: null }), P = Dt.hasEagerState ? Dt.eagerState : c(P, Dt.action);
        else {
          var un = {
            lane: fn,
            action: Dt.action,
            hasEagerState: Dt.hasEagerState,
            eagerState: Dt.eagerState,
            next: null
          };
          Ge === null ? (Oe = Ge = un, le = P) : Ge = Ge.next = un, Ai.lanes |= fn, yd |= fn;
        }
        Dt = Dt.next;
      } while (Dt !== null && Dt !== q);
      Ge === null ? le = P : Ge.next = Oe, vt(P, h.memoizedState) || (Tn = !0), h.memoizedState = P, h.baseState = le, h.baseQueue = Ge, E.lastRenderedState = P;
    }
    if (c = E.interleaved, c !== null) {
      V = c;
      do
        q = V.lane, Ai.lanes |= q, yd |= q, V = V.next;
      while (V !== c);
    } else
      V === null && (E.lanes = 0);
    return [h.memoizedState, E.dispatch];
  }
  function to(c) {
    var h = ks(), E = h.queue;
    if (E === null)
      throw Error(t(311));
    E.lastRenderedReducer = c;
    var P = E.dispatch, V = E.pending, q = h.memoizedState;
    if (V !== null) {
      E.pending = null;
      var le = V = V.next;
      do
        q = c(q, le.action), le = le.next;
      while (le !== V);
      vt(q, h.memoizedState) || (Tn = !0), h.memoizedState = q, h.baseQueue === null && (h.baseState = q), E.lastRenderedState = q;
    }
    return [q, P];
  }
  function ql() {
  }
  function ip(c, h) {
    var E = Ai, P = ks(), V = h(), q = !vt(P.memoizedState, V);
    if (q && (P.memoizedState = V, Tn = !0), P = P.queue, Hc(bi.bind(null, E, P, c), [c]), P.getSnapshot !== h || q || pi !== null && pi.memoizedState.tag & 1) {
      if (E.flags |= 2048, mu(9, Ms.bind(null, E, P, V, h), void 0, null), ea === null)
        throw Error(t(349));
      (Eo & 30) !== 0 || Ic(E, h, V);
    }
    return V;
  }
  function Ic(c, h, E) {
    c.flags |= 16384, c = { getSnapshot: h, value: E }, h = Ai.updateQueue, h === null ? (h = { lastEffect: null, stores: null }, Ai.updateQueue = h, h.stores = [c]) : (E = h.stores, E === null ? h.stores = [c] : E.push(c));
  }
  function Ms(c, h, E, P) {
    h.value = E, h.getSnapshot = P, no(h) && Ql(c);
  }
  function bi(c, h, E) {
    return E(function() {
      no(h) && Ql(c);
    });
  }
  function no(c) {
    var h = c.getSnapshot;
    c = c.value;
    try {
      var E = h();
      return !vt(c, E);
    } catch {
      return !0;
    }
  }
  function Ql(c) {
    var h = jo(c, 1);
    h !== null && Sl(h, c, 1, -1);
  }
  function Bc(c) {
    var h = aa();
    return typeof c == "function" && (c = c()), h.memoizedState = h.baseState = c, c = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Lf, lastRenderedState: c }, h.queue = c, c = c.dispatch = Of.bind(null, Ai, c), [h.memoizedState, c];
  }
  function mu(c, h, E, P) {
    return c = { tag: c, create: h, destroy: E, deps: P, next: null }, h = Ai.updateQueue, h === null ? (h = { lastEffect: null, stores: null }, Ai.updateQueue = h, h.lastEffect = c.next = c) : (E = h.lastEffect, E === null ? h.lastEffect = c.next = c : (P = E.next, E.next = c, c.next = P, h.lastEffect = c)), c;
  }
  function Pf() {
    return ks().memoizedState;
  }
  function vu(c, h, E, P) {
    var V = aa();
    Ai.flags |= c, V.memoizedState = mu(1 | h, E, void 0, P === void 0 ? null : P);
  }
  function Fu(c, h, E, P) {
    var V = ks();
    P = P === void 0 ? null : P;
    var q = void 0;
    if (Ht !== null) {
      var le = Ht.memoizedState;
      if (q = le.destroy, P !== null && Rf(P, le.deps)) {
        V.memoizedState = mu(h, E, q, P);
        return;
      }
    }
    Ai.flags |= c, V.memoizedState = mu(1 | h, E, q, P);
  }
  function Mo(c, h) {
    return vu(8390656, 8, c, h);
  }
  function Hc(c, h) {
    return Fu(2048, 8, c, h);
  }
  function dd(c, h) {
    return Fu(4, 2, c, h);
  }
  function Xo(c, h) {
    return Fu(4, 4, c, h);
  }
  function hd(c, h) {
    if (typeof h == "function")
      return c = c(), h(c), function() {
        h(null);
      };
    if (h != null)
      return c = c(), h.current = c, function() {
        h.current = null;
      };
  }
  function gu(c, h, E) {
    return E = E != null ? E.concat([c]) : null, Fu(4, 4, hd.bind(null, h, c), E);
  }
  function pd() {
  }
  function Ts(c, h) {
    var E = ks();
    h = h === void 0 ? null : h;
    var P = E.memoizedState;
    return P !== null && h !== null && Rf(h, P[1]) ? P[0] : (E.memoizedState = [c, h], c);
  }
  function Is(c, h) {
    var E = ks();
    h = h === void 0 ? null : h;
    var P = E.memoizedState;
    return P !== null && h !== null && Rf(h, P[1]) ? P[0] : (c = c(), E.memoizedState = [c, h], c);
  }
  function yu(c, h, E) {
    return (Eo & 21) === 0 ? (c.baseState && (c.baseState = !1, Tn = !0), c.memoizedState = E) : (vt(E, h) || (E = Ps(), Ai.lanes |= E, yd |= E, c.baseState = !0), h);
  }
  function mg(c, h) {
    var E = ei;
    ei = E !== 0 && 4 > E ? E : 4, c(!0);
    var P = _r.transition;
    _r.transition = {};
    try {
      c(!1), h();
    } finally {
      ei = E, _r.transition = P;
    }
  }
  function ti() {
    return ks().memoizedState;
  }
  function ku(c, h, E) {
    var P = ao(c);
    if (E = { lane: P, action: E, hasEagerState: !1, eagerState: null, next: null }, dc(c))
      Uf(h, E);
    else if (E = Wo(c, h, E, P), E !== null) {
      var V = ha();
      Sl(E, c, P, V), jp(E, h, P);
    }
  }
  function Of(c, h, E) {
    var P = ao(c), V = { lane: P, action: E, hasEagerState: !1, eagerState: null, next: null };
    if (dc(c))
      Uf(h, V);
    else {
      var q = c.alternate;
      if (c.lanes === 0 && (q === null || q.lanes === 0) && (q = h.lastRenderedReducer, q !== null))
        try {
          var le = h.lastRenderedState, Oe = q(le, E);
          if (V.hasEagerState = !0, V.eagerState = Oe, vt(Oe, le)) {
            var Ge = h.interleaved;
            Ge === null ? (V.next = V, rp(h)) : (V.next = Ge.next, Ge.next = V), h.interleaved = V;
            return;
          }
        } catch {
        } finally {
        }
      E = Wo(c, h, V, P), E !== null && (V = ha(), Sl(E, c, P, V), jp(E, h, P));
    }
  }
  function dc(c) {
    var h = c.alternate;
    return c === Ai || h !== null && h === Ai;
  }
  function Uf(c, h) {
    kc = lr = !0;
    var E = c.pending;
    E === null ? h.next = h : (h.next = E.next, E.next = h), c.pending = h;
  }
  function jp(c, h, E) {
    if ((E & 4194240) !== 0) {
      var P = h.lanes;
      P &= c.pendingLanes, E |= P, h.lanes = E, Pl(c, E);
    }
  }
  var y = { readContext: Qi, useCallback: Di, useContext: Di, useEffect: Di, useImperativeHandle: Di, useInsertionEffect: Di, useLayoutEffect: Di, useMemo: Di, useReducer: Di, useRef: Di, useState: Di, useDebugValue: Di, useDeferredValue: Di, useTransition: Di, useMutableSource: Di, useSyncExternalStore: Di, useId: Di, unstable_isNewReconciler: !1 }, x = { readContext: Qi, useCallback: function(c, h) {
    return aa().memoizedState = [c, h === void 0 ? null : h], c;
  }, useContext: Qi, useEffect: Mo, useImperativeHandle: function(c, h, E) {
    return E = E != null ? E.concat([c]) : null, vu(
      4194308,
      4,
      hd.bind(null, h, c),
      E
    );
  }, useLayoutEffect: function(c, h) {
    return vu(4194308, 4, c, h);
  }, useInsertionEffect: function(c, h) {
    return vu(4, 2, c, h);
  }, useMemo: function(c, h) {
    var E = aa();
    return h = h === void 0 ? null : h, c = c(), E.memoizedState = [c, h], c;
  }, useReducer: function(c, h, E) {
    var P = aa();
    return h = E !== void 0 ? E(h) : h, P.memoizedState = P.baseState = h, c = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: c, lastRenderedState: h }, P.queue = c, c = c.dispatch = ku.bind(null, Ai, c), [P.memoizedState, c];
  }, useRef: function(c) {
    var h = aa();
    return c = { current: c }, h.memoizedState = c;
  }, useState: Bc, useDebugValue: pd, useDeferredValue: function(c) {
    return aa().memoizedState = c;
  }, useTransition: function() {
    var c = Bc(!1), h = c[0];
    return c = mg.bind(null, c[1]), aa().memoizedState = c, [h, c];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(c, h, E) {
    var P = Ai, V = aa();
    if (ga) {
      if (E === void 0)
        throw Error(t(407));
      E = E();
    } else {
      if (E = h(), ea === null)
        throw Error(t(349));
      (Eo & 30) !== 0 || Ic(P, h, E);
    }
    V.memoizedState = E;
    var q = { value: E, getSnapshot: h };
    return V.queue = q, Mo(bi.bind(
      null,
      P,
      q,
      c
    ), [c]), P.flags |= 2048, mu(9, Ms.bind(null, P, q, E, h), void 0, null), E;
  }, useId: function() {
    var c = aa(), h = ea.identifierPrefix;
    if (ga) {
      var E = Bl, P = vn;
      E = (P & ~(1 << 32 - Ea(P) - 1)).toString(32) + E, h = ":" + h + "R" + E, E = Ha++, 0 < E && (h += "H" + E.toString(32)), h += ":";
    } else
      E = Yo++, h = ":" + h + "r" + E.toString(32) + ":";
    return c.memoizedState = h;
  }, unstable_isNewReconciler: !1 }, L = {
    readContext: Qi,
    useCallback: Ts,
    useContext: Qi,
    useEffect: Hc,
    useImperativeHandle: gu,
    useInsertionEffect: dd,
    useLayoutEffect: Xo,
    useMemo: Is,
    useReducer: Jd,
    useRef: Pf,
    useState: function() {
      return Jd(Lf);
    },
    useDebugValue: pd,
    useDeferredValue: function(c) {
      var h = ks();
      return yu(h, Ht.memoizedState, c);
    },
    useTransition: function() {
      var c = Jd(Lf)[0], h = ks().memoizedState;
      return [c, h];
    },
    useMutableSource: ql,
    useSyncExternalStore: ip,
    useId: ti,
    unstable_isNewReconciler: !1
  }, k = { readContext: Qi, useCallback: Ts, useContext: Qi, useEffect: Hc, useImperativeHandle: gu, useInsertionEffect: dd, useLayoutEffect: Xo, useMemo: Is, useReducer: to, useRef: Pf, useState: function() {
    return to(Lf);
  }, useDebugValue: pd, useDeferredValue: function(c) {
    var h = ks();
    return Ht === null ? h.memoizedState = c : yu(h, Ht.memoizedState, c);
  }, useTransition: function() {
    var c = to(Lf)[0], h = ks().memoizedState;
    return [c, h];
  }, useMutableSource: ql, useSyncExternalStore: ip, useId: ti, unstable_isNewReconciler: !1 };
  function X(c, h) {
    try {
      var E = "", P = h;
      do
        E += rt(P), P = P.return;
      while (P);
      var V = E;
    } catch (q) {
      V = `
Error generating stack: ` + q.message + `
` + q.stack;
    }
    return { value: c, source: h, stack: V, digest: null };
  }
  function $(c, h, E) {
    return { value: c, source: null, stack: E != null ? E : null, digest: h != null ? h : null };
  }
  function Ae(c, h) {
    try {
      console.error(h.value);
    } catch (E) {
      setTimeout(function() {
        throw E;
      });
    }
  }
  var $e = typeof WeakMap == "function" ? WeakMap : Map;
  function kt(c, h, E) {
    E = ns(-1, E), E.tag = 3, E.payload = { element: null };
    var P = h.value;
    return E.callback = function() {
      _g || (_g = !0, Jp = P), Ae(c, h);
    }, E;
  }
  function hn(c, h, E) {
    E = ns(-1, E), E.tag = 3;
    var P = c.type.getDerivedStateFromError;
    if (typeof P == "function") {
      var V = h.value;
      E.payload = function() {
        return P(V);
      }, E.callback = function() {
        Ae(c, h);
      };
    }
    var q = c.stateNode;
    return q !== null && typeof q.componentDidCatch == "function" && (E.callback = function() {
      Ae(c, h), typeof P != "function" && ($d === null ? $d = /* @__PURE__ */ new Set([this]) : $d.add(this));
      var le = h.stack;
      this.componentDidCatch(h.value, { componentStack: le !== null ? le : "" });
    }), E;
  }
  function wn(c, h, E) {
    var P = c.pingCache;
    if (P === null) {
      P = c.pingCache = new $e();
      var V = /* @__PURE__ */ new Set();
      P.set(h, V);
    } else
      V = P.get(h), V === void 0 && (V = /* @__PURE__ */ new Set(), P.set(h, V));
    V.has(E) || (V.add(E), c = Cy.bind(null, c, h, E), h.then(c, c));
  }
  function br(c) {
    do {
      var h;
      if ((h = c.tag === 13) && (h = c.memoizedState, h = h !== null ? h.dehydrated !== null : !0), h)
        return c;
      c = c.return;
    } while (c !== null);
    return null;
  }
  function ur(c, h, E, P, V) {
    return (c.mode & 1) === 0 ? (c === h ? c.flags |= 65536 : (c.flags |= 128, E.flags |= 131072, E.flags &= -52805, E.tag === 1 && (E.alternate === null ? E.tag = 17 : (h = ns(-1, 1), h.tag = 2, Mf(E, h, 1))), E.lanes |= 1), c) : (c.flags |= 65536, c.lanes = V, c);
  }
  var Sa = B.ReactCurrentOwner, Tn = !1;
  function Li(c, h, E, P) {
    h.child = c === null ? Zd(h, null, E, P) : Tf(h, c.child, E, P);
  }
  function vs(c, h, E, P, V) {
    E = E.render;
    var q = h.ref;
    return bn(h, V), P = Af(c, h, E, P, q, V), E = Df(), c !== null && !Tn ? (h.updateQueue = c.updateQueue, h.flags &= -2053, c.lanes &= ~V, Qo(c, h, V)) : (ga && E && Eh(h), h.flags |= 1, Li(c, h, P, V), h.child);
  }
  function pt(c, h, E, P, V) {
    if (c === null) {
      var q = E.type;
      return typeof q == "function" && !Pv(q) && q.defaultProps === void 0 && E.compare === null && E.defaultProps === void 0 ? (h.tag = 15, h.type = q, Ze(c, h, q, P, V)) : (c = Ph(E.type, null, P, h, h.mode, V), c.ref = h.ref, c.return = h, h.child = c);
    }
    if (q = c.child, (c.lanes & V) === 0) {
      var le = q.memoizedProps;
      if (E = E.compare, E = E !== null ? E : Mn, E(le, P) && c.ref === h.ref)
        return Qo(c, h, V);
    }
    return h.flags |= 1, c = Bu(q, P), c.ref = h.ref, c.return = h, h.child = c;
  }
  function Ze(c, h, E, P, V) {
    if (c !== null) {
      var q = c.memoizedProps;
      if (Mn(q, P) && c.ref === h.ref)
        if (Tn = !1, h.pendingProps = P = q, (c.lanes & V) !== 0)
          (c.flags & 131072) !== 0 && (Tn = !0);
        else
          return h.lanes = c.lanes, Qo(c, h, V);
    }
    return jn(c, h, E, P, V);
  }
  function Lt(c, h, E) {
    var P = h.pendingProps, V = P.children, q = c !== null ? c.memoizedState : null;
    if (P.mode === "hidden")
      if ((h.mode & 1) === 0)
        h.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, zi(Wm, Vc), Vc |= E;
      else {
        if ((E & 1073741824) === 0)
          return c = q !== null ? q.baseLanes | E : E, h.lanes = h.childLanes = 1073741824, h.memoizedState = { baseLanes: c, cachePool: null, transitions: null }, h.updateQueue = null, zi(Wm, Vc), Vc |= c, null;
        h.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, P = q !== null ? q.baseLanes : E, zi(Wm, Vc), Vc |= P;
      }
    else
      q !== null ? (P = q.baseLanes | E, h.memoizedState = null) : P = E, zi(Wm, Vc), Vc |= P;
    return Li(c, h, V, E), h.child;
  }
  function Qt(c, h) {
    var E = h.ref;
    (c === null && E !== null || c !== null && c.ref !== E) && (h.flags |= 512, h.flags |= 2097152);
  }
  function jn(c, h, E, P, V) {
    var q = Ia(E) ? es : Rr.current;
    return q = kl(h, q), bn(h, V), E = Af(c, h, E, P, q, V), P = Df(), c !== null && !Tn ? (h.updateQueue = c.updateQueue, h.flags &= -2053, c.lanes &= ~V, Qo(c, h, V)) : (ga && P && Eh(h), h.flags |= 1, Li(c, h, E, V), h.child);
  }
  function Wr(c, h, E, P, V) {
    if (Ia(E)) {
      var q = !0;
      Vo(h);
    } else
      q = !1;
    if (bn(h, V), h.stateNode === null)
      qo(c, h), qd(h, E, P), cc(h, E, P, V), P = !0;
    else if (c === null) {
      var le = h.stateNode, Oe = h.memoizedProps;
      le.props = Oe;
      var Ge = le.context, Dt = E.contextType;
      typeof Dt == "object" && Dt !== null ? Dt = Qi(Dt) : (Dt = Ia(E) ? es : Rr.current, Dt = kl(h, Dt));
      var fn = E.getDerivedStateFromProps, un = typeof fn == "function" || typeof le.getSnapshotBeforeUpdate == "function";
      un || typeof le.UNSAFE_componentWillReceiveProps != "function" && typeof le.componentWillReceiveProps != "function" || (Oe !== P || Ge !== Dt) && Nc(h, le, P, Dt), ts = !1;
      var rn = h.memoizedState;
      le.state = rn, Ra(h, P, le, V), Ge = h.memoizedState, Oe !== P || rn !== Ge || ps.current || ts ? (typeof fn == "function" && (Gl(h, E, fn, P), Ge = h.memoizedState), (Oe = ts || Es(h, E, Oe, P, rn, Ge, Dt)) ? (un || typeof le.UNSAFE_componentWillMount != "function" && typeof le.componentWillMount != "function" || (typeof le.componentWillMount == "function" && le.componentWillMount(), typeof le.UNSAFE_componentWillMount == "function" && le.UNSAFE_componentWillMount()), typeof le.componentDidMount == "function" && (h.flags |= 4194308)) : (typeof le.componentDidMount == "function" && (h.flags |= 4194308), h.memoizedProps = P, h.memoizedState = Ge), le.props = P, le.state = Ge, le.context = Dt, P = Oe) : (typeof le.componentDidMount == "function" && (h.flags |= 4194308), P = !1);
    } else {
      le = h.stateNode, xa(c, h), Oe = h.memoizedProps, Dt = h.type === h.elementType ? Oe : pu(h.type, Oe), le.props = Dt, un = h.pendingProps, rn = le.context, Ge = E.contextType, typeof Ge == "object" && Ge !== null ? Ge = Qi(Ge) : (Ge = Ia(E) ? es : Rr.current, Ge = kl(h, Ge));
      var Hn = E.getDerivedStateFromProps;
      (fn = typeof Hn == "function" || typeof le.getSnapshotBeforeUpdate == "function") || typeof le.UNSAFE_componentWillReceiveProps != "function" && typeof le.componentWillReceiveProps != "function" || (Oe !== un || rn !== Ge) && Nc(h, le, P, Ge), ts = !1, rn = h.memoizedState, le.state = rn, Ra(h, P, le, V);
      var Qn = h.memoizedState;
      Oe !== un || rn !== Qn || ps.current || ts ? (typeof Hn == "function" && (Gl(h, E, Hn, P), Qn = h.memoizedState), (Dt = ts || Es(h, E, Dt, P, rn, Qn, Ge) || !1) ? (fn || typeof le.UNSAFE_componentWillUpdate != "function" && typeof le.componentWillUpdate != "function" || (typeof le.componentWillUpdate == "function" && le.componentWillUpdate(P, Qn, Ge), typeof le.UNSAFE_componentWillUpdate == "function" && le.UNSAFE_componentWillUpdate(P, Qn, Ge)), typeof le.componentDidUpdate == "function" && (h.flags |= 4), typeof le.getSnapshotBeforeUpdate == "function" && (h.flags |= 1024)) : (typeof le.componentDidUpdate != "function" || Oe === c.memoizedProps && rn === c.memoizedState || (h.flags |= 4), typeof le.getSnapshotBeforeUpdate != "function" || Oe === c.memoizedProps && rn === c.memoizedState || (h.flags |= 1024), h.memoizedProps = P, h.memoizedState = Qn), le.props = P, le.state = Qn, le.context = Ge, P = Dt) : (typeof le.componentDidUpdate != "function" || Oe === c.memoizedProps && rn === c.memoizedState || (h.flags |= 4), typeof le.getSnapshotBeforeUpdate != "function" || Oe === c.memoizedProps && rn === c.memoizedState || (h.flags |= 1024), P = !1);
    }
    return Er(c, h, E, P, q, V);
  }
  function Er(c, h, E, P, V, q) {
    Qt(c, h);
    var le = (h.flags & 128) !== 0;
    if (!P && !le)
      return V && bv(h, E, !1), Qo(c, h, q);
    P = h.stateNode, Sa.current = h;
    var Oe = le && typeof E.getDerivedStateFromError != "function" ? null : P.render();
    return h.flags |= 1, c !== null && le ? (h.child = Tf(h, c.child, null, q), h.child = Tf(h, null, Oe, q)) : Li(c, h, Oe, q), h.memoizedState = P.state, V && bv(h, E, !0), h.child;
  }
  function Ar(c) {
    var h = c.stateNode;
    h.pendingContext ? bf(c, h.pendingContext, h.pendingContext !== h.context) : h.context && bf(c, h.context, !1), Mh(c, h.containerInfo);
  }
  function Va(c, h, E, P, V) {
    return fa(), Nu(V), h.flags |= 256, Li(c, h, E, P), h.child;
  }
  var Zr = { dehydrated: null, treeContext: null, retryLane: 0 };
  function hc(c) {
    return { baseLanes: c, cachePool: null, transitions: null };
  }
  function md(c, h, E) {
    var P = h.pendingProps, V = fr.current, q = !1, le = (h.flags & 128) !== 0, Oe;
    if ((Oe = le) || (Oe = c !== null && c.memoizedState === null ? !1 : (V & 2) !== 0), Oe ? (q = !0, h.flags &= -129) : (c === null || c.memoizedState !== null) && (V |= 1), zi(fr, V & 1), c === null)
      return Go(h), c = h.memoizedState, c !== null && (c = c.dehydrated, c !== null) ? ((h.mode & 1) === 0 ? h.lanes = 1 : c.data === "$!" ? h.lanes = 8 : h.lanes = 1073741824, null) : (le = P.children, c = P.fallback, q ? (P = h.mode, q = h.child, le = { mode: "hidden", children: le }, (P & 1) === 0 && q !== null ? (q.childLanes = 0, q.pendingProps = le) : q = yp(le, P, 0, null), c = em(c, P, E, null), q.return = h, c.return = h, q.sibling = c, h.child = q, h.child.memoizedState = hc(E), h.memoizedState = Zr, c) : ap(h, le));
    if (V = c.memoizedState, V !== null && (Oe = V.dehydrated, Oe !== null))
      return Yp(c, h, le, P, Oe, V, E);
    if (q) {
      q = P.fallback, le = h.mode, V = c.child, Oe = V.sibling;
      var Ge = { mode: "hidden", children: P.children };
      return (le & 1) === 0 && h.child !== V ? (P = h.child, P.childLanes = 0, P.pendingProps = Ge, h.deletions = null) : (P = Bu(V, Ge), P.subtreeFlags = V.subtreeFlags & 14680064), Oe !== null ? q = Bu(Oe, q) : (q = em(q, le, E, null), q.flags |= 2), q.return = h, P.return = h, P.sibling = q, h.child = P, P = q, q = h.child, le = c.child.memoizedState, le = le === null ? hc(E) : { baseLanes: le.baseLanes | E, cachePool: null, transitions: le.transitions }, q.memoizedState = le, q.childLanes = c.childLanes & ~E, h.memoizedState = Zr, P;
    }
    return q = c.child, c = q.sibling, P = Bu(q, { mode: "visible", children: P.children }), (h.mode & 1) === 0 && (P.lanes = E), P.return = h, P.sibling = null, c !== null && (E = h.deletions, E === null ? (h.deletions = [c], h.flags |= 16) : E.push(c)), h.child = P, h.memoizedState = null, P;
  }
  function ap(c, h) {
    return h = yp({ mode: "visible", children: h }, c.mode, 0, null), h.return = c, c.child = h;
  }
  function gr(c, h, E, P) {
    return P !== null && Nu(P), Tf(h, c.child, null, E), c = ap(h, h.pendingProps.children), c.flags |= 2, h.memoizedState = null, c;
  }
  function Yp(c, h, E, P, V, q, le) {
    if (E)
      return h.flags & 256 ? (h.flags &= -257, P = $(Error(t(422))), gr(c, h, le, P)) : h.memoizedState !== null ? (h.child = c.child, h.flags |= 128, null) : (q = P.fallback, V = h.mode, P = yp({ mode: "visible", children: P.children }, V, 0, null), q = em(q, V, le, null), q.flags |= 2, P.return = h, q.return = h, P.sibling = q, h.child = P, (h.mode & 1) !== 0 && Tf(h, c.child, null, le), h.child.memoizedState = hc(le), h.memoizedState = Zr, q);
    if ((h.mode & 1) === 0)
      return gr(c, h, le, null);
    if (V.data === "$!") {
      if (P = V.nextSibling && V.nextSibling.dataset, P)
        var Oe = P.dgst;
      return P = Oe, q = Error(t(419)), P = $(q, P, void 0), gr(c, h, le, P);
    }
    if (Oe = (le & c.childLanes) !== 0, Tn || Oe) {
      if (P = ea, P !== null) {
        switch (le & -le) {
          case 4:
            V = 2;
            break;
          case 16:
            V = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            V = 32;
            break;
          case 536870912:
            V = 268435456;
            break;
          default:
            V = 0;
        }
        V = (V & (P.suspendedLanes | le)) !== 0 ? 0 : V, V !== 0 && V !== q.retryLane && (q.retryLane = V, jo(c, V), Sl(P, c, V, -1));
      }
      return My(), P = $(Error(t(421))), gr(c, h, le, P);
    }
    return V.data === "$?" ? (h.flags |= 128, h.child = c.child, h = N0.bind(null, c), V._reactRetry = h, null) : (c = q.treeContext, yl = Fl(V.nextSibling), bs = h, ga = !0, hu = null, c !== null && ($s[ms++] = vn, $s[ms++] = Bl, $s[ms++] = zc, vn = c.id, Bl = c.overflow, zc = h), h = ap(h, P.children), h.flags |= 4096, h);
  }
  function Hm(c, h, E) {
    c.lanes |= h;
    var P = c.alternate;
    P !== null && (P.lanes |= h), Gi(c.return, h, E);
  }
  function zf(c, h, E, P, V) {
    var q = c.memoizedState;
    q === null ? c.memoizedState = { isBackwards: h, rendering: null, renderingStartTime: 0, last: P, tail: E, tailMode: V } : (q.isBackwards = h, q.rendering = null, q.renderingStartTime = 0, q.last = P, q.tail = E, q.tailMode = V);
  }
  function vg(c, h, E) {
    var P = h.pendingProps, V = P.revealOrder, q = P.tail;
    if (Li(c, h, P.children, E), P = fr.current, (P & 2) !== 0)
      P = P & 1 | 2, h.flags |= 128;
    else {
      if (c !== null && (c.flags & 128) !== 0)
        e:
          for (c = h.child; c !== null; ) {
            if (c.tag === 13)
              c.memoizedState !== null && Hm(c, E, h);
            else if (c.tag === 19)
              Hm(c, E, h);
            else if (c.child !== null) {
              c.child.return = c, c = c.child;
              continue;
            }
            if (c === h)
              break e;
            for (; c.sibling === null; ) {
              if (c.return === null || c.return === h)
                break e;
              c = c.return;
            }
            c.sibling.return = c.return, c = c.sibling;
          }
      P &= 1;
    }
    if (zi(fr, P), (h.mode & 1) === 0)
      h.memoizedState = null;
    else
      switch (V) {
        case "forwards":
          for (E = h.child, V = null; E !== null; )
            c = E.alternate, c !== null && ui(c) === null && (V = E), E = E.sibling;
          E = V, E === null ? (V = h.child, h.child = null) : (V = E.sibling, E.sibling = null), zf(h, !1, V, E, q);
          break;
        case "backwards":
          for (E = null, V = h.child, h.child = null; V !== null; ) {
            if (c = V.alternate, c !== null && ui(c) === null) {
              h.child = V;
              break;
            }
            c = V.sibling, V.sibling = E, E = V, V = c;
          }
          zf(h, !0, E, null, q);
          break;
        case "together":
          zf(h, !1, null, null, void 0);
          break;
        default:
          h.memoizedState = null;
      }
    return h.child;
  }
  function qo(c, h) {
    (h.mode & 1) === 0 && c !== null && (c.alternate = null, h.alternate = null, h.flags |= 2);
  }
  function Qo(c, h, E) {
    if (c !== null && (h.dependencies = c.dependencies), yd |= h.lanes, (E & h.childLanes) === 0)
      return null;
    if (c !== null && h.child !== c.child)
      throw Error(t(153));
    if (h.child !== null) {
      for (c = h.child, E = Bu(c, c.pendingProps), h.child = E, E.return = h; c.sibling !== null; )
        c = c.sibling, E = E.sibling = Bu(c, c.pendingProps), E.return = h;
      E.sibling = null;
    }
    return h.child;
  }
  function rs(c, h, E) {
    switch (h.tag) {
      case 3:
        Ar(h), fa();
        break;
      case 5:
        hr(h);
        break;
      case 1:
        Ia(h.type) && Vo(h);
        break;
      case 4:
        Mh(h, h.stateNode.containerInfo);
        break;
      case 10:
        var P = h.type._context, V = h.memoizedProps.value;
        zi(Vl, P._currentValue), P._currentValue = V;
        break;
      case 13:
        if (P = h.memoizedState, P !== null)
          return P.dehydrated !== null ? (zi(fr, fr.current & 1), h.flags |= 128, null) : (E & h.child.childLanes) !== 0 ? md(c, h, E) : (zi(fr, fr.current & 1), c = Qo(c, h, E), c !== null ? c.sibling : null);
        zi(fr, fr.current & 1);
        break;
      case 19:
        if (P = (E & h.childLanes) !== 0, (c.flags & 128) !== 0) {
          if (P)
            return vg(c, h, E);
          h.flags |= 128;
        }
        if (V = h.memoizedState, V !== null && (V.rendering = null, V.tail = null, V.lastEffect = null), zi(fr, fr.current), P)
          break;
        return null;
      case 22:
      case 23:
        return h.lanes = 0, Lt(c, h, E);
    }
    return Qo(c, h, E);
  }
  var Xp, Th, pc, ro;
  Xp = function(c, h) {
    for (var E = h.child; E !== null; ) {
      if (E.tag === 5 || E.tag === 6)
        c.appendChild(E.stateNode);
      else if (E.tag !== 4 && E.child !== null) {
        E.child.return = E, E = E.child;
        continue;
      }
      if (E === h)
        break;
      for (; E.sibling === null; ) {
        if (E.return === null || E.return === h)
          return;
        E = E.return;
      }
      E.sibling.return = E.return, E = E.sibling;
    }
  }, Th = function() {
  }, pc = function(c, h, E, P) {
    var V = c.memoizedProps;
    if (V !== P) {
      c = h.stateNode, Yl(Wl.current);
      var q = null;
      switch (E) {
        case "input":
          V = dt(c, V), P = dt(c, P), q = [];
          break;
        case "select":
          V = he({}, V, { value: void 0 }), P = he({}, P, { value: void 0 }), q = [];
          break;
        case "textarea":
          V = we(c, V), P = we(c, P), q = [];
          break;
        default:
          typeof V.onClick != "function" && typeof P.onClick == "function" && (c.onclick = bh);
      }
      dn(E, P);
      var le;
      E = null;
      for (Dt in V)
        if (!P.hasOwnProperty(Dt) && V.hasOwnProperty(Dt) && V[Dt] != null)
          if (Dt === "style") {
            var Oe = V[Dt];
            for (le in Oe)
              Oe.hasOwnProperty(le) && (E || (E = {}), E[le] = "");
          } else
            Dt !== "dangerouslySetInnerHTML" && Dt !== "children" && Dt !== "suppressContentEditableWarning" && Dt !== "suppressHydrationWarning" && Dt !== "autoFocus" && (i.hasOwnProperty(Dt) ? q || (q = []) : (q = q || []).push(Dt, null));
      for (Dt in P) {
        var Ge = P[Dt];
        if (Oe = V != null ? V[Dt] : void 0, P.hasOwnProperty(Dt) && Ge !== Oe && (Ge != null || Oe != null))
          if (Dt === "style")
            if (Oe) {
              for (le in Oe)
                !Oe.hasOwnProperty(le) || Ge && Ge.hasOwnProperty(le) || (E || (E = {}), E[le] = "");
              for (le in Ge)
                Ge.hasOwnProperty(le) && Oe[le] !== Ge[le] && (E || (E = {}), E[le] = Ge[le]);
            } else
              E || (q || (q = []), q.push(
                Dt,
                E
              )), E = Ge;
          else
            Dt === "dangerouslySetInnerHTML" ? (Ge = Ge ? Ge.__html : void 0, Oe = Oe ? Oe.__html : void 0, Ge != null && Oe !== Ge && (q = q || []).push(Dt, Ge)) : Dt === "children" ? typeof Ge != "string" && typeof Ge != "number" || (q = q || []).push(Dt, "" + Ge) : Dt !== "suppressContentEditableWarning" && Dt !== "suppressHydrationWarning" && (i.hasOwnProperty(Dt) ? (Ge != null && Dt === "onScroll" && kr("scroll", c), q || Oe === Ge || (q = [])) : (q = q || []).push(Dt, Ge));
      }
      E && (q = q || []).push("style", E);
      var Dt = q;
      (h.updateQueue = Dt) && (h.flags |= 4);
    }
  }, ro = function(c, h, E, P) {
    E !== P && (h.flags |= 4);
  };
  function sp(c, h) {
    if (!ga)
      switch (c.tailMode) {
        case "hidden":
          h = c.tail;
          for (var E = null; h !== null; )
            h.alternate !== null && (E = h), h = h.sibling;
          E === null ? c.tail = null : E.sibling = null;
          break;
        case "collapsed":
          E = c.tail;
          for (var P = null; E !== null; )
            E.alternate !== null && (P = E), E = E.sibling;
          P === null ? h || c.tail === null ? c.tail = null : c.tail.sibling = null : P.sibling = null;
      }
  }
  function xl(c) {
    var h = c.alternate !== null && c.alternate.child === c.child, E = 0, P = 0;
    if (h)
      for (var V = c.child; V !== null; )
        E |= V.lanes | V.childLanes, P |= V.subtreeFlags & 14680064, P |= V.flags & 14680064, V.return = c, V = V.sibling;
    else
      for (V = c.child; V !== null; )
        E |= V.lanes | V.childLanes, P |= V.subtreeFlags, P |= V.flags, V.return = c, V = V.sibling;
    return c.subtreeFlags |= P, c.childLanes = E, h;
  }
  function _y(c, h, E) {
    var P = h.pendingProps;
    switch (zu(h), h.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return xl(h), null;
      case 1:
        return Ia(h.type) && Il(), xl(h), null;
      case 3:
        return P = h.stateNode, fc(), wi(ps), wi(Rr), Xl(), P.pendingContext && (P.context = P.pendingContext, P.pendingContext = null), (c === null || c.child === null) && (il(h) ? h.flags |= 4 : c === null || c.memoizedState.isDehydrated && (h.flags & 256) === 0 || (h.flags |= 1024, hu !== null && (Kp(hu), hu = null))), Th(c, h), xl(h), null;
      case 5:
        Gr(h);
        var V = Yl(fd.current);
        if (E = h.type, c !== null && h.stateNode != null)
          pc(c, h, E, P, V), c.ref !== h.ref && (h.flags |= 512, h.flags |= 2097152);
        else {
          if (!P) {
            if (h.stateNode === null)
              throw Error(t(166));
            return xl(h), null;
          }
          if (c = Yl(Wl.current), il(h)) {
            P = h.stateNode, E = h.type;
            var q = h.memoizedProps;
            switch (P[Us] = h, P[Uu] = q, c = (h.mode & 1) !== 0, E) {
              case "dialog":
                kr("cancel", P), kr("close", P);
                break;
              case "iframe":
              case "object":
              case "embed":
                kr("load", P);
                break;
              case "video":
              case "audio":
                for (V = 0; V < ic.length; V++)
                  kr(ic[V], P);
                break;
              case "source":
                kr("error", P);
                break;
              case "img":
              case "image":
              case "link":
                kr(
                  "error",
                  P
                ), kr("load", P);
                break;
              case "details":
                kr("toggle", P);
                break;
              case "input":
                ht(P, q), kr("invalid", P);
                break;
              case "select":
                P._wrapperState = { wasMultiple: !!q.multiple }, kr("invalid", P);
                break;
              case "textarea":
                oe(P, q), kr("invalid", P);
            }
            dn(E, q), V = null;
            for (var le in q)
              if (q.hasOwnProperty(le)) {
                var Oe = q[le];
                le === "children" ? typeof Oe == "string" ? P.textContent !== Oe && (q.suppressHydrationWarning !== !0 && Gd(P.textContent, Oe, c), V = ["children", Oe]) : typeof Oe == "number" && P.textContent !== "" + Oe && (q.suppressHydrationWarning !== !0 && Gd(
                  P.textContent,
                  Oe,
                  c
                ), V = ["children", "" + Oe]) : i.hasOwnProperty(le) && Oe != null && le === "onScroll" && kr("scroll", P);
              }
            switch (E) {
              case "input":
                ft(P), yt(P, q, !0);
                break;
              case "textarea":
                ft(P), ut(P);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof q.onClick == "function" && (P.onclick = bh);
            }
            P = V, h.updateQueue = P, P !== null && (h.flags |= 4);
          } else {
            le = V.nodeType === 9 ? V : V.ownerDocument, c === "http://www.w3.org/1999/xhtml" && (c = Ft(E)), c === "http://www.w3.org/1999/xhtml" ? E === "script" ? (c = le.createElement("div"), c.innerHTML = "<script><\/script>", c = c.removeChild(c.firstChild)) : typeof P.is == "string" ? c = le.createElement(E, { is: P.is }) : (c = le.createElement(E), E === "select" && (le = c, P.multiple ? le.multiple = !0 : P.size && (le.size = P.size))) : c = le.createElementNS(c, E), c[Us] = h, c[Uu] = P, Xp(c, h, !1, !1), h.stateNode = c;
            e: {
              switch (le = ze(E, P), E) {
                case "dialog":
                  kr("cancel", c), kr("close", c), V = P;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  kr("load", c), V = P;
                  break;
                case "video":
                case "audio":
                  for (V = 0; V < ic.length; V++)
                    kr(ic[V], c);
                  V = P;
                  break;
                case "source":
                  kr("error", c), V = P;
                  break;
                case "img":
                case "image":
                case "link":
                  kr(
                    "error",
                    c
                  ), kr("load", c), V = P;
                  break;
                case "details":
                  kr("toggle", c), V = P;
                  break;
                case "input":
                  ht(c, P), V = dt(c, P), kr("invalid", c);
                  break;
                case "option":
                  V = P;
                  break;
                case "select":
                  c._wrapperState = { wasMultiple: !!P.multiple }, V = he({}, P, { value: void 0 }), kr("invalid", c);
                  break;
                case "textarea":
                  oe(c, P), V = we(c, P), kr("invalid", c);
                  break;
                default:
                  V = P;
              }
              dn(E, V), Oe = V;
              for (q in Oe)
                if (Oe.hasOwnProperty(q)) {
                  var Ge = Oe[q];
                  q === "style" ? at(c, Ge) : q === "dangerouslySetInnerHTML" ? (Ge = Ge ? Ge.__html : void 0, Ge != null && it(c, Ge)) : q === "children" ? typeof Ge == "string" ? (E !== "textarea" || Ge !== "") && an(c, Ge) : typeof Ge == "number" && an(c, "" + Ge) : q !== "suppressContentEditableWarning" && q !== "suppressHydrationWarning" && q !== "autoFocus" && (i.hasOwnProperty(q) ? Ge != null && q === "onScroll" && kr("scroll", c) : Ge != null && G(c, q, Ge, le));
                }
              switch (E) {
                case "input":
                  ft(c), yt(c, P, !1);
                  break;
                case "textarea":
                  ft(c), ut(c);
                  break;
                case "option":
                  P.value != null && c.setAttribute("value", "" + tt(P.value));
                  break;
                case "select":
                  c.multiple = !!P.multiple, q = P.value, q != null ? Rt(c, !!P.multiple, q, !1) : P.defaultValue != null && Rt(
                    c,
                    !!P.multiple,
                    P.defaultValue,
                    !0
                  );
                  break;
                default:
                  typeof V.onClick == "function" && (c.onclick = bh);
              }
              switch (E) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  P = !!P.autoFocus;
                  break e;
                case "img":
                  P = !0;
                  break e;
                default:
                  P = !1;
              }
            }
            P && (h.flags |= 4);
          }
          h.ref !== null && (h.flags |= 512, h.flags |= 2097152);
        }
        return xl(h), null;
      case 6:
        if (c && h.stateNode != null)
          ro(c, h, c.memoizedProps, P);
        else {
          if (typeof P != "string" && h.stateNode === null)
            throw Error(t(166));
          if (E = Yl(fd.current), Yl(Wl.current), il(h)) {
            if (P = h.stateNode, E = h.memoizedProps, P[Us] = h, (q = P.nodeValue !== E) && (c = bs, c !== null))
              switch (c.tag) {
                case 3:
                  Gd(P.nodeValue, E, (c.mode & 1) !== 0);
                  break;
                case 5:
                  c.memoizedProps.suppressHydrationWarning !== !0 && Gd(P.nodeValue, E, (c.mode & 1) !== 0);
              }
            q && (h.flags |= 4);
          } else
            P = (E.nodeType === 9 ? E : E.ownerDocument).createTextNode(P), P[Us] = h, h.stateNode = P;
        }
        return xl(h), null;
      case 13:
        if (wi(fr), P = h.memoizedState, c === null || c.memoizedState !== null && c.memoizedState.dehydrated !== null) {
          if (ga && yl !== null && (h.mode & 1) !== 0 && (h.flags & 128) === 0)
            Ns(), fa(), h.flags |= 98560, q = !1;
          else if (q = il(h), P !== null && P.dehydrated !== null) {
            if (c === null) {
              if (!q)
                throw Error(t(318));
              if (q = h.memoizedState, q = q !== null ? q.dehydrated : null, !q)
                throw Error(t(317));
              q[Us] = h;
            } else
              fa(), (h.flags & 128) === 0 && (h.memoizedState = null), h.flags |= 4;
            xl(h), q = !1;
          } else
            hu !== null && (Kp(hu), hu = null), q = !0;
          if (!q)
            return h.flags & 65536 ? h : null;
        }
        return (h.flags & 128) !== 0 ? (h.lanes = E, h) : (P = P !== null, P !== (c !== null && c.memoizedState !== null) && P && (h.child.flags |= 8192, (h.mode & 1) !== 0 && (c === null || (fr.current & 1) !== 0 ? ol === 0 && (ol = 3) : My())), h.updateQueue !== null && (h.flags |= 4), xl(h), null);
      case 4:
        return fc(), Th(c, h), c === null && rl(h.stateNode.containerInfo), xl(h), null;
      case 10:
        return da(h.type._context), xl(h), null;
      case 17:
        return Ia(h.type) && Il(), xl(h), null;
      case 19:
        if (wi(fr), q = h.memoizedState, q === null)
          return xl(h), null;
        if (P = (h.flags & 128) !== 0, le = q.rendering, le === null)
          if (P)
            sp(q, !1);
          else {
            if (ol !== 0 || c !== null && (c.flags & 128) !== 0)
              for (c = h.child; c !== null; ) {
                if (le = ui(c), le !== null) {
                  for (h.flags |= 128, sp(q, !1), P = le.updateQueue, P !== null && (h.updateQueue = P, h.flags |= 4), h.subtreeFlags = 0, P = E, E = h.child; E !== null; )
                    q = E, c = P, q.flags &= 14680066, le = q.alternate, le === null ? (q.childLanes = 0, q.lanes = c, q.child = null, q.subtreeFlags = 0, q.memoizedProps = null, q.memoizedState = null, q.updateQueue = null, q.dependencies = null, q.stateNode = null) : (q.childLanes = le.childLanes, q.lanes = le.lanes, q.child = le.child, q.subtreeFlags = 0, q.deletions = null, q.memoizedProps = le.memoizedProps, q.memoizedState = le.memoizedState, q.updateQueue = le.updateQueue, q.type = le.type, c = le.dependencies, q.dependencies = c === null ? null : { lanes: c.lanes, firstContext: c.firstContext }), E = E.sibling;
                  return zi(fr, fr.current & 1 | 2), h.child;
                }
                c = c.sibling;
              }
            q.tail !== null && en() > fp && (h.flags |= 128, P = !0, sp(q, !1), h.lanes = 4194304);
          }
        else {
          if (!P)
            if (c = ui(le), c !== null) {
              if (h.flags |= 128, P = !0, E = c.updateQueue, E !== null && (h.updateQueue = E, h.flags |= 4), sp(q, !0), q.tail === null && q.tailMode === "hidden" && !le.alternate && !ga)
                return xl(h), null;
            } else
              2 * en() - q.renderingStartTime > fp && E !== 1073741824 && (h.flags |= 128, P = !0, sp(q, !1), h.lanes = 4194304);
          q.isBackwards ? (le.sibling = h.child, h.child = le) : (E = q.last, E !== null ? E.sibling = le : h.child = le, q.last = le);
        }
        return q.tail !== null ? (h = q.tail, q.rendering = h, q.tail = h.sibling, q.renderingStartTime = en(), h.sibling = null, E = fr.current, zi(fr, P ? E & 1 | 2 : E & 1), h) : (xl(h), null);
      case 22:
      case 23:
        return wg(), P = h.memoizedState !== null, c !== null && c.memoizedState !== null !== P && (h.flags |= 8192), P && (h.mode & 1) !== 0 ? (Vc & 1073741824) !== 0 && (xl(h), h.subtreeFlags & 6 && (h.flags |= 8192)) : xl(h), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(t(156, h.tag));
  }
  function gg(c, h) {
    switch (zu(h), h.tag) {
      case 1:
        return Ia(h.type) && Il(), c = h.flags, c & 65536 ? (h.flags = c & -65537 | 128, h) : null;
      case 3:
        return fc(), wi(ps), wi(Rr), Xl(), c = h.flags, (c & 65536) !== 0 && (c & 128) === 0 ? (h.flags = c & -65537 | 128, h) : null;
      case 5:
        return Gr(h), null;
      case 13:
        if (wi(fr), c = h.memoizedState, c !== null && c.dehydrated !== null) {
          if (h.alternate === null)
            throw Error(t(340));
          fa();
        }
        return c = h.flags, c & 65536 ? (h.flags = c & -65537 | 128, h) : null;
      case 19:
        return wi(fr), null;
      case 4:
        return fc(), null;
      case 10:
        return da(h.type._context), null;
      case 22:
      case 23:
        return wg(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Iu = !1, Wi = !1, Ev = typeof WeakSet == "function" ? WeakSet : Set, Kn = null;
  function Ch(c, h) {
    var E = c.ref;
    if (E !== null)
      if (typeof E == "function")
        try {
          E(null);
        } catch (P) {
          Bs(c, h, P);
        }
      else
        E.current = null;
  }
  function Vm(c, h, E) {
    try {
      E();
    } catch (P) {
      Bs(c, h, P);
    }
  }
  var z0 = !1;
  function qp(c, h) {
    if (Sf = Os, c = er(), Ui(c)) {
      if ("selectionStart" in c)
        var E = { start: c.selectionStart, end: c.selectionEnd };
      else
        e: {
          E = (E = c.ownerDocument) && E.defaultView || window;
          var P = E.getSelection && E.getSelection();
          if (P && P.rangeCount !== 0) {
            E = P.anchorNode;
            var V = P.anchorOffset, q = P.focusNode;
            P = P.focusOffset;
            try {
              E.nodeType, q.nodeType;
            } catch {
              E = null;
              break e;
            }
            var le = 0, Oe = -1, Ge = -1, Dt = 0, fn = 0, un = c, rn = null;
            t:
              for (; ; ) {
                for (var Hn; un !== E || V !== 0 && un.nodeType !== 3 || (Oe = le + V), un !== q || P !== 0 && un.nodeType !== 3 || (Ge = le + P), un.nodeType === 3 && (le += un.nodeValue.length), (Hn = un.firstChild) !== null; )
                  rn = un, un = Hn;
                for (; ; ) {
                  if (un === c)
                    break t;
                  if (rn === E && ++Dt === V && (Oe = le), rn === q && ++fn === P && (Ge = le), (Hn = un.nextSibling) !== null)
                    break;
                  un = rn, rn = un.parentNode;
                }
                un = Hn;
              }
            E = Oe === -1 || Ge === -1 ? null : { start: Oe, end: Ge };
          } else
            E = null;
        }
      E = E || { start: 0, end: 0 };
    } else
      E = null;
    for (Ou = { focusedElem: c, selectionRange: E }, Os = !1, Kn = h; Kn !== null; )
      if (h = Kn, c = h.child, (h.subtreeFlags & 1028) !== 0 && c !== null)
        c.return = h, Kn = c;
      else
        for (; Kn !== null; ) {
          h = Kn;
          try {
            var Qn = h.alternate;
            if ((h.flags & 1024) !== 0)
              switch (h.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (Qn !== null) {
                    var ir = Qn.memoizedProps, Hs = Qn.memoizedState, mt = h.stateNode, Ke = mt.getSnapshotBeforeUpdate(h.elementType === h.type ? ir : pu(h.type, ir), Hs);
                    mt.__reactInternalSnapshotBeforeUpdate = Ke;
                  }
                  break;
                case 3:
                  var _t = h.stateNode.containerInfo;
                  _t.nodeType === 1 ? _t.textContent = "" : _t.nodeType === 9 && _t.documentElement && _t.removeChild(_t.documentElement);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(t(163));
              }
          } catch (_n) {
            Bs(h, h.return, _n);
          }
          if (c = h.sibling, c !== null) {
            c.return = h.return, Kn = c;
            break;
          }
          Kn = h.return;
        }
    return Qn = z0, z0 = !1, Qn;
  }
  function op(c, h, E) {
    var P = h.updateQueue;
    if (P = P !== null ? P.lastEffect : null, P !== null) {
      var V = P = P.next;
      do {
        if ((V.tag & c) === c) {
          var q = V.destroy;
          V.destroy = void 0, q !== void 0 && Vm(h, E, q);
        }
        V = V.next;
      } while (V !== P);
    }
  }
  function Gm(c, h) {
    if (h = h.updateQueue, h = h !== null ? h.lastEffect : null, h !== null) {
      var E = h = h.next;
      do {
        if ((E.tag & c) === c) {
          var P = E.create;
          E.destroy = P();
        }
        E = E.next;
      } while (E !== h);
    }
  }
  function Sy(c) {
    var h = c.ref;
    if (h !== null) {
      var E = c.stateNode;
      switch (c.tag) {
        case 5:
          c = E;
          break;
        default:
          c = E;
      }
      typeof h == "function" ? h(c) : h.current = c;
    }
  }
  function lp(c) {
    var h = c.alternate;
    h !== null && (c.alternate = null, lp(h)), c.child = null, c.deletions = null, c.sibling = null, c.tag === 5 && (h = c.stateNode, h !== null && (delete h[Us], delete h[Uu], delete h[od], delete h[xe], delete h[oc])), c.stateNode = null, c.return = null, c.dependencies = null, c.memoizedProps = null, c.memoizedState = null, c.pendingProps = null, c.stateNode = null, c.updateQueue = null;
  }
  function Qp(c) {
    return c.tag === 5 || c.tag === 3 || c.tag === 4;
  }
  function Zp(c) {
    e:
      for (; ; ) {
        for (; c.sibling === null; ) {
          if (c.return === null || Qp(c.return))
            return null;
          c = c.return;
        }
        for (c.sibling.return = c.return, c = c.sibling; c.tag !== 5 && c.tag !== 6 && c.tag !== 18; ) {
          if (c.flags & 2 || c.child === null || c.tag === 4)
            continue e;
          c.child.return = c, c = c.child;
        }
        if (!(c.flags & 2))
          return c.stateNode;
      }
  }
  function Kd(c, h, E) {
    var P = c.tag;
    if (P === 5 || P === 6)
      c = c.stateNode, h ? E.nodeType === 8 ? E.parentNode.insertBefore(c, h) : E.insertBefore(c, h) : (E.nodeType === 8 ? (h = E.parentNode, h.insertBefore(c, E)) : (h = E, h.appendChild(c)), E = E._reactRootContainer, E != null || h.onclick !== null || (h.onclick = bh));
    else if (P !== 4 && (c = c.child, c !== null))
      for (Kd(c, h, E), c = c.sibling; c !== null; )
        Kd(c, h, E), c = c.sibling;
  }
  function io(c, h, E) {
    var P = c.tag;
    if (P === 5 || P === 6)
      c = c.stateNode, h ? E.insertBefore(c, h) : E.appendChild(c);
    else if (P !== 4 && (c = c.child, c !== null))
      for (io(c, h, E), c = c.sibling; c !== null; )
        io(c, h, E), c = c.sibling;
  }
  var ji = null, is = !1;
  function To(c, h, E) {
    for (E = E.child; E !== null; )
      _l(c, h, E), E = E.sibling;
  }
  function _l(c, h, E) {
    if (mr && typeof mr.onCommitFiberUnmount == "function")
      try {
        mr.onCommitFiberUnmount(cs, E);
      } catch {
      }
    switch (E.tag) {
      case 5:
        Wi || Ch(E, h);
      case 6:
        var P = ji, V = is;
        ji = null, To(c, h, E), ji = P, is = V, ji !== null && (is ? (c = ji, E = E.stateNode, c.nodeType === 8 ? c.parentNode.removeChild(E) : c.removeChild(E)) : ji.removeChild(E.stateNode));
        break;
      case 18:
        ji !== null && (is ? (c = ji, E = E.stateNode, c.nodeType === 8 ? Dc(c.parentNode, E) : c.nodeType === 1 && Dc(c, E), Ri(c)) : Dc(ji, E.stateNode));
        break;
      case 4:
        P = ji, V = is, ji = E.stateNode.containerInfo, is = !0, To(c, h, E), ji = P, is = V;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!Wi && (P = E.updateQueue, P !== null && (P = P.lastEffect, P !== null))) {
          V = P = P.next;
          do {
            var q = V, le = q.destroy;
            q = q.tag, le !== void 0 && ((q & 2) !== 0 || (q & 4) !== 0) && Vm(E, h, le), V = V.next;
          } while (V !== P);
        }
        To(c, h, E);
        break;
      case 1:
        if (!Wi && (Ch(E, h), P = E.stateNode, typeof P.componentWillUnmount == "function"))
          try {
            P.props = E.memoizedProps, P.state = E.memoizedState, P.componentWillUnmount();
          } catch (Oe) {
            Bs(E, h, Oe);
          }
        To(c, h, E);
        break;
      case 21:
        To(c, h, E);
        break;
      case 22:
        E.mode & 1 ? (Wi = (P = Wi) || E.memoizedState !== null, To(c, h, E), Wi = P) : To(c, h, E);
        break;
      default:
        To(c, h, E);
    }
  }
  function vd(c) {
    var h = c.updateQueue;
    if (h !== null) {
      c.updateQueue = null;
      var E = c.stateNode;
      E === null && (E = c.stateNode = new Ev()), h.forEach(function(P) {
        var V = F0.bind(null, c, P);
        E.has(P) || (E.add(P), P.then(V, V));
      });
    }
  }
  function Nf(c, h) {
    var E = h.deletions;
    if (E !== null)
      for (var P = 0; P < E.length; P++) {
        var V = E[P];
        try {
          var q = c, le = h, Oe = le;
          e:
            for (; Oe !== null; ) {
              switch (Oe.tag) {
                case 5:
                  ji = Oe.stateNode, is = !1;
                  break e;
                case 3:
                  ji = Oe.stateNode.containerInfo, is = !0;
                  break e;
                case 4:
                  ji = Oe.stateNode.containerInfo, is = !0;
                  break e;
              }
              Oe = Oe.return;
            }
          if (ji === null)
            throw Error(t(160));
          _l(q, le, V), ji = null, is = !1;
          var Ge = V.alternate;
          Ge !== null && (Ge.return = null), V.return = null;
        } catch (Dt) {
          Bs(V, h, Dt);
        }
      }
    if (h.subtreeFlags & 12854)
      for (h = h.child; h !== null; )
        wy(h, c), h = h.sibling;
  }
  function wy(c, h) {
    var E = c.alternate, P = c.flags;
    switch (c.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (Nf(h, c), sl(c), P & 4) {
          try {
            op(3, c, c.return), Gm(3, c);
          } catch (ir) {
            Bs(c, c.return, ir);
          }
          try {
            op(5, c, c.return);
          } catch (ir) {
            Bs(c, c.return, ir);
          }
        }
        break;
      case 1:
        Nf(h, c), sl(c), P & 512 && E !== null && Ch(E, E.return);
        break;
      case 5:
        if (Nf(h, c), sl(c), P & 512 && E !== null && Ch(E, E.return), c.flags & 32) {
          var V = c.stateNode;
          try {
            an(V, "");
          } catch (ir) {
            Bs(c, c.return, ir);
          }
        }
        if (P & 4 && (V = c.stateNode, V != null)) {
          var q = c.memoizedProps, le = E !== null ? E.memoizedProps : q, Oe = c.type, Ge = c.updateQueue;
          if (c.updateQueue = null, Ge !== null)
            try {
              Oe === "input" && q.type === "radio" && q.name != null && xt(V, q), ze(Oe, le);
              var Dt = ze(Oe, q);
              for (le = 0; le < Ge.length; le += 2) {
                var fn = Ge[le], un = Ge[le + 1];
                fn === "style" ? at(V, un) : fn === "dangerouslySetInnerHTML" ? it(V, un) : fn === "children" ? an(V, un) : G(V, fn, un, Dt);
              }
              switch (Oe) {
                case "input":
                  Vt(V, q);
                  break;
                case "textarea":
                  Qe(V, q);
                  break;
                case "select":
                  var rn = V._wrapperState.wasMultiple;
                  V._wrapperState.wasMultiple = !!q.multiple;
                  var Hn = q.value;
                  Hn != null ? Rt(V, !!q.multiple, Hn, !1) : rn !== !!q.multiple && (q.defaultValue != null ? Rt(
                    V,
                    !!q.multiple,
                    q.defaultValue,
                    !0
                  ) : Rt(V, !!q.multiple, q.multiple ? [] : "", !1));
              }
              V[Uu] = q;
            } catch (ir) {
              Bs(c, c.return, ir);
            }
        }
        break;
      case 6:
        if (Nf(h, c), sl(c), P & 4) {
          if (c.stateNode === null)
            throw Error(t(162));
          V = c.stateNode, q = c.memoizedProps;
          try {
            V.nodeValue = q;
          } catch (ir) {
            Bs(c, c.return, ir);
          }
        }
        break;
      case 3:
        if (Nf(h, c), sl(c), P & 4 && E !== null && E.memoizedState.isDehydrated)
          try {
            Ri(h.containerInfo);
          } catch (ir) {
            Bs(c, c.return, ir);
          }
        break;
      case 4:
        Nf(h, c), sl(c);
        break;
      case 13:
        Nf(h, c), sl(c), V = c.child, V.flags & 8192 && (q = V.memoizedState !== null, V.stateNode.isHidden = q, !q || V.alternate !== null && V.alternate.memoizedState !== null || (Xm = en())), P & 4 && vd(c);
        break;
      case 22:
        if (fn = E !== null && E.memoizedState !== null, c.mode & 1 ? (Wi = (Dt = Wi) || fn, Nf(h, c), Wi = Dt) : Nf(h, c), sl(c), P & 8192) {
          if (Dt = c.memoizedState !== null, (c.stateNode.isHidden = Dt) && !fn && (c.mode & 1) !== 0)
            for (Kn = c, fn = c.child; fn !== null; ) {
              for (un = Kn = fn; Kn !== null; ) {
                switch (rn = Kn, Hn = rn.child, rn.tag) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    op(4, rn, rn.return);
                    break;
                  case 1:
                    Ch(rn, rn.return);
                    var Qn = rn.stateNode;
                    if (typeof Qn.componentWillUnmount == "function") {
                      P = rn, E = rn.return;
                      try {
                        h = P, Qn.props = h.memoizedProps, Qn.state = h.memoizedState, Qn.componentWillUnmount();
                      } catch (ir) {
                        Bs(P, E, ir);
                      }
                    }
                    break;
                  case 5:
                    Ch(rn, rn.return);
                    break;
                  case 22:
                    if (rn.memoizedState !== null) {
                      by(un);
                      continue;
                    }
                }
                Hn !== null ? (Hn.return = rn, Kn = Hn) : by(un);
              }
              fn = fn.sibling;
            }
          e:
            for (fn = null, un = c; ; ) {
              if (un.tag === 5) {
                if (fn === null) {
                  fn = un;
                  try {
                    V = un.stateNode, Dt ? (q = V.style, typeof q.setProperty == "function" ? q.setProperty("display", "none", "important") : q.display = "none") : (Oe = un.stateNode, Ge = un.memoizedProps.style, le = Ge != null && Ge.hasOwnProperty("display") ? Ge.display : null, Oe.style.display = Fe("display", le));
                  } catch (ir) {
                    Bs(c, c.return, ir);
                  }
                }
              } else if (un.tag === 6) {
                if (fn === null)
                  try {
                    un.stateNode.nodeValue = Dt ? "" : un.memoizedProps;
                  } catch (ir) {
                    Bs(c, c.return, ir);
                  }
              } else if ((un.tag !== 22 && un.tag !== 23 || un.memoizedState === null || un === c) && un.child !== null) {
                un.child.return = un, un = un.child;
                continue;
              }
              if (un === c)
                break e;
              for (; un.sibling === null; ) {
                if (un.return === null || un.return === c)
                  break e;
                fn === un && (fn = null), un = un.return;
              }
              fn === un && (fn = null), un.sibling.return = un.return, un = un.sibling;
            }
        }
        break;
      case 19:
        Nf(h, c), sl(c), P & 4 && vd(c);
        break;
      case 21:
        break;
      default:
        Nf(
          h,
          c
        ), sl(c);
    }
  }
  function sl(c) {
    var h = c.flags;
    if (h & 2) {
      try {
        e: {
          for (var E = c.return; E !== null; ) {
            if (Qp(E)) {
              var P = E;
              break e;
            }
            E = E.return;
          }
          throw Error(t(160));
        }
        switch (P.tag) {
          case 5:
            var V = P.stateNode;
            P.flags & 32 && (an(V, ""), P.flags &= -33);
            var q = Zp(c);
            io(c, q, V);
            break;
          case 3:
          case 4:
            var le = P.stateNode.containerInfo, Oe = Zp(c);
            Kd(c, Oe, le);
            break;
          default:
            throw Error(t(161));
        }
      } catch (Ge) {
        Bs(c, c.return, Ge);
      }
      c.flags &= -3;
    }
    h & 4096 && (c.flags &= -4097);
  }
  function yg(c, h, E) {
    Kn = c, Zl(c);
  }
  function Zl(c, h, E) {
    for (var P = (c.mode & 1) !== 0; Kn !== null; ) {
      var V = Kn, q = V.child;
      if (V.tag === 22 && P) {
        var le = V.memoizedState !== null || Iu;
        if (!le) {
          var Oe = V.alternate, Ge = Oe !== null && Oe.memoizedState !== null || Wi;
          Oe = Iu;
          var Dt = Wi;
          if (Iu = le, (Wi = Ge) && !Dt)
            for (Kn = V; Kn !== null; )
              le = Kn, Ge = le.child, le.tag === 22 && le.memoizedState !== null ? Mv(V) : Ge !== null ? (Ge.return = le, Kn = Ge) : Mv(V);
          for (; q !== null; )
            Kn = q, Zl(q), q = q.sibling;
          Kn = V, Iu = Oe, Wi = Dt;
        }
        gd(c);
      } else
        (V.subtreeFlags & 8772) !== 0 && q !== null ? (q.return = V, Kn = q) : gd(c);
    }
  }
  function gd(c) {
    for (; Kn !== null; ) {
      var h = Kn;
      if ((h.flags & 8772) !== 0) {
        var E = h.alternate;
        try {
          if ((h.flags & 8772) !== 0)
            switch (h.tag) {
              case 0:
              case 11:
              case 15:
                Wi || Gm(5, h);
                break;
              case 1:
                var P = h.stateNode;
                if (h.flags & 4 && !Wi)
                  if (E === null)
                    P.componentDidMount();
                  else {
                    var V = h.elementType === h.type ? E.memoizedProps : pu(h.type, E.memoizedProps);
                    P.componentDidUpdate(V, E.memoizedState, P.__reactInternalSnapshotBeforeUpdate);
                  }
                var q = h.updateQueue;
                q !== null && Ba(h, q, P);
                break;
              case 3:
                var le = h.updateQueue;
                if (le !== null) {
                  if (E = null, h.child !== null)
                    switch (h.child.tag) {
                      case 5:
                        E = h.child.stateNode;
                        break;
                      case 1:
                        E = h.child.stateNode;
                    }
                  Ba(h, le, E);
                }
                break;
              case 5:
                var Oe = h.stateNode;
                if (E === null && h.flags & 4) {
                  E = Oe;
                  var Ge = h.memoizedProps;
                  switch (h.type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      Ge.autoFocus && E.focus();
                      break;
                    case "img":
                      Ge.src && (E.src = Ge.src);
                  }
                }
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (h.memoizedState === null) {
                  var Dt = h.alternate;
                  if (Dt !== null) {
                    var fn = Dt.memoizedState;
                    if (fn !== null) {
                      var un = fn.dehydrated;
                      un !== null && Ri(un);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              default:
                throw Error(t(163));
            }
          Wi || h.flags & 512 && Sy(h);
        } catch (rn) {
          Bs(h, h.return, rn);
        }
      }
      if (h === c) {
        Kn = null;
        break;
      }
      if (E = h.sibling, E !== null) {
        E.return = h.return, Kn = E;
        break;
      }
      Kn = h.return;
    }
  }
  function by(c) {
    for (; Kn !== null; ) {
      var h = Kn;
      if (h === c) {
        Kn = null;
        break;
      }
      var E = h.sibling;
      if (E !== null) {
        E.return = h.return, Kn = E;
        break;
      }
      Kn = h.return;
    }
  }
  function Mv(c) {
    for (; Kn !== null; ) {
      var h = Kn;
      try {
        switch (h.tag) {
          case 0:
          case 11:
          case 15:
            var E = h.return;
            try {
              Gm(4, h);
            } catch (Ge) {
              Bs(h, E, Ge);
            }
            break;
          case 1:
            var P = h.stateNode;
            if (typeof P.componentDidMount == "function") {
              var V = h.return;
              try {
                P.componentDidMount();
              } catch (Ge) {
                Bs(h, V, Ge);
              }
            }
            var q = h.return;
            try {
              Sy(h);
            } catch (Ge) {
              Bs(h, q, Ge);
            }
            break;
          case 5:
            var le = h.return;
            try {
              Sy(h);
            } catch (Ge) {
              Bs(h, le, Ge);
            }
        }
      } catch (Ge) {
        Bs(h, h.return, Ge);
      }
      if (h === c) {
        Kn = null;
        break;
      }
      var Oe = h.sibling;
      if (Oe !== null) {
        Oe.return = h.return, Kn = Oe;
        break;
      }
      Kn = h.return;
    }
  }
  var xg = Math.ceil, Tv = B.ReactCurrentDispatcher, Rh = B.ReactCurrentOwner, sa = B.ReactCurrentBatchConfig, zr = 0, ea = null, Ga = null, gs = 0, Vc = 0, Wm = Wn(0), ol = 0, jm = null, yd = 0, Ym = 0, up = 0, cp = null, xu = null, Xm = 0, fp = 1 / 0, xd = null, _g = !1, Jp = null, $d = null, dp = !1, Zo = null, hp = 0, qm = 0, Cv = null, Gc = -1, pp = 0;
  function ha() {
    return (zr & 6) !== 0 ? en() : Gc !== -1 ? Gc : Gc = en();
  }
  function ao(c) {
    return (c.mode & 1) === 0 ? 1 : (zr & 2) !== 0 && gs !== 0 ? gs & -gs : Wp.transition !== null ? (pp === 0 && (pp = Ps()), pp) : (c = ei, c !== 0 || (c = window.event, c = c === void 0 ? 16 : Jf(c.type)), c);
  }
  function Sl(c, h, E, P) {
    if (50 < qm)
      throw qm = 0, Cv = null, Error(t(185));
    ou(c, E, P), ((zr & 2) === 0 || c !== ea) && (c === ea && ((zr & 2) === 0 && (Ym |= E), ol === 4 && _u(c, gs)), Jo(c, P), E === 1 && zr === 0 && (h.mode & 1) === 0 && (fp = en() + 500, wo && ws()));
  }
  function Jo(c, h) {
    var E = c.callbackNode;
    Ll(c, h);
    var P = vo(c, c === ea ? gs : 0);
    if (P === 0)
      E !== null && Yi(E), c.callbackNode = null, c.callbackPriority = 0;
    else if (h = P & -P, c.callbackPriority !== h) {
      if (E != null && Yi(E), h === 1)
        c.tag === 0 ? du(Av.bind(null, c)) : lc(Av.bind(null, c)), Wd(function() {
          (zr & 6) === 0 && ws();
        }), E = null;
      else {
        switch (go(P)) {
          case 1:
            E = us;
            break;
          case 4:
            E = qn;
            break;
          case 16:
            E = qa;
            break;
          case 536870912:
            E = Ls;
            break;
          default:
            E = qa;
        }
        E = jc(E, mp.bind(null, c));
      }
      c.callbackPriority = h, c.callbackNode = E;
    }
  }
  function mp(c, h) {
    if (Gc = -1, pp = 0, (zr & 6) !== 0)
      throw Error(t(327));
    var E = c.callbackNode;
    if (Wc() && c.callbackNode !== E)
      return null;
    var P = vo(c, c === ea ? gs : 0);
    if (P === 0)
      return null;
    if ((P & 30) !== 0 || (P & c.expiredLanes) !== 0 || h)
      h = vp(c, P);
    else {
      h = P;
      var V = zr;
      zr |= 2;
      var q = bg();
      (ea !== c || gs !== h) && (xd = null, fp = en() + 500, Ff(c, h));
      do
        try {
          Dv();
          break;
        } catch (Oe) {
          Ey(c, Oe);
        }
      while (1);
      Xd(), Tv.current = q, zr = V, Ga !== null ? h = 0 : (ea = null, gs = 0, h = ol);
    }
    if (h !== 0) {
      if (h === 2 && (V = Nd(c), V !== 0 && (P = V, h = Rv(c, V))), h === 1)
        throw E = jm, Ff(c, 0), _u(c, P), Jo(c, en()), E;
      if (h === 6)
        _u(c, P);
      else {
        if (V = c.current.alternate, (P & 30) === 0 && !Sg(V) && (h = vp(c, P), h === 2 && (q = Nd(c), q !== 0 && (P = q, h = Rv(c, q))), h === 1))
          throw E = jm, Ff(c, 0), _u(c, P), Jo(c, en()), E;
        switch (c.finishedWork = V, c.finishedLanes = P, h) {
          case 0:
          case 1:
            throw Error(t(345));
          case 2:
            Lh(c, xu, xd);
            break;
          case 3:
            if (_u(c, P), (P & 130023424) === P && (h = Xm + 500 - en(), 10 < h)) {
              if (vo(c, 0) !== 0)
                break;
              if (V = c.suspendedLanes, (V & P) !== P) {
                ha(), c.pingedLanes |= c.suspendedLanes & V;
                break;
              }
              c.timeoutHandle = fu(Lh.bind(null, c, xu, xd), h);
              break;
            }
            Lh(c, xu, xd);
            break;
          case 4:
            if (_u(c, P), (P & 4194240) === P)
              break;
            for (h = c.eventTimes, V = -1; 0 < P; ) {
              var le = 31 - Ea(P);
              q = 1 << le, le = h[le], le > V && (V = le), P &= ~q;
            }
            if (P = V, P = en() - P, P = (120 > P ? 120 : 480 > P ? 480 : 1080 > P ? 1080 : 1920 > P ? 1920 : 3e3 > P ? 3e3 : 4320 > P ? 4320 : 1960 * xg(P / 1960)) - P, 10 < P) {
              c.timeoutHandle = fu(Lh.bind(null, c, xu, xd), P);
              break;
            }
            Lh(c, xu, xd);
            break;
          case 5:
            Lh(c, xu, xd);
            break;
          default:
            throw Error(t(329));
        }
      }
    }
    return Jo(c, en()), c.callbackNode === E ? mp.bind(null, c) : null;
  }
  function Rv(c, h) {
    var E = cp;
    return c.current.memoizedState.isDehydrated && (Ff(c, h).flags |= 256), c = vp(c, h), c !== 2 && (h = xu, xu = E, h !== null && Kp(h)), c;
  }
  function Kp(c) {
    xu === null ? xu = c : xu.push.apply(xu, c);
  }
  function Sg(c) {
    for (var h = c; ; ) {
      if (h.flags & 16384) {
        var E = h.updateQueue;
        if (E !== null && (E = E.stores, E !== null))
          for (var P = 0; P < E.length; P++) {
            var V = E[P], q = V.getSnapshot;
            V = V.value;
            try {
              if (!vt(q(), V))
                return !1;
            } catch {
              return !1;
            }
          }
      }
      if (E = h.child, h.subtreeFlags & 16384 && E !== null)
        E.return = h, h = E;
      else {
        if (h === c)
          break;
        for (; h.sibling === null; ) {
          if (h.return === null || h.return === c)
            return !0;
          h = h.return;
        }
        h.sibling.return = h.return, h = h.sibling;
      }
    }
    return !0;
  }
  function _u(c, h) {
    for (h &= ~up, h &= ~Ym, c.suspendedLanes |= h, c.pingedLanes &= ~h, c = c.expirationTimes; 0 < h; ) {
      var E = 31 - Ea(h), P = 1 << E;
      c[E] = -1, h &= ~P;
    }
  }
  function Av(c) {
    if ((zr & 6) !== 0)
      throw Error(t(327));
    Wc();
    var h = vo(c, 0);
    if ((h & 1) === 0)
      return Jo(c, en()), null;
    var E = vp(c, h);
    if (c.tag !== 0 && E === 2) {
      var P = Nd(c);
      P !== 0 && (h = P, E = Rv(c, P));
    }
    if (E === 1)
      throw E = jm, Ff(c, 0), _u(c, h), Jo(c, en()), E;
    if (E === 6)
      throw Error(t(345));
    return c.finishedWork = c.current.alternate, c.finishedLanes = h, Lh(c, xu, xd), Jo(c, en()), null;
  }
  function Ah(c, h) {
    var E = zr;
    zr |= 1;
    try {
      return c(h);
    } finally {
      zr = E, zr === 0 && (fp = en() + 500, wo && ws());
    }
  }
  function Dh(c) {
    Zo !== null && Zo.tag === 0 && (zr & 6) === 0 && Wc();
    var h = zr;
    zr |= 1;
    var E = sa.transition, P = ei;
    try {
      if (sa.transition = null, ei = 1, c)
        return c();
    } finally {
      ei = P, sa.transition = E, zr = h, (zr & 6) === 0 && ws();
    }
  }
  function wg() {
    Vc = Wm.current, wi(Wm);
  }
  function Ff(c, h) {
    c.finishedWork = null, c.finishedLanes = 0;
    var E = c.timeoutHandle;
    if (E !== -1 && (c.timeoutHandle = -1, wf(E)), Ga !== null)
      for (E = Ga.return; E !== null; ) {
        var P = E;
        switch (zu(P), P.tag) {
          case 1:
            P = P.type.childContextTypes, P != null && Il();
            break;
          case 3:
            fc(), wi(ps), wi(Rr), Xl();
            break;
          case 5:
            Gr(P);
            break;
          case 4:
            fc();
            break;
          case 13:
            wi(fr);
            break;
          case 19:
            wi(fr);
            break;
          case 10:
            da(P.type._context);
            break;
          case 22:
          case 23:
            wg();
        }
        E = E.return;
      }
    if (ea = c, Ga = c = Bu(c.current, null), gs = Vc = h, ol = 0, jm = null, up = Ym = yd = 0, xu = cp = null, ya !== null) {
      for (h = 0; h < ya.length; h++)
        if (E = ya[h], P = E.interleaved, P !== null) {
          E.interleaved = null;
          var V = P.next, q = E.pending;
          if (q !== null) {
            var le = q.next;
            q.next = V, P.next = le;
          }
          E.pending = P;
        }
      ya = null;
    }
    return c;
  }
  function Ey(c, h) {
    do {
      var E = Ga;
      try {
        if (Xd(), Fc.current = y, lr) {
          for (var P = Ai.memoizedState; P !== null; ) {
            var V = P.queue;
            V !== null && (V.pending = null), P = P.next;
          }
          lr = !1;
        }
        if (Eo = 0, pi = Ht = Ai = null, kc = !1, Ha = 0, Rh.current = null, E === null || E.return === null) {
          ol = 1, jm = h, Ga = null;
          break;
        }
        e: {
          var q = c, le = E.return, Oe = E, Ge = h;
          if (h = gs, Oe.flags |= 32768, Ge !== null && typeof Ge == "object" && typeof Ge.then == "function") {
            var Dt = Ge, fn = Oe, un = fn.tag;
            if ((fn.mode & 1) === 0 && (un === 0 || un === 11 || un === 15)) {
              var rn = fn.alternate;
              rn ? (fn.updateQueue = rn.updateQueue, fn.memoizedState = rn.memoizedState, fn.lanes = rn.lanes) : (fn.updateQueue = null, fn.memoizedState = null);
            }
            var Hn = br(le);
            if (Hn !== null) {
              Hn.flags &= -257, ur(Hn, le, Oe, q, h), Hn.mode & 1 && wn(q, Dt, h), h = Hn, Ge = Dt;
              var Qn = h.updateQueue;
              if (Qn === null) {
                var ir = /* @__PURE__ */ new Set();
                ir.add(Ge), h.updateQueue = ir;
              } else
                Qn.add(Ge);
              break e;
            } else {
              if ((h & 1) === 0) {
                wn(q, Dt, h), My();
                break e;
              }
              Ge = Error(t(426));
            }
          } else if (ga && Oe.mode & 1) {
            var Hs = br(le);
            if (Hs !== null) {
              (Hs.flags & 65536) === 0 && (Hs.flags |= 256), ur(Hs, le, Oe, q, h), Nu(X(Ge, Oe));
              break e;
            }
          }
          q = Ge = X(Ge, Oe), ol !== 4 && (ol = 2), cp === null ? cp = [q] : cp.push(q), q = le;
          do {
            switch (q.tag) {
              case 3:
                q.flags |= 65536, h &= -h, q.lanes |= h;
                var mt = kt(q, Ge, h);
                Qr(q, mt);
                break e;
              case 1:
                Oe = Ge;
                var Ke = q.type, _t = q.stateNode;
                if ((q.flags & 128) === 0 && (typeof Ke.getDerivedStateFromError == "function" || _t !== null && typeof _t.componentDidCatch == "function" && ($d === null || !$d.has(_t)))) {
                  q.flags |= 65536, h &= -h, q.lanes |= h;
                  var _n = hn(q, Oe, h);
                  Qr(q, _n);
                  break e;
                }
            }
            q = q.return;
          } while (q !== null);
        }
        Qm(E);
      } catch (ar) {
        h = ar, Ga === E && E !== null && (Ga = E = E.return);
        continue;
      }
      break;
    } while (1);
  }
  function bg() {
    var c = Tv.current;
    return Tv.current = y, c === null ? y : c;
  }
  function My() {
    (ol === 0 || ol === 3 || ol === 2) && (ol = 4), ea === null || (yd & 268435455) === 0 && (Ym & 268435455) === 0 || _u(ea, gs);
  }
  function vp(c, h) {
    var E = zr;
    zr |= 2;
    var P = bg();
    (ea !== c || gs !== h) && (xd = null, Ff(c, h));
    do
      try {
        gp();
        break;
      } catch (V) {
        Ey(c, V);
      }
    while (1);
    if (Xd(), zr = E, Tv.current = P, Ga !== null)
      throw Error(t(261));
    return ea = null, gs = 0, ol;
  }
  function gp() {
    for (; Ga !== null; )
      Lv(Ga);
  }
  function Dv() {
    for (; Ga !== null && !La(); )
      Lv(Ga);
  }
  function Lv(c) {
    var h = Zm(c.alternate, c, Vc);
    c.memoizedProps = c.pendingProps, h === null ? Qm(c) : Ga = h, Rh.current = null;
  }
  function Qm(c) {
    var h = c;
    do {
      var E = h.alternate;
      if (c = h.return, (h.flags & 32768) === 0) {
        if (E = _y(E, h, Vc), E !== null) {
          Ga = E;
          return;
        }
      } else {
        if (E = gg(E, h), E !== null) {
          E.flags &= 32767, Ga = E;
          return;
        }
        if (c !== null)
          c.flags |= 32768, c.subtreeFlags = 0, c.deletions = null;
        else {
          ol = 6, Ga = null;
          return;
        }
      }
      if (h = h.sibling, h !== null) {
        Ga = h;
        return;
      }
      Ga = h = c;
    } while (h !== null);
    ol === 0 && (ol = 5);
  }
  function Lh(c, h, E) {
    var P = ei, V = sa.transition;
    try {
      sa.transition = null, ei = 1, Ty(c, h, E, P);
    } finally {
      sa.transition = V, ei = P;
    }
    return null;
  }
  function Ty(c, h, E, P) {
    do
      Wc();
    while (Zo !== null);
    if ((zr & 6) !== 0)
      throw Error(t(327));
    E = c.finishedWork;
    var V = c.finishedLanes;
    if (E === null)
      return null;
    if (c.finishedWork = null, c.finishedLanes = 0, E === c.current)
      throw Error(t(177));
    c.callbackNode = null, c.callbackPriority = 0;
    var q = E.lanes | E.childLanes;
    if (Jh(c, q), c === ea && (Ga = ea = null, gs = 0), (E.subtreeFlags & 2064) === 0 && (E.flags & 2064) === 0 || dp || (dp = !0, jc(qa, function() {
      return Wc(), null;
    })), q = (E.flags & 15990) !== 0, (E.subtreeFlags & 15990) !== 0 || q) {
      q = sa.transition, sa.transition = null;
      var le = ei;
      ei = 1;
      var Oe = zr;
      zr |= 4, Rh.current = null, qp(c, E), wy(E, c), ia(Ou), Os = !!Sf, Ou = Sf = null, c.current = E, yg(E), qs(), zr = Oe, ei = le, sa.transition = q;
    } else
      c.current = E;
    if (dp && (dp = !1, Zo = c, hp = V), q = c.pendingLanes, q === 0 && ($d = null), di(E.stateNode), Jo(c, en()), h !== null)
      for (P = c.onRecoverableError, E = 0; E < h.length; E++)
        V = h[E], P(V.value, { componentStack: V.stack, digest: V.digest });
    if (_g)
      throw _g = !1, c = Jp, Jp = null, c;
    return (hp & 1) !== 0 && c.tag !== 0 && Wc(), q = c.pendingLanes, (q & 1) !== 0 ? c === Cv ? qm++ : (qm = 0, Cv = c) : qm = 0, ws(), null;
  }
  function Wc() {
    if (Zo !== null) {
      var c = go(hp), h = sa.transition, E = ei;
      try {
        if (sa.transition = null, ei = 16 > c ? 16 : c, Zo === null)
          var P = !1;
        else {
          if (c = Zo, Zo = null, hp = 0, (zr & 6) !== 0)
            throw Error(t(331));
          var V = zr;
          for (zr |= 4, Kn = c.current; Kn !== null; ) {
            var q = Kn, le = q.child;
            if ((Kn.flags & 16) !== 0) {
              var Oe = q.deletions;
              if (Oe !== null) {
                for (var Ge = 0; Ge < Oe.length; Ge++) {
                  var Dt = Oe[Ge];
                  for (Kn = Dt; Kn !== null; ) {
                    var fn = Kn;
                    switch (fn.tag) {
                      case 0:
                      case 11:
                      case 15:
                        op(8, fn, q);
                    }
                    var un = fn.child;
                    if (un !== null)
                      un.return = fn, Kn = un;
                    else
                      for (; Kn !== null; ) {
                        fn = Kn;
                        var rn = fn.sibling, Hn = fn.return;
                        if (lp(fn), fn === Dt) {
                          Kn = null;
                          break;
                        }
                        if (rn !== null) {
                          rn.return = Hn, Kn = rn;
                          break;
                        }
                        Kn = Hn;
                      }
                  }
                }
                var Qn = q.alternate;
                if (Qn !== null) {
                  var ir = Qn.child;
                  if (ir !== null) {
                    Qn.child = null;
                    do {
                      var Hs = ir.sibling;
                      ir.sibling = null, ir = Hs;
                    } while (ir !== null);
                  }
                }
                Kn = q;
              }
            }
            if ((q.subtreeFlags & 2064) !== 0 && le !== null)
              le.return = q, Kn = le;
            else
              e:
                for (; Kn !== null; ) {
                  if (q = Kn, (q.flags & 2048) !== 0)
                    switch (q.tag) {
                      case 0:
                      case 11:
                      case 15:
                        op(9, q, q.return);
                    }
                  var mt = q.sibling;
                  if (mt !== null) {
                    mt.return = q.return, Kn = mt;
                    break e;
                  }
                  Kn = q.return;
                }
          }
          var Ke = c.current;
          for (Kn = Ke; Kn !== null; ) {
            le = Kn;
            var _t = le.child;
            if ((le.subtreeFlags & 2064) !== 0 && _t !== null)
              _t.return = le, Kn = _t;
            else
              e:
                for (le = Ke; Kn !== null; ) {
                  if (Oe = Kn, (Oe.flags & 2048) !== 0)
                    try {
                      switch (Oe.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Gm(9, Oe);
                      }
                    } catch (ar) {
                      Bs(Oe, Oe.return, ar);
                    }
                  if (Oe === le) {
                    Kn = null;
                    break e;
                  }
                  var _n = Oe.sibling;
                  if (_n !== null) {
                    _n.return = Oe.return, Kn = _n;
                    break e;
                  }
                  Kn = Oe.return;
                }
          }
          if (zr = V, ws(), mr && typeof mr.onPostCommitFiberRoot == "function")
            try {
              mr.onPostCommitFiberRoot(cs, c);
            } catch {
            }
          P = !0;
        }
        return P;
      } finally {
        ei = E, sa.transition = h;
      }
    }
    return !1;
  }
  function $p(c, h, E) {
    h = X(E, h), h = kt(c, h, 1), c = Mf(c, h, 1), h = ha(), c !== null && (ou(c, 1, h), Jo(c, h));
  }
  function Bs(c, h, E) {
    if (c.tag === 3)
      $p(c, c, E);
    else
      for (; h !== null; ) {
        if (h.tag === 3) {
          $p(h, c, E);
          break;
        } else if (h.tag === 1) {
          var P = h.stateNode;
          if (typeof h.type.getDerivedStateFromError == "function" || typeof P.componentDidCatch == "function" && ($d === null || !$d.has(P))) {
            c = X(E, c), c = hn(h, c, 1), h = Mf(h, c, 1), c = ha(), h !== null && (ou(h, 1, c), Jo(h, c));
            break;
          }
        }
        h = h.return;
      }
  }
  function Cy(c, h, E) {
    var P = c.pingCache;
    P !== null && P.delete(h), h = ha(), c.pingedLanes |= c.suspendedLanes & E, ea === c && (gs & E) === E && (ol === 4 || ol === 3 && (gs & 130023424) === gs && 500 > en() - Xm ? Ff(c, 0) : up |= E), Jo(c, h);
  }
  function Eg(c, h) {
    h === 0 && ((c.mode & 1) === 0 ? h = 1 : (h = Pa, Pa <<= 1, (Pa & 130023424) === 0 && (Pa = 4194304)));
    var E = ha();
    c = jo(c, h), c !== null && (ou(c, h, E), Jo(c, E));
  }
  function N0(c) {
    var h = c.memoizedState, E = 0;
    h !== null && (E = h.retryLane), Eg(c, E);
  }
  function F0(c, h) {
    var E = 0;
    switch (c.tag) {
      case 13:
        var P = c.stateNode, V = c.memoizedState;
        V !== null && (E = V.retryLane);
        break;
      case 19:
        P = c.stateNode;
        break;
      default:
        throw Error(t(314));
    }
    P !== null && P.delete(h), Eg(c, E);
  }
  var Zm;
  Zm = function(c, h, E) {
    if (c !== null)
      if (c.memoizedProps !== h.pendingProps || ps.current)
        Tn = !0;
      else {
        if ((c.lanes & E) === 0 && (h.flags & 128) === 0)
          return Tn = !1, rs(c, h, E);
        Tn = (c.flags & 131072) !== 0;
      }
    else
      Tn = !1, ga && (h.flags & 1048576) !== 0 && Im(h, Ur, h.index);
    switch (h.lanes = 0, h.tag) {
      case 2:
        var P = h.type;
        qo(c, h), c = h.pendingProps;
        var V = kl(h, Rr.current);
        bn(h, E), V = Af(null, h, P, c, V, E);
        var q = Df();
        return h.flags |= 1, typeof V == "object" && V !== null && typeof V.render == "function" && V.$$typeof === void 0 ? (h.tag = 1, h.memoizedState = null, h.updateQueue = null, Ia(P) ? (q = !0, Vo(h)) : q = !1, h.memoizedState = V.state !== null && V.state !== void 0 ? V.state : null, An(h), V.updater = ud, h.stateNode = V, V._reactInternals = h, cc(h, P, c, E), h = Er(null, h, P, !0, q, E)) : (h.tag = 0, ga && q && Eh(h), Li(null, h, V, E), h = h.child), h;
      case 16:
        P = h.elementType;
        e: {
          switch (qo(c, h), c = h.pendingProps, V = P._init, P = V(P._payload), h.type = P, V = h.tag = Mg(P), c = pu(P, c), V) {
            case 0:
              h = jn(null, h, P, c, E);
              break e;
            case 1:
              h = Wr(null, h, P, c, E);
              break e;
            case 11:
              h = vs(null, h, P, c, E);
              break e;
            case 14:
              h = pt(null, h, P, pu(P.type, c), E);
              break e;
          }
          throw Error(t(
            306,
            P,
            ""
          ));
        }
        return h;
      case 0:
        return P = h.type, V = h.pendingProps, V = h.elementType === P ? V : pu(P, V), jn(c, h, P, V, E);
      case 1:
        return P = h.type, V = h.pendingProps, V = h.elementType === P ? V : pu(P, V), Wr(c, h, P, V, E);
      case 3:
        e: {
          if (Ar(h), c === null)
            throw Error(t(387));
          P = h.pendingProps, q = h.memoizedState, V = q.element, xa(c, h), Ra(h, P, null, E);
          var le = h.memoizedState;
          if (P = le.element, q.isDehydrated)
            if (q = { element: P, isDehydrated: !1, cache: le.cache, pendingSuspenseBoundaries: le.pendingSuspenseBoundaries, transitions: le.transitions }, h.updateQueue.baseState = q, h.memoizedState = q, h.flags & 256) {
              V = X(Error(t(423)), h), h = Va(c, h, P, E, V);
              break e;
            } else if (P !== V) {
              V = X(Error(t(424)), h), h = Va(c, h, P, E, V);
              break e;
            } else
              for (yl = Fl(h.stateNode.containerInfo.firstChild), bs = h, ga = !0, hu = null, E = Zd(h, null, P, E), h.child = E; E; )
                E.flags = E.flags & -3 | 4096, E = E.sibling;
          else {
            if (fa(), P === V) {
              h = Qo(c, h, E);
              break e;
            }
            Li(c, h, P, E);
          }
          h = h.child;
        }
        return h;
      case 5:
        return hr(h), c === null && Go(h), P = h.type, V = h.pendingProps, q = c !== null ? c.memoizedProps : null, le = V.children, ad(P, V) ? le = null : q !== null && ad(P, q) && (h.flags |= 32), Qt(c, h), Li(c, h, le, E), h.child;
      case 6:
        return c === null && Go(h), null;
      case 13:
        return md(c, h, E);
      case 4:
        return Mh(h, h.stateNode.containerInfo), P = h.pendingProps, c === null ? h.child = Tf(h, null, P, E) : Li(c, h, P, E), h.child;
      case 11:
        return P = h.type, V = h.pendingProps, V = h.elementType === P ? V : pu(P, V), vs(c, h, P, V, E);
      case 7:
        return Li(c, h, h.pendingProps, E), h.child;
      case 8:
        return Li(c, h, h.pendingProps.children, E), h.child;
      case 12:
        return Li(c, h, h.pendingProps.children, E), h.child;
      case 10:
        e: {
          if (P = h.type._context, V = h.pendingProps, q = h.memoizedProps, le = V.value, zi(Vl, P._currentValue), P._currentValue = le, q !== null)
            if (vt(q.value, le)) {
              if (q.children === V.children && !ps.current) {
                h = Qo(c, h, E);
                break e;
              }
            } else
              for (q = h.child, q !== null && (q.return = h); q !== null; ) {
                var Oe = q.dependencies;
                if (Oe !== null) {
                  le = q.child;
                  for (var Ge = Oe.firstContext; Ge !== null; ) {
                    if (Ge.context === P) {
                      if (q.tag === 1) {
                        Ge = ns(-1, E & -E), Ge.tag = 2;
                        var Dt = q.updateQueue;
                        if (Dt !== null) {
                          Dt = Dt.shared;
                          var fn = Dt.pending;
                          fn === null ? Ge.next = Ge : (Ge.next = fn.next, fn.next = Ge), Dt.pending = Ge;
                        }
                      }
                      q.lanes |= E, Ge = q.alternate, Ge !== null && (Ge.lanes |= E), Gi(
                        q.return,
                        E,
                        h
                      ), Oe.lanes |= E;
                      break;
                    }
                    Ge = Ge.next;
                  }
                } else if (q.tag === 10)
                  le = q.type === h.type ? null : q.child;
                else if (q.tag === 18) {
                  if (le = q.return, le === null)
                    throw Error(t(341));
                  le.lanes |= E, Oe = le.alternate, Oe !== null && (Oe.lanes |= E), Gi(le, E, h), le = q.sibling;
                } else
                  le = q.child;
                if (le !== null)
                  le.return = q;
                else
                  for (le = q; le !== null; ) {
                    if (le === h) {
                      le = null;
                      break;
                    }
                    if (q = le.sibling, q !== null) {
                      q.return = le.return, le = q;
                      break;
                    }
                    le = le.return;
                  }
                q = le;
              }
          Li(c, h, V.children, E), h = h.child;
        }
        return h;
      case 9:
        return V = h.type, P = h.pendingProps.children, bn(h, E), V = Qi(V), P = P(V), h.flags |= 1, Li(c, h, P, E), h.child;
      case 14:
        return P = h.type, V = pu(P, h.pendingProps), V = pu(P.type, V), pt(c, h, P, V, E);
      case 15:
        return Ze(c, h, h.type, h.pendingProps, E);
      case 17:
        return P = h.type, V = h.pendingProps, V = h.elementType === P ? V : pu(P, V), qo(c, h), h.tag = 1, Ia(P) ? (c = !0, Vo(h)) : c = !1, bn(h, E), qd(h, P, V), cc(h, P, V, E), Er(null, h, P, !0, c, E);
      case 19:
        return vg(c, h, E);
      case 22:
        return Lt(c, h, E);
    }
    throw Error(t(156, h.tag));
  };
  function jc(c, h) {
    return wr(c, h);
  }
  function Ry(c, h, E, P) {
    this.tag = c, this.key = E, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = h, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = P, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function wl(c, h, E, P) {
    return new Ry(c, h, E, P);
  }
  function Pv(c) {
    return c = c.prototype, !(!c || !c.isReactComponent);
  }
  function Mg(c) {
    if (typeof c == "function")
      return Pv(c) ? 1 : 0;
    if (c != null) {
      if (c = c.$$typeof, c === ue)
        return 11;
      if (c === De)
        return 14;
    }
    return 2;
  }
  function Bu(c, h) {
    var E = c.alternate;
    return E === null ? (E = wl(c.tag, h, c.key, c.mode), E.elementType = c.elementType, E.type = c.type, E.stateNode = c.stateNode, E.alternate = c, c.alternate = E) : (E.pendingProps = h, E.type = c.type, E.flags = 0, E.subtreeFlags = 0, E.deletions = null), E.flags = c.flags & 14680064, E.childLanes = c.childLanes, E.lanes = c.lanes, E.child = c.child, E.memoizedProps = c.memoizedProps, E.memoizedState = c.memoizedState, E.updateQueue = c.updateQueue, h = c.dependencies, E.dependencies = h === null ? null : { lanes: h.lanes, firstContext: h.firstContext }, E.sibling = c.sibling, E.index = c.index, E.ref = c.ref, E;
  }
  function Ph(c, h, E, P, V, q) {
    var le = 2;
    if (P = c, typeof c == "function")
      Pv(c) && (le = 1);
    else if (typeof c == "string")
      le = 5;
    else
      e:
        switch (c) {
          case te:
            return em(E.children, V, q, h);
          case Y:
            le = 8, V |= 8;
            break;
          case re:
            return c = wl(12, E, h, V | 2), c.elementType = re, c.lanes = q, c;
          case Me:
            return c = wl(13, E, h, V), c.elementType = Me, c.lanes = q, c;
          case me:
            return c = wl(19, E, h, V), c.elementType = me, c.lanes = q, c;
          case He:
            return yp(E, V, q, h);
          default:
            if (typeof c == "object" && c !== null)
              switch (c.$$typeof) {
                case se:
                  le = 10;
                  break e;
                case ce:
                  le = 9;
                  break e;
                case ue:
                  le = 11;
                  break e;
                case De:
                  le = 14;
                  break e;
                case Re:
                  le = 16, P = null;
                  break e;
              }
            throw Error(t(130, c == null ? c : typeof c, ""));
        }
    return h = wl(le, E, h, V), h.elementType = c, h.type = P, h.lanes = q, h;
  }
  function em(c, h, E, P) {
    return c = wl(7, c, P, h), c.lanes = E, c;
  }
  function yp(c, h, E, P) {
    return c = wl(22, c, P, h), c.elementType = He, c.lanes = E, c.stateNode = { isHidden: !1 }, c;
  }
  function mc(c, h, E) {
    return c = wl(6, c, null, h), c.lanes = E, c;
  }
  function Aa(c, h, E) {
    return h = wl(4, c.children !== null ? c.children : [], c.key, h), h.lanes = E, h.stateNode = { containerInfo: c.containerInfo, pendingChildren: null, implementation: c.implementation }, h;
  }
  function xp(c, h, E, P, V) {
    this.tag = h, this.containerInfo = c, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Ju(0), this.expirationTimes = Ju(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Ju(0), this.identifierPrefix = P, this.onRecoverableError = V, this.mutableSourceEagerHydrationData = null;
  }
  function Cs(c, h, E, P, V, q, le, Oe, Ge) {
    return c = new xp(c, h, E, Oe, Ge), h === 1 ? (h = 1, q === !0 && (h |= 8)) : h = 0, q = wl(3, null, null, h), c.current = q, q.stateNode = c, q.memoizedState = { element: P, isDehydrated: E, cache: null, transitions: null, pendingSuspenseBoundaries: null }, An(q), c;
  }
  function bl(c, h, E) {
    var P = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return { $$typeof: K, key: P == null ? null : "" + P, children: c, containerInfo: h, implementation: E };
  }
  function Ov(c) {
    if (!c)
      return Oc;
    c = c._reactInternals;
    e: {
      if (mn(c) !== c || c.tag !== 1)
        throw Error(t(170));
      var h = c;
      do {
        switch (h.tag) {
          case 3:
            h = h.stateNode.context;
            break e;
          case 1:
            if (Ia(h.type)) {
              h = h.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        h = h.return;
      } while (h !== null);
      throw Error(t(171));
    }
    if (c.tag === 1) {
      var E = c.type;
      if (Ia(E))
        return jd(c, E, h);
    }
    return h;
  }
  function Tg(c, h, E, P, V, q, le, Oe, Ge) {
    return c = Cs(E, P, !0, c, V, q, le, Oe, Ge), c.context = Ov(null), E = c.current, P = ha(), V = ao(E), q = ns(P, V), q.callback = h != null ? h : null, Mf(E, q, V), c.current.lanes = V, ou(c, V, P), Jo(c, P), c;
  }
  function Uv(c, h, E, P) {
    var V = h.current, q = ha(), le = ao(V);
    return E = Ov(E), h.context === null ? h.context = E : h.pendingContext = E, h = ns(q, le), h.payload = { element: c }, P = P === void 0 ? null : P, P !== null && (h.callback = P), c = Mf(V, h, le), c !== null && (Sl(c, V, le, q), _a(c, V, le)), le;
  }
  function zn(c) {
    if (c = c.current, !c.child)
      return null;
    switch (c.child.tag) {
      case 5:
        return c.child.stateNode;
      default:
        return c.child.stateNode;
    }
  }
  function Hu(c, h) {
    if (c = c.memoizedState, c !== null && c.dehydrated !== null) {
      var E = c.retryLane;
      c.retryLane = E !== 0 && E < h ? E : h;
    }
  }
  function zv(c, h) {
    Hu(c, h), (c = c.alternate) && Hu(c, h);
  }
  function tm() {
    return null;
  }
  var Oh = typeof reportError == "function" ? reportError : function(c) {
    console.error(c);
  };
  function oa(c) {
    this._internalRoot = c;
  }
  Rs.prototype.render = oa.prototype.render = function(c) {
    var h = this._internalRoot;
    if (h === null)
      throw Error(t(409));
    Uv(c, h, null, null);
  }, Rs.prototype.unmount = oa.prototype.unmount = function() {
    var c = this._internalRoot;
    if (c !== null) {
      this._internalRoot = null;
      var h = c.containerInfo;
      Dh(function() {
        Uv(null, c, null, null);
      }), h[So] = null;
    }
  };
  function Rs(c) {
    this._internalRoot = c;
  }
  Rs.prototype.unstable_scheduleHydration = function(c) {
    if (c) {
      var h = fs();
      c = { blockedOn: null, target: c, priority: h };
      for (var E = 0; E < Xi.length && h !== 0 && h < Xi[E].priority; E++)
        ;
      Xi.splice(E, 0, c), E === 0 && hl(c);
    }
  };
  function Co(c) {
    return !(!c || c.nodeType !== 1 && c.nodeType !== 9 && c.nodeType !== 11);
  }
  function nm(c) {
    return !(!c || c.nodeType !== 1 && c.nodeType !== 9 && c.nodeType !== 11 && (c.nodeType !== 8 || c.nodeValue !== " react-mount-point-unstable "));
  }
  function Jm() {
  }
  function _p(c, h, E, P, V) {
    if (V) {
      if (typeof P == "function") {
        var q = P;
        P = function() {
          var Dt = zn(le);
          q.call(Dt);
        };
      }
      var le = Tg(h, P, c, 0, null, !1, !1, "", Jm);
      return c._reactRootContainer = le, c[So] = le.current, rl(c.nodeType === 8 ? c.parentNode : c), Dh(), le;
    }
    for (; V = c.lastChild; )
      c.removeChild(V);
    if (typeof P == "function") {
      var Oe = P;
      P = function() {
        var Dt = zn(Ge);
        Oe.call(Dt);
      };
    }
    var Ge = Cs(c, 0, !1, null, null, !1, !1, "", Jm);
    return c._reactRootContainer = Ge, c[So] = Ge.current, rl(c.nodeType === 8 ? c.parentNode : c), Dh(function() {
      Uv(h, Ge, E, P);
    }), Ge;
  }
  function Cg(c, h, E, P, V) {
    var q = E._reactRootContainer;
    if (q) {
      var le = q;
      if (typeof V == "function") {
        var Oe = V;
        V = function() {
          var Ge = zn(le);
          Oe.call(Ge);
        };
      }
      Uv(h, le, c, V);
    } else
      le = _p(E, h, c, V, P);
    return zn(le);
  }
  Xf = function(c) {
    switch (c.tag) {
      case 3:
        var h = c.stateNode;
        if (h.current.memoizedState.isDehydrated) {
          var E = Dl(h.pendingLanes);
          E !== 0 && (Pl(h, E | 1), Jo(h, en()), (zr & 6) === 0 && (fp = en() + 500, ws()));
        }
        break;
      case 13:
        Dh(function() {
          var P = jo(c, 1);
          if (P !== null) {
            var V = ha();
            Sl(P, c, 1, V);
          }
        }), zv(c, 1);
    }
  }, No = function(c) {
    if (c.tag === 13) {
      var h = jo(c, 134217728);
      if (h !== null) {
        var E = ha();
        Sl(h, c, 134217728, E);
      }
      zv(c, 134217728);
    }
  }, Ci = function(c) {
    if (c.tag === 13) {
      var h = ao(c), E = jo(c, h);
      if (E !== null) {
        var P = ha();
        Sl(E, c, h, P);
      }
      zv(c, h);
    }
  }, fs = function() {
    return ei;
  }, qf = function(c, h) {
    var E = ei;
    try {
      return ei = c, h();
    } finally {
      ei = E;
    }
  }, Gt = function(c, h, E) {
    switch (h) {
      case "input":
        if (Vt(c, E), h = E.name, E.type === "radio" && h != null) {
          for (E = c; E.parentNode; )
            E = E.parentNode;
          for (E = E.querySelectorAll("input[name=" + JSON.stringify("" + h) + '][type="radio"]'), h = 0; h < E.length; h++) {
            var P = E[h];
            if (P !== c && P.form === c.form) {
              var V = vr(P);
              if (!V)
                throw Error(t(90));
              Ie(P), Vt(P, V);
            }
          }
        }
        break;
      case "textarea":
        Qe(c, E);
        break;
      case "select":
        h = E.value, h != null && Rt(c, !!E.multiple, h, !1);
    }
  }, Ir = Ah, Bn = Dh;
  var u1 = { usingClientEntryPoint: !1, Events: [ka, Gn, vr, Or, Ii, Ah] }, jt = { findFiberByHostInstance: Ks, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, kf = { bundleType: jt.bundleType, version: jt.version, rendererPackageName: jt.rendererPackageName, rendererConfig: jt.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: B.ReactCurrentDispatcher, findHostInstanceByFiber: function(c) {
    return c = Jn(c), c === null ? null : c.stateNode;
  }, findFiberByHostInstance: jt.findFiberByHostInstance || tm, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var _d = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!_d.isDisabled && _d.supportsFiber)
      try {
        cs = _d.inject(kf), mr = _d;
      } catch {
      }
  }
  return Pp.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = u1, Pp.createPortal = function(c, h) {
    var E = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!Co(h))
      throw Error(t(200));
    return bl(c, h, null, E);
  }, Pp.createRoot = function(c, h) {
    if (!Co(c))
      throw Error(t(299));
    var E = !1, P = "", V = Oh;
    return h != null && (h.unstable_strictMode === !0 && (E = !0), h.identifierPrefix !== void 0 && (P = h.identifierPrefix), h.onRecoverableError !== void 0 && (V = h.onRecoverableError)), h = Cs(c, 1, !1, null, null, E, !1, P, V), c[So] = h.current, rl(c.nodeType === 8 ? c.parentNode : c), new oa(h);
  }, Pp.findDOMNode = function(c) {
    if (c == null)
      return null;
    if (c.nodeType === 1)
      return c;
    var h = c._reactInternals;
    if (h === void 0)
      throw typeof c.render == "function" ? Error(t(188)) : (c = Object.keys(c).join(","), Error(t(268, c)));
    return c = Jn(h), c = c === null ? null : c.stateNode, c;
  }, Pp.flushSync = function(c) {
    return Dh(c);
  }, Pp.hydrate = function(c, h, E) {
    if (!nm(h))
      throw Error(t(200));
    return Cg(null, c, h, !0, E);
  }, Pp.hydrateRoot = function(c, h, E) {
    if (!Co(c))
      throw Error(t(405));
    var P = E != null && E.hydratedSources || null, V = !1, q = "", le = Oh;
    if (E != null && (E.unstable_strictMode === !0 && (V = !0), E.identifierPrefix !== void 0 && (q = E.identifierPrefix), E.onRecoverableError !== void 0 && (le = E.onRecoverableError)), h = Tg(h, null, c, 1, E != null ? E : null, V, !1, q, le), c[So] = h.current, rl(c), P)
      for (c = 0; c < P.length; c++)
        E = P[c], V = E._getVersion, V = V(E._source), h.mutableSourceEagerHydrationData == null ? h.mutableSourceEagerHydrationData = [E, V] : h.mutableSourceEagerHydrationData.push(
          E,
          V
        );
    return new Rs(h);
  }, Pp.render = function(c, h, E) {
    if (!nm(h))
      throw Error(t(200));
    return Cg(null, c, h, !1, E);
  }, Pp.unmountComponentAtNode = function(c) {
    if (!nm(c))
      throw Error(t(40));
    return c._reactRootContainer ? (Dh(function() {
      Cg(null, null, c, !1, function() {
        c._reactRootContainer = null, c[So] = null;
      });
    }), !0) : !1;
  }, Pp.unstable_batchedUpdates = Ah, Pp.unstable_renderSubtreeIntoContainer = function(c, h, E, P) {
    if (!nm(E))
      throw Error(t(200));
    if (c == null || c._reactInternals === void 0)
      throw Error(t(38));
    return Cg(c, h, E, !1, P);
  }, Pp.version = "18.2.0-next-9e3b772b8-20220608", Pp;
}
var Op = {};
/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Cz;
function yj() {
  return Cz || (Cz = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var a = ph, e = Jk(), t = a.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, r = !1;
    function i(n) {
      r = n;
    }
    function s(n) {
      if (!r) {
        for (var o = arguments.length, m = new Array(o > 1 ? o - 1 : 0), S = 1; S < o; S++)
          m[S - 1] = arguments[S];
        d("warn", n, m);
      }
    }
    function l(n) {
      if (!r) {
        for (var o = arguments.length, m = new Array(o > 1 ? o - 1 : 0), S = 1; S < o; S++)
          m[S - 1] = arguments[S];
        d("error", n, m);
      }
    }
    function d(n, o, m) {
      {
        var S = t.ReactDebugCurrentFrame, C = S.getStackAddendum();
        C !== "" && (o += "%s", m = m.concat([C]));
        var F = m.map(function(j) {
          return String(j);
        });
        F.unshift("Warning: " + o), Function.prototype.apply.call(console[n], console, F);
      }
    }
    var p = 0, g = 1, _ = 2, w = 3, T = 4, R = 5, D = 6, O = 7, U = 8, H = 9, I = 10, G = 11, B = 12, Q = 13, K = 14, te = 15, Y = 16, re = 17, se = 18, ce = 19, ue = 21, Me = 22, me = 23, De = 24, Re = 25, He = !0, ve = !1, fe = !1, he = !1, ye = !1, Ee = !0, Ve = !1, Je = !1, rt = !0, Ne = !0, ct = !0, tt = /* @__PURE__ */ new Set(), Tt = {}, gt = {};
    function ft(n, o) {
      Ie(n, o), Ie(n + "Capture", o);
    }
    function Ie(n, o) {
      Tt[n] && l("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", n), Tt[n] = o;
      {
        var m = n.toLowerCase();
        gt[m] = n, n === "onDoubleClick" && (gt.ondblclick = n);
      }
      for (var S = 0; S < o.length; S++)
        tt.add(o[S]);
    }
    var qe = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", dt = Object.prototype.hasOwnProperty;
    function ht(n) {
      {
        var o = typeof Symbol == "function" && Symbol.toStringTag, m = o && n[Symbol.toStringTag] || n.constructor.name || "Object";
        return m;
      }
    }
    function xt(n) {
      try {
        return Vt(n), !1;
      } catch {
        return !0;
      }
    }
    function Vt(n) {
      return "" + n;
    }
    function yt(n, o) {
      if (xt(n))
        return l("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", o, ht(n)), Vt(n);
    }
    function Nt(n) {
      if (xt(n))
        return l("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", ht(n)), Vt(n);
    }
    function Zt(n, o) {
      if (xt(n))
        return l("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", o, ht(n)), Vt(n);
    }
    function Rt(n, o) {
      if (xt(n))
        return l("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", o, ht(n)), Vt(n);
    }
    function we(n) {
      if (xt(n))
        return l("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", ht(n)), Vt(n);
    }
    function oe(n) {
      if (xt(n))
        return l("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", ht(n)), Vt(n);
    }
    var Qe = 0, ut = 1, Ft = 2, Ot = 3, Wt = 4, it = 5, an = 6, Be = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", pe = Be + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", Fe = new RegExp("^[" + Be + "][" + pe + "]*$"), at = {}, st = {};
    function dn(n) {
      return dt.call(st, n) ? !0 : dt.call(at, n) ? !1 : Fe.test(n) ? (st[n] = !0, !0) : (at[n] = !0, l("Invalid attribute name: `%s`", n), !1);
    }
    function ze(n, o, m) {
      return o !== null ? o.type === Qe : m ? !1 : n.length > 2 && (n[0] === "o" || n[0] === "O") && (n[1] === "n" || n[1] === "N");
    }
    function wt(n, o, m, S) {
      if (m !== null && m.type === Qe)
        return !1;
      switch (typeof o) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (S)
            return !1;
          if (m !== null)
            return !m.acceptsBooleans;
          var C = n.toLowerCase().slice(0, 5);
          return C !== "data-" && C !== "aria-";
        }
        default:
          return !1;
      }
    }
    function Pe(n, o, m, S) {
      if (o === null || typeof o > "u" || wt(n, o, m, S))
        return !0;
      if (S)
        return !1;
      if (m !== null)
        switch (m.type) {
          case Ot:
            return !o;
          case Wt:
            return o === !1;
          case it:
            return isNaN(o);
          case an:
            return isNaN(o) || o < 1;
        }
      return !1;
    }
    function Gt(n) {
      return cn.hasOwnProperty(n) ? cn[n] : null;
    }
    function At(n, o, m, S, C, F, j) {
      this.acceptsBooleans = o === Ft || o === Ot || o === Wt, this.attributeName = S, this.attributeNamespace = C, this.mustUseProperty = m, this.propertyName = n, this.type = o, this.sanitizeURL = F, this.removeEmptyString = j;
    }
    var cn = {}, ki = [
      "children",
      "dangerouslySetInnerHTML",
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    ki.forEach(function(n) {
      cn[n] = new At(
        n,
        Qe,
        !1,
        n,
        null,
        !1,
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(n) {
      var o = n[0], m = n[1];
      cn[o] = new At(
        o,
        ut,
        !1,
        m,
        null,
        !1,
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(n) {
      cn[n] = new At(
        n,
        Ft,
        !1,
        n.toLowerCase(),
        null,
        !1,
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(n) {
      cn[n] = new At(
        n,
        Ft,
        !1,
        n,
        null,
        !1,
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      "itemScope"
    ].forEach(function(n) {
      cn[n] = new At(
        n,
        Ot,
        !1,
        n.toLowerCase(),
        null,
        !1,
        !1
      );
    }), [
      "checked",
      "multiple",
      "muted",
      "selected"
    ].forEach(function(n) {
      cn[n] = new At(
        n,
        Ot,
        !0,
        n,
        null,
        !1,
        !1
      );
    }), [
      "capture",
      "download"
    ].forEach(function(n) {
      cn[n] = new At(
        n,
        Wt,
        !1,
        n,
        null,
        !1,
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
    ].forEach(function(n) {
      cn[n] = new At(
        n,
        an,
        !1,
        n,
        null,
        !1,
        !1
      );
    }), ["rowSpan", "start"].forEach(function(n) {
      cn[n] = new At(
        n,
        it,
        !1,
        n.toLowerCase(),
        null,
        !1,
        !1
      );
    });
    var Or = /[\-\:]([a-z])/g, Ii = function(n) {
      return n[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
    ].forEach(function(n) {
      var o = n.replace(Or, Ii);
      cn[o] = new At(
        o,
        ut,
        !1,
        n,
        null,
        !1,
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
    ].forEach(function(n) {
      var o = n.replace(Or, Ii);
      cn[o] = new At(
        o,
        ut,
        !1,
        n,
        "http://www.w3.org/1999/xlink",
        !1,
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
    ].forEach(function(n) {
      var o = n.replace(Or, Ii);
      cn[o] = new At(
        o,
        ut,
        !1,
        n,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(n) {
      cn[n] = new At(
        n,
        ut,
        !1,
        n.toLowerCase(),
        null,
        !1,
        !1
      );
    });
    var Ir = "xlinkHref";
    cn[Ir] = new At(
      "xlinkHref",
      ut,
      !1,
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(n) {
      cn[n] = new At(
        n,
        ut,
        !1,
        n.toLowerCase(),
        null,
        !0,
        !0
      );
    });
    var Bn = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, Mi = !1;
    function yi(n) {
      !Mi && Bn.test(n) && (Mi = !0, l("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(n)));
    }
    function ii(n, o, m, S) {
      if (S.mustUseProperty) {
        var C = S.propertyName;
        return n[C];
      } else {
        yt(m, o), S.sanitizeURL && yi("" + m);
        var F = S.attributeName, j = null;
        if (S.type === Wt) {
          if (n.hasAttribute(F)) {
            var J = n.getAttribute(F);
            return J === "" ? !0 : Pe(o, m, S, !1) ? J : J === "" + m ? m : J;
          }
        } else if (n.hasAttribute(F)) {
          if (Pe(o, m, S, !1))
            return n.getAttribute(F);
          if (S.type === Ot)
            return m;
          j = n.getAttribute(F);
        }
        return Pe(o, m, S, !1) ? j === null ? m : j : j === "" + m ? m : j;
      }
    }
    function Bi(n, o, m, S) {
      {
        if (!dn(o))
          return;
        if (!n.hasAttribute(o))
          return m === void 0 ? void 0 : null;
        var C = n.getAttribute(o);
        return yt(m, o), C === "" + m ? m : C;
      }
    }
    function xi(n, o, m, S) {
      var C = Gt(o);
      if (!ze(o, C, S)) {
        if (Pe(o, m, C, S) && (m = null), S || C === null) {
          if (dn(o)) {
            var F = o;
            m === null ? n.removeAttribute(F) : (yt(m, o), n.setAttribute(F, "" + m));
          }
          return;
        }
        var j = C.mustUseProperty;
        if (j) {
          var J = C.propertyName;
          if (m === null) {
            var ne = C.type;
            n[J] = ne === Ot ? !1 : "";
          } else
            n[J] = m;
          return;
        }
        var Se = C.attributeName, Ce = C.attributeNamespace;
        if (m === null)
          n.removeAttribute(Se);
        else {
          var nt = C.type, et;
          nt === Ot || nt === Wt && m === !0 ? et = "" : (yt(m, Se), et = "" + m, C.sanitizeURL && yi(et.toString())), Ce ? n.setAttributeNS(Ce, Se, et) : n.setAttribute(Se, et);
        }
      }
    }
    var $r = Symbol.for("react.element"), ai = Symbol.for("react.portal"), Te = Symbol.for("react.fragment"), ot = Symbol.for("react.strict_mode"), de = Symbol.for("react.profiler"), Le = Symbol.for("react.provider"), Ye = Symbol.for("react.context"), $t = Symbol.for("react.forward_ref"), mn = Symbol.for("react.suspense"), Rn = Symbol.for("react.suspense_list"), gn = Symbol.for("react.memo"), yn = Symbol.for("react.lazy"), Jn = Symbol.for("react.scope"), rr = Symbol.for("react.debug_trace_mode"), wr = Symbol.for("react.offscreen"), Yi = Symbol.for("react.legacy_hidden"), La = Symbol.for("react.cache"), qs = Symbol.for("react.tracing_marker"), en = Symbol.iterator, Xr = "@@iterator";
    function us(n) {
      if (n === null || typeof n != "object")
        return null;
      var o = en && n[en] || n[Xr];
      return typeof o == "function" ? o : null;
    }
    var qn = Object.assign, qa = 0, mo, Ls, cs, mr, di, Ea, Si;
    function Ti() {
    }
    Ti.__reactDisabledLog = !0;
    function Uo() {
      {
        if (qa === 0) {
          mo = console.log, Ls = console.info, cs = console.warn, mr = console.error, di = console.group, Ea = console.groupCollapsed, Si = console.groupEnd;
          var n = {
            configurable: !0,
            enumerable: !0,
            value: Ti,
            writable: !0
          };
          Object.defineProperties(console, {
            info: n,
            log: n,
            warn: n,
            error: n,
            group: n,
            groupCollapsed: n,
            groupEnd: n
          });
        }
        qa++;
      }
    }
    function zo() {
      {
        if (qa--, qa === 0) {
          var n = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: qn({}, n, {
              value: mo
            }),
            info: qn({}, n, {
              value: Ls
            }),
            warn: qn({}, n, {
              value: cs
            }),
            error: qn({}, n, {
              value: mr
            }),
            group: qn({}, n, {
              value: di
            }),
            groupCollapsed: qn({}, n, {
              value: Ea
            }),
            groupEnd: qn({}, n, {
              value: Si
            })
          });
        }
        qa < 0 && l("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Pa = t.ReactCurrentDispatcher, Dl;
    function vo(n, o, m) {
      {
        if (Dl === void 0)
          try {
            throw Error();
          } catch (C) {
            var S = C.stack.trim().match(/\n( *(at )?)/);
            Dl = S && S[1] || "";
          }
        return `
` + Dl + n;
      }
    }
    var Yf = !1, Ll;
    {
      var Nd = typeof WeakMap == "function" ? WeakMap : Map;
      Ll = new Nd();
    }
    function Ps(n, o) {
      if (!n || Yf)
        return "";
      {
        var m = Ll.get(n);
        if (m !== void 0)
          return m;
      }
      var S;
      Yf = !0;
      var C = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var F;
      F = Pa.current, Pa.current = null, Uo();
      try {
        if (o) {
          var j = function() {
            throw Error();
          };
          if (Object.defineProperty(j.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(j, []);
            } catch (Ut) {
              S = Ut;
            }
            Reflect.construct(n, [], j);
          } else {
            try {
              j.call();
            } catch (Ut) {
              S = Ut;
            }
            n.call(j.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Ut) {
            S = Ut;
          }
          n();
        }
      } catch (Ut) {
        if (Ut && S && typeof Ut.stack == "string") {
          for (var J = Ut.stack.split(`
`), ne = S.stack.split(`
`), Se = J.length - 1, Ce = ne.length - 1; Se >= 1 && Ce >= 0 && J[Se] !== ne[Ce]; )
            Ce--;
          for (; Se >= 1 && Ce >= 0; Se--, Ce--)
            if (J[Se] !== ne[Ce]) {
              if (Se !== 1 || Ce !== 1)
                do
                  if (Se--, Ce--, Ce < 0 || J[Se] !== ne[Ce]) {
                    var nt = `
` + J[Se].replace(" at new ", " at ");
                    return n.displayName && nt.includes("<anonymous>") && (nt = nt.replace("<anonymous>", n.displayName)), typeof n == "function" && Ll.set(n, nt), nt;
                  }
                while (Se >= 1 && Ce >= 0);
              break;
            }
        }
      } finally {
        Yf = !1, Pa.current = F, zo(), Error.prepareStackTrace = C;
      }
      var et = n ? n.displayName || n.name : "", Pt = et ? vo(et) : "";
      return typeof n == "function" && Ll.set(n, Pt), Pt;
    }
    function Ju(n, o, m) {
      return Ps(n, !0);
    }
    function ou(n, o, m) {
      return Ps(n, !1);
    }
    function Jh(n) {
      var o = n.prototype;
      return !!(o && o.isReactComponent);
    }
    function Pl(n, o, m) {
      if (n == null)
        return "";
      if (typeof n == "function")
        return Ps(n, Jh(n));
      if (typeof n == "string")
        return vo(n);
      switch (n) {
        case mn:
          return vo("Suspense");
        case Rn:
          return vo("SuspenseList");
      }
      if (typeof n == "object")
        switch (n.$$typeof) {
          case $t:
            return ou(n.render);
          case gn:
            return Pl(n.type, o, m);
          case yn: {
            var S = n, C = S._payload, F = S._init;
            try {
              return Pl(F(C), o, m);
            } catch {
            }
          }
        }
      return "";
    }
    function ei(n) {
      switch (n._debugOwner && n._debugOwner.type, n._debugSource, n.tag) {
        case R:
          return vo(n.type);
        case Y:
          return vo("Lazy");
        case Q:
          return vo("Suspense");
        case ce:
          return vo("SuspenseList");
        case p:
        case _:
        case te:
          return ou(n.type);
        case G:
          return ou(n.type.render);
        case g:
          return Ju(n.type);
        default:
          return "";
      }
    }
    function go(n) {
      try {
        var o = "", m = n;
        do
          o += ei(m), m = m.return;
        while (m);
        return o;
      } catch (S) {
        return `
Error generating stack: ` + S.message + `
` + S.stack;
      }
    }
    function Xf(n, o, m) {
      var S = n.displayName;
      if (S)
        return S;
      var C = o.displayName || o.name || "";
      return C !== "" ? m + "(" + C + ")" : m;
    }
    function No(n) {
      return n.displayName || "Context";
    }
    function Ci(n) {
      if (n == null)
        return null;
      if (typeof n.tag == "number" && l("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof n == "function")
        return n.displayName || n.name || null;
      if (typeof n == "string")
        return n;
      switch (n) {
        case Te:
          return "Fragment";
        case ai:
          return "Portal";
        case de:
          return "Profiler";
        case ot:
          return "StrictMode";
        case mn:
          return "Suspense";
        case Rn:
          return "SuspenseList";
      }
      if (typeof n == "object")
        switch (n.$$typeof) {
          case Ye:
            var o = n;
            return No(o) + ".Consumer";
          case Le:
            var m = n;
            return No(m._context) + ".Provider";
          case $t:
            return Xf(n, n.render, "ForwardRef");
          case gn:
            var S = n.displayName || null;
            return S !== null ? S : Ci(n.type) || "Memo";
          case yn: {
            var C = n, F = C._payload, j = C._init;
            try {
              return Ci(j(F));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function fs(n, o, m) {
      var S = o.displayName || o.name || "";
      return n.displayName || (S !== "" ? m + "(" + S + ")" : m);
    }
    function qf(n) {
      return n.displayName || "Context";
    }
    function xr(n) {
      var o = n.tag, m = n.type;
      switch (o) {
        case De:
          return "Cache";
        case H:
          var S = m;
          return qf(S) + ".Consumer";
        case I:
          var C = m;
          return qf(C._context) + ".Provider";
        case se:
          return "DehydratedFragment";
        case G:
          return fs(m, m.render, "ForwardRef");
        case O:
          return "Fragment";
        case R:
          return m;
        case T:
          return "Portal";
        case w:
          return "Root";
        case D:
          return "Text";
        case Y:
          return Ci(m);
        case U:
          return m === ot ? "StrictMode" : "Mode";
        case Me:
          return "Offscreen";
        case B:
          return "Profiler";
        case ue:
          return "Scope";
        case Q:
          return "Suspense";
        case ce:
          return "SuspenseList";
        case Re:
          return "TracingMarker";
        case g:
        case p:
        case re:
        case _:
        case K:
        case te:
          if (typeof m == "function")
            return m.displayName || m.name || null;
          if (typeof m == "string")
            return m;
          break;
      }
      return null;
    }
    var Tu = t.ReactDebugCurrentFrame, ua = null, Cr = !1;
    function dl() {
      {
        if (ua === null)
          return null;
        var n = ua._debugOwner;
        if (n !== null && typeof n < "u")
          return xr(n);
      }
      return null;
    }
    function yo() {
      return ua === null ? "" : go(ua);
    }
    function Ka() {
      Tu.getCurrentStack = null, ua = null, Cr = !1;
    }
    function Xi(n) {
      Tu.getCurrentStack = n === null ? null : yo, ua = n, Cr = !1;
    }
    function Lm() {
      return ua;
    }
    function hi(n) {
      Cr = n;
    }
    function Qa(n) {
      return "" + n;
    }
    function Sc(n) {
      switch (typeof n) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return n;
        case "object":
          return oe(n), n;
        default:
          return "";
      }
    }
    var hl = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function pf(n, o) {
      hl[o.type] || o.onChange || o.onInput || o.readOnly || o.disabled || o.value == null || l("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), o.onChange || o.readOnly || o.disabled || o.checked == null || l("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function mf(n) {
      var o = n.type, m = n.nodeName;
      return m && m.toLowerCase() === "input" && (o === "checkbox" || o === "radio");
    }
    function lu(n) {
      return n._valueTracker;
    }
    function Hi(n) {
      n._valueTracker = null;
    }
    function Ri(n) {
      var o = "";
      return n && (mf(n) ? o = n.checked ? "true" : "false" : o = n.value), o;
    }
    function Fo(n) {
      var o = mf(n) ? "checked" : "value", m = Object.getOwnPropertyDescriptor(n.constructor.prototype, o);
      oe(n[o]);
      var S = "" + n[o];
      if (!(n.hasOwnProperty(o) || typeof m > "u" || typeof m.get != "function" || typeof m.set != "function")) {
        var C = m.get, F = m.set;
        Object.defineProperty(n, o, {
          configurable: !0,
          get: function() {
            return C.call(this);
          },
          set: function(J) {
            oe(J), S = "" + J, F.call(this, J);
          }
        }), Object.defineProperty(n, o, {
          enumerable: m.enumerable
        });
        var j = {
          getValue: function() {
            return S;
          },
          setValue: function(J) {
            oe(J), S = "" + J;
          },
          stopTracking: function() {
            Hi(n), delete n[o];
          }
        };
        return j;
      }
    }
    function Os(n) {
      lu(n) || (n._valueTracker = Fo(n));
    }
    function wc(n) {
      if (!n)
        return !1;
      var o = lu(n);
      if (!o)
        return !0;
      var m = o.getValue(), S = Ri(n);
      return S !== m ? (o.setValue(S), !0) : !1;
    }
    function Ol(n) {
      if (n = n || (typeof document < "u" ? document : void 0), typeof n > "u")
        return null;
      try {
        return n.activeElement || n.body;
      } catch {
        return n.body;
      }
    }
    var Qf = !1, Zf = !1, ko = !1, Jf = !1;
    function Ki(n) {
      var o = n.type === "checkbox" || n.type === "radio";
      return o ? n.checked != null : n.value != null;
    }
    function Cu(n, o) {
      var m = n, S = o.checked, C = qn({}, o, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: S != null ? S : m._wrapperState.initialChecked
      });
      return C;
    }
    function Oa(n, o) {
      pf("input", o), o.checked !== void 0 && o.defaultChecked !== void 0 && !Zf && (l("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", dl() || "A component", o.type), Zf = !0), o.value !== void 0 && o.defaultValue !== void 0 && !Qf && (l("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", dl() || "A component", o.type), Qf = !0);
      var m = n, S = o.defaultValue == null ? "" : o.defaultValue;
      m._wrapperState = {
        initialChecked: o.checked != null ? o.checked : o.defaultChecked,
        initialValue: Sc(o.value != null ? o.value : S),
        controlled: Ki(o)
      };
    }
    function xs(n, o) {
      var m = n, S = o.checked;
      S != null && xi(m, "checked", S, !1);
    }
    function uu(n, o) {
      var m = n;
      {
        var S = Ki(o);
        !m._wrapperState.controlled && S && !Jf && (l("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), Jf = !0), m._wrapperState.controlled && !S && !ko && (l("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), ko = !0);
      }
      xs(n, o);
      var C = Sc(o.value), F = o.type;
      if (C != null)
        F === "number" ? (C === 0 && m.value === "" || m.value != C) && (m.value = Qa(C)) : m.value !== Qa(C) && (m.value = Qa(C));
      else if (F === "submit" || F === "reset") {
        m.removeAttribute("value");
        return;
      }
      o.hasOwnProperty("value") ? Ru(m, o.type, C) : o.hasOwnProperty("defaultValue") && Ru(m, o.type, Sc(o.defaultValue)), o.checked == null && o.defaultChecked != null && (m.defaultChecked = !!o.defaultChecked);
    }
    function Ua(n, o, m) {
      var S = n;
      if (o.hasOwnProperty("value") || o.hasOwnProperty("defaultValue")) {
        var C = o.type, F = C === "submit" || C === "reset";
        if (F && (o.value === void 0 || o.value === null))
          return;
        var j = Qa(S._wrapperState.initialValue);
        m || j !== S.value && (S.value = j), S.defaultValue = j;
      }
      var J = S.name;
      J !== "" && (S.name = ""), S.defaultChecked = !S.defaultChecked, S.defaultChecked = !!S._wrapperState.initialChecked, J !== "" && (S.name = J);
    }
    function bc(n, o) {
      var m = n;
      uu(m, o), xo(m, o);
    }
    function xo(n, o) {
      var m = o.name;
      if (o.type === "radio" && m != null) {
        for (var S = n; S.parentNode; )
          S = S.parentNode;
        yt(m, "name");
        for (var C = S.querySelectorAll("input[name=" + JSON.stringify("" + m) + '][type="radio"]'), F = 0; F < C.length; F++) {
          var j = C[F];
          if (!(j === n || j.form !== n.form)) {
            var J = dr(j);
            if (!J)
              throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
            wc(j), uu(j, J);
          }
        }
      }
    }
    function Ru(n, o, m) {
      (o !== "number" || Ol(n.ownerDocument) !== n) && (m == null ? n.defaultValue = Qa(n._wrapperState.initialValue) : n.defaultValue !== Qa(m) && (n.defaultValue = Qa(m)));
    }
    var Ul = !1, za = !1, Qs = !1;
    function qr(n, o) {
      o.value == null && (typeof o.children == "object" && o.children !== null ? a.Children.forEach(o.children, function(m) {
        m != null && (typeof m == "string" || typeof m == "number" || za || (za = !0, l("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }) : o.dangerouslySetInnerHTML != null && (Qs || (Qs = !0, l("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")))), o.selected != null && !Ul && (l("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), Ul = !0);
    }
    function _s(n, o) {
      o.value != null && n.setAttribute("value", Qa(Sc(o.value)));
    }
    var va = Array.isArray;
    function Zs(n) {
      return va(n);
    }
    var Kf;
    Kf = !1;
    function el() {
      var n = dl();
      return n ? `

Check the render method of \`` + n + "`." : "";
    }
    var Ku = ["value", "defaultValue"];
    function Kh(n) {
      {
        pf("select", n);
        for (var o = 0; o < Ku.length; o++) {
          var m = Ku[o];
          if (n[m] != null) {
            var S = Zs(n[m]);
            n.multiple && !S ? l("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", m, el()) : !n.multiple && S && l("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", m, el());
          }
        }
      }
    }
    function qi(n, o, m, S) {
      var C = n.options;
      if (o) {
        for (var F = m, j = {}, J = 0; J < F.length; J++)
          j["$" + F[J]] = !0;
        for (var ne = 0; ne < C.length; ne++) {
          var Se = j.hasOwnProperty("$" + C[ne].value);
          C[ne].selected !== Se && (C[ne].selected = Se), Se && S && (C[ne].defaultSelected = !0);
        }
      } else {
        for (var Ce = Qa(Sc(m)), nt = null, et = 0; et < C.length; et++) {
          if (C[et].value === Ce) {
            C[et].selected = !0, S && (C[et].defaultSelected = !0);
            return;
          }
          nt === null && !C[et].disabled && (nt = C[et]);
        }
        nt !== null && (nt.selected = !0);
      }
    }
    function Au(n, o) {
      return qn({}, o, {
        value: void 0
      });
    }
    function Fp(n, o) {
      var m = n;
      Kh(o), m._wrapperState = {
        wasMultiple: !!o.multiple
      }, o.value !== void 0 && o.defaultValue !== void 0 && !Kf && (l("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Kf = !0);
    }
    function pg(n, o) {
      var m = n;
      m.multiple = !!o.multiple;
      var S = o.value;
      S != null ? qi(m, !!o.multiple, S, !1) : o.defaultValue != null && qi(m, !!o.multiple, o.defaultValue, !0);
    }
    function $h(n, o) {
      var m = n, S = m._wrapperState.wasMultiple;
      m._wrapperState.wasMultiple = !!o.multiple;
      var C = o.value;
      C != null ? qi(m, !!o.multiple, C, !1) : S !== !!o.multiple && (o.defaultValue != null ? qi(m, !!o.multiple, o.defaultValue, !0) : qi(m, !!o.multiple, o.multiple ? [] : "", !1));
    }
    function Pm(n, o) {
      var m = n, S = o.value;
      S != null && qi(m, !!o.multiple, S, !1);
    }
    var Om = !1;
    function Um(n, o) {
      var m = n;
      if (o.dangerouslySetInnerHTML != null)
        throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
      var S = qn({}, o, {
        value: void 0,
        defaultValue: void 0,
        children: Qa(m._wrapperState.initialValue)
      });
      return S;
    }
    function zm(n, o) {
      var m = n;
      pf("textarea", o), o.value !== void 0 && o.defaultValue !== void 0 && !Om && (l("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", dl() || "A component"), Om = !0);
      var S = o.value;
      if (S == null) {
        var C = o.children, F = o.defaultValue;
        if (C != null) {
          l("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
          {
            if (F != null)
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if (Zs(C)) {
              if (C.length > 1)
                throw new Error("<textarea> can only have at most one child.");
              C = C[0];
            }
            F = C;
          }
        }
        F == null && (F = ""), S = F;
      }
      m._wrapperState = {
        initialValue: Sc(S)
      };
    }
    function gh(n, o) {
      var m = n, S = Sc(o.value), C = Sc(o.defaultValue);
      if (S != null) {
        var F = Qa(S);
        F !== m.value && (m.value = F), o.defaultValue == null && m.defaultValue !== F && (m.defaultValue = F);
      }
      C != null && (m.defaultValue = Qa(C));
    }
    function $u(n, o) {
      var m = n, S = m.textContent;
      S === m._wrapperState.initialValue && S !== "" && S !== null && (m.value = S);
    }
    function Fd(n, o) {
      gh(n, o);
    }
    var Du = "http://www.w3.org/1999/xhtml", kp = "http://www.w3.org/1998/Math/MathML", pl = "http://www.w3.org/2000/svg";
    function tl(n) {
      switch (n) {
        case "svg":
          return pl;
        case "math":
          return kp;
        default:
          return Du;
      }
    }
    function vf(n, o) {
      return n == null || n === Du ? tl(o) : n === pl && o === "foreignObject" ? Du : n;
    }
    var $f = function(n) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(o, m, S, C) {
        MSApp.execUnsafeLocalFunction(function() {
          return n(o, m, S, C);
        });
      } : n;
    }, cu, gf = $f(function(n, o) {
      if (n.namespaceURI === pl && !("innerHTML" in n)) {
        cu = cu || document.createElement("div"), cu.innerHTML = "<svg>" + o.valueOf().toString() + "</svg>";
        for (var m = cu.firstChild; n.firstChild; )
          n.removeChild(n.firstChild);
        for (; m.firstChild; )
          n.appendChild(m.firstChild);
        return;
      }
      n.innerHTML = o;
    }), zl = 1, ec = 3, Oi = 8, Za = 9, Ma = 11, ca = function(n, o) {
      if (o) {
        var m = n.firstChild;
        if (m && m === n.lastChild && m.nodeType === ec) {
          m.nodeValue = o;
          return;
        }
      }
      n.textContent = o;
    }, kd = {
      animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
      background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
      backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
      border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
      borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
      borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
      borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
      borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
      borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
      borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
      borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
      borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
      borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
      borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
      borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
      columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
      columns: ["columnCount", "columnWidth"],
      flex: ["flexBasis", "flexGrow", "flexShrink"],
      flexFlow: ["flexDirection", "flexWrap"],
      font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
      fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
      gap: ["columnGap", "rowGap"],
      grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
      gridColumn: ["gridColumnEnd", "gridColumnStart"],
      gridColumnGap: ["columnGap"],
      gridGap: ["columnGap", "rowGap"],
      gridRow: ["gridRowEnd", "gridRowStart"],
      gridRowGap: ["rowGap"],
      gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
      margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
      marker: ["markerEnd", "markerMid", "markerStart"],
      mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
      maskPosition: ["maskPositionX", "maskPositionY"],
      outline: ["outlineColor", "outlineStyle", "outlineWidth"],
      overflow: ["overflowX", "overflowY"],
      padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
      placeContent: ["alignContent", "justifyContent"],
      placeItems: ["alignItems", "justifyItems"],
      placeSelf: ["alignSelf", "justifySelf"],
      textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
      textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
      transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
      wordWrap: ["overflowWrap"]
    }, nl = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function Nm(n, o) {
      return n + o.charAt(0).toUpperCase() + o.substring(1);
    }
    var Fm = ["Webkit", "ms", "Moz", "O"];
    Object.keys(nl).forEach(function(n) {
      Fm.forEach(function(o) {
        nl[Nm(o, n)] = nl[n];
      });
    });
    function yh(n, o, m) {
      var S = o == null || typeof o == "boolean" || o === "";
      return S ? "" : !m && typeof o == "number" && o !== 0 && !(nl.hasOwnProperty(n) && nl[n]) ? o + "px" : (Rt(o, n), ("" + o).trim());
    }
    var ed = /([A-Z])/g, Id = /^ms-/;
    function Ip(n) {
      return n.replace(ed, "-$1").toLowerCase().replace(Id, "-ms-");
    }
    var xh = function() {
    };
    {
      var Bd = /^(?:webkit|moz|o)[A-Z]/, td = /^-ms-/, Ss = /-(.)/g, tc = /;\s*$/, yf = {}, Ec = {}, Bp = !1, nc = !1, Na = function(n) {
        return n.replace(Ss, function(o, m) {
          return m.toUpperCase();
        });
      }, Hd = function(n) {
        yf.hasOwnProperty(n) && yf[n] || (yf[n] = !0, l(
          "Unsupported style property %s. Did you mean %s?",
          n,
          Na(n.replace(td, "ms-"))
        ));
      }, nd = function(n) {
        yf.hasOwnProperty(n) && yf[n] || (yf[n] = !0, l("Unsupported vendor-prefixed style property %s. Did you mean %s?", n, n.charAt(0).toUpperCase() + n.slice(1)));
      }, rc = function(n, o) {
        Ec.hasOwnProperty(o) && Ec[o] || (Ec[o] = !0, l(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, n, o.replace(tc, "")));
      }, Hp = function(n, o) {
        Bp || (Bp = !0, l("`NaN` is an invalid value for the `%s` css style property.", n));
      }, _h = function(n, o) {
        nc || (nc = !0, l("`Infinity` is an invalid value for the `%s` css style property.", n));
      };
      xh = function(n, o) {
        n.indexOf("-") > -1 ? Hd(n) : Bd.test(n) ? nd(n) : tc.test(o) && rc(n, o), typeof o == "number" && (isNaN(o) ? Hp(n, o) : isFinite(o) || _h(n, o));
      };
    }
    var Vp = xh;
    function Io(n) {
      {
        var o = "", m = "";
        for (var S in n)
          if (!!n.hasOwnProperty(S)) {
            var C = n[S];
            if (C != null) {
              var F = S.indexOf("--") === 0;
              o += m + (F ? S : Ip(S)) + ":", o += yh(S, C, F), m = ";";
            }
          }
        return o || null;
      }
    }
    function Xe(n, o) {
      var m = n.style;
      for (var S in o)
        if (!!o.hasOwnProperty(S)) {
          var C = S.indexOf("--") === 0;
          C || Vp(S, o[S]);
          var F = yh(S, o[S], C);
          S === "float" && (S = "cssFloat"), C ? m.setProperty(S, F) : m[S] = F;
        }
    }
    function Bt(n) {
      return n == null || typeof n == "boolean" || n === "";
    }
    function vt(n) {
      var o = {};
      for (var m in n)
        for (var S = kd[m] || [m], C = 0; C < S.length; C++)
          o[S[C]] = m;
      return o;
    }
    function Mn(n, o) {
      {
        if (!o)
          return;
        var m = vt(n), S = vt(o), C = {};
        for (var F in m) {
          var j = m[F], J = S[F];
          if (J && j !== J) {
            var ne = j + "," + J;
            if (C[ne])
              continue;
            C[ne] = !0, l("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", Bt(n[j]) ? "Removing" : "Updating", j, J);
          }
        }
      }
    }
    var $n = {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0
    }, or = qn({
      menuitem: !0
    }, $n), Ta = "__html";
    function er(n, o) {
      if (!!o) {
        if (or[n] && (o.children != null || o.dangerouslySetInnerHTML != null))
          throw new Error(n + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
        if (o.dangerouslySetInnerHTML != null) {
          if (o.children != null)
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof o.dangerouslySetInnerHTML != "object" || !(Ta in o.dangerouslySetInnerHTML))
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        }
        if (!o.suppressContentEditableWarning && o.contentEditable && o.children != null && l("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), o.style != null && typeof o.style != "object")
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      }
    }
    function Ui(n, o) {
      if (n.indexOf("-") === -1)
        return typeof o.is == "string";
      switch (n) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var ia = {
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, Bo = {
      "aria-current": 0,
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      "aria-hidden": 0,
      "aria-invalid": 0,
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, ds = {}, Vd = new RegExp("^(aria)-[" + pe + "]*$"), Nl = new RegExp("^(aria)[A-Z][" + pe + "]*$");
    function $a(n, o) {
      {
        if (dt.call(ds, o) && ds[o])
          return !0;
        if (Nl.test(o)) {
          var m = "aria-" + o.slice(4).toLowerCase(), S = Bo.hasOwnProperty(m) ? m : null;
          if (S == null)
            return l("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", o), ds[o] = !0, !0;
          if (o !== S)
            return l("Invalid ARIA attribute `%s`. Did you mean `%s`?", o, S), ds[o] = !0, !0;
        }
        if (Vd.test(o)) {
          var C = o.toLowerCase(), F = Bo.hasOwnProperty(C) ? C : null;
          if (F == null)
            return ds[o] = !0, !1;
          if (o !== F)
            return l("Unknown ARIA attribute `%s`. Did you mean `%s`?", o, F), ds[o] = !0, !0;
        }
      }
      return !0;
    }
    function ml(n, o) {
      {
        var m = [];
        for (var S in o) {
          var C = $a(n, S);
          C || m.push(S);
        }
        var F = m.map(function(j) {
          return "`" + j + "`";
        }).join(", ");
        m.length === 1 ? l("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", F, n) : m.length > 1 && l("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", F, n);
      }
    }
    function _i(n, o) {
      Ui(n, o) || ml(n, o);
    }
    var Mc = !1;
    function Lu(n, o) {
      {
        if (n !== "input" && n !== "textarea" && n !== "select")
          return;
        o != null && o.value === null && !Mc && (Mc = !0, n === "select" && o.multiple ? l("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", n) : l("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", n));
      }
    }
    var vl = function() {
    };
    {
      var Ca = {}, Sh = /^on./, Gp = /^on[^A-Z]/, Tc = new RegExp("^(aria)-[" + pe + "]*$"), Cc = new RegExp("^(aria)[A-Z][" + pe + "]*$");
      vl = function(n, o, m, S) {
        if (dt.call(Ca, o) && Ca[o])
          return !0;
        var C = o.toLowerCase();
        if (C === "onfocusin" || C === "onfocusout")
          return l("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), Ca[o] = !0, !0;
        if (S != null) {
          var F = S.registrationNameDependencies, j = S.possibleRegistrationNames;
          if (F.hasOwnProperty(o))
            return !0;
          var J = j.hasOwnProperty(C) ? j[C] : null;
          if (J != null)
            return l("Invalid event handler property `%s`. Did you mean `%s`?", o, J), Ca[o] = !0, !0;
          if (Sh.test(o))
            return l("Unknown event handler property `%s`. It will be ignored.", o), Ca[o] = !0, !0;
        } else if (Sh.test(o))
          return Gp.test(o) && l("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", o), Ca[o] = !0, !0;
        if (Tc.test(o) || Cc.test(o))
          return !0;
        if (C === "innerhtml")
          return l("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), Ca[o] = !0, !0;
        if (C === "aria")
          return l("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), Ca[o] = !0, !0;
        if (C === "is" && m !== null && m !== void 0 && typeof m != "string")
          return l("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof m), Ca[o] = !0, !0;
        if (typeof m == "number" && isNaN(m))
          return l("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", o), Ca[o] = !0, !0;
        var ne = Gt(o), Se = ne !== null && ne.type === Qe;
        if (ia.hasOwnProperty(C)) {
          var Ce = ia[C];
          if (Ce !== o)
            return l("Invalid DOM property `%s`. Did you mean `%s`?", o, Ce), Ca[o] = !0, !0;
        } else if (!Se && o !== C)
          return l("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", o, C), Ca[o] = !0, !0;
        return typeof m == "boolean" && wt(o, m, ne, !1) ? (m ? l('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', m, o, o, m, o) : l('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', m, o, o, m, o, o, o), Ca[o] = !0, !0) : Se ? !0 : wt(o, m, ne, !1) ? (Ca[o] = !0, !1) : ((m === "false" || m === "true") && ne !== null && ne.type === Ot && (l("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", m, o, m === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', o, m), Ca[o] = !0), !0);
      };
    }
    var Mr = function(n, o, m) {
      {
        var S = [];
        for (var C in o) {
          var F = vl(n, C, o[C], m);
          F || S.push(C);
        }
        var j = S.map(function(J) {
          return "`" + J + "`";
        }).join(", ");
        S.length === 1 ? l("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", j, n) : S.length > 1 && l("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", j, n);
      }
    };
    function $i(n, o, m) {
      Ui(n, o) || Mr(n, o, m);
    }
    var Br = 1, Fa = 1 << 1, _o = 1 << 2, rd = Br | Fa | _o, wh = null;
    function ic(n) {
      wh !== null && l("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."), wh = n;
    }
    function xf() {
      wh === null && l("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."), wh = null;
    }
    function id(n) {
      return n === wh;
    }
    function sn(n) {
      var o = n.target || n.srcElement || window;
      return o.correspondingUseElement && (o = o.correspondingUseElement), o.nodeType === ec ? o.parentNode : o;
    }
    var kr = null, Hr = null, Ho = null;
    function rl(n) {
      var o = Cn(n);
      if (!!o) {
        if (typeof kr != "function")
          throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
        var m = o.stateNode;
        if (m) {
          var S = dr(m);
          kr(o.stateNode, o.type, S);
        }
      }
    }
    function ac(n) {
      kr = n;
    }
    function Pu(n) {
      Hr ? Ho ? Ho.push(n) : Ho = [n] : Hr = n;
    }
    function Rc() {
      return Hr !== null || Ho !== null;
    }
    function _f() {
      if (!!Hr) {
        var n = Hr, o = Ho;
        if (Hr = null, Ho = null, rl(n), o)
          for (var m = 0; m < o.length; m++)
            rl(o[m]);
      }
    }
    var sc = function(n, o) {
      return n(o);
    }, hs = function() {
    }, Js = !1;
    function km() {
      var n = Rc();
      n && (hs(), _f());
    }
    function ep(n, o, m) {
      if (Js)
        return n(o, m);
      Js = !0;
      try {
        return sc(n, o, m);
      } finally {
        Js = !1, km();
      }
    }
    function Gd(n, o, m) {
      sc = n, hs = m;
    }
    function bh(n) {
      return n === "button" || n === "input" || n === "select" || n === "textarea";
    }
    function Sf(n, o, m) {
      switch (n) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          return !!(m.disabled && bh(o));
        default:
          return !1;
      }
    }
    function Ou(n, o) {
      var m = n.stateNode;
      if (m === null)
        return null;
      var S = dr(m);
      if (S === null)
        return null;
      var C = S[o];
      if (Sf(o, n.type, S))
        return null;
      if (C && typeof C != "function")
        throw new Error("Expected `" + o + "` listener to be a function, instead got a value of `" + typeof C + "` type.");
      return C;
    }
    var ad = !1;
    if (qe)
      try {
        var fu = {};
        Object.defineProperty(fu, "passive", {
          get: function() {
            ad = !0;
          }
        }), window.addEventListener("test", fu, fu), window.removeEventListener("test", fu, fu);
      } catch {
        ad = !1;
      }
    function wf(n, o, m, S, C, F, j, J, ne) {
      var Se = Array.prototype.slice.call(arguments, 3);
      try {
        o.apply(m, Se);
      } catch (Ce) {
        this.onError(Ce);
      }
    }
    var Ac = wf;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var Wd = document.createElement("react");
      Ac = function(o, m, S, C, F, j, J, ne, Se) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var Ce = document.createEvent("Event"), nt = !1, et = !0, Pt = window.event, Ut = Object.getOwnPropertyDescriptor(window, "event");
        function Xt() {
          Wd.removeEventListener(qt, Dr, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = Pt);
        }
        var tr = Array.prototype.slice.call(arguments, 3);
        function Dr() {
          nt = !0, Xt(), m.apply(S, tr), et = !1;
        }
        var Sr, ma = !1, ta = !1;
        function bt(Et) {
          if (Sr = Et.error, ma = !0, Sr === null && Et.colno === 0 && Et.lineno === 0 && (ta = !0), Et.defaultPrevented && Sr != null && typeof Sr == "object")
            try {
              Sr._suppressLogging = !0;
            } catch {
            }
        }
        var qt = "react-" + (o || "invokeguardedcallback");
        if (window.addEventListener("error", bt), Wd.addEventListener(qt, Dr, !1), Ce.initEvent(qt, !1, !1), Wd.dispatchEvent(Ce), Ut && Object.defineProperty(window, "event", Ut), nt && et && (ma ? ta && (Sr = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : Sr = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(Sr)), window.removeEventListener("error", bt), !nt)
          return Xt(), wf.apply(this, arguments);
      };
    }
    var sd = Ac, Dc = !1, Fl = null, Lc = !1, Pc = null, Us = {
      onError: function(n) {
        Dc = !0, Fl = n;
      }
    };
    function Uu(n, o, m, S, C, F, j, J, ne) {
      Dc = !1, Fl = null, sd.apply(Us, arguments);
    }
    function So(n, o, m, S, C, F, j, J, ne) {
      if (Uu.apply(this, arguments), Dc) {
        var Se = oc();
        Lc || (Lc = !0, Pc = Se);
      }
    }
    function od() {
      if (Lc) {
        var n = Pc;
        throw Lc = !1, Pc = null, n;
      }
    }
    function xe() {
      return Dc;
    }
    function oc() {
      if (Dc) {
        var n = Fl;
        return Dc = !1, Fl = null, n;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    function Ks(n) {
      return n._reactInternals;
    }
    function ka(n) {
      return n._reactInternals !== void 0;
    }
    function Gn(n, o) {
      n._reactInternals = o;
    }
    var vr = 0, Vi = 1, si = 2, Wn = 4, wi = 16, zi = 32, Oc = 64, Rr = 128, ps = 256, es = 512, kl = 1024, Ia = 2048, Il = 4096, bf = 8192, jd = 16384, Vo = Ia | Wn | Oc | es | kl | jd, bv = 32767, gl = 32768, wo = 65536, tp = 131072, lc = 1048576, du = 2097152, ws = 4194304, Uc = 8388608, Vr = 16777216, uc = 33554432, Ur = Wn | kl | 0, $s = si | Wn | wi | zi | es | Il | bf, ms = Wn | Oc | es | bf, zc = Ia | wi, vn = ws | Uc | du, Bl = t.ReactCurrentOwner;
    function bo(n) {
      var o = n, m = n;
      if (n.alternate)
        for (; o.return; )
          o = o.return;
      else {
        var S = o;
        do
          o = S, (o.flags & (si | Il)) !== vr && (m = o.return), S = o.return;
        while (S);
      }
      return o.tag === w ? m : null;
    }
    function Im(n) {
      if (n.tag === Q) {
        var o = n.memoizedState;
        if (o === null) {
          var m = n.alternate;
          m !== null && (o = m.memoizedState);
        }
        if (o !== null)
          return o.dehydrated;
      }
      return null;
    }
    function Eh(n) {
      return n.tag === w ? n.stateNode.containerInfo : null;
    }
    function zu(n) {
      return bo(n) === n;
    }
    function bs(n) {
      {
        var o = Bl.current;
        if (o !== null && o.tag === g) {
          var m = o, S = m.stateNode;
          S._warnedAboutRefsInRender || l("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", xr(m) || "A component"), S._warnedAboutRefsInRender = !0;
        }
      }
      var C = Ks(n);
      return C ? bo(C) === C : !1;
    }
    function yl(n) {
      if (bo(n) !== n)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function ga(n) {
      var o = n.alternate;
      if (!o) {
        var m = bo(n);
        if (m === null)
          throw new Error("Unable to find node on an unmounted component.");
        return m !== n ? null : n;
      }
      for (var S = n, C = o; ; ) {
        var F = S.return;
        if (F === null)
          break;
        var j = F.alternate;
        if (j === null) {
          var J = F.return;
          if (J !== null) {
            S = C = J;
            continue;
          }
          break;
        }
        if (F.child === j.child) {
          for (var ne = F.child; ne; ) {
            if (ne === S)
              return yl(F), n;
            if (ne === C)
              return yl(F), o;
            ne = ne.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (S.return !== C.return)
          S = F, C = j;
        else {
          for (var Se = !1, Ce = F.child; Ce; ) {
            if (Ce === S) {
              Se = !0, S = F, C = j;
              break;
            }
            if (Ce === C) {
              Se = !0, C = F, S = j;
              break;
            }
            Ce = Ce.sibling;
          }
          if (!Se) {
            for (Ce = j.child; Ce; ) {
              if (Ce === S) {
                Se = !0, S = j, C = F;
                break;
              }
              if (Ce === C) {
                Se = !0, C = j, S = F;
                break;
              }
              Ce = Ce.sibling;
            }
            if (!Se)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (S.alternate !== C)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (S.tag !== w)
        throw new Error("Unable to find node on an unmounted component.");
      return S.stateNode.current === S ? n : o;
    }
    function hu(n) {
      var o = ga(n);
      return o !== null ? zs(o) : null;
    }
    function zs(n) {
      if (n.tag === R || n.tag === D)
        return n;
      for (var o = n.child; o !== null; ) {
        var m = zs(o);
        if (m !== null)
          return m;
        o = o.sibling;
      }
      return null;
    }
    function ld(n) {
      var o = ga(n);
      return o !== null ? Hl(o) : null;
    }
    function Hl(n) {
      if (n.tag === R || n.tag === D)
        return n;
      for (var o = n.child; o !== null; ) {
        if (o.tag !== T) {
          var m = Hl(o);
          if (m !== null)
            return m;
        }
        o = o.sibling;
      }
      return null;
    }
    var Go = e.unstable_scheduleCallback, Yd = e.unstable_cancelCallback, il = e.unstable_shouldYield, Ns = e.unstable_requestPaint, fa = e.unstable_now, Nu = e.unstable_getCurrentPriorityLevel, Wp = e.unstable_ImmediatePriority, pu = e.unstable_UserBlockingPriority, Vl = e.unstable_NormalPriority, np = e.unstable_LowPriority, Ef = e.unstable_IdlePriority, eo = e.unstable_yieldValue, Xd = e.unstable_setDisableYieldValue, da = null, Gi = null, bn = null, Qi = !1, ya = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function rp(n) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var o = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (o.isDisabled)
        return !0;
      if (!o.supportsFiber)
        return l("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        rt && (n = qn({}, n, {
          getLaneLabelMap: Mf,
          injectProfilingHooks: ns
        })), da = o.inject(n), Gi = o;
      } catch (m) {
        l("React instrumentation encountered an error: %s.", m);
      }
      return !!o.checkDCE;
    }
    function Wo(n, o) {
      if (Gi && typeof Gi.onScheduleFiberRoot == "function")
        try {
          Gi.onScheduleFiberRoot(da, n, o);
        } catch (m) {
          Qi || (Qi = !0, l("React instrumentation encountered an error: %s", m));
        }
    }
    function jo(n, o) {
      if (Gi && typeof Gi.onCommitFiberRoot == "function")
        try {
          var m = (n.current.flags & Rr) === Rr;
          if (Ne) {
            var S;
            switch (o) {
              case qo:
                S = Wp;
                break;
              case Qo:
                S = pu;
                break;
              case rs:
                S = Vl;
                break;
              case Xp:
                S = Ef;
                break;
              default:
                S = Vl;
                break;
            }
            Gi.onCommitFiberRoot(da, n, S, m);
          }
        } catch (C) {
          Qi || (Qi = !0, l("React instrumentation encountered an error: %s", C));
        }
    }
    function ts(n) {
      if (Gi && typeof Gi.onPostCommitFiberRoot == "function")
        try {
          Gi.onPostCommitFiberRoot(da, n);
        } catch (o) {
          Qi || (Qi = !0, l("React instrumentation encountered an error: %s", o));
        }
    }
    function An(n) {
      if (Gi && typeof Gi.onCommitFiberUnmount == "function")
        try {
          Gi.onCommitFiberUnmount(da, n);
        } catch (o) {
          Qi || (Qi = !0, l("React instrumentation encountered an error: %s", o));
        }
    }
    function xa(n) {
      if (typeof eo == "function" && (Xd(n), i(n)), Gi && typeof Gi.setStrictMode == "function")
        try {
          Gi.setStrictMode(da, n);
        } catch (o) {
          Qi || (Qi = !0, l("React instrumentation encountered an error: %s", o));
        }
    }
    function ns(n) {
      bn = n;
    }
    function Mf() {
      {
        for (var n = /* @__PURE__ */ new Map(), o = 1, m = 0; m < Ai; m++) {
          var S = mg(o);
          n.set(o, S), o *= 2;
        }
        return n;
      }
    }
    function _a(n) {
      bn !== null && typeof bn.markCommitStarted == "function" && bn.markCommitStarted(n);
    }
    function Qr() {
      bn !== null && typeof bn.markCommitStopped == "function" && bn.markCommitStopped();
    }
    function Ra(n) {
      bn !== null && typeof bn.markComponentRenderStarted == "function" && bn.markComponentRenderStarted(n);
    }
    function Ba() {
      bn !== null && typeof bn.markComponentRenderStopped == "function" && bn.markComponentRenderStopped();
    }
    function li(n) {
      bn !== null && typeof bn.markComponentPassiveEffectMountStarted == "function" && bn.markComponentPassiveEffectMountStarted(n);
    }
    function Gl() {
      bn !== null && typeof bn.markComponentPassiveEffectMountStopped == "function" && bn.markComponentPassiveEffectMountStopped();
    }
    function ud(n) {
      bn !== null && typeof bn.markComponentPassiveEffectUnmountStarted == "function" && bn.markComponentPassiveEffectUnmountStarted(n);
    }
    function Es() {
      bn !== null && typeof bn.markComponentPassiveEffectUnmountStopped == "function" && bn.markComponentPassiveEffectUnmountStopped();
    }
    function qd(n) {
      bn !== null && typeof bn.markComponentLayoutEffectMountStarted == "function" && bn.markComponentLayoutEffectMountStarted(n);
    }
    function Nc() {
      bn !== null && typeof bn.markComponentLayoutEffectMountStopped == "function" && bn.markComponentLayoutEffectMountStopped();
    }
    function cc(n) {
      bn !== null && typeof bn.markComponentLayoutEffectUnmountStarted == "function" && bn.markComponentLayoutEffectUnmountStarted(n);
    }
    function Qd() {
      bn !== null && typeof bn.markComponentLayoutEffectUnmountStopped == "function" && bn.markComponentLayoutEffectUnmountStopped();
    }
    function cd(n, o, m) {
      bn !== null && typeof bn.markComponentErrored == "function" && bn.markComponentErrored(n, o, m);
    }
    function al(n, o, m) {
      bn !== null && typeof bn.markComponentSuspended == "function" && bn.markComponentSuspended(n, o, m);
    }
    function Bm(n) {
      bn !== null && typeof bn.markLayoutEffectsStarted == "function" && bn.markLayoutEffectsStarted(n);
    }
    function Tf() {
      bn !== null && typeof bn.markLayoutEffectsStopped == "function" && bn.markLayoutEffectsStopped();
    }
    function Zd(n) {
      bn !== null && typeof bn.markPassiveEffectsStarted == "function" && bn.markPassiveEffectsStarted(n);
    }
    function Cf() {
      bn !== null && typeof bn.markPassiveEffectsStopped == "function" && bn.markPassiveEffectsStopped();
    }
    function Wl(n) {
      bn !== null && typeof bn.markRenderStarted == "function" && bn.markRenderStarted(n);
    }
    function jl() {
      bn !== null && typeof bn.markRenderYielded == "function" && bn.markRenderYielded();
    }
    function fd() {
      bn !== null && typeof bn.markRenderStopped == "function" && bn.markRenderStopped();
    }
    function Yl(n) {
      bn !== null && typeof bn.markRenderScheduled == "function" && bn.markRenderScheduled(n);
    }
    function Mh(n, o) {
      bn !== null && typeof bn.markForceUpdateScheduled == "function" && bn.markForceUpdateScheduled(n, o);
    }
    function fc(n, o) {
      bn !== null && typeof bn.markStateUpdateScheduled == "function" && bn.markStateUpdateScheduled(n, o);
    }
    var hr = 0, Gr = 1, fr = 2, ui = 8, Fs = 16, Xl = Math.clz32 ? Math.clz32 : Eo, Fc = Math.log, _r = Math.LN2;
    function Eo(n) {
      var o = n >>> 0;
      return o === 0 ? 32 : 31 - (Fc(o) / _r | 0) | 0;
    }
    var Ai = 31, Ht = 0, pi = 0, lr = 1, kc = 2, Ha = 4, Yo = 8, Di = 16, Rf = 32, Af = 4194240, Df = 64, aa = 128, ks = 256, Lf = 512, Jd = 1024, to = 2048, ql = 4096, ip = 8192, Ic = 16384, Ms = 32768, bi = 65536, no = 131072, Ql = 262144, Bc = 524288, mu = 1048576, Pf = 2097152, vu = 130023424, Fu = 4194304, Mo = 8388608, Hc = 16777216, dd = 33554432, Xo = 67108864, hd = Fu, gu = 134217728, pd = 268435455, Ts = 268435456, Is = 536870912, yu = 1073741824;
    function mg(n) {
      {
        if (n & lr)
          return "Sync";
        if (n & kc)
          return "InputContinuousHydration";
        if (n & Ha)
          return "InputContinuous";
        if (n & Yo)
          return "DefaultHydration";
        if (n & Di)
          return "Default";
        if (n & Rf)
          return "TransitionHydration";
        if (n & Af)
          return "Transition";
        if (n & vu)
          return "Retry";
        if (n & gu)
          return "SelectiveHydration";
        if (n & Ts)
          return "IdleHydration";
        if (n & Is)
          return "Idle";
        if (n & yu)
          return "Offscreen";
      }
    }
    var ti = -1, ku = Df, Of = Fu;
    function dc(n) {
      switch (Tn(n)) {
        case lr:
          return lr;
        case kc:
          return kc;
        case Ha:
          return Ha;
        case Yo:
          return Yo;
        case Di:
          return Di;
        case Rf:
          return Rf;
        case Df:
        case aa:
        case ks:
        case Lf:
        case Jd:
        case to:
        case ql:
        case ip:
        case Ic:
        case Ms:
        case bi:
        case no:
        case Ql:
        case Bc:
        case mu:
        case Pf:
          return n & Af;
        case Fu:
        case Mo:
        case Hc:
        case dd:
        case Xo:
          return n & vu;
        case gu:
          return gu;
        case Ts:
          return Ts;
        case Is:
          return Is;
        case yu:
          return yu;
        default:
          return l("Should have found matching lanes. This is a bug in React."), n;
      }
    }
    function Uf(n, o) {
      var m = n.pendingLanes;
      if (m === Ht)
        return Ht;
      var S = Ht, C = n.suspendedLanes, F = n.pingedLanes, j = m & pd;
      if (j !== Ht) {
        var J = j & ~C;
        if (J !== Ht)
          S = dc(J);
        else {
          var ne = j & F;
          ne !== Ht && (S = dc(ne));
        }
      } else {
        var Se = m & ~C;
        Se !== Ht ? S = dc(Se) : F !== Ht && (S = dc(F));
      }
      if (S === Ht)
        return Ht;
      if (o !== Ht && o !== S && (o & C) === Ht) {
        var Ce = Tn(S), nt = Tn(o);
        if (Ce >= nt || Ce === Di && (nt & Af) !== Ht)
          return o;
      }
      (S & Ha) !== Ht && (S |= m & Di);
      var et = n.entangledLanes;
      if (et !== Ht)
        for (var Pt = n.entanglements, Ut = S & et; Ut > 0; ) {
          var Xt = vs(Ut), tr = 1 << Xt;
          S |= Pt[Xt], Ut &= ~tr;
        }
      return S;
    }
    function jp(n, o) {
      for (var m = n.eventTimes, S = ti; o > 0; ) {
        var C = vs(o), F = 1 << C, j = m[C];
        j > S && (S = j), o &= ~F;
      }
      return S;
    }
    function y(n, o) {
      switch (n) {
        case lr:
        case kc:
        case Ha:
          return o + 250;
        case Yo:
        case Di:
        case Rf:
        case Df:
        case aa:
        case ks:
        case Lf:
        case Jd:
        case to:
        case ql:
        case ip:
        case Ic:
        case Ms:
        case bi:
        case no:
        case Ql:
        case Bc:
        case mu:
        case Pf:
          return o + 5e3;
        case Fu:
        case Mo:
        case Hc:
        case dd:
        case Xo:
          return ti;
        case gu:
        case Ts:
        case Is:
        case yu:
          return ti;
        default:
          return l("Should have found matching lanes. This is a bug in React."), ti;
      }
    }
    function x(n, o) {
      for (var m = n.pendingLanes, S = n.suspendedLanes, C = n.pingedLanes, F = n.expirationTimes, j = m; j > 0; ) {
        var J = vs(j), ne = 1 << J, Se = F[J];
        Se === ti ? ((ne & S) === Ht || (ne & C) !== Ht) && (F[J] = y(ne, o)) : Se <= o && (n.expiredLanes |= ne), j &= ~ne;
      }
    }
    function L(n) {
      return dc(n.pendingLanes);
    }
    function k(n) {
      var o = n.pendingLanes & ~yu;
      return o !== Ht ? o : o & yu ? yu : Ht;
    }
    function X(n) {
      return (n & lr) !== Ht;
    }
    function $(n) {
      return (n & pd) !== Ht;
    }
    function Ae(n) {
      return (n & vu) === n;
    }
    function $e(n) {
      var o = lr | Ha | Di;
      return (n & o) === Ht;
    }
    function kt(n) {
      return (n & Af) === n;
    }
    function hn(n, o) {
      var m = kc | Ha | Yo | Di;
      return (o & m) !== Ht;
    }
    function wn(n, o) {
      return (o & n.expiredLanes) !== Ht;
    }
    function br(n) {
      return (n & Af) !== Ht;
    }
    function ur() {
      var n = ku;
      return ku <<= 1, (ku & Af) === Ht && (ku = Df), n;
    }
    function Sa() {
      var n = Of;
      return Of <<= 1, (Of & vu) === Ht && (Of = Fu), n;
    }
    function Tn(n) {
      return n & -n;
    }
    function Li(n) {
      return Tn(n);
    }
    function vs(n) {
      return 31 - Xl(n);
    }
    function pt(n) {
      return vs(n);
    }
    function Ze(n, o) {
      return (n & o) !== Ht;
    }
    function Lt(n, o) {
      return (n & o) === o;
    }
    function Qt(n, o) {
      return n | o;
    }
    function jn(n, o) {
      return n & ~o;
    }
    function Wr(n, o) {
      return n & o;
    }
    function Er(n) {
      return n;
    }
    function Ar(n, o) {
      return n !== pi && n < o ? n : o;
    }
    function Va(n) {
      for (var o = [], m = 0; m < Ai; m++)
        o.push(n);
      return o;
    }
    function Zr(n, o, m) {
      n.pendingLanes |= o, o !== Is && (n.suspendedLanes = Ht, n.pingedLanes = Ht);
      var S = n.eventTimes, C = pt(o);
      S[C] = m;
    }
    function hc(n, o) {
      n.suspendedLanes |= o, n.pingedLanes &= ~o;
      for (var m = n.expirationTimes, S = o; S > 0; ) {
        var C = vs(S), F = 1 << C;
        m[C] = ti, S &= ~F;
      }
    }
    function md(n, o, m) {
      n.pingedLanes |= n.suspendedLanes & o;
    }
    function ap(n, o) {
      var m = n.pendingLanes & ~o;
      n.pendingLanes = o, n.suspendedLanes = Ht, n.pingedLanes = Ht, n.expiredLanes &= o, n.mutableReadLanes &= o, n.entangledLanes &= o;
      for (var S = n.entanglements, C = n.eventTimes, F = n.expirationTimes, j = m; j > 0; ) {
        var J = vs(j), ne = 1 << J;
        S[J] = Ht, C[J] = ti, F[J] = ti, j &= ~ne;
      }
    }
    function gr(n, o) {
      for (var m = n.entangledLanes |= o, S = n.entanglements, C = m; C; ) {
        var F = vs(C), j = 1 << F;
        j & o | S[F] & o && (S[F] |= o), C &= ~j;
      }
    }
    function Yp(n, o) {
      var m = Tn(o), S;
      switch (m) {
        case Ha:
          S = kc;
          break;
        case Di:
          S = Yo;
          break;
        case Df:
        case aa:
        case ks:
        case Lf:
        case Jd:
        case to:
        case ql:
        case ip:
        case Ic:
        case Ms:
        case bi:
        case no:
        case Ql:
        case Bc:
        case mu:
        case Pf:
        case Fu:
        case Mo:
        case Hc:
        case dd:
        case Xo:
          S = Rf;
          break;
        case Is:
          S = Ts;
          break;
        default:
          S = pi;
          break;
      }
      return (S & (n.suspendedLanes | o)) !== pi ? pi : S;
    }
    function Hm(n, o, m) {
      if (!!ya)
        for (var S = n.pendingUpdatersLaneMap; m > 0; ) {
          var C = pt(m), F = 1 << C, j = S[C];
          j.add(o), m &= ~F;
        }
    }
    function zf(n, o) {
      if (!!ya)
        for (var m = n.pendingUpdatersLaneMap, S = n.memoizedUpdaters; o > 0; ) {
          var C = pt(o), F = 1 << C, j = m[C];
          j.size > 0 && (j.forEach(function(J) {
            var ne = J.alternate;
            (ne === null || !S.has(ne)) && S.add(J);
          }), j.clear()), o &= ~F;
        }
    }
    function vg(n, o) {
      return null;
    }
    var qo = lr, Qo = Ha, rs = Di, Xp = Is, Th = pi;
    function pc() {
      return Th;
    }
    function ro(n) {
      Th = n;
    }
    function sp(n, o) {
      var m = Th;
      try {
        return Th = n, o();
      } finally {
        Th = m;
      }
    }
    function xl(n, o) {
      return n !== 0 && n < o ? n : o;
    }
    function _y(n, o) {
      return n === 0 || n > o ? n : o;
    }
    function gg(n, o) {
      return n !== 0 && n < o;
    }
    function Iu(n) {
      var o = Tn(n);
      return gg(qo, o) ? gg(Qo, o) ? $(o) ? rs : Xp : Qo : qo;
    }
    function Wi(n) {
      var o = n.current.memoizedState;
      return o.isDehydrated;
    }
    var Ev;
    function Kn(n) {
      Ev = n;
    }
    function Ch(n) {
      Ev(n);
    }
    var Vm;
    function z0(n) {
      Vm = n;
    }
    var qp;
    function op(n) {
      qp = n;
    }
    var Gm;
    function Sy(n) {
      Gm = n;
    }
    var lp;
    function Qp(n) {
      lp = n;
    }
    var Zp = !1, Kd = [], io = null, ji = null, is = null, To = /* @__PURE__ */ new Map(), _l = /* @__PURE__ */ new Map(), vd = [], Nf = [
      "mousedown",
      "mouseup",
      "touchcancel",
      "touchend",
      "touchstart",
      "auxclick",
      "dblclick",
      "pointercancel",
      "pointerdown",
      "pointerup",
      "dragend",
      "dragstart",
      "drop",
      "compositionend",
      "compositionstart",
      "keydown",
      "keypress",
      "keyup",
      "input",
      "textInput",
      "copy",
      "cut",
      "paste",
      "click",
      "change",
      "contextmenu",
      "reset",
      "submit"
    ];
    function wy(n) {
      return Nf.indexOf(n) > -1;
    }
    function sl(n, o, m, S, C) {
      return {
        blockedOn: n,
        domEventName: o,
        eventSystemFlags: m,
        nativeEvent: C,
        targetContainers: [S]
      };
    }
    function yg(n, o) {
      switch (n) {
        case "focusin":
        case "focusout":
          io = null;
          break;
        case "dragenter":
        case "dragleave":
          ji = null;
          break;
        case "mouseover":
        case "mouseout":
          is = null;
          break;
        case "pointerover":
        case "pointerout": {
          var m = o.pointerId;
          To.delete(m);
          break;
        }
        case "gotpointercapture":
        case "lostpointercapture": {
          var S = o.pointerId;
          _l.delete(S);
          break;
        }
      }
    }
    function Zl(n, o, m, S, C, F) {
      if (n === null || n.nativeEvent !== F) {
        var j = sl(o, m, S, C, F);
        if (o !== null) {
          var J = Cn(o);
          J !== null && Vm(J);
        }
        return j;
      }
      n.eventSystemFlags |= S;
      var ne = n.targetContainers;
      return C !== null && ne.indexOf(C) === -1 && ne.push(C), n;
    }
    function gd(n, o, m, S, C) {
      switch (o) {
        case "focusin": {
          var F = C;
          return io = Zl(io, n, o, m, S, F), !0;
        }
        case "dragenter": {
          var j = C;
          return ji = Zl(ji, n, o, m, S, j), !0;
        }
        case "mouseover": {
          var J = C;
          return is = Zl(is, n, o, m, S, J), !0;
        }
        case "pointerover": {
          var ne = C, Se = ne.pointerId;
          return To.set(Se, Zl(To.get(Se) || null, n, o, m, S, ne)), !0;
        }
        case "gotpointercapture": {
          var Ce = C, nt = Ce.pointerId;
          return _l.set(nt, Zl(_l.get(nt) || null, n, o, m, S, Ce)), !0;
        }
      }
      return !1;
    }
    function by(n) {
      var o = on(n.target);
      if (o !== null) {
        var m = bo(o);
        if (m !== null) {
          var S = m.tag;
          if (S === Q) {
            var C = Im(m);
            if (C !== null) {
              n.blockedOn = C, lp(n.priority, function() {
                qp(m);
              });
              return;
            }
          } else if (S === w) {
            var F = m.stateNode;
            if (Wi(F)) {
              n.blockedOn = Eh(m);
              return;
            }
          }
        }
      }
      n.blockedOn = null;
    }
    function Mv(n) {
      for (var o = Gm(), m = {
        blockedOn: null,
        target: n,
        priority: o
      }, S = 0; S < vd.length && gg(o, vd[S].priority); S++)
        ;
      vd.splice(S, 0, m), S === 0 && by(m);
    }
    function xg(n) {
      if (n.blockedOn !== null)
        return !1;
      for (var o = n.targetContainers; o.length > 0; ) {
        var m = o[0], S = cp(n.domEventName, n.eventSystemFlags, m, n.nativeEvent);
        if (S === null) {
          var C = n.nativeEvent, F = new C.constructor(C.type, C);
          ic(F), C.target.dispatchEvent(F), xf();
        } else {
          var j = Cn(S);
          return j !== null && Vm(j), n.blockedOn = S, !1;
        }
        o.shift();
      }
      return !0;
    }
    function Tv(n, o, m) {
      xg(n) && m.delete(o);
    }
    function Rh() {
      Zp = !1, io !== null && xg(io) && (io = null), ji !== null && xg(ji) && (ji = null), is !== null && xg(is) && (is = null), To.forEach(Tv), _l.forEach(Tv);
    }
    function sa(n, o) {
      n.blockedOn === o && (n.blockedOn = null, Zp || (Zp = !0, e.unstable_scheduleCallback(e.unstable_NormalPriority, Rh)));
    }
    function zr(n) {
      if (Kd.length > 0) {
        sa(Kd[0], n);
        for (var o = 1; o < Kd.length; o++) {
          var m = Kd[o];
          m.blockedOn === n && (m.blockedOn = null);
        }
      }
      io !== null && sa(io, n), ji !== null && sa(ji, n), is !== null && sa(is, n);
      var S = function(J) {
        return sa(J, n);
      };
      To.forEach(S), _l.forEach(S);
      for (var C = 0; C < vd.length; C++) {
        var F = vd[C];
        F.blockedOn === n && (F.blockedOn = null);
      }
      for (; vd.length > 0; ) {
        var j = vd[0];
        if (j.blockedOn !== null)
          break;
        by(j), j.blockedOn === null && vd.shift();
      }
    }
    var ea = t.ReactCurrentBatchConfig, Ga = !0;
    function gs(n) {
      Ga = !!n;
    }
    function Vc() {
      return Ga;
    }
    function Wm(n, o, m) {
      var S = xu(o), C;
      switch (S) {
        case qo:
          C = ol;
          break;
        case Qo:
          C = jm;
          break;
        case rs:
        default:
          C = yd;
          break;
      }
      return C.bind(null, o, m, n);
    }
    function ol(n, o, m, S) {
      var C = pc(), F = ea.transition;
      ea.transition = null;
      try {
        ro(qo), yd(n, o, m, S);
      } finally {
        ro(C), ea.transition = F;
      }
    }
    function jm(n, o, m, S) {
      var C = pc(), F = ea.transition;
      ea.transition = null;
      try {
        ro(Qo), yd(n, o, m, S);
      } finally {
        ro(C), ea.transition = F;
      }
    }
    function yd(n, o, m, S) {
      !Ga || Ym(n, o, m, S);
    }
    function Ym(n, o, m, S) {
      var C = cp(n, o, m, S);
      if (C === null) {
        Nr(n, o, S, up, m), yg(n, S);
        return;
      }
      if (gd(C, n, o, m, S)) {
        S.stopPropagation();
        return;
      }
      if (yg(n, S), o & _o && wy(n)) {
        for (; C !== null; ) {
          var F = Cn(C);
          F !== null && Ch(F);
          var j = cp(n, o, m, S);
          if (j === null && Nr(n, o, S, up, m), j === C)
            break;
          C = j;
        }
        C !== null && S.stopPropagation();
        return;
      }
      Nr(n, o, S, null, m);
    }
    var up = null;
    function cp(n, o, m, S) {
      up = null;
      var C = sn(S), F = on(C);
      if (F !== null) {
        var j = bo(F);
        if (j === null)
          F = null;
        else {
          var J = j.tag;
          if (J === Q) {
            var ne = Im(j);
            if (ne !== null)
              return ne;
            F = null;
          } else if (J === w) {
            var Se = j.stateNode;
            if (Wi(Se))
              return Eh(j);
            F = null;
          } else
            j !== F && (F = null);
        }
      }
      return up = F, null;
    }
    function xu(n) {
      switch (n) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return qo;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return Qo;
        case "message": {
          var o = Nu();
          switch (o) {
            case Wp:
              return qo;
            case pu:
              return Qo;
            case Vl:
            case np:
              return rs;
            case Ef:
              return Xp;
            default:
              return rs;
          }
        }
        default:
          return rs;
      }
    }
    function Xm(n, o, m) {
      return n.addEventListener(o, m, !1), m;
    }
    function fp(n, o, m) {
      return n.addEventListener(o, m, !0), m;
    }
    function xd(n, o, m, S) {
      return n.addEventListener(o, m, {
        capture: !0,
        passive: S
      }), m;
    }
    function _g(n, o, m, S) {
      return n.addEventListener(o, m, {
        passive: S
      }), m;
    }
    var Jp = null, $d = null, dp = null;
    function Zo(n) {
      return Jp = n, $d = Cv(), !0;
    }
    function hp() {
      Jp = null, $d = null, dp = null;
    }
    function qm() {
      if (dp)
        return dp;
      var n, o = $d, m = o.length, S, C = Cv(), F = C.length;
      for (n = 0; n < m && o[n] === C[n]; n++)
        ;
      var j = m - n;
      for (S = 1; S <= j && o[m - S] === C[F - S]; S++)
        ;
      var J = S > 1 ? 1 - S : void 0;
      return dp = C.slice(n, J), dp;
    }
    function Cv() {
      return "value" in Jp ? Jp.value : Jp.textContent;
    }
    function Gc(n) {
      var o, m = n.keyCode;
      return "charCode" in n ? (o = n.charCode, o === 0 && m === 13 && (o = 13)) : o = m, o === 10 && (o = 13), o >= 32 || o === 13 ? o : 0;
    }
    function pp() {
      return !0;
    }
    function ha() {
      return !1;
    }
    function ao(n) {
      function o(m, S, C, F, j) {
        this._reactName = m, this._targetInst = C, this.type = S, this.nativeEvent = F, this.target = j, this.currentTarget = null;
        for (var J in n)
          if (!!n.hasOwnProperty(J)) {
            var ne = n[J];
            ne ? this[J] = ne(F) : this[J] = F[J];
          }
        var Se = F.defaultPrevented != null ? F.defaultPrevented : F.returnValue === !1;
        return Se ? this.isDefaultPrevented = pp : this.isDefaultPrevented = ha, this.isPropagationStopped = ha, this;
      }
      return qn(o.prototype, {
        preventDefault: function() {
          this.defaultPrevented = !0;
          var m = this.nativeEvent;
          !m || (m.preventDefault ? m.preventDefault() : typeof m.returnValue != "unknown" && (m.returnValue = !1), this.isDefaultPrevented = pp);
        },
        stopPropagation: function() {
          var m = this.nativeEvent;
          !m || (m.stopPropagation ? m.stopPropagation() : typeof m.cancelBubble != "unknown" && (m.cancelBubble = !0), this.isPropagationStopped = pp);
        },
        persist: function() {
        },
        isPersistent: pp
      }), o;
    }
    var Sl = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(n) {
        return n.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, Jo = ao(Sl), mp = qn({}, Sl, {
      view: 0,
      detail: 0
    }), Rv = ao(mp), Kp, Sg, _u;
    function Av(n) {
      n !== _u && (_u && n.type === "mousemove" ? (Kp = n.screenX - _u.screenX, Sg = n.screenY - _u.screenY) : (Kp = 0, Sg = 0), _u = n);
    }
    var Ah = qn({}, mp, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: Eg,
      button: 0,
      buttons: 0,
      relatedTarget: function(n) {
        return n.relatedTarget === void 0 ? n.fromElement === n.srcElement ? n.toElement : n.fromElement : n.relatedTarget;
      },
      movementX: function(n) {
        return "movementX" in n ? n.movementX : (Av(n), Kp);
      },
      movementY: function(n) {
        return "movementY" in n ? n.movementY : Sg;
      }
    }), Dh = ao(Ah), wg = qn({}, Ah, {
      dataTransfer: 0
    }), Ff = ao(wg), Ey = qn({}, mp, {
      relatedTarget: 0
    }), bg = ao(Ey), My = qn({}, Sl, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), vp = ao(My), gp = qn({}, Sl, {
      clipboardData: function(n) {
        return "clipboardData" in n ? n.clipboardData : window.clipboardData;
      }
    }), Dv = ao(gp), Lv = qn({}, Sl, {
      data: 0
    }), Qm = ao(Lv), Lh = Qm, Ty = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, Wc = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    };
    function $p(n) {
      if (n.key) {
        var o = Ty[n.key] || n.key;
        if (o !== "Unidentified")
          return o;
      }
      if (n.type === "keypress") {
        var m = Gc(n);
        return m === 13 ? "Enter" : String.fromCharCode(m);
      }
      return n.type === "keydown" || n.type === "keyup" ? Wc[n.keyCode] || "Unidentified" : "";
    }
    var Bs = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function Cy(n) {
      var o = this, m = o.nativeEvent;
      if (m.getModifierState)
        return m.getModifierState(n);
      var S = Bs[n];
      return S ? !!m[S] : !1;
    }
    function Eg(n) {
      return Cy;
    }
    var N0 = qn({}, mp, {
      key: $p,
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: Eg,
      charCode: function(n) {
        return n.type === "keypress" ? Gc(n) : 0;
      },
      keyCode: function(n) {
        return n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0;
      },
      which: function(n) {
        return n.type === "keypress" ? Gc(n) : n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0;
      }
    }), F0 = ao(N0), Zm = qn({}, Ah, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), jc = ao(Zm), Ry = qn({}, mp, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: Eg
    }), wl = ao(Ry), Pv = qn({}, Sl, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), Mg = ao(Pv), Bu = qn({}, Ah, {
      deltaX: function(n) {
        return "deltaX" in n ? n.deltaX : "wheelDeltaX" in n ? -n.wheelDeltaX : 0;
      },
      deltaY: function(n) {
        return "deltaY" in n ? n.deltaY : "wheelDeltaY" in n ? -n.wheelDeltaY : "wheelDelta" in n ? -n.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    }), Ph = ao(Bu), em = [9, 13, 27, 32], yp = 229, mc = qe && "CompositionEvent" in window, Aa = null;
    qe && "documentMode" in document && (Aa = document.documentMode);
    var xp = qe && "TextEvent" in window && !Aa, Cs = qe && (!mc || Aa && Aa > 8 && Aa <= 11), bl = 32, Ov = String.fromCharCode(bl);
    function Tg() {
      ft("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), ft("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]), ft("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]), ft("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
    }
    var Uv = !1;
    function zn(n) {
      return (n.ctrlKey || n.altKey || n.metaKey) && !(n.ctrlKey && n.altKey);
    }
    function Hu(n) {
      switch (n) {
        case "compositionstart":
          return "onCompositionStart";
        case "compositionend":
          return "onCompositionEnd";
        case "compositionupdate":
          return "onCompositionUpdate";
      }
    }
    function zv(n, o) {
      return n === "keydown" && o.keyCode === yp;
    }
    function tm(n, o) {
      switch (n) {
        case "keyup":
          return em.indexOf(o.keyCode) !== -1;
        case "keydown":
          return o.keyCode !== yp;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function Oh(n) {
      var o = n.detail;
      return typeof o == "object" && "data" in o ? o.data : null;
    }
    function oa(n) {
      return n.locale === "ko";
    }
    var Rs = !1;
    function Co(n, o, m, S, C) {
      var F, j;
      if (mc ? F = Hu(o) : Rs ? tm(o, S) && (F = "onCompositionEnd") : zv(o, S) && (F = "onCompositionStart"), !F)
        return null;
      Cs && !oa(S) && (!Rs && F === "onCompositionStart" ? Rs = Zo(C) : F === "onCompositionEnd" && Rs && (j = qm()));
      var J = jr(m, F);
      if (J.length > 0) {
        var ne = new Qm(F, o, null, S, C);
        if (n.push({
          event: ne,
          listeners: J
        }), j)
          ne.data = j;
        else {
          var Se = Oh(S);
          Se !== null && (ne.data = Se);
        }
      }
    }
    function nm(n, o) {
      switch (n) {
        case "compositionend":
          return Oh(o);
        case "keypress":
          var m = o.which;
          return m !== bl ? null : (Uv = !0, Ov);
        case "textInput":
          var S = o.data;
          return S === Ov && Uv ? null : S;
        default:
          return null;
      }
    }
    function Jm(n, o) {
      if (Rs) {
        if (n === "compositionend" || !mc && tm(n, o)) {
          var m = qm();
          return hp(), Rs = !1, m;
        }
        return null;
      }
      switch (n) {
        case "paste":
          return null;
        case "keypress":
          if (!zn(o)) {
            if (o.char && o.char.length > 1)
              return o.char;
            if (o.which)
              return String.fromCharCode(o.which);
          }
          return null;
        case "compositionend":
          return Cs && !oa(o) ? null : o.data;
        default:
          return null;
      }
    }
    function _p(n, o, m, S, C) {
      var F;
      if (xp ? F = nm(o, S) : F = Jm(o, S), !F)
        return null;
      var j = jr(m, "onBeforeInput");
      if (j.length > 0) {
        var J = new Lh("onBeforeInput", "beforeinput", null, S, C);
        n.push({
          event: J,
          listeners: j
        }), J.data = F;
      }
    }
    function Cg(n, o, m, S, C, F, j) {
      Co(n, o, m, S, C), _p(n, o, m, S, C);
    }
    var u1 = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
    };
    function jt(n) {
      var o = n && n.nodeName && n.nodeName.toLowerCase();
      return o === "input" ? !!u1[n.type] : o === "textarea";
    }
    /**
     * Checks if an event is supported in the current execution environment.
     *
     * NOTE: This will not work correctly for non-generic events such as `change`,
     * `reset`, `load`, `error`, and `select`.
     *
     * Borrows from Modernizr.
     *
     * @param {string} eventNameSuffix Event name, e.g. "click".
     * @return {boolean} True if the event is supported.
     * @internal
     * @license Modernizr 3.0.0pre (Custom Build) | MIT
     */
    function kf(n) {
      if (!qe)
        return !1;
      var o = "on" + n, m = o in document;
      if (!m) {
        var S = document.createElement("div");
        S.setAttribute(o, "return;"), m = typeof S[o] == "function";
      }
      return m;
    }
    function _d() {
      ft("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
    }
    function c(n, o, m, S) {
      Pu(S);
      var C = jr(o, "onChange");
      if (C.length > 0) {
        var F = new Jo("onChange", "change", null, m, S);
        n.push({
          event: F,
          listeners: C
        });
      }
    }
    var h = null, E = null;
    function P(n) {
      var o = n.nodeName && n.nodeName.toLowerCase();
      return o === "select" || o === "input" && n.type === "file";
    }
    function V(n) {
      var o = [];
      c(o, E, n, sn(n)), ep(q, o);
    }
    function q(n) {
      q0(n, 0);
    }
    function le(n) {
      var o = On(n);
      if (wc(o))
        return n;
    }
    function Oe(n, o) {
      if (n === "change")
        return o;
    }
    var Ge = !1;
    qe && (Ge = kf("input") && (!document.documentMode || document.documentMode > 9));
    function Dt(n, o) {
      h = n, E = o, h.attachEvent("onpropertychange", un);
    }
    function fn() {
      !h || (h.detachEvent("onpropertychange", un), h = null, E = null);
    }
    function un(n) {
      n.propertyName === "value" && le(E) && V(n);
    }
    function rn(n, o, m) {
      n === "focusin" ? (fn(), Dt(o, m)) : n === "focusout" && fn();
    }
    function Hn(n, o) {
      if (n === "selectionchange" || n === "keyup" || n === "keydown")
        return le(E);
    }
    function Qn(n) {
      var o = n.nodeName;
      return o && o.toLowerCase() === "input" && (n.type === "checkbox" || n.type === "radio");
    }
    function ir(n, o) {
      if (n === "click")
        return le(o);
    }
    function Hs(n, o) {
      if (n === "input" || n === "change")
        return le(o);
    }
    function mt(n) {
      var o = n._wrapperState;
      !o || !o.controlled || n.type !== "number" || Ru(n, "number", n.value);
    }
    function Ke(n, o, m, S, C, F, j) {
      var J = m ? On(m) : window, ne, Se;
      if (P(J) ? ne = Oe : jt(J) ? Ge ? ne = Hs : (ne = Hn, Se = rn) : Qn(J) && (ne = ir), ne) {
        var Ce = ne(o, m);
        if (Ce) {
          c(n, Ce, S, C);
          return;
        }
      }
      Se && Se(o, J, m), o === "focusout" && mt(J);
    }
    function _t() {
      Ie("onMouseEnter", ["mouseout", "mouseover"]), Ie("onMouseLeave", ["mouseout", "mouseover"]), Ie("onPointerEnter", ["pointerout", "pointerover"]), Ie("onPointerLeave", ["pointerout", "pointerover"]);
    }
    function _n(n, o, m, S, C, F, j) {
      var J = o === "mouseover" || o === "pointerover", ne = o === "mouseout" || o === "pointerout";
      if (J && !id(S)) {
        var Se = S.relatedTarget || S.fromElement;
        if (Se && (on(Se) || Kt(Se)))
          return;
      }
      if (!(!ne && !J)) {
        var Ce;
        if (C.window === C)
          Ce = C;
        else {
          var nt = C.ownerDocument;
          nt ? Ce = nt.defaultView || nt.parentWindow : Ce = window;
        }
        var et, Pt;
        if (ne) {
          var Ut = S.relatedTarget || S.toElement;
          if (et = m, Pt = Ut ? on(Ut) : null, Pt !== null) {
            var Xt = bo(Pt);
            (Pt !== Xt || Pt.tag !== R && Pt.tag !== D) && (Pt = null);
          }
        } else
          et = null, Pt = m;
        if (et !== Pt) {
          var tr = Dh, Dr = "onMouseLeave", Sr = "onMouseEnter", ma = "mouse";
          (o === "pointerout" || o === "pointerover") && (tr = jc, Dr = "onPointerLeave", Sr = "onPointerEnter", ma = "pointer");
          var ta = et == null ? Ce : On(et), bt = Pt == null ? Ce : On(Pt), qt = new tr(Dr, ma + "leave", et, S, C);
          qt.target = ta, qt.relatedTarget = bt;
          var Et = null, xn = on(C);
          if (xn === m) {
            var nr = new tr(Sr, ma + "enter", Pt, S, C);
            nr.target = bt, nr.relatedTarget = ta, Et = nr;
          }
          Z0(n, qt, Et, et, Pt);
        }
      }
    }
    function ar(n, o) {
      return n === o && (n !== 0 || 1 / n === 1 / o) || n !== n && o !== o;
    }
    var Zn = typeof Object.is == "function" ? Object.is : ar;
    function pr(n, o) {
      if (Zn(n, o))
        return !0;
      if (typeof n != "object" || n === null || typeof o != "object" || o === null)
        return !1;
      var m = Object.keys(n), S = Object.keys(o);
      if (m.length !== S.length)
        return !1;
      for (var C = 0; C < m.length; C++) {
        var F = m[C];
        if (!dt.call(o, F) || !Zn(n[F], o[F]))
          return !1;
      }
      return !0;
    }
    function Lr(n) {
      for (; n && n.firstChild; )
        n = n.firstChild;
      return n;
    }
    function ll(n) {
      for (; n; ) {
        if (n.nextSibling)
          return n.nextSibling;
        n = n.parentNode;
      }
    }
    function Zi(n, o) {
      for (var m = Lr(n), S = 0, C = 0; m; ) {
        if (m.nodeType === ec) {
          if (C = S + m.textContent.length, S <= o && C >= o)
            return {
              node: m,
              offset: o - S
            };
          S = C;
        }
        m = Lr(ll(m));
      }
    }
    function If(n) {
      var o = n.ownerDocument, m = o && o.defaultView || window, S = m.getSelection && m.getSelection();
      if (!S || S.rangeCount === 0)
        return null;
      var C = S.anchorNode, F = S.anchorOffset, j = S.focusNode, J = S.focusOffset;
      try {
        C.nodeType, j.nodeType;
      } catch {
        return null;
      }
      return Rg(n, C, F, j, J);
    }
    function Rg(n, o, m, S, C) {
      var F = 0, j = -1, J = -1, ne = 0, Se = 0, Ce = n, nt = null;
      e:
        for (; ; ) {
          for (var et = null; Ce === o && (m === 0 || Ce.nodeType === ec) && (j = F + m), Ce === S && (C === 0 || Ce.nodeType === ec) && (J = F + C), Ce.nodeType === ec && (F += Ce.nodeValue.length), (et = Ce.firstChild) !== null; )
            nt = Ce, Ce = et;
          for (; ; ) {
            if (Ce === n)
              break e;
            if (nt === o && ++ne === m && (j = F), nt === S && ++Se === C && (J = F), (et = Ce.nextSibling) !== null)
              break;
            Ce = nt, nt = Ce.parentNode;
          }
          Ce = et;
        }
      return j === -1 || J === -1 ? null : {
        start: j,
        end: J
      };
    }
    function k0(n, o) {
      var m = n.ownerDocument || document, S = m && m.defaultView || window;
      if (!!S.getSelection) {
        var C = S.getSelection(), F = n.textContent.length, j = Math.min(o.start, F), J = o.end === void 0 ? j : Math.min(o.end, F);
        if (!C.extend && j > J) {
          var ne = J;
          J = j, j = ne;
        }
        var Se = Zi(n, j), Ce = Zi(n, J);
        if (Se && Ce) {
          if (C.rangeCount === 1 && C.anchorNode === Se.node && C.anchorOffset === Se.offset && C.focusNode === Ce.node && C.focusOffset === Ce.offset)
            return;
          var nt = m.createRange();
          nt.setStart(Se.node, Se.offset), C.removeAllRanges(), j > J ? (C.addRange(nt), C.extend(Ce.node, Ce.offset)) : (nt.setEnd(Ce.node, Ce.offset), C.addRange(nt));
        }
      }
    }
    function Ag(n) {
      return n && n.nodeType === ec;
    }
    function I0(n, o) {
      return !n || !o ? !1 : n === o ? !0 : Ag(n) ? !1 : Ag(o) ? I0(n, o.parentNode) : "contains" in n ? n.contains(o) : n.compareDocumentPosition ? !!(n.compareDocumentPosition(o) & 16) : !1;
    }
    function B0(n) {
      return n && n.ownerDocument && I0(n.ownerDocument.documentElement, n);
    }
    function Ay(n) {
      try {
        return typeof n.contentWindow.location.href == "string";
      } catch {
        return !1;
      }
    }
    function Dy() {
      for (var n = window, o = Ol(); o instanceof n.HTMLIFrameElement; ) {
        if (Ay(o))
          n = o.contentWindow;
        else
          return o;
        o = Ol(n.document);
      }
      return o;
    }
    function Nv(n) {
      var o = n && n.nodeName && n.nodeName.toLowerCase();
      return o && (o === "input" && (n.type === "text" || n.type === "search" || n.type === "tel" || n.type === "url" || n.type === "password") || o === "textarea" || n.contentEditable === "true");
    }
    function Vu() {
      var n = Dy();
      return {
        focusedElem: n,
        selectionRange: Nv(n) ? H0(n) : null
      };
    }
    function c1(n) {
      var o = Dy(), m = n.focusedElem, S = n.selectionRange;
      if (o !== m && B0(m)) {
        S !== null && Nv(m) && rm(m, S);
        for (var C = [], F = m; F = F.parentNode; )
          F.nodeType === zl && C.push({
            element: F,
            left: F.scrollLeft,
            top: F.scrollTop
          });
        typeof m.focus == "function" && m.focus();
        for (var j = 0; j < C.length; j++) {
          var J = C[j];
          J.element.scrollLeft = J.left, J.element.scrollTop = J.top;
        }
      }
    }
    function H0(n) {
      var o;
      return "selectionStart" in n ? o = {
        start: n.selectionStart,
        end: n.selectionEnd
      } : o = If(n), o || {
        start: 0,
        end: 0
      };
    }
    function rm(n, o) {
      var m = o.start, S = o.end;
      S === void 0 && (S = m), "selectionStart" in n ? (n.selectionStart = m, n.selectionEnd = Math.min(S, n.value.length)) : k0(n, o);
    }
    var Jr = qe && "documentMode" in document && document.documentMode <= 11;
    function rS() {
      ft("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
    }
    var ul = null, As = null, Ly = null, Sd = !1;
    function f1(n) {
      if ("selectionStart" in n && Nv(n))
        return {
          start: n.selectionStart,
          end: n.selectionEnd
        };
      var o = n.ownerDocument && n.ownerDocument.defaultView || window, m = o.getSelection();
      return {
        anchorNode: m.anchorNode,
        anchorOffset: m.anchorOffset,
        focusNode: m.focusNode,
        focusOffset: m.focusOffset
      };
    }
    function V0(n) {
      return n.window === n ? n.document : n.nodeType === Za ? n : n.ownerDocument;
    }
    function G0(n, o, m) {
      var S = V0(m);
      if (!(Sd || ul == null || ul !== Ol(S))) {
        var C = f1(ul);
        if (!Ly || !pr(Ly, C)) {
          Ly = C;
          var F = jr(As, "onSelect");
          if (F.length > 0) {
            var j = new Jo("onSelect", "select", null, o, m);
            n.push({
              event: j,
              listeners: F
            }), j.target = ul;
          }
        }
      }
    }
    function W0(n, o, m, S, C, F, j) {
      var J = m ? On(m) : window;
      switch (o) {
        case "focusin":
          (jt(J) || J.contentEditable === "true") && (ul = J, As = m, Ly = null);
          break;
        case "focusout":
          ul = null, As = null, Ly = null;
          break;
        case "mousedown":
          Sd = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Sd = !1, G0(n, S, C);
          break;
        case "selectionchange":
          if (Jr)
            break;
        case "keydown":
        case "keyup":
          G0(n, S, C);
      }
    }
    function Dg(n, o) {
      var m = {};
      return m[n.toLowerCase()] = o.toLowerCase(), m["Webkit" + n] = "webkit" + o, m["Moz" + n] = "moz" + o, m;
    }
    var im = {
      animationend: Dg("Animation", "AnimationEnd"),
      animationiteration: Dg("Animation", "AnimationIteration"),
      animationstart: Dg("Animation", "AnimationStart"),
      transitionend: Dg("Transition", "TransitionEnd")
    }, j0 = {}, Sp = {};
    qe && (Sp = document.createElement("div").style, "AnimationEvent" in window || (delete im.animationend.animation, delete im.animationiteration.animation, delete im.animationstart.animation), "TransitionEvent" in window || delete im.transitionend.transition);
    function Fv(n) {
      if (j0[n])
        return j0[n];
      if (!im[n])
        return n;
      var o = im[n];
      for (var m in o)
        if (o.hasOwnProperty(m) && m in Sp)
          return j0[n] = o[m];
      return n;
    }
    var Lg = Fv("animationend"), Vs = Fv("animationiteration"), so = Fv("animationstart"), d1 = Fv("transitionend"), Y0 = /* @__PURE__ */ new Map(), Py = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
    function Km(n, o) {
      Y0.set(n, o), ft(o, [n]);
    }
    function xb() {
      for (var n = 0; n < Py.length; n++) {
        var o = Py[n], m = o.toLowerCase(), S = o[0].toUpperCase() + o.slice(1);
        Km(m, "on" + S);
      }
      Km(Lg, "onAnimationEnd"), Km(Vs, "onAnimationIteration"), Km(so, "onAnimationStart"), Km("dblclick", "onDoubleClick"), Km("focusin", "onFocus"), Km("focusout", "onBlur"), Km(d1, "onTransitionEnd");
    }
    function iS(n, o, m, S, C, F, j) {
      var J = Y0.get(o);
      if (J !== void 0) {
        var ne = Jo, Se = o;
        switch (o) {
          case "keypress":
            if (Gc(S) === 0)
              return;
          case "keydown":
          case "keyup":
            ne = F0;
            break;
          case "focusin":
            Se = "focus", ne = bg;
            break;
          case "focusout":
            Se = "blur", ne = bg;
            break;
          case "beforeblur":
          case "afterblur":
            ne = bg;
            break;
          case "click":
            if (S.button === 2)
              return;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            ne = Dh;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            ne = Ff;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            ne = wl;
            break;
          case Lg:
          case Vs:
          case so:
            ne = vp;
            break;
          case d1:
            ne = Mg;
            break;
          case "scroll":
            ne = Rv;
            break;
          case "wheel":
            ne = Ph;
            break;
          case "copy":
          case "cut":
          case "paste":
            ne = Dv;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            ne = jc;
            break;
        }
        var Ce = (F & _o) !== 0;
        {
          var nt = !Ce && o === "scroll", et = wp(m, J, S.type, Ce, nt);
          if (et.length > 0) {
            var Pt = new ne(J, Se, null, S, C);
            n.push({
              event: Pt,
              listeners: et
            });
          }
        }
      }
    }
    xb(), _t(), _d(), rS(), Tg();
    function aS(n, o, m, S, C, F, j) {
      iS(n, o, m, S, C, F);
      var J = (F & rd) === 0;
      J && (_n(n, o, m, S, C), Ke(n, o, m, S, C), W0(n, o, m, S, C), Cg(n, o, m, S, C));
    }
    var kv = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"], $m = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(kv));
    function Oy(n, o, m) {
      var S = n.type || "unknown-event";
      n.currentTarget = m, So(S, o, void 0, n), n.currentTarget = null;
    }
    function X0(n, o, m) {
      var S;
      if (m)
        for (var C = o.length - 1; C >= 0; C--) {
          var F = o[C], j = F.instance, J = F.currentTarget, ne = F.listener;
          if (j !== S && n.isPropagationStopped())
            return;
          Oy(n, ne, J), S = j;
        }
      else
        for (var Se = 0; Se < o.length; Se++) {
          var Ce = o[Se], nt = Ce.instance, et = Ce.currentTarget, Pt = Ce.listener;
          if (nt !== S && n.isPropagationStopped())
            return;
          Oy(n, Pt, et), S = nt;
        }
    }
    function q0(n, o) {
      for (var m = (o & _o) !== 0, S = 0; S < n.length; S++) {
        var C = n[S], F = C.event, j = C.listeners;
        X0(F, j, m);
      }
      od();
    }
    function Uy(n, o, m, S, C) {
      var F = sn(m), j = [];
      aS(j, n, S, m, F, o), q0(j, o);
    }
    function Ni(n, o) {
      $m.has(n) || l('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', n);
      var m = !1, S = Fr(o), C = Da(n, m);
      S.has(C) || (zy(o, n, Fa, m), S.add(C));
    }
    function am(n, o, m) {
      $m.has(n) && !o && l('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', n);
      var S = 0;
      o && (S |= _o), zy(m, n, S, o);
    }
    var wd = "_reactListening" + Math.random().toString(36).slice(2);
    function Yc(n) {
      if (!n[wd]) {
        n[wd] = !0, tt.forEach(function(m) {
          m !== "selectionchange" && ($m.has(m) || am(m, !1, n), am(m, !0, n));
        });
        var o = n.nodeType === Za ? n : n.ownerDocument;
        o !== null && (o[wd] || (o[wd] = !0, am("selectionchange", !1, o)));
      }
    }
    function zy(n, o, m, S, C) {
      var F = Wm(n, o, m), j = void 0;
      ad && (o === "touchstart" || o === "touchmove" || o === "wheel") && (j = !0), n = n, S ? j !== void 0 ? xd(n, o, F, j) : fp(n, o, F) : j !== void 0 ? _g(n, o, F, j) : Xm(n, o, F);
    }
    function Q0(n, o) {
      return n === o || n.nodeType === Oi && n.parentNode === o;
    }
    function Nr(n, o, m, S, C) {
      var F = S;
      if ((o & Br) === 0 && (o & Fa) === 0) {
        var j = C;
        if (S !== null) {
          var J = S;
          e:
            for (; ; ) {
              if (J === null)
                return;
              var ne = J.tag;
              if (ne === w || ne === T) {
                var Se = J.stateNode.containerInfo;
                if (Q0(Se, j))
                  break;
                if (ne === T)
                  for (var Ce = J.return; Ce !== null; ) {
                    var nt = Ce.tag;
                    if (nt === w || nt === T) {
                      var et = Ce.stateNode.containerInfo;
                      if (Q0(et, j))
                        return;
                    }
                    Ce = Ce.return;
                  }
                for (; Se !== null; ) {
                  var Pt = on(Se);
                  if (Pt === null)
                    return;
                  var Ut = Pt.tag;
                  if (Ut === R || Ut === D) {
                    J = F = Pt;
                    continue e;
                  }
                  Se = Se.parentNode;
                }
              }
              J = J.return;
            }
        }
      }
      ep(function() {
        return Uy(n, o, m, F);
      });
    }
    function bd(n, o, m) {
      return {
        instance: n,
        listener: o,
        currentTarget: m
      };
    }
    function wp(n, o, m, S, C, F) {
      for (var j = o !== null ? o + "Capture" : null, J = S ? j : o, ne = [], Se = n, Ce = null; Se !== null; ) {
        var nt = Se, et = nt.stateNode, Pt = nt.tag;
        if (Pt === R && et !== null && (Ce = et, J !== null)) {
          var Ut = Ou(Se, J);
          Ut != null && ne.push(bd(Se, Ut, Ce));
        }
        if (C)
          break;
        Se = Se.return;
      }
      return ne;
    }
    function jr(n, o) {
      for (var m = o + "Capture", S = [], C = n; C !== null; ) {
        var F = C, j = F.stateNode, J = F.tag;
        if (J === R && j !== null) {
          var ne = j, Se = Ou(C, m);
          Se != null && S.unshift(bd(C, Se, ne));
          var Ce = Ou(C, o);
          Ce != null && S.push(bd(C, Ce, ne));
        }
        C = C.return;
      }
      return S;
    }
    function Uh(n) {
      if (n === null)
        return null;
      do
        n = n.return;
      while (n && n.tag !== R);
      return n || null;
    }
    function Xc(n, o) {
      for (var m = n, S = o, C = 0, F = m; F; F = Uh(F))
        C++;
      for (var j = 0, J = S; J; J = Uh(J))
        j++;
      for (; C - j > 0; )
        m = Uh(m), C--;
      for (; j - C > 0; )
        S = Uh(S), j--;
      for (var ne = C; ne--; ) {
        if (m === S || S !== null && m === S.alternate)
          return m;
        m = Uh(m), S = Uh(S);
      }
      return null;
    }
    function Ny(n, o, m, S, C) {
      for (var F = o._reactName, j = [], J = m; J !== null && J !== S; ) {
        var ne = J, Se = ne.alternate, Ce = ne.stateNode, nt = ne.tag;
        if (Se !== null && Se === S)
          break;
        if (nt === R && Ce !== null) {
          var et = Ce;
          if (C) {
            var Pt = Ou(J, F);
            Pt != null && j.unshift(bd(J, Pt, et));
          } else if (!C) {
            var Ut = Ou(J, F);
            Ut != null && j.push(bd(J, Ut, et));
          }
        }
        J = J.return;
      }
      j.length !== 0 && n.push({
        event: o,
        listeners: j
      });
    }
    function Z0(n, o, m, S, C) {
      var F = S && C ? Xc(S, C) : null;
      S !== null && Ny(n, o, S, F, !1), C !== null && m !== null && Ny(n, m, C, F, !0);
    }
    function Da(n, o) {
      return n + "__" + (o ? "capture" : "bubble");
    }
    var Bf = !1, Pg = "dangerouslySetInnerHTML", Iv = "suppressContentEditableWarning", sm = "suppressHydrationWarning", h1 = "autoFocus", om = "children", ev = "style", Bv = "__html", Hf, Og, vc, J0, Ug, Fy, sS;
    Hf = {
      dialog: !0,
      webview: !0
    }, Og = function(n, o) {
      _i(n, o), Lu(n, o), $i(n, o, {
        registrationNameDependencies: Tt,
        possibleRegistrationNames: gt
      });
    }, Fy = qe && !document.documentMode, vc = function(n, o, m) {
      if (!Bf) {
        var S = ky(m), C = ky(o);
        C !== S && (Bf = !0, l("Prop `%s` did not match. Server: %s Client: %s", n, JSON.stringify(C), JSON.stringify(S)));
      }
    }, J0 = function(n) {
      if (!Bf) {
        Bf = !0;
        var o = [];
        n.forEach(function(m) {
          o.push(m);
        }), l("Extra attributes from the server: %s", o);
      }
    }, Ug = function(n, o) {
      o === !1 ? l("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", n, n, n) : l("Expected `%s` listener to be a function, instead got a value of `%s` type.", n, typeof o);
    }, sS = function(n, o) {
      var m = n.namespaceURI === Du ? n.ownerDocument.createElement(n.tagName) : n.ownerDocument.createElementNS(n.namespaceURI, n.tagName);
      return m.innerHTML = o, m.innerHTML;
    };
    var p1 = /\r\n?/g, m1 = /\u0000|\uFFFD/g;
    function ky(n) {
      we(n);
      var o = typeof n == "string" ? n : "" + n;
      return o.replace(p1, `
`).replace(m1, "");
    }
    function tv(n, o, m, S) {
      var C = ky(o), F = ky(n);
      if (F !== C && (S && (Bf || (Bf = !0, l('Text content did not match. Server: "%s" Client: "%s"', F, C))), m && He))
        throw new Error("Text content does not match server-rendered HTML.");
    }
    function v1(n) {
      return n.nodeType === Za ? n : n.ownerDocument;
    }
    function _b() {
    }
    function K0(n) {
      n.onclick = _b;
    }
    function Jl(n, o, m, S, C) {
      for (var F in S)
        if (!!S.hasOwnProperty(F)) {
          var j = S[F];
          if (F === ev)
            j && Object.freeze(j), Xe(o, j);
          else if (F === Pg) {
            var J = j ? j[Bv] : void 0;
            J != null && gf(o, J);
          } else if (F === om)
            if (typeof j == "string") {
              var ne = n !== "textarea" || j !== "";
              ne && ca(o, j);
            } else
              typeof j == "number" && ca(o, "" + j);
          else
            F === Iv || F === sm || F === h1 || (Tt.hasOwnProperty(F) ? j != null && (typeof j != "function" && Ug(F, j), F === "onScroll" && Ni("scroll", o)) : j != null && xi(o, F, j, C));
        }
    }
    function qc(n, o, m, S) {
      for (var C = 0; C < o.length; C += 2) {
        var F = o[C], j = o[C + 1];
        F === ev ? Xe(n, j) : F === Pg ? gf(n, j) : F === om ? ca(n, j) : xi(n, F, j, S);
      }
    }
    function Sb(n, o, m, S) {
      var C, F = v1(m), j, J = S;
      if (J === Du && (J = tl(n)), J === Du) {
        if (C = Ui(n, o), !C && n !== n.toLowerCase() && l("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", n), n === "script") {
          var ne = F.createElement("div");
          ne.innerHTML = "<script><\/script>";
          var Se = ne.firstChild;
          j = ne.removeChild(Se);
        } else if (typeof o.is == "string")
          j = F.createElement(n, {
            is: o.is
          });
        else if (j = F.createElement(n), n === "select") {
          var Ce = j;
          o.multiple ? Ce.multiple = !0 : o.size && (Ce.size = o.size);
        }
      } else
        j = F.createElementNS(J, n);
      return J === Du && !C && Object.prototype.toString.call(j) === "[object HTMLUnknownElement]" && !dt.call(Hf, n) && (Hf[n] = !0, l("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", n)), j;
    }
    function wb(n, o) {
      return v1(o).createTextNode(n);
    }
    function bp(n, o, m, S) {
      var C = Ui(o, m);
      Og(o, m);
      var F;
      switch (o) {
        case "dialog":
          Ni("cancel", n), Ni("close", n), F = m;
          break;
        case "iframe":
        case "object":
        case "embed":
          Ni("load", n), F = m;
          break;
        case "video":
        case "audio":
          for (var j = 0; j < kv.length; j++)
            Ni(kv[j], n);
          F = m;
          break;
        case "source":
          Ni("error", n), F = m;
          break;
        case "img":
        case "image":
        case "link":
          Ni("error", n), Ni("load", n), F = m;
          break;
        case "details":
          Ni("toggle", n), F = m;
          break;
        case "input":
          Oa(n, m), F = Cu(n, m), Ni("invalid", n);
          break;
        case "option":
          qr(n, m), F = m;
          break;
        case "select":
          Fp(n, m), F = Au(n, m), Ni("invalid", n);
          break;
        case "textarea":
          zm(n, m), F = Um(n, m), Ni("invalid", n);
          break;
        default:
          F = m;
      }
      switch (er(o, F), Jl(o, n, S, F, C), o) {
        case "input":
          Os(n), Ua(n, m, !1);
          break;
        case "textarea":
          Os(n), $u(n);
          break;
        case "option":
          _s(n, m);
          break;
        case "select":
          pg(n, m);
          break;
        default:
          typeof F.onClick == "function" && K0(n);
          break;
      }
    }
    function g1(n, o, m, S, C) {
      Og(o, S);
      var F = null, j, J;
      switch (o) {
        case "input":
          j = Cu(n, m), J = Cu(n, S), F = [];
          break;
        case "select":
          j = Au(n, m), J = Au(n, S), F = [];
          break;
        case "textarea":
          j = Um(n, m), J = Um(n, S), F = [];
          break;
        default:
          j = m, J = S, typeof j.onClick != "function" && typeof J.onClick == "function" && K0(n);
          break;
      }
      er(o, J);
      var ne, Se, Ce = null;
      for (ne in j)
        if (!(J.hasOwnProperty(ne) || !j.hasOwnProperty(ne) || j[ne] == null))
          if (ne === ev) {
            var nt = j[ne];
            for (Se in nt)
              nt.hasOwnProperty(Se) && (Ce || (Ce = {}), Ce[Se] = "");
          } else
            ne === Pg || ne === om || ne === Iv || ne === sm || ne === h1 || (Tt.hasOwnProperty(ne) ? F || (F = []) : (F = F || []).push(ne, null));
      for (ne in J) {
        var et = J[ne], Pt = j != null ? j[ne] : void 0;
        if (!(!J.hasOwnProperty(ne) || et === Pt || et == null && Pt == null))
          if (ne === ev)
            if (et && Object.freeze(et), Pt) {
              for (Se in Pt)
                Pt.hasOwnProperty(Se) && (!et || !et.hasOwnProperty(Se)) && (Ce || (Ce = {}), Ce[Se] = "");
              for (Se in et)
                et.hasOwnProperty(Se) && Pt[Se] !== et[Se] && (Ce || (Ce = {}), Ce[Se] = et[Se]);
            } else
              Ce || (F || (F = []), F.push(ne, Ce)), Ce = et;
          else if (ne === Pg) {
            var Ut = et ? et[Bv] : void 0, Xt = Pt ? Pt[Bv] : void 0;
            Ut != null && Xt !== Ut && (F = F || []).push(ne, Ut);
          } else
            ne === om ? (typeof et == "string" || typeof et == "number") && (F = F || []).push(ne, "" + et) : ne === Iv || ne === sm || (Tt.hasOwnProperty(ne) ? (et != null && (typeof et != "function" && Ug(ne, et), ne === "onScroll" && Ni("scroll", n)), !F && Pt !== et && (F = [])) : (F = F || []).push(ne, et));
      }
      return Ce && (Mn(Ce, J[ev]), (F = F || []).push(ev, Ce)), F;
    }
    function oS(n, o, m, S, C) {
      m === "input" && C.type === "radio" && C.name != null && xs(n, C);
      var F = Ui(m, S), j = Ui(m, C);
      switch (qc(n, o, F, j), m) {
        case "input":
          uu(n, C);
          break;
        case "textarea":
          gh(n, C);
          break;
        case "select":
          $h(n, C);
          break;
      }
    }
    function Iy(n) {
      {
        var o = n.toLowerCase();
        return ia.hasOwnProperty(o) && ia[o] || null;
      }
    }
    function By(n, o, m, S, C, F, j) {
      var J, ne;
      switch (J = Ui(o, m), Og(o, m), o) {
        case "dialog":
          Ni("cancel", n), Ni("close", n);
          break;
        case "iframe":
        case "object":
        case "embed":
          Ni("load", n);
          break;
        case "video":
        case "audio":
          for (var Se = 0; Se < kv.length; Se++)
            Ni(kv[Se], n);
          break;
        case "source":
          Ni("error", n);
          break;
        case "img":
        case "image":
        case "link":
          Ni("error", n), Ni("load", n);
          break;
        case "details":
          Ni("toggle", n);
          break;
        case "input":
          Oa(n, m), Ni("invalid", n);
          break;
        case "option":
          qr(n, m);
          break;
        case "select":
          Fp(n, m), Ni("invalid", n);
          break;
        case "textarea":
          zm(n, m), Ni("invalid", n);
          break;
      }
      er(o, m);
      {
        ne = /* @__PURE__ */ new Set();
        for (var Ce = n.attributes, nt = 0; nt < Ce.length; nt++) {
          var et = Ce[nt].name.toLowerCase();
          switch (et) {
            case "value":
              break;
            case "checked":
              break;
            case "selected":
              break;
            default:
              ne.add(Ce[nt].name);
          }
        }
      }
      var Pt = null;
      for (var Ut in m)
        if (!!m.hasOwnProperty(Ut)) {
          var Xt = m[Ut];
          if (Ut === om)
            typeof Xt == "string" ? n.textContent !== Xt && (m[sm] !== !0 && tv(n.textContent, Xt, F, j), Pt = [om, Xt]) : typeof Xt == "number" && n.textContent !== "" + Xt && (m[sm] !== !0 && tv(n.textContent, Xt, F, j), Pt = [om, "" + Xt]);
          else if (Tt.hasOwnProperty(Ut))
            Xt != null && (typeof Xt != "function" && Ug(Ut, Xt), Ut === "onScroll" && Ni("scroll", n));
          else if (j && !0 && typeof J == "boolean") {
            var tr = void 0, Dr = J && Ve ? null : Gt(Ut);
            if (m[sm] !== !0) {
              if (!(Ut === Iv || Ut === sm || Ut === "value" || Ut === "checked" || Ut === "selected")) {
                if (Ut === Pg) {
                  var Sr = n.innerHTML, ma = Xt ? Xt[Bv] : void 0;
                  if (ma != null) {
                    var ta = sS(n, ma);
                    ta !== Sr && vc(Ut, Sr, ta);
                  }
                } else if (Ut === ev) {
                  if (ne.delete(Ut), Fy) {
                    var bt = Io(Xt);
                    tr = n.getAttribute("style"), bt !== tr && vc(Ut, tr, bt);
                  }
                } else if (J && !Ve)
                  ne.delete(Ut.toLowerCase()), tr = Bi(n, Ut, Xt), Xt !== tr && vc(Ut, tr, Xt);
                else if (!ze(Ut, Dr, J) && !Pe(Ut, Xt, Dr, J)) {
                  var qt = !1;
                  if (Dr !== null)
                    ne.delete(Dr.attributeName), tr = ii(n, Ut, Xt, Dr);
                  else {
                    var Et = S;
                    if (Et === Du && (Et = tl(o)), Et === Du)
                      ne.delete(Ut.toLowerCase());
                    else {
                      var xn = Iy(Ut);
                      xn !== null && xn !== Ut && (qt = !0, ne.delete(xn)), ne.delete(Ut);
                    }
                    tr = Bi(n, Ut, Xt);
                  }
                  var nr = Ve;
                  !nr && Xt !== tr && !qt && vc(Ut, tr, Xt);
                }
              }
            }
          }
        }
      switch (j && ne.size > 0 && m[sm] !== !0 && J0(ne), o) {
        case "input":
          Os(n), Ua(n, m, !0);
          break;
        case "textarea":
          Os(n), $u(n);
          break;
        case "select":
        case "option":
          break;
        default:
          typeof m.onClick == "function" && K0(n);
          break;
      }
      return Pt;
    }
    function Hy(n, o, m) {
      var S = n.nodeValue !== o;
      return S;
    }
    function zg(n, o) {
      {
        if (Bf)
          return;
        Bf = !0, l("Did not expect server HTML to contain a <%s> in <%s>.", o.nodeName.toLowerCase(), n.nodeName.toLowerCase());
      }
    }
    function $0(n, o) {
      {
        if (Bf)
          return;
        Bf = !0, l('Did not expect server HTML to contain the text node "%s" in <%s>.', o.nodeValue, n.nodeName.toLowerCase());
      }
    }
    function Hv(n, o, m) {
      {
        if (Bf)
          return;
        Bf = !0, l("Expected server HTML to contain a matching <%s> in <%s>.", o, n.nodeName.toLowerCase());
      }
    }
    function El(n, o) {
      {
        if (o === "" || Bf)
          return;
        Bf = !0, l('Expected server HTML to contain a matching text node for "%s" in <%s>.', o, n.nodeName.toLowerCase());
      }
    }
    function y1(n, o, m) {
      switch (o) {
        case "input":
          bc(n, m);
          return;
        case "textarea":
          Fd(n, m);
          return;
        case "select":
          Pm(n, m);
          return;
      }
    }
    var lm = function() {
    }, Qc = function() {
    };
    {
      var x1 = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"], Ng = [
        "applet",
        "caption",
        "html",
        "table",
        "td",
        "th",
        "marquee",
        "object",
        "template",
        "foreignObject",
        "desc",
        "title"
      ], nv = Ng.concat(["button"]), _1 = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"], ex = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null
      };
      Qc = function(n, o) {
        var m = qn({}, n || ex), S = {
          tag: o
        };
        return Ng.indexOf(o) !== -1 && (m.aTagInScope = null, m.buttonTagInScope = null, m.nobrTagInScope = null), nv.indexOf(o) !== -1 && (m.pTagInButtonScope = null), x1.indexOf(o) !== -1 && o !== "address" && o !== "div" && o !== "p" && (m.listItemTagAutoclosing = null, m.dlItemTagAutoclosing = null), m.current = S, o === "form" && (m.formTag = S), o === "a" && (m.aTagInScope = S), o === "button" && (m.buttonTagInScope = S), o === "nobr" && (m.nobrTagInScope = S), o === "p" && (m.pTagInButtonScope = S), o === "li" && (m.listItemTagAutoclosing = S), (o === "dd" || o === "dt") && (m.dlItemTagAutoclosing = S), m;
      };
      var Vv = function(n, o) {
        switch (o) {
          case "select":
            return n === "option" || n === "optgroup" || n === "#text";
          case "optgroup":
            return n === "option" || n === "#text";
          case "option":
            return n === "#text";
          case "tr":
            return n === "th" || n === "td" || n === "style" || n === "script" || n === "template";
          case "tbody":
          case "thead":
          case "tfoot":
            return n === "tr" || n === "style" || n === "script" || n === "template";
          case "colgroup":
            return n === "col" || n === "template";
          case "table":
            return n === "caption" || n === "colgroup" || n === "tbody" || n === "tfoot" || n === "thead" || n === "style" || n === "script" || n === "template";
          case "head":
            return n === "base" || n === "basefont" || n === "bgsound" || n === "link" || n === "meta" || n === "title" || n === "noscript" || n === "noframes" || n === "style" || n === "script" || n === "template";
          case "html":
            return n === "head" || n === "body" || n === "frameset";
          case "frameset":
            return n === "frame";
          case "#document":
            return n === "html";
        }
        switch (n) {
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return o !== "h1" && o !== "h2" && o !== "h3" && o !== "h4" && o !== "h5" && o !== "h6";
          case "rp":
          case "rt":
            return _1.indexOf(o) === -1;
          case "body":
          case "caption":
          case "col":
          case "colgroup":
          case "frameset":
          case "frame":
          case "head":
          case "html":
          case "tbody":
          case "td":
          case "tfoot":
          case "th":
          case "thead":
          case "tr":
            return o == null;
        }
        return !0;
      }, S1 = function(n, o) {
        switch (n) {
          case "address":
          case "article":
          case "aside":
          case "blockquote":
          case "center":
          case "details":
          case "dialog":
          case "dir":
          case "div":
          case "dl":
          case "fieldset":
          case "figcaption":
          case "figure":
          case "footer":
          case "header":
          case "hgroup":
          case "main":
          case "menu":
          case "nav":
          case "ol":
          case "p":
          case "section":
          case "summary":
          case "ul":
          case "pre":
          case "listing":
          case "table":
          case "hr":
          case "xmp":
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return o.pTagInButtonScope;
          case "form":
            return o.formTag || o.pTagInButtonScope;
          case "li":
            return o.listItemTagAutoclosing;
          case "dd":
          case "dt":
            return o.dlItemTagAutoclosing;
          case "button":
            return o.buttonTagInScope;
          case "a":
            return o.aTagInScope;
          case "nobr":
            return o.nobrTagInScope;
        }
        return null;
      }, Vy = {};
      lm = function(n, o, m) {
        m = m || ex;
        var S = m.current, C = S && S.tag;
        o != null && (n != null && l("validateDOMNesting: when childText is passed, childTag should be null"), n = "#text");
        var F = Vv(n, C) ? null : S, j = F ? null : S1(n, m), J = F || j;
        if (!!J) {
          var ne = J.tag, Se = !!F + "|" + n + "|" + ne;
          if (!Vy[Se]) {
            Vy[Se] = !0;
            var Ce = n, nt = "";
            if (n === "#text" ? /\S/.test(o) ? Ce = "Text nodes" : (Ce = "Whitespace text nodes", nt = " Make sure you don't have any extra whitespace between tags on each line of your source code.") : Ce = "<" + n + ">", F) {
              var et = "";
              ne === "table" && n === "tr" && (et += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), l("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", Ce, ne, nt, et);
            } else
              l("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", Ce, ne);
          }
        }
      };
    }
    var Kl = "suppressHydrationWarning", Gy = "$", Wy = "/$", Fg = "$?", kg = "$!", lS = "style", w1 = null, b1 = null;
    function bb(n) {
      var o, m, S = n.nodeType;
      switch (S) {
        case Za:
        case Ma: {
          o = S === Za ? "#document" : "#fragment";
          var C = n.documentElement;
          m = C ? C.namespaceURI : vf(null, "");
          break;
        }
        default: {
          var F = S === Oi ? n.parentNode : n, j = F.namespaceURI || null;
          o = F.tagName, m = vf(j, o);
          break;
        }
      }
      {
        var J = o.toLowerCase(), ne = Qc(null, J);
        return {
          namespace: m,
          ancestorInfo: ne
        };
      }
    }
    function uS(n, o, m) {
      {
        var S = n, C = vf(S.namespace, o), F = Qc(S.ancestorInfo, o);
        return {
          namespace: C,
          ancestorInfo: F
        };
      }
    }
    function cS(n) {
      return n;
    }
    function fS(n) {
      w1 = Vc(), b1 = Vu();
      var o = null;
      return gs(!1), o;
    }
    function E1(n) {
      c1(b1), gs(w1), w1 = null, b1 = null;
    }
    function dS(n, o, m, S, C) {
      var F;
      {
        var j = S;
        if (lm(n, null, j.ancestorInfo), typeof o.children == "string" || typeof o.children == "number") {
          var J = "" + o.children, ne = Qc(j.ancestorInfo, n);
          lm(null, J, ne);
        }
        F = j.namespace;
      }
      var Se = Sb(n, o, m, F);
      return je(C, Se), mi(Se, o), Se;
    }
    function Eb(n, o) {
      n.appendChild(o);
    }
    function hS(n, o, m, S, C) {
      switch (bp(n, o, m, S), o) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          return !!m.autoFocus;
        case "img":
          return !0;
        default:
          return !1;
      }
    }
    function Mb(n, o, m, S, C, F) {
      {
        var j = F;
        if (typeof S.children != typeof m.children && (typeof S.children == "string" || typeof S.children == "number")) {
          var J = "" + S.children, ne = Qc(j.ancestorInfo, o);
          lm(null, J, ne);
        }
      }
      return g1(n, o, m, S);
    }
    function M1(n, o) {
      return n === "textarea" || n === "noscript" || typeof o.children == "string" || typeof o.children == "number" || typeof o.dangerouslySetInnerHTML == "object" && o.dangerouslySetInnerHTML !== null && o.dangerouslySetInnerHTML.__html != null;
    }
    function Tb(n, o, m, S) {
      {
        var C = m;
        lm(null, n, C.ancestorInfo);
      }
      var F = wb(n, o);
      return je(S, F), F;
    }
    function Cb() {
      var n = window.event;
      return n === void 0 ? rs : xu(n.type);
    }
    var T1 = typeof setTimeout == "function" ? setTimeout : void 0, C1 = typeof clearTimeout == "function" ? clearTimeout : void 0, Ig = -1, jy = typeof Promise == "function" ? Promise : void 0, pS = typeof queueMicrotask == "function" ? queueMicrotask : typeof jy < "u" ? function(n) {
      return jy.resolve(null).then(n).catch(Rb);
    } : T1;
    function Rb(n) {
      setTimeout(function() {
        throw n;
      });
    }
    function mS(n, o, m, S) {
      switch (o) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          m.autoFocus && n.focus();
          return;
        case "img": {
          m.src && (n.src = m.src);
          return;
        }
      }
    }
    function tx(n, o, m, S, C, F) {
      oS(n, o, m, S, C), mi(n, C);
    }
    function Yy(n) {
      ca(n, "");
    }
    function vS(n, o, m) {
      n.nodeValue = m;
    }
    function R1(n, o) {
      n.appendChild(o);
    }
    function gS(n, o) {
      var m;
      n.nodeType === Oi ? (m = n.parentNode, m.insertBefore(o, n)) : (m = n, m.appendChild(o));
      var S = n._reactRootContainer;
      S == null && m.onclick === null && K0(m);
    }
    function yS(n, o, m) {
      n.insertBefore(o, m);
    }
    function nx(n, o, m) {
      n.nodeType === Oi ? n.parentNode.insertBefore(o, m) : n.insertBefore(o, m);
    }
    function rx(n, o) {
      n.removeChild(o);
    }
    function Ab(n, o) {
      n.nodeType === Oi ? n.parentNode.removeChild(o) : n.removeChild(o);
    }
    function A1(n, o) {
      var m = o, S = 0;
      do {
        var C = m.nextSibling;
        if (n.removeChild(m), C && C.nodeType === Oi) {
          var F = C.data;
          if (F === Wy)
            if (S === 0) {
              n.removeChild(C), zr(o);
              return;
            } else
              S--;
          else
            (F === Gy || F === Fg || F === kg) && S++;
        }
        m = C;
      } while (m);
      zr(o);
    }
    function Vf(n, o) {
      n.nodeType === Oi ? A1(n.parentNode, o) : n.nodeType === zl && A1(n, o), zr(n);
    }
    function ix(n) {
      n = n;
      var o = n.style;
      typeof o.setProperty == "function" ? o.setProperty("display", "none", "important") : o.display = "none";
    }
    function Db(n) {
      n.nodeValue = "";
    }
    function Lb(n, o) {
      n = n;
      var m = o[lS], S = m != null && m.hasOwnProperty("display") ? m.display : null;
      n.style.display = yh("display", S);
    }
    function Pb(n, o) {
      n.nodeValue = o;
    }
    function Ob(n) {
      n.nodeType === zl ? n.textContent = "" : n.nodeType === Za && n.documentElement && n.removeChild(n.documentElement);
    }
    function ax(n, o, m) {
      return n.nodeType !== zl || o.toLowerCase() !== n.nodeName.toLowerCase() ? null : n;
    }
    function Ub(n, o) {
      return o === "" || n.nodeType !== ec ? null : n;
    }
    function Xy(n) {
      return n.nodeType !== Oi ? null : n;
    }
    function D1(n) {
      return n.data === Fg;
    }
    function L1(n) {
      return n.data === kg;
    }
    function xS(n) {
      var o = n.nextSibling && n.nextSibling.dataset, m, S, C;
      return o && (m = o.dgst, S = o.msg, C = o.stck), {
        message: S,
        digest: m,
        stack: C
      };
    }
    function zb(n, o) {
      n._reactRetry = o;
    }
    function Bg(n) {
      for (; n != null; n = n.nextSibling) {
        var o = n.nodeType;
        if (o === zl || o === ec)
          break;
        if (o === Oi) {
          var m = n.data;
          if (m === Gy || m === kg || m === Fg)
            break;
          if (m === Wy)
            return null;
        }
      }
      return n;
    }
    function qy(n) {
      return Bg(n.nextSibling);
    }
    function sx(n) {
      return Bg(n.firstChild);
    }
    function um(n) {
      return Bg(n.firstChild);
    }
    function P1(n) {
      return Bg(n.nextSibling);
    }
    function Qy(n, o, m, S, C, F, j) {
      je(F, n), mi(n, m);
      var J;
      {
        var ne = C;
        J = ne.namespace;
      }
      var Se = (F.mode & Gr) !== hr;
      return By(n, o, m, J, S, Se, j);
    }
    function Nb(n, o, m, S) {
      return je(m, n), m.mode & Gr, Hy(n, o);
    }
    function _S(n, o) {
      je(o, n);
    }
    function Fb(n) {
      for (var o = n.nextSibling, m = 0; o; ) {
        if (o.nodeType === Oi) {
          var S = o.data;
          if (S === Wy) {
            if (m === 0)
              return qy(o);
            m--;
          } else
            (S === Gy || S === kg || S === Fg) && m++;
        }
        o = o.nextSibling;
      }
      return null;
    }
    function O1(n) {
      for (var o = n.previousSibling, m = 0; o; ) {
        if (o.nodeType === Oi) {
          var S = o.data;
          if (S === Gy || S === kg || S === Fg) {
            if (m === 0)
              return o;
            m--;
          } else
            S === Wy && m++;
        }
        o = o.previousSibling;
      }
      return null;
    }
    function SS(n) {
      zr(n);
    }
    function wS(n) {
      zr(n);
    }
    function U1(n) {
      return n !== "head" && n !== "body";
    }
    function kb(n, o, m, S) {
      var C = !0;
      tv(o.nodeValue, m, S, C);
    }
    function Zy(n, o, m, S, C, F) {
      if (o[Kl] !== !0) {
        var j = !0;
        tv(S.nodeValue, C, F, j);
      }
    }
    function ox(n, o) {
      o.nodeType === zl ? zg(n, o) : o.nodeType === Oi || $0(n, o);
    }
    function Ib(n, o) {
      {
        var m = n.parentNode;
        m !== null && (o.nodeType === zl ? zg(m, o) : o.nodeType === Oi || $0(m, o));
      }
    }
    function bS(n, o, m, S, C) {
      (C || o[Kl] !== !0) && (S.nodeType === zl ? zg(m, S) : S.nodeType === Oi || $0(m, S));
    }
    function Bb(n, o, m) {
      Hv(n, o);
    }
    function ES(n, o) {
      El(n, o);
    }
    function MS(n, o, m) {
      {
        var S = n.parentNode;
        S !== null && Hv(S, o);
      }
    }
    function lx(n, o) {
      {
        var m = n.parentNode;
        m !== null && El(m, o);
      }
    }
    function rv(n, o, m, S, C, F) {
      (F || o[Kl] !== !0) && Hv(m, S);
    }
    function Hb(n, o, m, S, C) {
      (C || o[Kl] !== !0) && El(m, S);
    }
    function Vn(n) {
      l("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", n.nodeName.toLowerCase());
    }
    function Hg(n) {
      Yc(n);
    }
    var zh = Math.random().toString(36).slice(2), v = "__reactFiber$" + zh, b = "__reactProps$" + zh, N = "__reactContainer$" + zh, Z = "__reactEvents$" + zh, ie = "__reactListeners$" + zh, be = "__reactHandles$" + zh;
    function ke(n) {
      delete n[v], delete n[b], delete n[Z], delete n[ie], delete n[be];
    }
    function je(n, o) {
      o[v] = n;
    }
    function lt(n, o) {
      o[N] = n;
    }
    function nn(n) {
      n[N] = null;
    }
    function Kt(n) {
      return !!n[N];
    }
    function on(n) {
      var o = n[v];
      if (o)
        return o;
      for (var m = n.parentNode; m; ) {
        if (o = m[N] || m[v], o) {
          var S = o.alternate;
          if (o.child !== null || S !== null && S.child !== null)
            for (var C = O1(n); C !== null; ) {
              var F = C[v];
              if (F)
                return F;
              C = O1(C);
            }
          return o;
        }
        n = m, m = n.parentNode;
      }
      return null;
    }
    function Cn(n) {
      var o = n[v] || n[N];
      return o && (o.tag === R || o.tag === D || o.tag === Q || o.tag === w) ? o : null;
    }
    function On(n) {
      if (n.tag === R || n.tag === D)
        return n.stateNode;
      throw new Error("getNodeFromInstance: Invalid argument.");
    }
    function dr(n) {
      return n[b] || null;
    }
    function mi(n, o) {
      n[b] = o;
    }
    function Fr(n) {
      var o = n[Z];
      return o === void 0 && (o = n[Z] = /* @__PURE__ */ new Set()), o;
    }
    var Fi = {}, Ji = t.ReactDebugCurrentFrame;
    function Gu(n) {
      if (n) {
        var o = n._owner, m = Pl(n.type, n._source, o ? o.type : null);
        Ji.setExtraStackFrame(m);
      } else
        Ji.setExtraStackFrame(null);
    }
    function Gs(n, o, m, S, C) {
      {
        var F = Function.call.bind(dt);
        for (var j in n)
          if (F(n, j)) {
            var J = void 0;
            try {
              if (typeof n[j] != "function") {
                var ne = Error((S || "React class") + ": " + m + " type `" + j + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof n[j] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw ne.name = "Invariant Violation", ne;
              }
              J = n[j](o, j, S, m, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Se) {
              J = Se;
            }
            J && !(J instanceof Error) && (Gu(C), l("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", S || "React class", m, j, typeof J), Gu(null)), J instanceof Error && !(J.message in Fi) && (Fi[J.message] = !0, Gu(C), l("Failed %s type: %s", m, J.message), Gu(null));
          }
      }
    }
    var gc = [], Ws;
    Ws = [];
    var $l = -1;
    function Wu(n) {
      return {
        current: n
      };
    }
    function ju(n, o) {
      if ($l < 0) {
        l("Unexpected pop.");
        return;
      }
      o !== Ws[$l] && l("Unexpected Fiber popped."), n.current = gc[$l], gc[$l] = null, Ws[$l] = null, $l--;
    }
    function Gf(n, o, m) {
      $l++, gc[$l] = n.current, Ws[$l] = m, n.current = o;
    }
    var Vb;
    Vb = {};
    var eh = {};
    Object.freeze(eh);
    var iv = Wu(eh), cm = Wu(!1), z1 = eh;
    function Vg(n, o, m) {
      return m && fm(o) ? z1 : iv.current;
    }
    function Gb(n, o, m) {
      {
        var S = n.stateNode;
        S.__reactInternalMemoizedUnmaskedChildContext = o, S.__reactInternalMemoizedMaskedChildContext = m;
      }
    }
    function ux(n, o) {
      {
        var m = n.type, S = m.contextTypes;
        if (!S)
          return eh;
        var C = n.stateNode;
        if (C && C.__reactInternalMemoizedUnmaskedChildContext === o)
          return C.__reactInternalMemoizedMaskedChildContext;
        var F = {};
        for (var j in S)
          F[j] = o[j];
        {
          var J = xr(n) || "Unknown";
          Gs(S, F, "context", J);
        }
        return C && Gb(n, o, F), F;
      }
    }
    function cx() {
      return cm.current;
    }
    function fm(n) {
      {
        var o = n.childContextTypes;
        return o != null;
      }
    }
    function TS(n) {
      ju(cm, n), ju(iv, n);
    }
    function fx(n) {
      ju(cm, n), ju(iv, n);
    }
    function oT(n, o, m) {
      {
        if (iv.current !== eh)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        Gf(iv, o, n), Gf(cm, m, n);
      }
    }
    function lT(n, o, m) {
      {
        var S = n.stateNode, C = o.childContextTypes;
        if (typeof S.getChildContext != "function") {
          {
            var F = xr(n) || "Unknown";
            Vb[F] || (Vb[F] = !0, l("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", F, F));
          }
          return m;
        }
        var j = S.getChildContext();
        for (var J in j)
          if (!(J in C))
            throw new Error((xr(n) || "Unknown") + '.getChildContext(): key "' + J + '" is not defined in childContextTypes.');
        {
          var ne = xr(n) || "Unknown";
          Gs(C, j, "child context", ne);
        }
        return qn({}, m, j);
      }
    }
    function CS(n) {
      {
        var o = n.stateNode, m = o && o.__reactInternalMemoizedMergedChildContext || eh;
        return z1 = iv.current, Gf(iv, m, n), Gf(cm, cm.current, n), !0;
      }
    }
    function uT(n, o, m) {
      {
        var S = n.stateNode;
        if (!S)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (m) {
          var C = lT(n, o, z1);
          S.__reactInternalMemoizedMergedChildContext = C, ju(cm, n), ju(iv, n), Gf(iv, C, n), Gf(cm, m, n);
        } else
          ju(cm, n), Gf(cm, m, n);
      }
    }
    function iR(n) {
      {
        if (!zu(n) || n.tag !== g)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var o = n;
        do {
          switch (o.tag) {
            case w:
              return o.stateNode.context;
            case g: {
              var m = o.type;
              if (fm(m))
                return o.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          o = o.return;
        } while (o !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var Gg = 0, N1 = 1, dm = null, Wb = !1, RS = !1;
    function cT(n) {
      dm === null ? dm = [n] : dm.push(n);
    }
    function fT(n) {
      Wb = !0, cT(n);
    }
    function dT() {
      Wb && Wg();
    }
    function Wg() {
      if (!RS && dm !== null) {
        RS = !0;
        var n = 0, o = pc();
        try {
          var m = !0, S = dm;
          for (ro(qo); n < S.length; n++) {
            var C = S[n];
            do
              C = C(m);
            while (C !== null);
          }
          dm = null, Wb = !1;
        } catch (F) {
          throw dm !== null && (dm = dm.slice(n + 1)), Go(Wp, Wg), F;
        } finally {
          ro(o), RS = !1;
        }
      }
      return null;
    }
    var dx = [], hx = 0, AS = null, DS = 0, Ep = [], Mp = 0, Jy = null, Gv = 1, Wv = "";
    function hT(n) {
      return hm(), (n.flags & lc) !== vr;
    }
    function Tp(n) {
      return hm(), DS;
    }
    function aR() {
      var n = Wv, o = Gv, m = o & ~LS(o);
      return m.toString(32) + n;
    }
    function Ky(n, o) {
      hm(), dx[hx++] = DS, dx[hx++] = AS, AS = n, DS = o;
    }
    function pT(n, o, m) {
      hm(), Ep[Mp++] = Gv, Ep[Mp++] = Wv, Ep[Mp++] = Jy, Jy = n;
      var S = Gv, C = Wv, F = $y(S) - 1, j = S & ~(1 << F), J = m + 1, ne = $y(o) + F;
      if (ne > 30) {
        var Se = F - F % 5, Ce = (1 << Se) - 1, nt = (j & Ce).toString(32), et = j >> Se, Pt = F - Se, Ut = $y(o) + Pt, Xt = J << Pt, tr = Xt | et, Dr = nt + C;
        Gv = 1 << Ut | tr, Wv = Dr;
      } else {
        var Sr = J << F, ma = Sr | j, ta = C;
        Gv = 1 << ne | ma, Wv = ta;
      }
    }
    function jb(n) {
      hm();
      var o = n.return;
      if (o !== null) {
        var m = 1, S = 0;
        Ky(n, m), pT(n, m, S);
      }
    }
    function $y(n) {
      return 32 - Xl(n);
    }
    function LS(n) {
      return 1 << $y(n) - 1;
    }
    function px(n) {
      for (; n === AS; )
        AS = dx[--hx], dx[hx] = null, DS = dx[--hx], dx[hx] = null;
      for (; n === Jy; )
        Jy = Ep[--Mp], Ep[Mp] = null, Wv = Ep[--Mp], Ep[Mp] = null, Gv = Ep[--Mp], Ep[Mp] = null;
    }
    function PS() {
      return hm(), Jy !== null ? {
        id: Gv,
        overflow: Wv
      } : null;
    }
    function OS(n, o) {
      hm(), Ep[Mp++] = Gv, Ep[Mp++] = Wv, Ep[Mp++] = Jy, Gv = o.id, Wv = o.overflow, Jy = n;
    }
    function hm() {
      js() || l("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var Zc = null, Cp = null, pm = !1, e0 = !1, jg = null;
    function Yb() {
      pm && l("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function US() {
      e0 = !0;
    }
    function Xb() {
      return e0;
    }
    function mT(n) {
      var o = n.stateNode.containerInfo;
      return Cp = um(o), Zc = n, pm = !0, jg = null, e0 = !1, !0;
    }
    function sR(n, o, m) {
      return Cp = P1(o), Zc = n, pm = !0, jg = null, e0 = !1, m !== null && OS(n, m), !0;
    }
    function F1(n, o) {
      switch (n.tag) {
        case w: {
          ox(n.stateNode.containerInfo, o);
          break;
        }
        case R: {
          var m = (n.mode & Gr) !== hr;
          bS(
            n.type,
            n.memoizedProps,
            n.stateNode,
            o,
            m
          );
          break;
        }
        case Q: {
          var S = n.memoizedState;
          S.dehydrated !== null && Ib(S.dehydrated, o);
          break;
        }
      }
    }
    function vT(n, o) {
      F1(n, o);
      var m = JB();
      m.stateNode = o, m.return = n;
      var S = n.deletions;
      S === null ? (n.deletions = [m], n.flags |= wi) : S.push(m);
    }
    function qb(n, o) {
      {
        if (e0)
          return;
        switch (n.tag) {
          case w: {
            var m = n.stateNode.containerInfo;
            switch (o.tag) {
              case R:
                var S = o.type;
                o.pendingProps, Bb(m, S);
                break;
              case D:
                var C = o.pendingProps;
                ES(m, C);
                break;
            }
            break;
          }
          case R: {
            var F = n.type, j = n.memoizedProps, J = n.stateNode;
            switch (o.tag) {
              case R: {
                var ne = o.type, Se = o.pendingProps, Ce = (n.mode & Gr) !== hr;
                rv(
                  F,
                  j,
                  J,
                  ne,
                  Se,
                  Ce
                );
                break;
              }
              case D: {
                var nt = o.pendingProps, et = (n.mode & Gr) !== hr;
                Hb(
                  F,
                  j,
                  J,
                  nt,
                  et
                );
                break;
              }
            }
            break;
          }
          case Q: {
            var Pt = n.memoizedState, Ut = Pt.dehydrated;
            if (Ut !== null)
              switch (o.tag) {
                case R:
                  var Xt = o.type;
                  o.pendingProps, MS(Ut, Xt);
                  break;
                case D:
                  var tr = o.pendingProps;
                  lx(Ut, tr);
                  break;
              }
            break;
          }
          default:
            return;
        }
      }
    }
    function gT(n, o) {
      o.flags = o.flags & ~Il | si, qb(n, o);
    }
    function k1(n, o) {
      switch (n.tag) {
        case R: {
          var m = n.type;
          n.pendingProps;
          var S = ax(o, m);
          return S !== null ? (n.stateNode = S, Zc = n, Cp = sx(S), !0) : !1;
        }
        case D: {
          var C = n.pendingProps, F = Ub(o, C);
          return F !== null ? (n.stateNode = F, Zc = n, Cp = null, !0) : !1;
        }
        case Q: {
          var j = Xy(o);
          if (j !== null) {
            var J = {
              dehydrated: j,
              treeContext: PS(),
              retryLane: yu
            };
            n.memoizedState = J;
            var ne = KB(j);
            return ne.return = n, n.child = ne, Zc = n, Cp = null, !0;
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function Qb(n) {
      return (n.mode & Gr) !== hr && (n.flags & Rr) === vr;
    }
    function Zb(n) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function Jb(n) {
      if (!!pm) {
        var o = Cp;
        if (!o) {
          Qb(n) && (qb(Zc, n), Zb()), gT(Zc, n), pm = !1, Zc = n;
          return;
        }
        var m = o;
        if (!k1(n, o)) {
          Qb(n) && (qb(Zc, n), Zb()), o = qy(m);
          var S = Zc;
          if (!o || !k1(n, o)) {
            gT(Zc, n), pm = !1, Zc = n;
            return;
          }
          vT(S, m);
        }
      }
    }
    function oR(n, o, m) {
      var S = n.stateNode, C = !e0, F = Qy(S, n.type, n.memoizedProps, o, m, n, C);
      return n.updateQueue = F, F !== null;
    }
    function yT(n) {
      var o = n.stateNode, m = n.memoizedProps, S = Nb(o, m, n);
      if (S) {
        var C = Zc;
        if (C !== null)
          switch (C.tag) {
            case w: {
              var F = C.stateNode.containerInfo, j = (C.mode & Gr) !== hr;
              kb(
                F,
                o,
                m,
                j
              );
              break;
            }
            case R: {
              var J = C.type, ne = C.memoizedProps, Se = C.stateNode, Ce = (C.mode & Gr) !== hr;
              Zy(
                J,
                ne,
                Se,
                o,
                m,
                Ce
              );
              break;
            }
          }
      }
      return S;
    }
    function lR(n) {
      var o = n.memoizedState, m = o !== null ? o.dehydrated : null;
      if (!m)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      _S(m, n);
    }
    function Kb(n) {
      var o = n.memoizedState, m = o !== null ? o.dehydrated : null;
      if (!m)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return Fb(m);
    }
    function zS(n) {
      for (var o = n.return; o !== null && o.tag !== R && o.tag !== w && o.tag !== Q; )
        o = o.return;
      Zc = o;
    }
    function oo(n) {
      if (n !== Zc)
        return !1;
      if (!pm)
        return zS(n), pm = !0, !1;
      if (n.tag !== w && (n.tag !== R || U1(n.type) && !M1(n.type, n.memoizedProps))) {
        var o = Cp;
        if (o)
          if (Qb(n))
            eu(n), Zb();
          else
            for (; o; )
              vT(n, o), o = qy(o);
      }
      return zS(n), n.tag === Q ? Cp = Kb(n) : Cp = Zc ? qy(n.stateNode) : null, !0;
    }
    function mm() {
      return pm && Cp !== null;
    }
    function eu(n) {
      for (var o = Cp; o; )
        F1(n, o), o = qy(o);
    }
    function Yg() {
      Zc = null, Cp = null, pm = !1, e0 = !1;
    }
    function Jc() {
      jg !== null && (FP(jg), jg = null);
    }
    function js() {
      return pm;
    }
    function vm(n) {
      jg === null ? jg = [n] : jg.push(n);
    }
    var I1 = t.ReactCurrentBatchConfig, t0 = null;
    function NS() {
      return I1.transition;
    }
    var Ed = {
      recordUnsafeLifecycleWarnings: function(n, o) {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function(n, o) {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    };
    {
      var xT = function(n) {
        for (var o = null, m = n; m !== null; )
          m.mode & ui && (o = m), m = m.return;
        return o;
      }, jv = function(n) {
        var o = [];
        return n.forEach(function(m) {
          o.push(m);
        }), o.sort().join(", ");
      }, ci = [], Su = [], Ys = [], cl = [], th = [], n0 = [], Ro = /* @__PURE__ */ new Set();
      Ed.recordUnsafeLifecycleWarnings = function(n, o) {
        Ro.has(n.type) || (typeof o.componentWillMount == "function" && o.componentWillMount.__suppressDeprecationWarning !== !0 && ci.push(n), n.mode & ui && typeof o.UNSAFE_componentWillMount == "function" && Su.push(n), typeof o.componentWillReceiveProps == "function" && o.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && Ys.push(n), n.mode & ui && typeof o.UNSAFE_componentWillReceiveProps == "function" && cl.push(n), typeof o.componentWillUpdate == "function" && o.componentWillUpdate.__suppressDeprecationWarning !== !0 && th.push(n), n.mode & ui && typeof o.UNSAFE_componentWillUpdate == "function" && n0.push(n));
      }, Ed.flushPendingUnsafeLifecycleWarnings = function() {
        var n = /* @__PURE__ */ new Set();
        ci.length > 0 && (ci.forEach(function(et) {
          n.add(xr(et) || "Component"), Ro.add(et.type);
        }), ci = []);
        var o = /* @__PURE__ */ new Set();
        Su.length > 0 && (Su.forEach(function(et) {
          o.add(xr(et) || "Component"), Ro.add(et.type);
        }), Su = []);
        var m = /* @__PURE__ */ new Set();
        Ys.length > 0 && (Ys.forEach(function(et) {
          m.add(xr(et) || "Component"), Ro.add(et.type);
        }), Ys = []);
        var S = /* @__PURE__ */ new Set();
        cl.length > 0 && (cl.forEach(function(et) {
          S.add(xr(et) || "Component"), Ro.add(et.type);
        }), cl = []);
        var C = /* @__PURE__ */ new Set();
        th.length > 0 && (th.forEach(function(et) {
          C.add(xr(et) || "Component"), Ro.add(et.type);
        }), th = []);
        var F = /* @__PURE__ */ new Set();
        if (n0.length > 0 && (n0.forEach(function(et) {
          F.add(xr(et) || "Component"), Ro.add(et.type);
        }), n0 = []), o.size > 0) {
          var j = jv(o);
          l(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, j);
        }
        if (S.size > 0) {
          var J = jv(S);
          l(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, J);
        }
        if (F.size > 0) {
          var ne = jv(F);
          l(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, ne);
        }
        if (n.size > 0) {
          var Se = jv(n);
          s(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, Se);
        }
        if (m.size > 0) {
          var Ce = jv(m);
          s(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, Ce);
        }
        if (C.size > 0) {
          var nt = jv(C);
          s(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, nt);
        }
      };
      var Xg = /* @__PURE__ */ new Map(), B1 = /* @__PURE__ */ new Set();
      Ed.recordLegacyContextWarning = function(n, o) {
        var m = xT(n);
        if (m === null) {
          l("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!B1.has(n.type)) {
          var S = Xg.get(m);
          (n.type.contextTypes != null || n.type.childContextTypes != null || o !== null && typeof o.getChildContext == "function") && (S === void 0 && (S = [], Xg.set(m, S)), S.push(n));
        }
      }, Ed.flushLegacyContextWarning = function() {
        Xg.forEach(function(n, o) {
          if (n.length !== 0) {
            var m = n[0], S = /* @__PURE__ */ new Set();
            n.forEach(function(F) {
              S.add(xr(F) || "Component"), B1.add(F.type);
            });
            var C = jv(S);
            try {
              Xi(m), l(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, C);
            } finally {
              Ka();
            }
          }
        });
      }, Ed.discardPendingWarnings = function() {
        ci = [], Su = [], Ys = [], cl = [], th = [], n0 = [], Xg = /* @__PURE__ */ new Map();
      };
    }
    function Md(n, o) {
      if (n && n.defaultProps) {
        var m = qn({}, o), S = n.defaultProps;
        for (var C in S)
          m[C] === void 0 && (m[C] = S[C]);
        return m;
      }
      return o;
    }
    var mx = Wu(null), r0;
    r0 = {};
    var Kc = null, qg = null, FS = null, H1 = !1;
    function kS() {
      Kc = null, qg = null, FS = null, H1 = !1;
    }
    function i0() {
      H1 = !0;
    }
    function $b() {
      H1 = !1;
    }
    function V1(n, o, m) {
      Gf(mx, o._currentValue, n), o._currentValue = m, o._currentRenderer !== void 0 && o._currentRenderer !== null && o._currentRenderer !== r0 && l("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), o._currentRenderer = r0;
    }
    function G1(n, o) {
      var m = mx.current;
      ju(mx, o), n._currentValue = m;
    }
    function Qg(n, o, m) {
      for (var S = n; S !== null; ) {
        var C = S.alternate;
        if (Lt(S.childLanes, o) ? C !== null && !Lt(C.childLanes, o) && (C.childLanes = Qt(C.childLanes, o)) : (S.childLanes = Qt(S.childLanes, o), C !== null && (C.childLanes = Qt(C.childLanes, o))), S === m)
          break;
        S = S.return;
      }
      S !== m && l("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function a0(n, o, m) {
      Yv(n, o, m);
    }
    function Yv(n, o, m) {
      var S = n.child;
      for (S !== null && (S.return = n); S !== null; ) {
        var C = void 0, F = S.dependencies;
        if (F !== null) {
          C = S.child;
          for (var j = F.firstContext; j !== null; ) {
            if (j.context === o) {
              if (S.tag === g) {
                var J = Li(m), ne = sv(ti, J);
                ne.tag = Tl;
                var Se = S.updateQueue;
                if (Se !== null) {
                  var Ce = Se.shared, nt = Ce.pending;
                  nt === null ? ne.next = ne : (ne.next = nt.next, nt.next = ne), Ce.pending = ne;
                }
              }
              S.lanes = Qt(S.lanes, m);
              var et = S.alternate;
              et !== null && (et.lanes = Qt(et.lanes, m)), Qg(S.return, m, n), F.lanes = Qt(F.lanes, m);
              break;
            }
            j = j.next;
          }
        } else if (S.tag === I)
          C = S.type === n.type ? null : S.child;
        else if (S.tag === se) {
          var Pt = S.return;
          if (Pt === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          Pt.lanes = Qt(Pt.lanes, m);
          var Ut = Pt.alternate;
          Ut !== null && (Ut.lanes = Qt(Ut.lanes, m)), Qg(Pt, m, n), C = S.sibling;
        } else
          C = S.child;
        if (C !== null)
          C.return = S;
        else
          for (C = S; C !== null; ) {
            if (C === n) {
              C = null;
              break;
            }
            var Xt = C.sibling;
            if (Xt !== null) {
              Xt.return = C.return, C = Xt;
              break;
            }
            C = C.return;
          }
        S = C;
      }
    }
    function av(n, o) {
      Kc = n, qg = null, FS = null;
      var m = n.dependencies;
      if (m !== null) {
        var S = m.firstContext;
        S !== null && (Ze(m.lanes, o) && OE(), m.firstContext = null);
      }
    }
    function Ml(n) {
      H1 && l("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var o = n._currentValue;
      if (FS !== n) {
        var m = {
          context: n,
          memoizedValue: o,
          next: null
        };
        if (qg === null) {
          if (Kc === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          qg = m, Kc.dependencies = {
            lanes: Ht,
            firstContext: m
          };
        } else
          qg = qg.next = m;
      }
      return o;
    }
    var s0 = null;
    function o0(n) {
      s0 === null ? s0 = [n] : s0.push(n);
    }
    function eE() {
      if (s0 !== null) {
        for (var n = 0; n < s0.length; n++) {
          var o = s0[n], m = o.interleaved;
          if (m !== null) {
            o.interleaved = null;
            var S = m.next, C = o.pending;
            if (C !== null) {
              var F = C.next;
              C.next = S, m.next = F;
            }
            o.pending = m;
          }
        }
        s0 = null;
      }
    }
    function _T(n, o, m, S) {
      var C = o.interleaved;
      return C === null ? (m.next = m, o0(o)) : (m.next = C.next, C.next = m), o.interleaved = m, yc(n, S);
    }
    function IS(n, o, m, S) {
      var C = o.interleaved;
      C === null ? (m.next = m, o0(o)) : (m.next = C.next, C.next = m), o.interleaved = m;
    }
    function W1(n, o, m, S) {
      var C = o.interleaved;
      return C === null ? (m.next = m, o0(o)) : (m.next = C.next, C.next = m), o.interleaved = m, yc(n, S);
    }
    function $c(n, o) {
      return yc(n, o);
    }
    var BS = yc;
    function yc(n, o) {
      n.lanes = Qt(n.lanes, o);
      var m = n.alternate;
      m !== null && (m.lanes = Qt(m.lanes, o)), m === null && (n.flags & (si | Il)) !== vr && QP(n);
      for (var S = n, C = n.return; C !== null; )
        C.childLanes = Qt(C.childLanes, o), m = C.alternate, m !== null ? m.childLanes = Qt(m.childLanes, o) : (C.flags & (si | Il)) !== vr && QP(n), S = C, C = C.return;
      if (S.tag === w) {
        var F = S.stateNode;
        return F;
      } else
        return null;
    }
    var Xv = 0, ST = 1, Tl = 2, tE = 3, l0 = !1, HS, ef;
    HS = !1, ef = null;
    function VS(n) {
      var o = {
        baseState: n.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          interleaved: null,
          lanes: Ht
        },
        effects: null
      };
      n.updateQueue = o;
    }
    function GS(n, o) {
      var m = o.updateQueue, S = n.updateQueue;
      if (m === S) {
        var C = {
          baseState: S.baseState,
          firstBaseUpdate: S.firstBaseUpdate,
          lastBaseUpdate: S.lastBaseUpdate,
          shared: S.shared,
          effects: S.effects
        };
        o.updateQueue = C;
      }
    }
    function sv(n, o) {
      var m = {
        eventTime: n,
        lane: o,
        tag: Xv,
        payload: null,
        callback: null,
        next: null
      };
      return m;
    }
    function Zg(n, o, m) {
      var S = n.updateQueue;
      if (S === null)
        return null;
      var C = S.shared;
      if (ef === C && !HS && (l("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), HS = !0), uB()) {
        var F = C.pending;
        return F === null ? o.next = o : (o.next = F.next, F.next = o), C.pending = o, BS(n, m);
      } else
        return W1(n, C, o, m);
    }
    function WS(n, o, m) {
      var S = o.updateQueue;
      if (S !== null) {
        var C = S.shared;
        if (br(m)) {
          var F = C.lanes;
          F = Wr(F, n.pendingLanes);
          var j = Qt(F, m);
          C.lanes = j, gr(n, j);
        }
      }
    }
    function ov(n, o) {
      var m = n.updateQueue, S = n.alternate;
      if (S !== null) {
        var C = S.updateQueue;
        if (m === C) {
          var F = null, j = null, J = m.firstBaseUpdate;
          if (J !== null) {
            var ne = J;
            do {
              var Se = {
                eventTime: ne.eventTime,
                lane: ne.lane,
                tag: ne.tag,
                payload: ne.payload,
                callback: ne.callback,
                next: null
              };
              j === null ? F = j = Se : (j.next = Se, j = Se), ne = ne.next;
            } while (ne !== null);
            j === null ? F = j = o : (j.next = o, j = o);
          } else
            F = j = o;
          m = {
            baseState: C.baseState,
            firstBaseUpdate: F,
            lastBaseUpdate: j,
            shared: C.shared,
            effects: C.effects
          }, n.updateQueue = m;
          return;
        }
      }
      var Ce = m.lastBaseUpdate;
      Ce === null ? m.firstBaseUpdate = o : Ce.next = o, m.lastBaseUpdate = o;
    }
    function wT(n, o, m, S, C, F) {
      switch (m.tag) {
        case ST: {
          var j = m.payload;
          if (typeof j == "function") {
            i0();
            var J = j.call(F, S, C);
            {
              if (n.mode & ui) {
                xa(!0);
                try {
                  j.call(F, S, C);
                } finally {
                  xa(!1);
                }
              }
              $b();
            }
            return J;
          }
          return j;
        }
        case tE:
          n.flags = n.flags & ~wo | Rr;
        case Xv: {
          var ne = m.payload, Se;
          if (typeof ne == "function") {
            i0(), Se = ne.call(F, S, C);
            {
              if (n.mode & ui) {
                xa(!0);
                try {
                  ne.call(F, S, C);
                } finally {
                  xa(!1);
                }
              }
              $b();
            }
          } else
            Se = ne;
          return Se == null ? S : qn({}, S, Se);
        }
        case Tl:
          return l0 = !0, S;
      }
      return S;
    }
    function jS(n, o, m, S) {
      var C = n.updateQueue;
      l0 = !1, ef = C.shared;
      var F = C.firstBaseUpdate, j = C.lastBaseUpdate, J = C.shared.pending;
      if (J !== null) {
        C.shared.pending = null;
        var ne = J, Se = ne.next;
        ne.next = null, j === null ? F = Se : j.next = Se, j = ne;
        var Ce = n.alternate;
        if (Ce !== null) {
          var nt = Ce.updateQueue, et = nt.lastBaseUpdate;
          et !== j && (et === null ? nt.firstBaseUpdate = Se : et.next = Se, nt.lastBaseUpdate = ne);
        }
      }
      if (F !== null) {
        var Pt = C.baseState, Ut = Ht, Xt = null, tr = null, Dr = null, Sr = F;
        do {
          var ma = Sr.lane, ta = Sr.eventTime;
          if (Lt(S, ma)) {
            if (Dr !== null) {
              var qt = {
                eventTime: ta,
                lane: pi,
                tag: Sr.tag,
                payload: Sr.payload,
                callback: Sr.callback,
                next: null
              };
              Dr = Dr.next = qt;
            }
            Pt = wT(n, C, Sr, Pt, o, m);
            var Et = Sr.callback;
            if (Et !== null && Sr.lane !== pi) {
              n.flags |= Oc;
              var xn = C.effects;
              xn === null ? C.effects = [Sr] : xn.push(Sr);
            }
          } else {
            var bt = {
              eventTime: ta,
              lane: ma,
              tag: Sr.tag,
              payload: Sr.payload,
              callback: Sr.callback,
              next: null
            };
            Dr === null ? (tr = Dr = bt, Xt = Pt) : Dr = Dr.next = bt, Ut = Qt(Ut, ma);
          }
          if (Sr = Sr.next, Sr === null) {
            if (J = C.shared.pending, J === null)
              break;
            var nr = J, Xn = nr.next;
            nr.next = null, Sr = Xn, C.lastBaseUpdate = nr, C.shared.pending = null;
          }
        } while (!0);
        Dr === null && (Xt = Pt), C.baseState = Xt, C.firstBaseUpdate = tr, C.lastBaseUpdate = Dr;
        var Yr = C.shared.interleaved;
        if (Yr !== null) {
          var fi = Yr;
          do
            Ut = Qt(Ut, fi.lane), fi = fi.next;
          while (fi !== Yr);
        } else
          F === null && (C.shared.lanes = Ht);
        jE(Ut), n.lanes = Ut, n.memoizedState = Pt;
      }
      ef = null;
    }
    function uR(n, o) {
      if (typeof n != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + n));
      n.call(o);
    }
    function bT() {
      l0 = !1;
    }
    function YS() {
      return l0;
    }
    function j1(n, o, m) {
      var S = o.effects;
      if (o.effects = null, S !== null)
        for (var C = 0; C < S.length; C++) {
          var F = S[C], j = F.callback;
          j !== null && (F.callback = null, uR(j, m));
        }
    }
    var nE = {}, ET = new a.Component().refs, vx, Y1, qv, XS, qS, rE, QS, gx, iE, X1;
    {
      vx = /* @__PURE__ */ new Set(), Y1 = /* @__PURE__ */ new Set(), qv = /* @__PURE__ */ new Set(), XS = /* @__PURE__ */ new Set(), gx = /* @__PURE__ */ new Set(), qS = /* @__PURE__ */ new Set(), iE = /* @__PURE__ */ new Set(), X1 = /* @__PURE__ */ new Set();
      var MT = /* @__PURE__ */ new Set();
      QS = function(n, o) {
        if (!(n === null || typeof n == "function")) {
          var m = o + "_" + n;
          MT.has(m) || (MT.add(m), l("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", o, n));
        }
      }, rE = function(n, o) {
        if (o === void 0) {
          var m = Ci(n) || "Component";
          qS.has(m) || (qS.add(m), l("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", m));
        }
      }, Object.defineProperty(nE, "_processChildContext", {
        enumerable: !1,
        value: function() {
          throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
      }), Object.freeze(nE);
    }
    function aE(n, o, m, S) {
      var C = n.memoizedState, F = m(S, C);
      {
        if (n.mode & ui) {
          xa(!0);
          try {
            F = m(S, C);
          } finally {
            xa(!1);
          }
        }
        rE(o, F);
      }
      var j = F == null ? C : qn({}, C, F);
      if (n.memoizedState = j, n.lanes === Ht) {
        var J = n.updateQueue;
        J.baseState = j;
      }
    }
    var yx = {
      isMounted: bs,
      enqueueSetState: function(n, o, m) {
        var S = Ks(n), C = Bh(), F = zx(S), j = sv(C, F);
        j.payload = o, m != null && (QS(m, "setState"), j.callback = m);
        var J = Zg(S, j, F);
        J !== null && (lf(J, S, F, C), WS(J, S, F)), fc(S, F);
      },
      enqueueReplaceState: function(n, o, m) {
        var S = Ks(n), C = Bh(), F = zx(S), j = sv(C, F);
        j.tag = ST, j.payload = o, m != null && (QS(m, "replaceState"), j.callback = m);
        var J = Zg(S, j, F);
        J !== null && (lf(J, S, F, C), WS(J, S, F)), fc(S, F);
      },
      enqueueForceUpdate: function(n, o) {
        var m = Ks(n), S = Bh(), C = zx(m), F = sv(S, C);
        F.tag = Tl, o != null && (QS(o, "forceUpdate"), F.callback = o);
        var j = Zg(m, F, C);
        j !== null && (lf(j, m, C, S), WS(j, m, C)), Mh(m, C);
      }
    };
    function TT(n, o, m, S, C, F, j) {
      var J = n.stateNode;
      if (typeof J.shouldComponentUpdate == "function") {
        var ne = J.shouldComponentUpdate(S, F, j);
        {
          if (n.mode & ui) {
            xa(!0);
            try {
              ne = J.shouldComponentUpdate(S, F, j);
            } finally {
              xa(!1);
            }
          }
          ne === void 0 && l("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", Ci(o) || "Component");
        }
        return ne;
      }
      return o.prototype && o.prototype.isPureReactComponent ? !pr(m, S) || !pr(C, F) : !0;
    }
    function cR(n, o, m) {
      var S = n.stateNode;
      {
        var C = Ci(o) || "Component", F = S.render;
        F || (o.prototype && typeof o.prototype.render == "function" ? l("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", C) : l("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", C)), S.getInitialState && !S.getInitialState.isReactClassApproved && !S.state && l("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", C), S.getDefaultProps && !S.getDefaultProps.isReactClassApproved && l("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", C), S.propTypes && l("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", C), S.contextType && l("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", C), S.contextTypes && l("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", C), o.contextType && o.contextTypes && !iE.has(o) && (iE.add(o), l("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", C)), typeof S.componentShouldUpdate == "function" && l("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", C), o.prototype && o.prototype.isPureReactComponent && typeof S.shouldComponentUpdate < "u" && l("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", Ci(o) || "A pure component"), typeof S.componentDidUnmount == "function" && l("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", C), typeof S.componentDidReceiveProps == "function" && l("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", C), typeof S.componentWillRecieveProps == "function" && l("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", C), typeof S.UNSAFE_componentWillRecieveProps == "function" && l("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", C);
        var j = S.props !== m;
        S.props !== void 0 && j && l("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", C, C), S.defaultProps && l("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", C, C), typeof S.getSnapshotBeforeUpdate == "function" && typeof S.componentDidUpdate != "function" && !qv.has(o) && (qv.add(o), l("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", Ci(o))), typeof S.getDerivedStateFromProps == "function" && l("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", C), typeof S.getDerivedStateFromError == "function" && l("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", C), typeof o.getSnapshotBeforeUpdate == "function" && l("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", C);
        var J = S.state;
        J && (typeof J != "object" || Zs(J)) && l("%s.state: must be set to an object or null", C), typeof S.getChildContext == "function" && typeof o.childContextTypes != "object" && l("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", C);
      }
    }
    function CT(n, o) {
      o.updater = yx, n.stateNode = o, Gn(o, n), o._reactInternalInstance = nE;
    }
    function sE(n, o, m) {
      var S = !1, C = eh, F = eh, j = o.contextType;
      if ("contextType" in o) {
        var J = j === null || j !== void 0 && j.$$typeof === Ye && j._context === void 0;
        if (!J && !X1.has(o)) {
          X1.add(o);
          var ne = "";
          j === void 0 ? ne = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof j != "object" ? ne = " However, it is set to a " + typeof j + "." : j.$$typeof === Le ? ne = " Did you accidentally pass the Context.Provider instead?" : j._context !== void 0 ? ne = " Did you accidentally pass the Context.Consumer instead?" : ne = " However, it is set to an object with keys {" + Object.keys(j).join(", ") + "}.", l("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", Ci(o) || "Component", ne);
        }
      }
      if (typeof j == "object" && j !== null)
        F = Ml(j);
      else {
        C = Vg(n, o, !0);
        var Se = o.contextTypes;
        S = Se != null, F = S ? ux(n, C) : eh;
      }
      var Ce = new o(m, F);
      if (n.mode & ui) {
        xa(!0);
        try {
          Ce = new o(m, F);
        } finally {
          xa(!1);
        }
      }
      var nt = n.memoizedState = Ce.state !== null && Ce.state !== void 0 ? Ce.state : null;
      CT(n, Ce);
      {
        if (typeof o.getDerivedStateFromProps == "function" && nt === null) {
          var et = Ci(o) || "Component";
          Y1.has(et) || (Y1.add(et), l("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", et, Ce.state === null ? "null" : "undefined", et));
        }
        if (typeof o.getDerivedStateFromProps == "function" || typeof Ce.getSnapshotBeforeUpdate == "function") {
          var Pt = null, Ut = null, Xt = null;
          if (typeof Ce.componentWillMount == "function" && Ce.componentWillMount.__suppressDeprecationWarning !== !0 ? Pt = "componentWillMount" : typeof Ce.UNSAFE_componentWillMount == "function" && (Pt = "UNSAFE_componentWillMount"), typeof Ce.componentWillReceiveProps == "function" && Ce.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? Ut = "componentWillReceiveProps" : typeof Ce.UNSAFE_componentWillReceiveProps == "function" && (Ut = "UNSAFE_componentWillReceiveProps"), typeof Ce.componentWillUpdate == "function" && Ce.componentWillUpdate.__suppressDeprecationWarning !== !0 ? Xt = "componentWillUpdate" : typeof Ce.UNSAFE_componentWillUpdate == "function" && (Xt = "UNSAFE_componentWillUpdate"), Pt !== null || Ut !== null || Xt !== null) {
            var tr = Ci(o) || "Component", Dr = typeof o.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            XS.has(tr) || (XS.add(tr), l(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, tr, Dr, Pt !== null ? `
  ` + Pt : "", Ut !== null ? `
  ` + Ut : "", Xt !== null ? `
  ` + Xt : ""));
          }
        }
      }
      return S && Gb(n, C, F), Ce;
    }
    function RT(n, o) {
      var m = o.state;
      typeof o.componentWillMount == "function" && o.componentWillMount(), typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount(), m !== o.state && (l("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", xr(n) || "Component"), yx.enqueueReplaceState(o, o.state, null));
    }
    function Jg(n, o, m, S) {
      var C = o.state;
      if (typeof o.componentWillReceiveProps == "function" && o.componentWillReceiveProps(m, S), typeof o.UNSAFE_componentWillReceiveProps == "function" && o.UNSAFE_componentWillReceiveProps(m, S), o.state !== C) {
        {
          var F = xr(n) || "Component";
          vx.has(F) || (vx.add(F), l("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", F));
        }
        yx.enqueueReplaceState(o, o.state, null);
      }
    }
    function oE(n, o, m, S) {
      cR(n, o, m);
      var C = n.stateNode;
      C.props = m, C.state = n.memoizedState, C.refs = ET, VS(n);
      var F = o.contextType;
      if (typeof F == "object" && F !== null)
        C.context = Ml(F);
      else {
        var j = Vg(n, o, !0);
        C.context = ux(n, j);
      }
      {
        if (C.state === m) {
          var J = Ci(o) || "Component";
          gx.has(J) || (gx.add(J), l("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", J));
        }
        n.mode & ui && Ed.recordLegacyContextWarning(n, C), Ed.recordUnsafeLifecycleWarnings(n, C);
      }
      C.state = n.memoizedState;
      var ne = o.getDerivedStateFromProps;
      if (typeof ne == "function" && (aE(n, o, ne, m), C.state = n.memoizedState), typeof o.getDerivedStateFromProps != "function" && typeof C.getSnapshotBeforeUpdate != "function" && (typeof C.UNSAFE_componentWillMount == "function" || typeof C.componentWillMount == "function") && (RT(n, C), jS(n, m, C, S), C.state = n.memoizedState), typeof C.componentDidMount == "function") {
        var Se = Wn;
        Se |= ws, (n.mode & Fs) !== hr && (Se |= Vr), n.flags |= Se;
      }
    }
    function lv(n, o, m, S) {
      var C = n.stateNode, F = n.memoizedProps;
      C.props = F;
      var j = C.context, J = o.contextType, ne = eh;
      if (typeof J == "object" && J !== null)
        ne = Ml(J);
      else {
        var Se = Vg(n, o, !0);
        ne = ux(n, Se);
      }
      var Ce = o.getDerivedStateFromProps, nt = typeof Ce == "function" || typeof C.getSnapshotBeforeUpdate == "function";
      !nt && (typeof C.UNSAFE_componentWillReceiveProps == "function" || typeof C.componentWillReceiveProps == "function") && (F !== m || j !== ne) && Jg(n, C, m, ne), bT();
      var et = n.memoizedState, Pt = C.state = et;
      if (jS(n, m, C, S), Pt = n.memoizedState, F === m && et === Pt && !cx() && !YS()) {
        if (typeof C.componentDidMount == "function") {
          var Ut = Wn;
          Ut |= ws, (n.mode & Fs) !== hr && (Ut |= Vr), n.flags |= Ut;
        }
        return !1;
      }
      typeof Ce == "function" && (aE(n, o, Ce, m), Pt = n.memoizedState);
      var Xt = YS() || TT(n, o, F, m, et, Pt, ne);
      if (Xt) {
        if (!nt && (typeof C.UNSAFE_componentWillMount == "function" || typeof C.componentWillMount == "function") && (typeof C.componentWillMount == "function" && C.componentWillMount(), typeof C.UNSAFE_componentWillMount == "function" && C.UNSAFE_componentWillMount()), typeof C.componentDidMount == "function") {
          var tr = Wn;
          tr |= ws, (n.mode & Fs) !== hr && (tr |= Vr), n.flags |= tr;
        }
      } else {
        if (typeof C.componentDidMount == "function") {
          var Dr = Wn;
          Dr |= ws, (n.mode & Fs) !== hr && (Dr |= Vr), n.flags |= Dr;
        }
        n.memoizedProps = m, n.memoizedState = Pt;
      }
      return C.props = m, C.state = Pt, C.context = ne, Xt;
    }
    function fR(n, o, m, S, C) {
      var F = o.stateNode;
      GS(n, o);
      var j = o.memoizedProps, J = o.type === o.elementType ? j : Md(o.type, j);
      F.props = J;
      var ne = o.pendingProps, Se = F.context, Ce = m.contextType, nt = eh;
      if (typeof Ce == "object" && Ce !== null)
        nt = Ml(Ce);
      else {
        var et = Vg(o, m, !0);
        nt = ux(o, et);
      }
      var Pt = m.getDerivedStateFromProps, Ut = typeof Pt == "function" || typeof F.getSnapshotBeforeUpdate == "function";
      !Ut && (typeof F.UNSAFE_componentWillReceiveProps == "function" || typeof F.componentWillReceiveProps == "function") && (j !== ne || Se !== nt) && Jg(o, F, S, nt), bT();
      var Xt = o.memoizedState, tr = F.state = Xt;
      if (jS(o, S, F, C), tr = o.memoizedState, j === ne && Xt === tr && !cx() && !YS() && !fe)
        return typeof F.componentDidUpdate == "function" && (j !== n.memoizedProps || Xt !== n.memoizedState) && (o.flags |= Wn), typeof F.getSnapshotBeforeUpdate == "function" && (j !== n.memoizedProps || Xt !== n.memoizedState) && (o.flags |= kl), !1;
      typeof Pt == "function" && (aE(o, m, Pt, S), tr = o.memoizedState);
      var Dr = YS() || TT(o, m, J, S, Xt, tr, nt) || fe;
      return Dr ? (!Ut && (typeof F.UNSAFE_componentWillUpdate == "function" || typeof F.componentWillUpdate == "function") && (typeof F.componentWillUpdate == "function" && F.componentWillUpdate(S, tr, nt), typeof F.UNSAFE_componentWillUpdate == "function" && F.UNSAFE_componentWillUpdate(S, tr, nt)), typeof F.componentDidUpdate == "function" && (o.flags |= Wn), typeof F.getSnapshotBeforeUpdate == "function" && (o.flags |= kl)) : (typeof F.componentDidUpdate == "function" && (j !== n.memoizedProps || Xt !== n.memoizedState) && (o.flags |= Wn), typeof F.getSnapshotBeforeUpdate == "function" && (j !== n.memoizedProps || Xt !== n.memoizedState) && (o.flags |= kl), o.memoizedProps = S, o.memoizedState = tr), F.props = S, F.state = tr, F.context = nt, Dr;
    }
    var lE, ZS, uE, cE, fE, dE = function(n, o) {
    };
    lE = !1, ZS = !1, uE = {}, cE = {}, fE = {}, dE = function(n, o) {
      if (!(n === null || typeof n != "object") && !(!n._store || n._store.validated || n.key != null)) {
        if (typeof n._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        n._store.validated = !0;
        var m = xr(o) || "Component";
        cE[m] || (cE[m] = !0, l('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function tu(n, o, m) {
      var S = m.ref;
      if (S !== null && typeof S != "function" && typeof S != "object") {
        if ((n.mode & ui || Je) && !(m._owner && m._self && m._owner.stateNode !== m._self)) {
          var C = xr(n) || "Component";
          uE[C] || (l('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', S), uE[C] = !0);
        }
        if (m._owner) {
          var F = m._owner, j;
          if (F) {
            var J = F;
            if (J.tag !== g)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            j = J.stateNode;
          }
          if (!j)
            throw new Error("Missing owner for string ref " + S + ". This error is likely caused by a bug in React. Please file an issue.");
          var ne = j;
          Zt(S, "ref");
          var Se = "" + S;
          if (o !== null && o.ref !== null && typeof o.ref == "function" && o.ref._stringRef === Se)
            return o.ref;
          var Ce = function(nt) {
            var et = ne.refs;
            et === ET && (et = ne.refs = {}), nt === null ? delete et[Se] : et[Se] = nt;
          };
          return Ce._stringRef = Se, Ce;
        } else {
          if (typeof S != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!m._owner)
            throw new Error("Element ref was specified as a string (" + S + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return S;
    }
    function JS(n, o) {
      var m = Object.prototype.toString.call(o);
      throw new Error("Objects are not valid as a React child (found: " + (m === "[object Object]" ? "object with keys {" + Object.keys(o).join(", ") + "}" : m) + "). If you meant to render a collection of children, use an array instead.");
    }
    function q1(n) {
      {
        var o = xr(n) || "Component";
        if (fE[o])
          return;
        fE[o] = !0, l("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function AT(n) {
      var o = n._payload, m = n._init;
      return m(o);
    }
    function DT(n) {
      function o(bt, qt) {
        if (!!n) {
          var Et = bt.deletions;
          Et === null ? (bt.deletions = [qt], bt.flags |= wi) : Et.push(qt);
        }
      }
      function m(bt, qt) {
        if (!n)
          return null;
        for (var Et = qt; Et !== null; )
          o(bt, Et), Et = Et.sibling;
        return null;
      }
      function S(bt, qt) {
        for (var Et = /* @__PURE__ */ new Map(), xn = qt; xn !== null; )
          xn.key !== null ? Et.set(xn.key, xn) : Et.set(xn.index, xn), xn = xn.sibling;
        return Et;
      }
      function C(bt, qt) {
        var Et = h_(bt, qt);
        return Et.index = 0, Et.sibling = null, Et;
      }
      function F(bt, qt, Et) {
        if (bt.index = Et, !n)
          return bt.flags |= lc, qt;
        var xn = bt.alternate;
        if (xn !== null) {
          var nr = xn.index;
          return nr < qt ? (bt.flags |= si, qt) : nr;
        } else
          return bt.flags |= si, qt;
      }
      function j(bt) {
        return n && bt.alternate === null && (bt.flags |= si), bt;
      }
      function J(bt, qt, Et, xn) {
        if (qt === null || qt.tag !== D) {
          var nr = pA(Et, bt.mode, xn);
          return nr.return = bt, nr;
        } else {
          var Xn = C(qt, Et);
          return Xn.return = bt, Xn;
        }
      }
      function ne(bt, qt, Et, xn) {
        var nr = Et.type;
        if (nr === Te)
          return Ce(bt, qt, Et.props.children, xn, Et.key);
        if (qt !== null && (qt.elementType === nr || $P(qt, Et) || typeof nr == "object" && nr !== null && nr.$$typeof === yn && AT(nr) === qt.type)) {
          var Xn = C(qt, Et.props);
          return Xn.ref = tu(bt, qt, Et), Xn.return = bt, Xn._debugSource = Et._source, Xn._debugOwner = Et._owner, Xn;
        }
        var Yr = hA(Et, bt.mode, xn);
        return Yr.ref = tu(bt, qt, Et), Yr.return = bt, Yr;
      }
      function Se(bt, qt, Et, xn) {
        if (qt === null || qt.tag !== T || qt.stateNode.containerInfo !== Et.containerInfo || qt.stateNode.implementation !== Et.implementation) {
          var nr = mA(Et, bt.mode, xn);
          return nr.return = bt, nr;
        } else {
          var Xn = C(qt, Et.children || []);
          return Xn.return = bt, Xn;
        }
      }
      function Ce(bt, qt, Et, xn, nr) {
        if (qt === null || qt.tag !== O) {
          var Xn = Fx(Et, bt.mode, xn, nr);
          return Xn.return = bt, Xn;
        } else {
          var Yr = C(qt, Et);
          return Yr.return = bt, Yr;
        }
      }
      function nt(bt, qt, Et) {
        if (typeof qt == "string" && qt !== "" || typeof qt == "number") {
          var xn = pA("" + qt, bt.mode, Et);
          return xn.return = bt, xn;
        }
        if (typeof qt == "object" && qt !== null) {
          switch (qt.$$typeof) {
            case $r: {
              var nr = hA(qt, bt.mode, Et);
              return nr.ref = tu(bt, null, qt), nr.return = bt, nr;
            }
            case ai: {
              var Xn = mA(qt, bt.mode, Et);
              return Xn.return = bt, Xn;
            }
            case yn: {
              var Yr = qt._payload, fi = qt._init;
              return nt(bt, fi(Yr), Et);
            }
          }
          if (Zs(qt) || us(qt)) {
            var Ds = Fx(qt, bt.mode, Et, null);
            return Ds.return = bt, Ds;
          }
          JS(bt, qt);
        }
        return typeof qt == "function" && q1(bt), null;
      }
      function et(bt, qt, Et, xn) {
        var nr = qt !== null ? qt.key : null;
        if (typeof Et == "string" && Et !== "" || typeof Et == "number")
          return nr !== null ? null : J(bt, qt, "" + Et, xn);
        if (typeof Et == "object" && Et !== null) {
          switch (Et.$$typeof) {
            case $r:
              return Et.key === nr ? ne(bt, qt, Et, xn) : null;
            case ai:
              return Et.key === nr ? Se(bt, qt, Et, xn) : null;
            case yn: {
              var Xn = Et._payload, Yr = Et._init;
              return et(bt, qt, Yr(Xn), xn);
            }
          }
          if (Zs(Et) || us(Et))
            return nr !== null ? null : Ce(bt, qt, Et, xn, null);
          JS(bt, Et);
        }
        return typeof Et == "function" && q1(bt), null;
      }
      function Pt(bt, qt, Et, xn, nr) {
        if (typeof xn == "string" && xn !== "" || typeof xn == "number") {
          var Xn = bt.get(Et) || null;
          return J(qt, Xn, "" + xn, nr);
        }
        if (typeof xn == "object" && xn !== null) {
          switch (xn.$$typeof) {
            case $r: {
              var Yr = bt.get(xn.key === null ? Et : xn.key) || null;
              return ne(qt, Yr, xn, nr);
            }
            case ai: {
              var fi = bt.get(xn.key === null ? Et : xn.key) || null;
              return Se(qt, fi, xn, nr);
            }
            case yn:
              var Ds = xn._payload, ja = xn._init;
              return Pt(bt, qt, Et, ja(Ds), nr);
          }
          if (Zs(xn) || us(xn)) {
            var qu = bt.get(Et) || null;
            return Ce(qt, qu, xn, nr, null);
          }
          JS(qt, xn);
        }
        return typeof xn == "function" && q1(qt), null;
      }
      function Ut(bt, qt, Et) {
        {
          if (typeof bt != "object" || bt === null)
            return qt;
          switch (bt.$$typeof) {
            case $r:
            case ai:
              dE(bt, Et);
              var xn = bt.key;
              if (typeof xn != "string")
                break;
              if (qt === null) {
                qt = /* @__PURE__ */ new Set(), qt.add(xn);
                break;
              }
              if (!qt.has(xn)) {
                qt.add(xn);
                break;
              }
              l("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.", xn);
              break;
            case yn:
              var nr = bt._payload, Xn = bt._init;
              Ut(Xn(nr), qt, Et);
              break;
          }
        }
        return qt;
      }
      function Xt(bt, qt, Et, xn) {
        for (var nr = null, Xn = 0; Xn < Et.length; Xn++) {
          var Yr = Et[Xn];
          nr = Ut(Yr, nr, bt);
        }
        for (var fi = null, Ds = null, ja = qt, qu = 0, Ya = 0, bu = null; ja !== null && Ya < Et.length; Ya++) {
          ja.index > Ya ? (bu = ja, ja = null) : bu = ja.sibling;
          var sh = et(bt, ja, Et[Ya], xn);
          if (sh === null) {
            ja === null && (ja = bu);
            break;
          }
          n && ja && sh.alternate === null && o(bt, ja), qu = F(sh, qu, Ya), Ds === null ? fi = sh : Ds.sibling = sh, Ds = sh, ja = bu;
        }
        if (Ya === Et.length) {
          if (m(bt, ja), js()) {
            var Ld = Ya;
            Ky(bt, Ld);
          }
          return fi;
        }
        if (ja === null) {
          for (; Ya < Et.length; Ya++) {
            var xm = nt(bt, Et[Ya], xn);
            xm !== null && (qu = F(xm, qu, Ya), Ds === null ? fi = xm : Ds.sibling = xm, Ds = xm);
          }
          if (js()) {
            var Hh = Ya;
            Ky(bt, Hh);
          }
          return fi;
        }
        for (var Vh = S(bt, ja); Ya < Et.length; Ya++) {
          var oh = Pt(Vh, bt, Ya, Et[Ya], xn);
          oh !== null && (n && oh.alternate !== null && Vh.delete(oh.key === null ? Ya : oh.key), qu = F(oh, qu, Ya), Ds === null ? fi = oh : Ds.sibling = oh, Ds = oh);
        }
        if (n && Vh.forEach(function(_w) {
          return o(bt, _w);
        }), js()) {
          var _0 = Ya;
          Ky(bt, _0);
        }
        return fi;
      }
      function tr(bt, qt, Et, xn) {
        var nr = us(Et);
        if (typeof nr != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && Et[Symbol.toStringTag] === "Generator" && (ZS || l("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), ZS = !0), Et.entries === nr && (lE || l("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), lE = !0);
          var Xn = nr.call(Et);
          if (Xn)
            for (var Yr = null, fi = Xn.next(); !fi.done; fi = Xn.next()) {
              var Ds = fi.value;
              Yr = Ut(Ds, Yr, bt);
            }
        }
        var ja = nr.call(Et);
        if (ja == null)
          throw new Error("An iterable object provided no iterator.");
        for (var qu = null, Ya = null, bu = qt, sh = 0, Ld = 0, xm = null, Hh = ja.next(); bu !== null && !Hh.done; Ld++, Hh = ja.next()) {
          bu.index > Ld ? (xm = bu, bu = null) : xm = bu.sibling;
          var Vh = et(bt, bu, Hh.value, xn);
          if (Vh === null) {
            bu === null && (bu = xm);
            break;
          }
          n && bu && Vh.alternate === null && o(bt, bu), sh = F(Vh, sh, Ld), Ya === null ? qu = Vh : Ya.sibling = Vh, Ya = Vh, bu = xm;
        }
        if (Hh.done) {
          if (m(bt, bu), js()) {
            var oh = Ld;
            Ky(bt, oh);
          }
          return qu;
        }
        if (bu === null) {
          for (; !Hh.done; Ld++, Hh = ja.next()) {
            var _0 = nt(bt, Hh.value, xn);
            _0 !== null && (sh = F(_0, sh, Ld), Ya === null ? qu = _0 : Ya.sibling = _0, Ya = _0);
          }
          if (js()) {
            var _w = Ld;
            Ky(bt, _w);
          }
          return qu;
        }
        for (var ZE = S(bt, bu); !Hh.done; Ld++, Hh = ja.next()) {
          var ay = Pt(ZE, bt, Ld, Hh.value, xn);
          ay !== null && (n && ay.alternate !== null && ZE.delete(ay.key === null ? Ld : ay.key), sh = F(ay, sh, Ld), Ya === null ? qu = ay : Ya.sibling = ay, Ya = ay);
        }
        if (n && ZE.forEach(function(A5) {
          return o(bt, A5);
        }), js()) {
          var R5 = Ld;
          Ky(bt, R5);
        }
        return qu;
      }
      function Dr(bt, qt, Et, xn) {
        if (qt !== null && qt.tag === D) {
          m(bt, qt.sibling);
          var nr = C(qt, Et);
          return nr.return = bt, nr;
        }
        m(bt, qt);
        var Xn = pA(Et, bt.mode, xn);
        return Xn.return = bt, Xn;
      }
      function Sr(bt, qt, Et, xn) {
        for (var nr = Et.key, Xn = qt; Xn !== null; ) {
          if (Xn.key === nr) {
            var Yr = Et.type;
            if (Yr === Te) {
              if (Xn.tag === O) {
                m(bt, Xn.sibling);
                var fi = C(Xn, Et.props.children);
                return fi.return = bt, fi._debugSource = Et._source, fi._debugOwner = Et._owner, fi;
              }
            } else if (Xn.elementType === Yr || $P(Xn, Et) || typeof Yr == "object" && Yr !== null && Yr.$$typeof === yn && AT(Yr) === Xn.type) {
              m(bt, Xn.sibling);
              var Ds = C(Xn, Et.props);
              return Ds.ref = tu(bt, Xn, Et), Ds.return = bt, Ds._debugSource = Et._source, Ds._debugOwner = Et._owner, Ds;
            }
            m(bt, Xn);
            break;
          } else
            o(bt, Xn);
          Xn = Xn.sibling;
        }
        if (Et.type === Te) {
          var ja = Fx(Et.props.children, bt.mode, xn, Et.key);
          return ja.return = bt, ja;
        } else {
          var qu = hA(Et, bt.mode, xn);
          return qu.ref = tu(bt, qt, Et), qu.return = bt, qu;
        }
      }
      function ma(bt, qt, Et, xn) {
        for (var nr = Et.key, Xn = qt; Xn !== null; ) {
          if (Xn.key === nr)
            if (Xn.tag === T && Xn.stateNode.containerInfo === Et.containerInfo && Xn.stateNode.implementation === Et.implementation) {
              m(bt, Xn.sibling);
              var Yr = C(Xn, Et.children || []);
              return Yr.return = bt, Yr;
            } else {
              m(bt, Xn);
              break;
            }
          else
            o(bt, Xn);
          Xn = Xn.sibling;
        }
        var fi = mA(Et, bt.mode, xn);
        return fi.return = bt, fi;
      }
      function ta(bt, qt, Et, xn) {
        var nr = typeof Et == "object" && Et !== null && Et.type === Te && Et.key === null;
        if (nr && (Et = Et.props.children), typeof Et == "object" && Et !== null) {
          switch (Et.$$typeof) {
            case $r:
              return j(Sr(bt, qt, Et, xn));
            case ai:
              return j(ma(bt, qt, Et, xn));
            case yn:
              var Xn = Et._payload, Yr = Et._init;
              return ta(bt, qt, Yr(Xn), xn);
          }
          if (Zs(Et))
            return Xt(bt, qt, Et, xn);
          if (us(Et))
            return tr(bt, qt, Et, xn);
          JS(bt, Et);
        }
        return typeof Et == "string" && Et !== "" || typeof Et == "number" ? j(Dr(bt, qt, "" + Et, xn)) : (typeof Et == "function" && q1(bt), m(bt, qt));
      }
      return ta;
    }
    var xx = DT(!0), LT = DT(!1);
    function dR(n, o) {
      if (n !== null && o.child !== n.child)
        throw new Error("Resuming work not yet implemented.");
      if (o.child !== null) {
        var m = o.child, S = h_(m, m.pendingProps);
        for (o.child = S, S.return = o; m.sibling !== null; )
          m = m.sibling, S = S.sibling = h_(m, m.pendingProps), S.return = o;
        S.sibling = null;
      }
    }
    function PT(n, o) {
      for (var m = n.child; m !== null; )
        YB(m, o), m = m.sibling;
    }
    var Kg = {}, gm = Wu(Kg), _x = Wu(Kg), Sx = Wu(Kg);
    function KS(n) {
      if (n === Kg)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return n;
    }
    function hE() {
      var n = KS(Sx.current);
      return n;
    }
    function Q1(n, o) {
      Gf(Sx, o, n), Gf(_x, n, n), Gf(gm, Kg, n);
      var m = bb(o);
      ju(gm, n), Gf(gm, m, n);
    }
    function wx(n) {
      ju(gm, n), ju(_x, n), ju(Sx, n);
    }
    function u0() {
      var n = KS(gm.current);
      return n;
    }
    function $S(n) {
      KS(Sx.current);
      var o = KS(gm.current), m = uS(o, n.type);
      o !== m && (Gf(_x, n, n), Gf(gm, m, n));
    }
    function bx(n) {
      _x.current === n && (ju(gm, n), ju(_x, n));
    }
    var OT = 0, pE = 1, UT = 1, Z1 = 2, Cl = Wu(OT);
    function $g(n, o) {
      return (n & o) !== 0;
    }
    function Ex(n) {
      return n & pE;
    }
    function ey(n, o) {
      return n & pE | o;
    }
    function mE(n, o) {
      return n | o;
    }
    function uv(n, o) {
      Gf(Cl, o, n);
    }
    function c0(n) {
      ju(Cl, n);
    }
    function zT(n, o) {
      var m = n.memoizedState;
      return m !== null ? m.dehydrated !== null : (n.memoizedProps, !0);
    }
    function ew(n) {
      for (var o = n; o !== null; ) {
        if (o.tag === Q) {
          var m = o.memoizedState;
          if (m !== null) {
            var S = m.dehydrated;
            if (S === null || D1(S) || L1(S))
              return o;
          }
        } else if (o.tag === ce && o.memoizedProps.revealOrder !== void 0) {
          var C = (o.flags & Rr) !== vr;
          if (C)
            return o;
        } else if (o.child !== null) {
          o.child.return = o, o = o.child;
          continue;
        }
        if (o === n)
          return null;
        for (; o.sibling === null; ) {
          if (o.return === null || o.return === n)
            return null;
          o = o.return;
        }
        o.sibling.return = o.return, o = o.sibling;
      }
      return null;
    }
    var nh = 0, nu = 1, cv = 2, ru = 4, tf = 8, vE = [];
    function J1() {
      for (var n = 0; n < vE.length; n++) {
        var o = vE[n];
        o._workInProgressVersionPrimary = null;
      }
      vE.length = 0;
    }
    function NT(n, o) {
      var m = o._getVersion, S = m(o._source);
      n.mutableSourceEagerHydrationData == null ? n.mutableSourceEagerHydrationData = [o, S] : n.mutableSourceEagerHydrationData.push(o, S);
    }
    var Yn = t.ReactCurrentDispatcher, nf = t.ReactCurrentBatchConfig, K1, Mx;
    K1 = /* @__PURE__ */ new Set();
    var f0 = Ht, la = null, Yu = null, Xu = null, Tx = !1, d0 = !1, Rp = 0, hR = 0, pR = 25, tn = null, Nh = null, fv = -1, gE = !1;
    function Wa() {
      {
        var n = tn;
        Nh === null ? Nh = [n] : Nh.push(n);
      }
    }
    function Dn() {
      {
        var n = tn;
        Nh !== null && (fv++, Nh[fv] !== n && mR(n));
      }
    }
    function h0(n) {
      n != null && !Zs(n) && l("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", tn, typeof n);
    }
    function mR(n) {
      {
        var o = xr(la);
        if (!K1.has(o) && (K1.add(o), Nh !== null)) {
          for (var m = "", S = 30, C = 0; C <= fv; C++) {
            for (var F = Nh[C], j = C === fv ? n : F, J = C + 1 + ". " + F; J.length < S; )
              J += " ";
            J += j + `
`, m += J;
          }
          l(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, o, m);
        }
      }
    }
    function rf() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function yE(n, o) {
      if (gE)
        return !1;
      if (o === null)
        return l("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", tn), !1;
      n.length !== o.length && l(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, tn, "[" + o.join(", ") + "]", "[" + n.join(", ") + "]");
      for (var m = 0; m < o.length && m < n.length; m++)
        if (!Zn(n[m], o[m]))
          return !1;
      return !0;
    }
    function Cx(n, o, m, S, C, F) {
      f0 = F, la = o, Nh = n !== null ? n._debugHookTypes : null, fv = -1, gE = n !== null && n.type !== o.type, o.memoizedState = null, o.updateQueue = null, o.lanes = Ht, n !== null && n.memoizedState !== null ? Yn.current = En : Nh !== null ? Yn.current = Mt : Yn.current = Jt;
      var j = m(S, C);
      if (d0) {
        var J = 0;
        do {
          if (d0 = !1, Rp = 0, J >= pR)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          J += 1, gE = !1, Yu = null, Xu = null, o.updateQueue = null, fv = -1, Yn.current = yr, j = m(S, C);
        } while (d0);
      }
      Yn.current = Ct, o._debugHookTypes = Nh;
      var ne = Yu !== null && Yu.next !== null;
      if (f0 = Ht, la = null, Yu = null, Xu = null, tn = null, Nh = null, fv = -1, n !== null && (n.flags & vn) !== (o.flags & vn) && (n.mode & Gr) !== hr && l("Internal React error: Expected static flag was missing. Please notify the React team."), Tx = !1, ne)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return j;
    }
    function ty() {
      var n = Rp !== 0;
      return Rp = 0, n;
    }
    function tw(n, o, m) {
      o.updateQueue = n.updateQueue, (o.mode & Fs) !== hr ? o.flags &= ~(uc | Vr | Ia | Wn) : o.flags &= ~(Ia | Wn), n.lanes = jn(n.lanes, m);
    }
    function xE() {
      if (Yn.current = Ct, Tx) {
        for (var n = la.memoizedState; n !== null; ) {
          var o = n.queue;
          o !== null && (o.pending = null), n = n.next;
        }
        Tx = !1;
      }
      f0 = Ht, la = null, Yu = null, Xu = null, Nh = null, fv = -1, tn = null, St = !1, d0 = !1, Rp = 0;
    }
    function dv() {
      var n = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return Xu === null ? la.memoizedState = Xu = n : Xu = Xu.next = n, Xu;
    }
    function Ap() {
      var n;
      if (Yu === null) {
        var o = la.alternate;
        o !== null ? n = o.memoizedState : n = null;
      } else
        n = Yu.next;
      var m;
      if (Xu === null ? m = la.memoizedState : m = Xu.next, m !== null)
        Xu = m, m = Xu.next, Yu = n;
      else {
        if (n === null)
          throw new Error("Rendered more hooks than during the previous render.");
        Yu = n;
        var S = {
          memoizedState: Yu.memoizedState,
          baseState: Yu.baseState,
          baseQueue: Yu.baseQueue,
          queue: Yu.queue,
          next: null
        };
        Xu === null ? la.memoizedState = Xu = S : Xu = Xu.next = S;
      }
      return Xu;
    }
    function FT() {
      return {
        lastEffect: null,
        stores: null
      };
    }
    function _E(n, o) {
      return typeof o == "function" ? o(n) : o;
    }
    function nw(n, o, m) {
      var S = dv(), C;
      m !== void 0 ? C = m(o) : C = o, S.memoizedState = S.baseState = C;
      var F = {
        pending: null,
        interleaved: null,
        lanes: Ht,
        dispatch: null,
        lastRenderedReducer: n,
        lastRenderedState: C
      };
      S.queue = F;
      var j = F.dispatch = Sn.bind(null, la, F);
      return [S.memoizedState, j];
    }
    function SE(n, o, m) {
      var S = Ap(), C = S.queue;
      if (C === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      C.lastRenderedReducer = n;
      var F = Yu, j = F.baseQueue, J = C.pending;
      if (J !== null) {
        if (j !== null) {
          var ne = j.next, Se = J.next;
          j.next = Se, J.next = ne;
        }
        F.baseQueue !== j && l("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), F.baseQueue = j = J, C.pending = null;
      }
      if (j !== null) {
        var Ce = j.next, nt = F.baseState, et = null, Pt = null, Ut = null, Xt = Ce;
        do {
          var tr = Xt.lane;
          if (Lt(f0, tr)) {
            if (Ut !== null) {
              var Sr = {
                lane: pi,
                action: Xt.action,
                hasEagerState: Xt.hasEagerState,
                eagerState: Xt.eagerState,
                next: null
              };
              Ut = Ut.next = Sr;
            }
            if (Xt.hasEagerState)
              nt = Xt.eagerState;
            else {
              var ma = Xt.action;
              nt = n(nt, ma);
            }
          } else {
            var Dr = {
              lane: tr,
              action: Xt.action,
              hasEagerState: Xt.hasEagerState,
              eagerState: Xt.eagerState,
              next: null
            };
            Ut === null ? (Pt = Ut = Dr, et = nt) : Ut = Ut.next = Dr, la.lanes = Qt(la.lanes, tr), jE(tr);
          }
          Xt = Xt.next;
        } while (Xt !== null && Xt !== Ce);
        Ut === null ? et = nt : Ut.next = Pt, Zn(nt, S.memoizedState) || OE(), S.memoizedState = nt, S.baseState = et, S.baseQueue = Ut, C.lastRenderedState = nt;
      }
      var ta = C.interleaved;
      if (ta !== null) {
        var bt = ta;
        do {
          var qt = bt.lane;
          la.lanes = Qt(la.lanes, qt), jE(qt), bt = bt.next;
        } while (bt !== ta);
      } else
        j === null && (C.lanes = Ht);
      var Et = C.dispatch;
      return [S.memoizedState, Et];
    }
    function wE(n, o, m) {
      var S = Ap(), C = S.queue;
      if (C === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      C.lastRenderedReducer = n;
      var F = C.dispatch, j = C.pending, J = S.memoizedState;
      if (j !== null) {
        C.pending = null;
        var ne = j.next, Se = ne;
        do {
          var Ce = Se.action;
          J = n(J, Ce), Se = Se.next;
        } while (Se !== ne);
        Zn(J, S.memoizedState) || OE(), S.memoizedState = J, S.baseQueue === null && (S.baseState = J), C.lastRenderedState = J;
      }
      return [J, F];
    }
    function vR(n, o, m) {
    }
    function kT(n, o, m) {
    }
    function bE(n, o, m) {
      var S = la, C = dv(), F, j = js();
      if (j) {
        if (m === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        F = m(), Mx || F !== m() && (l("The result of getServerSnapshot should be cached to avoid an infinite loop"), Mx = !0);
      } else {
        if (F = o(), !Mx) {
          var J = o();
          Zn(F, J) || (l("The result of getSnapshot should be cached to avoid an infinite loop"), Mx = !0);
        }
        var ne = KT();
        if (ne === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        hn(ne, f0) || IT(S, o, F);
      }
      C.memoizedState = F;
      var Se = {
        value: F,
        getSnapshot: o
      };
      return C.queue = Se, n_(ME.bind(null, S, Se, n), [n]), S.flags |= Ia, Rx(nu | tf, EE.bind(null, S, Se, F, o), void 0, null), F;
    }
    function rw(n, o, m) {
      var S = la, C = Ap(), F = o();
      if (!Mx) {
        var j = o();
        Zn(F, j) || (l("The result of getSnapshot should be cached to avoid an infinite loop"), Mx = !0);
      }
      var J = C.memoizedState, ne = !Zn(J, F);
      ne && (C.memoizedState = F, OE());
      var Se = C.queue;
      if (Dx(ME.bind(null, S, Se, n), [n]), Se.getSnapshot !== o || ne || Xu !== null && Xu.memoizedState.tag & nu) {
        S.flags |= Ia, Rx(nu | tf, EE.bind(null, S, Se, F, o), void 0, null);
        var Ce = KT();
        if (Ce === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        hn(Ce, f0) || IT(S, o, F);
      }
      return F;
    }
    function IT(n, o, m) {
      n.flags |= jd;
      var S = {
        getSnapshot: o,
        value: m
      }, C = la.updateQueue;
      if (C === null)
        C = FT(), la.updateQueue = C, C.stores = [S];
      else {
        var F = C.stores;
        F === null ? C.stores = [S] : F.push(S);
      }
    }
    function EE(n, o, m, S) {
      o.value = m, o.getSnapshot = S, TE(o) && CE(n);
    }
    function ME(n, o, m) {
      var S = function() {
        TE(o) && CE(n);
      };
      return m(S);
    }
    function TE(n) {
      var o = n.getSnapshot, m = n.value;
      try {
        var S = o();
        return !Zn(m, S);
      } catch {
        return !0;
      }
    }
    function CE(n) {
      var o = $c(n, lr);
      o !== null && lf(o, n, lr, ti);
    }
    function $1(n) {
      var o = dv();
      typeof n == "function" && (n = n()), o.memoizedState = o.baseState = n;
      var m = {
        pending: null,
        interleaved: null,
        lanes: Ht,
        dispatch: null,
        lastRenderedReducer: _E,
        lastRenderedState: n
      };
      o.queue = m;
      var S = m.dispatch = Tr.bind(null, la, m);
      return [o.memoizedState, S];
    }
    function iw(n) {
      return SE(_E);
    }
    function aw(n) {
      return wE(_E);
    }
    function Rx(n, o, m, S) {
      var C = {
        tag: n,
        create: o,
        destroy: m,
        deps: S,
        next: null
      }, F = la.updateQueue;
      if (F === null)
        F = FT(), la.updateQueue = F, F.lastEffect = C.next = C;
      else {
        var j = F.lastEffect;
        if (j === null)
          F.lastEffect = C.next = C;
        else {
          var J = j.next;
          j.next = C, C.next = J, F.lastEffect = C;
        }
      }
      return C;
    }
    function sw(n) {
      var o = dv();
      {
        var m = {
          current: n
        };
        return o.memoizedState = m, m;
      }
    }
    function e_(n) {
      var o = Ap();
      return o.memoizedState;
    }
    function Ax(n, o, m, S) {
      var C = dv(), F = S === void 0 ? null : S;
      la.flags |= n, C.memoizedState = Rx(nu | o, m, void 0, F);
    }
    function t_(n, o, m, S) {
      var C = Ap(), F = S === void 0 ? null : S, j = void 0;
      if (Yu !== null) {
        var J = Yu.memoizedState;
        if (j = J.destroy, F !== null) {
          var ne = J.deps;
          if (yE(F, ne)) {
            C.memoizedState = Rx(o, m, j, F);
            return;
          }
        }
      }
      la.flags |= n, C.memoizedState = Rx(nu | o, m, j, F);
    }
    function n_(n, o) {
      return (la.mode & Fs) !== hr ? Ax(uc | Ia | Uc, tf, n, o) : Ax(Ia | Uc, tf, n, o);
    }
    function Dx(n, o) {
      return t_(Ia, tf, n, o);
    }
    function ow(n, o) {
      return Ax(Wn, cv, n, o);
    }
    function r_(n, o) {
      return t_(Wn, cv, n, o);
    }
    function lw(n, o) {
      var m = Wn;
      return m |= ws, (la.mode & Fs) !== hr && (m |= Vr), Ax(m, ru, n, o);
    }
    function i_(n, o) {
      return t_(Wn, ru, n, o);
    }
    function RE(n, o) {
      if (typeof o == "function") {
        var m = o, S = n();
        return m(S), function() {
          m(null);
        };
      } else if (o != null) {
        var C = o;
        C.hasOwnProperty("current") || l("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(C).join(", ") + "}");
        var F = n();
        return C.current = F, function() {
          C.current = null;
        };
      }
    }
    function a_(n, o, m) {
      typeof o != "function" && l("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", o !== null ? typeof o : "null");
      var S = m != null ? m.concat([n]) : null, C = Wn;
      return C |= ws, (la.mode & Fs) !== hr && (C |= Vr), Ax(C, ru, RE.bind(null, o, n), S);
    }
    function uw(n, o, m) {
      typeof o != "function" && l("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", o !== null ? typeof o : "null");
      var S = m != null ? m.concat([n]) : null;
      return t_(Wn, ru, RE.bind(null, o, n), S);
    }
    function gR(n, o) {
    }
    var cw = gR;
    function AE(n, o) {
      var m = dv(), S = o === void 0 ? null : o;
      return m.memoizedState = [n, S], n;
    }
    function u(n, o) {
      var m = Ap(), S = o === void 0 ? null : o, C = m.memoizedState;
      if (C !== null && S !== null) {
        var F = C[1];
        if (yE(S, F))
          return C[0];
      }
      return m.memoizedState = [n, S], n;
    }
    function f(n, o) {
      var m = dv(), S = o === void 0 ? null : o, C = n();
      return m.memoizedState = [C, S], C;
    }
    function M(n, o) {
      var m = Ap(), S = o === void 0 ? null : o, C = m.memoizedState;
      if (C !== null && S !== null) {
        var F = C[1];
        if (yE(S, F))
          return C[0];
      }
      var j = n();
      return m.memoizedState = [j, S], j;
    }
    function A(n) {
      var o = dv();
      return o.memoizedState = n, n;
    }
    function z(n) {
      var o = Ap(), m = Yu, S = m.memoizedState;
      return ee(o, S, n);
    }
    function W(n) {
      var o = Ap();
      if (Yu === null)
        return o.memoizedState = n, n;
      var m = Yu.memoizedState;
      return ee(o, m, n);
    }
    function ee(n, o, m) {
      var S = !$e(f0);
      if (S) {
        if (!Zn(m, o)) {
          var C = ur();
          la.lanes = Qt(la.lanes, C), jE(C), n.baseState = !0;
        }
        return o;
      } else
        return n.baseState && (n.baseState = !1, OE()), n.memoizedState = m, m;
    }
    function ae(n, o, m) {
      var S = pc();
      ro(xl(S, Qo)), n(!0);
      var C = nf.transition;
      nf.transition = {};
      var F = nf.transition;
      nf.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        n(!1), o();
      } finally {
        if (ro(S), nf.transition = C, C === null && F._updatedFibers) {
          var j = F._updatedFibers.size;
          j > 10 && s("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), F._updatedFibers.clear();
        }
      }
    }
    function _e() {
      var n = $1(!1), o = n[0], m = n[1], S = ae.bind(null, m), C = dv();
      return C.memoizedState = S, [o, S];
    }
    function Ue() {
      var n = iw(), o = n[0], m = Ap(), S = m.memoizedState;
      return [o, S];
    }
    function We() {
      var n = aw(), o = n[0], m = Ap(), S = m.memoizedState;
      return [o, S];
    }
    var St = !1;
    function It() {
      return St;
    }
    function Yt() {
      var n = dv(), o = KT(), m = o.identifierPrefix, S;
      if (js()) {
        var C = aR();
        S = ":" + m + "R" + C;
        var F = Rp++;
        F > 0 && (S += "H" + F.toString(32)), S += ":";
      } else {
        var j = hR++;
        S = ":" + m + "r" + j.toString(32) + ":";
      }
      return n.memoizedState = S, S;
    }
    function pn() {
      var n = Ap(), o = n.memoizedState;
      return o;
    }
    function Sn(n, o, m) {
      typeof arguments[3] == "function" && l("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var S = zx(n), C = {
        lane: S,
        action: m,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (vi(n))
        Pr(o, C);
      else {
        var F = _T(n, o, C, S);
        if (F !== null) {
          var j = Bh();
          lf(F, n, S, j), lo(F, o, S);
        }
      }
      uo(n, S);
    }
    function Tr(n, o, m) {
      typeof arguments[3] == "function" && l("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var S = zx(n), C = {
        lane: S,
        action: m,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (vi(n))
        Pr(o, C);
      else {
        var F = n.alternate;
        if (n.lanes === Ht && (F === null || F.lanes === Ht)) {
          var j = o.lastRenderedReducer;
          if (j !== null) {
            var J;
            J = Yn.current, Yn.current = ni;
            try {
              var ne = o.lastRenderedState, Se = j(ne, m);
              if (C.hasEagerState = !0, C.eagerState = Se, Zn(Se, ne)) {
                IS(n, o, C, S);
                return;
              }
            } catch {
            } finally {
              Yn.current = J;
            }
          }
        }
        var Ce = _T(n, o, C, S);
        if (Ce !== null) {
          var nt = Bh();
          lf(Ce, n, S, nt), lo(Ce, o, S);
        }
      }
      uo(n, S);
    }
    function vi(n) {
      var o = n.alternate;
      return n === la || o !== null && o === la;
    }
    function Pr(n, o) {
      d0 = Tx = !0;
      var m = n.pending;
      m === null ? o.next = o : (o.next = m.next, m.next = o), n.pending = o;
    }
    function lo(n, o, m) {
      if (br(m)) {
        var S = o.lanes;
        S = Wr(S, n.pendingLanes);
        var C = Qt(S, m);
        o.lanes = C, gr(n, C);
      }
    }
    function uo(n, o, m) {
      fc(n, o);
    }
    var Ct = {
      readContext: Ml,
      useCallback: rf,
      useContext: rf,
      useEffect: rf,
      useImperativeHandle: rf,
      useInsertionEffect: rf,
      useLayoutEffect: rf,
      useMemo: rf,
      useReducer: rf,
      useRef: rf,
      useState: rf,
      useDebugValue: rf,
      useDeferredValue: rf,
      useTransition: rf,
      useMutableSource: rf,
      useSyncExternalStore: rf,
      useId: rf,
      unstable_isNewReconciler: ve
    }, Jt = null, Mt = null, En = null, yr = null, Nn = null, ni = null, wa = null;
    {
      var ys = function() {
        l("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, kn = function() {
        l("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      Jt = {
        readContext: function(n) {
          return Ml(n);
        },
        useCallback: function(n, o) {
          return tn = "useCallback", Wa(), h0(o), AE(n, o);
        },
        useContext: function(n) {
          return tn = "useContext", Wa(), Ml(n);
        },
        useEffect: function(n, o) {
          return tn = "useEffect", Wa(), h0(o), n_(n, o);
        },
        useImperativeHandle: function(n, o, m) {
          return tn = "useImperativeHandle", Wa(), h0(m), a_(n, o, m);
        },
        useInsertionEffect: function(n, o) {
          return tn = "useInsertionEffect", Wa(), h0(o), ow(n, o);
        },
        useLayoutEffect: function(n, o) {
          return tn = "useLayoutEffect", Wa(), h0(o), lw(n, o);
        },
        useMemo: function(n, o) {
          tn = "useMemo", Wa(), h0(o);
          var m = Yn.current;
          Yn.current = Nn;
          try {
            return f(n, o);
          } finally {
            Yn.current = m;
          }
        },
        useReducer: function(n, o, m) {
          tn = "useReducer", Wa();
          var S = Yn.current;
          Yn.current = Nn;
          try {
            return nw(n, o, m);
          } finally {
            Yn.current = S;
          }
        },
        useRef: function(n) {
          return tn = "useRef", Wa(), sw(n);
        },
        useState: function(n) {
          tn = "useState", Wa();
          var o = Yn.current;
          Yn.current = Nn;
          try {
            return $1(n);
          } finally {
            Yn.current = o;
          }
        },
        useDebugValue: function(n, o) {
          return tn = "useDebugValue", Wa(), void 0;
        },
        useDeferredValue: function(n) {
          return tn = "useDeferredValue", Wa(), A(n);
        },
        useTransition: function() {
          return tn = "useTransition", Wa(), _e();
        },
        useMutableSource: function(n, o, m) {
          return tn = "useMutableSource", Wa(), void 0;
        },
        useSyncExternalStore: function(n, o, m) {
          return tn = "useSyncExternalStore", Wa(), bE(n, o, m);
        },
        useId: function() {
          return tn = "useId", Wa(), Yt();
        },
        unstable_isNewReconciler: ve
      }, Mt = {
        readContext: function(n) {
          return Ml(n);
        },
        useCallback: function(n, o) {
          return tn = "useCallback", Dn(), AE(n, o);
        },
        useContext: function(n) {
          return tn = "useContext", Dn(), Ml(n);
        },
        useEffect: function(n, o) {
          return tn = "useEffect", Dn(), n_(n, o);
        },
        useImperativeHandle: function(n, o, m) {
          return tn = "useImperativeHandle", Dn(), a_(n, o, m);
        },
        useInsertionEffect: function(n, o) {
          return tn = "useInsertionEffect", Dn(), ow(n, o);
        },
        useLayoutEffect: function(n, o) {
          return tn = "useLayoutEffect", Dn(), lw(n, o);
        },
        useMemo: function(n, o) {
          tn = "useMemo", Dn();
          var m = Yn.current;
          Yn.current = Nn;
          try {
            return f(n, o);
          } finally {
            Yn.current = m;
          }
        },
        useReducer: function(n, o, m) {
          tn = "useReducer", Dn();
          var S = Yn.current;
          Yn.current = Nn;
          try {
            return nw(n, o, m);
          } finally {
            Yn.current = S;
          }
        },
        useRef: function(n) {
          return tn = "useRef", Dn(), sw(n);
        },
        useState: function(n) {
          tn = "useState", Dn();
          var o = Yn.current;
          Yn.current = Nn;
          try {
            return $1(n);
          } finally {
            Yn.current = o;
          }
        },
        useDebugValue: function(n, o) {
          return tn = "useDebugValue", Dn(), void 0;
        },
        useDeferredValue: function(n) {
          return tn = "useDeferredValue", Dn(), A(n);
        },
        useTransition: function() {
          return tn = "useTransition", Dn(), _e();
        },
        useMutableSource: function(n, o, m) {
          return tn = "useMutableSource", Dn(), void 0;
        },
        useSyncExternalStore: function(n, o, m) {
          return tn = "useSyncExternalStore", Dn(), bE(n, o, m);
        },
        useId: function() {
          return tn = "useId", Dn(), Yt();
        },
        unstable_isNewReconciler: ve
      }, En = {
        readContext: function(n) {
          return Ml(n);
        },
        useCallback: function(n, o) {
          return tn = "useCallback", Dn(), u(n, o);
        },
        useContext: function(n) {
          return tn = "useContext", Dn(), Ml(n);
        },
        useEffect: function(n, o) {
          return tn = "useEffect", Dn(), Dx(n, o);
        },
        useImperativeHandle: function(n, o, m) {
          return tn = "useImperativeHandle", Dn(), uw(n, o, m);
        },
        useInsertionEffect: function(n, o) {
          return tn = "useInsertionEffect", Dn(), r_(n, o);
        },
        useLayoutEffect: function(n, o) {
          return tn = "useLayoutEffect", Dn(), i_(n, o);
        },
        useMemo: function(n, o) {
          tn = "useMemo", Dn();
          var m = Yn.current;
          Yn.current = ni;
          try {
            return M(n, o);
          } finally {
            Yn.current = m;
          }
        },
        useReducer: function(n, o, m) {
          tn = "useReducer", Dn();
          var S = Yn.current;
          Yn.current = ni;
          try {
            return SE(n, o, m);
          } finally {
            Yn.current = S;
          }
        },
        useRef: function(n) {
          return tn = "useRef", Dn(), e_();
        },
        useState: function(n) {
          tn = "useState", Dn();
          var o = Yn.current;
          Yn.current = ni;
          try {
            return iw(n);
          } finally {
            Yn.current = o;
          }
        },
        useDebugValue: function(n, o) {
          return tn = "useDebugValue", Dn(), cw();
        },
        useDeferredValue: function(n) {
          return tn = "useDeferredValue", Dn(), z(n);
        },
        useTransition: function() {
          return tn = "useTransition", Dn(), Ue();
        },
        useMutableSource: function(n, o, m) {
          return tn = "useMutableSource", Dn(), void 0;
        },
        useSyncExternalStore: function(n, o, m) {
          return tn = "useSyncExternalStore", Dn(), rw(n, o);
        },
        useId: function() {
          return tn = "useId", Dn(), pn();
        },
        unstable_isNewReconciler: ve
      }, yr = {
        readContext: function(n) {
          return Ml(n);
        },
        useCallback: function(n, o) {
          return tn = "useCallback", Dn(), u(n, o);
        },
        useContext: function(n) {
          return tn = "useContext", Dn(), Ml(n);
        },
        useEffect: function(n, o) {
          return tn = "useEffect", Dn(), Dx(n, o);
        },
        useImperativeHandle: function(n, o, m) {
          return tn = "useImperativeHandle", Dn(), uw(n, o, m);
        },
        useInsertionEffect: function(n, o) {
          return tn = "useInsertionEffect", Dn(), r_(n, o);
        },
        useLayoutEffect: function(n, o) {
          return tn = "useLayoutEffect", Dn(), i_(n, o);
        },
        useMemo: function(n, o) {
          tn = "useMemo", Dn();
          var m = Yn.current;
          Yn.current = wa;
          try {
            return M(n, o);
          } finally {
            Yn.current = m;
          }
        },
        useReducer: function(n, o, m) {
          tn = "useReducer", Dn();
          var S = Yn.current;
          Yn.current = wa;
          try {
            return wE(n, o, m);
          } finally {
            Yn.current = S;
          }
        },
        useRef: function(n) {
          return tn = "useRef", Dn(), e_();
        },
        useState: function(n) {
          tn = "useState", Dn();
          var o = Yn.current;
          Yn.current = wa;
          try {
            return aw(n);
          } finally {
            Yn.current = o;
          }
        },
        useDebugValue: function(n, o) {
          return tn = "useDebugValue", Dn(), cw();
        },
        useDeferredValue: function(n) {
          return tn = "useDeferredValue", Dn(), W(n);
        },
        useTransition: function() {
          return tn = "useTransition", Dn(), We();
        },
        useMutableSource: function(n, o, m) {
          return tn = "useMutableSource", Dn(), void 0;
        },
        useSyncExternalStore: function(n, o, m) {
          return tn = "useSyncExternalStore", Dn(), rw(n, o);
        },
        useId: function() {
          return tn = "useId", Dn(), pn();
        },
        unstable_isNewReconciler: ve
      }, Nn = {
        readContext: function(n) {
          return ys(), Ml(n);
        },
        useCallback: function(n, o) {
          return tn = "useCallback", kn(), Wa(), AE(n, o);
        },
        useContext: function(n) {
          return tn = "useContext", kn(), Wa(), Ml(n);
        },
        useEffect: function(n, o) {
          return tn = "useEffect", kn(), Wa(), n_(n, o);
        },
        useImperativeHandle: function(n, o, m) {
          return tn = "useImperativeHandle", kn(), Wa(), a_(n, o, m);
        },
        useInsertionEffect: function(n, o) {
          return tn = "useInsertionEffect", kn(), Wa(), ow(n, o);
        },
        useLayoutEffect: function(n, o) {
          return tn = "useLayoutEffect", kn(), Wa(), lw(n, o);
        },
        useMemo: function(n, o) {
          tn = "useMemo", kn(), Wa();
          var m = Yn.current;
          Yn.current = Nn;
          try {
            return f(n, o);
          } finally {
            Yn.current = m;
          }
        },
        useReducer: function(n, o, m) {
          tn = "useReducer", kn(), Wa();
          var S = Yn.current;
          Yn.current = Nn;
          try {
            return nw(n, o, m);
          } finally {
            Yn.current = S;
          }
        },
        useRef: function(n) {
          return tn = "useRef", kn(), Wa(), sw(n);
        },
        useState: function(n) {
          tn = "useState", kn(), Wa();
          var o = Yn.current;
          Yn.current = Nn;
          try {
            return $1(n);
          } finally {
            Yn.current = o;
          }
        },
        useDebugValue: function(n, o) {
          return tn = "useDebugValue", kn(), Wa(), void 0;
        },
        useDeferredValue: function(n) {
          return tn = "useDeferredValue", kn(), Wa(), A(n);
        },
        useTransition: function() {
          return tn = "useTransition", kn(), Wa(), _e();
        },
        useMutableSource: function(n, o, m) {
          return tn = "useMutableSource", kn(), Wa(), void 0;
        },
        useSyncExternalStore: function(n, o, m) {
          return tn = "useSyncExternalStore", kn(), Wa(), bE(n, o, m);
        },
        useId: function() {
          return tn = "useId", kn(), Wa(), Yt();
        },
        unstable_isNewReconciler: ve
      }, ni = {
        readContext: function(n) {
          return ys(), Ml(n);
        },
        useCallback: function(n, o) {
          return tn = "useCallback", kn(), Dn(), u(n, o);
        },
        useContext: function(n) {
          return tn = "useContext", kn(), Dn(), Ml(n);
        },
        useEffect: function(n, o) {
          return tn = "useEffect", kn(), Dn(), Dx(n, o);
        },
        useImperativeHandle: function(n, o, m) {
          return tn = "useImperativeHandle", kn(), Dn(), uw(n, o, m);
        },
        useInsertionEffect: function(n, o) {
          return tn = "useInsertionEffect", kn(), Dn(), r_(n, o);
        },
        useLayoutEffect: function(n, o) {
          return tn = "useLayoutEffect", kn(), Dn(), i_(n, o);
        },
        useMemo: function(n, o) {
          tn = "useMemo", kn(), Dn();
          var m = Yn.current;
          Yn.current = ni;
          try {
            return M(n, o);
          } finally {
            Yn.current = m;
          }
        },
        useReducer: function(n, o, m) {
          tn = "useReducer", kn(), Dn();
          var S = Yn.current;
          Yn.current = ni;
          try {
            return SE(n, o, m);
          } finally {
            Yn.current = S;
          }
        },
        useRef: function(n) {
          return tn = "useRef", kn(), Dn(), e_();
        },
        useState: function(n) {
          tn = "useState", kn(), Dn();
          var o = Yn.current;
          Yn.current = ni;
          try {
            return iw(n);
          } finally {
            Yn.current = o;
          }
        },
        useDebugValue: function(n, o) {
          return tn = "useDebugValue", kn(), Dn(), cw();
        },
        useDeferredValue: function(n) {
          return tn = "useDeferredValue", kn(), Dn(), z(n);
        },
        useTransition: function() {
          return tn = "useTransition", kn(), Dn(), Ue();
        },
        useMutableSource: function(n, o, m) {
          return tn = "useMutableSource", kn(), Dn(), void 0;
        },
        useSyncExternalStore: function(n, o, m) {
          return tn = "useSyncExternalStore", kn(), Dn(), rw(n, o);
        },
        useId: function() {
          return tn = "useId", kn(), Dn(), pn();
        },
        unstable_isNewReconciler: ve
      }, wa = {
        readContext: function(n) {
          return ys(), Ml(n);
        },
        useCallback: function(n, o) {
          return tn = "useCallback", kn(), Dn(), u(n, o);
        },
        useContext: function(n) {
          return tn = "useContext", kn(), Dn(), Ml(n);
        },
        useEffect: function(n, o) {
          return tn = "useEffect", kn(), Dn(), Dx(n, o);
        },
        useImperativeHandle: function(n, o, m) {
          return tn = "useImperativeHandle", kn(), Dn(), uw(n, o, m);
        },
        useInsertionEffect: function(n, o) {
          return tn = "useInsertionEffect", kn(), Dn(), r_(n, o);
        },
        useLayoutEffect: function(n, o) {
          return tn = "useLayoutEffect", kn(), Dn(), i_(n, o);
        },
        useMemo: function(n, o) {
          tn = "useMemo", kn(), Dn();
          var m = Yn.current;
          Yn.current = ni;
          try {
            return M(n, o);
          } finally {
            Yn.current = m;
          }
        },
        useReducer: function(n, o, m) {
          tn = "useReducer", kn(), Dn();
          var S = Yn.current;
          Yn.current = ni;
          try {
            return wE(n, o, m);
          } finally {
            Yn.current = S;
          }
        },
        useRef: function(n) {
          return tn = "useRef", kn(), Dn(), e_();
        },
        useState: function(n) {
          tn = "useState", kn(), Dn();
          var o = Yn.current;
          Yn.current = ni;
          try {
            return aw(n);
          } finally {
            Yn.current = o;
          }
        },
        useDebugValue: function(n, o) {
          return tn = "useDebugValue", kn(), Dn(), cw();
        },
        useDeferredValue: function(n) {
          return tn = "useDeferredValue", kn(), Dn(), W(n);
        },
        useTransition: function() {
          return tn = "useTransition", kn(), Dn(), We();
        },
        useMutableSource: function(n, o, m) {
          return tn = "useMutableSource", kn(), Dn(), void 0;
        },
        useSyncExternalStore: function(n, o, m) {
          return tn = "useSyncExternalStore", kn(), Dn(), rw(n, o);
        },
        useId: function() {
          return tn = "useId", kn(), Dn(), pn();
        },
        unstable_isNewReconciler: ve
      };
    }
    var as = e.unstable_now, ba = 0, Ei = -1, Ao = -1, co = -1, rh = !1, wu = !1;
    function ih() {
      return rh;
    }
    function Fh() {
      wu = !0;
    }
    function hv() {
      rh = !1, wu = !1;
    }
    function Lx() {
      rh = wu, wu = !1;
    }
    function p0() {
      return ba;
    }
    function ah() {
      ba = as();
    }
    function Qv(n) {
      Ao = as(), n.actualStartTime < 0 && (n.actualStartTime = as());
    }
    function fw(n) {
      Ao = -1;
    }
    function s_(n, o) {
      if (Ao >= 0) {
        var m = as() - Ao;
        n.actualDuration += m, o && (n.selfBaseDuration = m), Ao = -1;
      }
    }
    function pv(n) {
      if (Ei >= 0) {
        var o = as() - Ei;
        Ei = -1;
        for (var m = n.return; m !== null; ) {
          switch (m.tag) {
            case w:
              var S = m.stateNode;
              S.effectDuration += o;
              return;
            case B:
              var C = m.stateNode;
              C.effectDuration += o;
              return;
          }
          m = m.return;
        }
      }
    }
    function DE(n) {
      if (co >= 0) {
        var o = as() - co;
        co = -1;
        for (var m = n.return; m !== null; ) {
          switch (m.tag) {
            case w:
              var S = m.stateNode;
              S !== null && (S.passiveEffectDuration += o);
              return;
            case B:
              var C = m.stateNode;
              C !== null && (C.passiveEffectDuration += o);
              return;
          }
          m = m.return;
        }
      }
    }
    function ny() {
      Ei = as();
    }
    function yR() {
      co = as();
    }
    function xR(n) {
      for (var o = n.child; o; )
        n.actualDuration += o.actualDuration, o = o.sibling;
    }
    function o_(n, o) {
      return {
        value: n,
        source: o,
        stack: go(o),
        digest: null
      };
    }
    function _R(n, o, m) {
      return {
        value: n,
        source: null,
        stack: m != null ? m : null,
        digest: o != null ? o : null
      };
    }
    function O4(n, o) {
      return !0;
    }
    function SR(n, o) {
      try {
        var m = O4(n, o);
        if (m === !1)
          return;
        var S = o.value, C = o.source, F = o.stack, j = F !== null ? F : "";
        if (S != null && S._suppressLogging) {
          if (n.tag === g)
            return;
          console.error(S);
        }
        var J = C ? xr(C) : null, ne = J ? "The above error occurred in the <" + J + "> component:" : "The above error occurred in one of your React components:", Se;
        if (n.tag === w)
          Se = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var Ce = xr(n) || "Anonymous";
          Se = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + Ce + ".");
        }
        var nt = ne + `
` + j + `

` + ("" + Se);
        console.error(nt);
      } catch (et) {
        setTimeout(function() {
          throw et;
        });
      }
    }
    var U4 = typeof WeakMap == "function" ? WeakMap : Map;
    function GL(n, o, m) {
      var S = sv(ti, m);
      S.tag = tE, S.payload = {
        element: null
      };
      var C = o.value;
      return S.callback = function() {
        TB(C), SR(n, o);
      }, S;
    }
    function wR(n, o, m) {
      var S = sv(ti, m);
      S.tag = tE;
      var C = n.type.getDerivedStateFromError;
      if (typeof C == "function") {
        var F = o.value;
        S.payload = function() {
          return C(F);
        }, S.callback = function() {
          eO(n), SR(n, o);
        };
      }
      var j = n.stateNode;
      return j !== null && typeof j.componentDidCatch == "function" && (S.callback = function() {
        eO(n), SR(n, o), typeof C != "function" && EB(this);
        var ne = o.value, Se = o.stack;
        this.componentDidCatch(ne, {
          componentStack: Se !== null ? Se : ""
        }), typeof C != "function" && (Ze(n.lanes, lr) || l("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", xr(n) || "Unknown"));
      }), S;
    }
    function WL(n, o, m) {
      var S = n.pingCache, C;
      if (S === null ? (S = n.pingCache = new U4(), C = /* @__PURE__ */ new Set(), S.set(o, C)) : (C = S.get(o), C === void 0 && (C = /* @__PURE__ */ new Set(), S.set(o, C))), !C.has(m)) {
        C.add(m);
        var F = CB.bind(null, n, o, m);
        ya && YE(n, m), o.then(F, F);
      }
    }
    function z4(n, o, m, S) {
      var C = n.updateQueue;
      if (C === null) {
        var F = /* @__PURE__ */ new Set();
        F.add(m), n.updateQueue = F;
      } else
        C.add(m);
    }
    function N4(n, o) {
      var m = n.tag;
      if ((n.mode & Gr) === hr && (m === p || m === G || m === te)) {
        var S = n.alternate;
        S ? (n.updateQueue = S.updateQueue, n.memoizedState = S.memoizedState, n.lanes = S.lanes) : (n.updateQueue = null, n.memoizedState = null);
      }
    }
    function jL(n) {
      var o = n;
      do {
        if (o.tag === Q && zT(o))
          return o;
        o = o.return;
      } while (o !== null);
      return null;
    }
    function YL(n, o, m, S, C) {
      if ((n.mode & Gr) === hr) {
        if (n === o)
          n.flags |= wo;
        else {
          if (n.flags |= Rr, m.flags |= tp, m.flags &= ~(Vo | gl), m.tag === g) {
            var F = m.alternate;
            if (F === null)
              m.tag = re;
            else {
              var j = sv(ti, lr);
              j.tag = Tl, Zg(m, j, lr);
            }
          }
          m.lanes = Qt(m.lanes, lr);
        }
        return n;
      }
      return n.flags |= wo, n.lanes = C, n;
    }
    function F4(n, o, m, S, C) {
      if (m.flags |= gl, ya && YE(n, C), S !== null && typeof S == "object" && typeof S.then == "function") {
        var F = S;
        N4(m), js() && m.mode & Gr && US();
        var j = jL(o);
        if (j !== null) {
          j.flags &= ~ps, YL(j, o, m, n, C), j.mode & Gr && WL(n, F, C), z4(j, n, F);
          return;
        } else {
          if (!X(C)) {
            WL(n, F, C), tA();
            return;
          }
          var J = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          S = J;
        }
      } else if (js() && m.mode & Gr) {
        US();
        var ne = jL(o);
        if (ne !== null) {
          (ne.flags & wo) === vr && (ne.flags |= ps), YL(ne, o, m, n, C), vm(o_(S, m));
          return;
        }
      }
      S = o_(S, m), vB(S);
      var Se = o;
      do {
        switch (Se.tag) {
          case w: {
            var Ce = S;
            Se.flags |= wo;
            var nt = Li(C);
            Se.lanes = Qt(Se.lanes, nt);
            var et = GL(Se, Ce, nt);
            ov(Se, et);
            return;
          }
          case g:
            var Pt = S, Ut = Se.type, Xt = Se.stateNode;
            if ((Se.flags & Rr) === vr && (typeof Ut.getDerivedStateFromError == "function" || Xt !== null && typeof Xt.componentDidCatch == "function" && !jP(Xt))) {
              Se.flags |= wo;
              var tr = Li(C);
              Se.lanes = Qt(Se.lanes, tr);
              var Dr = wR(Se, Pt, tr);
              ov(Se, Dr);
              return;
            }
            break;
        }
        Se = Se.return;
      } while (Se !== null);
    }
    function k4() {
      return null;
    }
    var LE = t.ReactCurrentOwner, Zv = !1, bR, PE, ER, MR, TR, l_, CR, BT;
    bR = {}, PE = {}, ER = {}, MR = {}, TR = {}, l_ = !1, CR = {}, BT = {};
    function kh(n, o, m, S) {
      n === null ? o.child = LT(o, null, m, S) : o.child = xx(o, n.child, m, S);
    }
    function I4(n, o, m, S) {
      o.child = xx(o, n.child, null, S), o.child = xx(o, null, m, S);
    }
    function XL(n, o, m, S, C) {
      if (o.type !== o.elementType) {
        var F = m.propTypes;
        F && Gs(
          F,
          S,
          "prop",
          Ci(m)
        );
      }
      var j = m.render, J = o.ref, ne, Se;
      av(o, C), Ra(o);
      {
        if (LE.current = o, hi(!0), ne = Cx(n, o, j, S, J, C), Se = ty(), o.mode & ui) {
          xa(!0);
          try {
            ne = Cx(n, o, j, S, J, C), Se = ty();
          } finally {
            xa(!1);
          }
        }
        hi(!1);
      }
      return Ba(), n !== null && !Zv ? (tw(n, o, C), m0(n, o, C)) : (js() && Se && jb(o), o.flags |= Vi, kh(n, o, ne, C), o.child);
    }
    function qL(n, o, m, S, C) {
      if (n === null) {
        var F = m.type;
        if (WB(F) && m.compare === null && m.defaultProps === void 0) {
          var j = F;
          return j = xw(F), o.tag = te, o.type = j, DR(o, F), QL(n, o, j, S, C);
        }
        {
          var J = F.propTypes;
          J && Gs(
            J,
            S,
            "prop",
            Ci(F)
          );
        }
        var ne = dA(m.type, null, S, o, o.mode, C);
        return ne.ref = o.ref, ne.return = o, o.child = ne, ne;
      }
      {
        var Se = m.type, Ce = Se.propTypes;
        Ce && Gs(
          Ce,
          S,
          "prop",
          Ci(Se)
        );
      }
      var nt = n.child, et = NR(n, C);
      if (!et) {
        var Pt = nt.memoizedProps, Ut = m.compare;
        if (Ut = Ut !== null ? Ut : pr, Ut(Pt, S) && n.ref === o.ref)
          return m0(n, o, C);
      }
      o.flags |= Vi;
      var Xt = h_(nt, S);
      return Xt.ref = o.ref, Xt.return = o, o.child = Xt, Xt;
    }
    function QL(n, o, m, S, C) {
      if (o.type !== o.elementType) {
        var F = o.elementType;
        if (F.$$typeof === yn) {
          var j = F, J = j._payload, ne = j._init;
          try {
            F = ne(J);
          } catch {
            F = null;
          }
          var Se = F && F.propTypes;
          Se && Gs(
            Se,
            S,
            "prop",
            Ci(F)
          );
        }
      }
      if (n !== null) {
        var Ce = n.memoizedProps;
        if (pr(Ce, S) && n.ref === o.ref && o.type === n.type)
          if (Zv = !1, o.pendingProps = S = Ce, NR(n, C))
            (n.flags & tp) !== vr && (Zv = !0);
          else
            return o.lanes = n.lanes, m0(n, o, C);
      }
      return RR(n, o, m, S, C);
    }
    function ZL(n, o, m) {
      var S = o.pendingProps, C = S.children, F = n !== null ? n.memoizedState : null;
      if (S.mode === "hidden" || he)
        if ((o.mode & Gr) === hr) {
          var j = {
            baseLanes: Ht,
            cachePool: null,
            transitions: null
          };
          o.memoizedState = j, $T(o, m);
        } else if (Ze(m, yu)) {
          var nt = {
            baseLanes: Ht,
            cachePool: null,
            transitions: null
          };
          o.memoizedState = nt;
          var et = F !== null ? F.baseLanes : m;
          $T(o, et);
        } else {
          var J = null, ne;
          if (F !== null) {
            var Se = F.baseLanes;
            ne = Qt(Se, m);
          } else
            ne = m;
          o.lanes = o.childLanes = yu;
          var Ce = {
            baseLanes: ne,
            cachePool: J,
            transitions: null
          };
          return o.memoizedState = Ce, o.updateQueue = null, $T(o, ne), null;
        }
      else {
        var Pt;
        F !== null ? (Pt = Qt(F.baseLanes, m), o.memoizedState = null) : Pt = m, $T(o, Pt);
      }
      return kh(n, o, C, m), o.child;
    }
    function B4(n, o, m) {
      var S = o.pendingProps;
      return kh(n, o, S, m), o.child;
    }
    function H4(n, o, m) {
      var S = o.pendingProps.children;
      return kh(n, o, S, m), o.child;
    }
    function V4(n, o, m) {
      {
        o.flags |= Wn;
        {
          var S = o.stateNode;
          S.effectDuration = 0, S.passiveEffectDuration = 0;
        }
      }
      var C = o.pendingProps, F = C.children;
      return kh(n, o, F, m), o.child;
    }
    function JL(n, o) {
      var m = o.ref;
      (n === null && m !== null || n !== null && n.ref !== m) && (o.flags |= es, o.flags |= du);
    }
    function RR(n, o, m, S, C) {
      if (o.type !== o.elementType) {
        var F = m.propTypes;
        F && Gs(
          F,
          S,
          "prop",
          Ci(m)
        );
      }
      var j;
      {
        var J = Vg(o, m, !0);
        j = ux(o, J);
      }
      var ne, Se;
      av(o, C), Ra(o);
      {
        if (LE.current = o, hi(!0), ne = Cx(n, o, m, S, j, C), Se = ty(), o.mode & ui) {
          xa(!0);
          try {
            ne = Cx(n, o, m, S, j, C), Se = ty();
          } finally {
            xa(!1);
          }
        }
        hi(!1);
      }
      return Ba(), n !== null && !Zv ? (tw(n, o, C), m0(n, o, C)) : (js() && Se && jb(o), o.flags |= Vi, kh(n, o, ne, C), o.child);
    }
    function KL(n, o, m, S, C) {
      {
        switch (a5(o)) {
          case !1: {
            var F = o.stateNode, j = o.type, J = new j(o.memoizedProps, F.context), ne = J.state;
            F.updater.enqueueSetState(F, ne, null);
            break;
          }
          case !0: {
            o.flags |= Rr, o.flags |= wo;
            var Se = new Error("Simulated error coming from DevTools"), Ce = Li(C);
            o.lanes = Qt(o.lanes, Ce);
            var nt = wR(o, o_(Se, o), Ce);
            ov(o, nt);
            break;
          }
        }
        if (o.type !== o.elementType) {
          var et = m.propTypes;
          et && Gs(
            et,
            S,
            "prop",
            Ci(m)
          );
        }
      }
      var Pt;
      fm(m) ? (Pt = !0, CS(o)) : Pt = !1, av(o, C);
      var Ut = o.stateNode, Xt;
      Ut === null ? (VT(n, o), sE(o, m, S), oE(o, m, S, C), Xt = !0) : n === null ? Xt = lv(o, m, S, C) : Xt = fR(n, o, m, S, C);
      var tr = AR(n, o, m, Xt, Pt, C);
      {
        var Dr = o.stateNode;
        Xt && Dr.props !== S && (l_ || l("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", xr(o) || "a component"), l_ = !0);
      }
      return tr;
    }
    function AR(n, o, m, S, C, F) {
      JL(n, o);
      var j = (o.flags & Rr) !== vr;
      if (!S && !j)
        return C && uT(o, m, !1), m0(n, o, F);
      var J = o.stateNode;
      LE.current = o;
      var ne;
      if (j && typeof m.getDerivedStateFromError != "function")
        ne = null, fw();
      else {
        Ra(o);
        {
          if (hi(!0), ne = J.render(), o.mode & ui) {
            xa(!0);
            try {
              J.render();
            } finally {
              xa(!1);
            }
          }
          hi(!1);
        }
        Ba();
      }
      return o.flags |= Vi, n !== null && j ? I4(n, o, ne, F) : kh(n, o, ne, F), o.memoizedState = J.state, C && uT(o, m, !0), o.child;
    }
    function $L(n) {
      var o = n.stateNode;
      o.pendingContext ? oT(n, o.pendingContext, o.pendingContext !== o.context) : o.context && oT(n, o.context, !1), Q1(n, o.containerInfo);
    }
    function G4(n, o, m) {
      if ($L(o), n === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var S = o.pendingProps, C = o.memoizedState, F = C.element;
      GS(n, o), jS(o, S, null, m);
      var j = o.memoizedState;
      o.stateNode;
      var J = j.element;
      if (C.isDehydrated) {
        var ne = {
          element: J,
          isDehydrated: !1,
          cache: j.cache,
          pendingSuspenseBoundaries: j.pendingSuspenseBoundaries,
          transitions: j.transitions
        }, Se = o.updateQueue;
        if (Se.baseState = ne, o.memoizedState = ne, o.flags & ps) {
          var Ce = o_(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), o);
          return eP(n, o, J, m, Ce);
        } else if (J !== F) {
          var nt = o_(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), o);
          return eP(n, o, J, m, nt);
        } else {
          mT(o);
          var et = LT(o, null, J, m);
          o.child = et;
          for (var Pt = et; Pt; )
            Pt.flags = Pt.flags & ~si | Il, Pt = Pt.sibling;
        }
      } else {
        if (Yg(), J === F)
          return m0(n, o, m);
        kh(n, o, J, m);
      }
      return o.child;
    }
    function eP(n, o, m, S, C) {
      return Yg(), vm(C), o.flags |= ps, kh(n, o, m, S), o.child;
    }
    function W4(n, o, m) {
      $S(o), n === null && Jb(o);
      var S = o.type, C = o.pendingProps, F = n !== null ? n.memoizedProps : null, j = C.children, J = M1(S, C);
      return J ? j = null : F !== null && M1(S, F) && (o.flags |= zi), JL(n, o), kh(n, o, j, m), o.child;
    }
    function j4(n, o) {
      return n === null && Jb(o), null;
    }
    function Y4(n, o, m, S) {
      VT(n, o);
      var C = o.pendingProps, F = m, j = F._payload, J = F._init, ne = J(j);
      o.type = ne;
      var Se = o.tag = jB(ne), Ce = Md(ne, C), nt;
      switch (Se) {
        case p:
          return DR(o, ne), o.type = ne = xw(ne), nt = RR(null, o, ne, Ce, S), nt;
        case g:
          return o.type = ne = sA(ne), nt = KL(null, o, ne, Ce, S), nt;
        case G:
          return o.type = ne = oA(ne), nt = XL(null, o, ne, Ce, S), nt;
        case K: {
          if (o.type !== o.elementType) {
            var et = ne.propTypes;
            et && Gs(
              et,
              Ce,
              "prop",
              Ci(ne)
            );
          }
          return nt = qL(
            null,
            o,
            ne,
            Md(ne.type, Ce),
            S
          ), nt;
        }
      }
      var Pt = "";
      throw ne !== null && typeof ne == "object" && ne.$$typeof === yn && (Pt = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + ne + ". " + ("Lazy element type must resolve to a class or function." + Pt));
    }
    function X4(n, o, m, S, C) {
      VT(n, o), o.tag = g;
      var F;
      return fm(m) ? (F = !0, CS(o)) : F = !1, av(o, C), sE(o, m, S), oE(o, m, S, C), AR(null, o, m, !0, F, C);
    }
    function q4(n, o, m, S) {
      VT(n, o);
      var C = o.pendingProps, F;
      {
        var j = Vg(o, m, !1);
        F = ux(o, j);
      }
      av(o, S);
      var J, ne;
      Ra(o);
      {
        if (m.prototype && typeof m.prototype.render == "function") {
          var Se = Ci(m) || "Unknown";
          bR[Se] || (l("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", Se, Se), bR[Se] = !0);
        }
        o.mode & ui && Ed.recordLegacyContextWarning(o, null), hi(!0), LE.current = o, J = Cx(null, o, m, C, F, S), ne = ty(), hi(!1);
      }
      if (Ba(), o.flags |= Vi, typeof J == "object" && J !== null && typeof J.render == "function" && J.$$typeof === void 0) {
        var Ce = Ci(m) || "Unknown";
        PE[Ce] || (l("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", Ce, Ce, Ce), PE[Ce] = !0);
      }
      if (typeof J == "object" && J !== null && typeof J.render == "function" && J.$$typeof === void 0) {
        {
          var nt = Ci(m) || "Unknown";
          PE[nt] || (l("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", nt, nt, nt), PE[nt] = !0);
        }
        o.tag = g, o.memoizedState = null, o.updateQueue = null;
        var et = !1;
        return fm(m) ? (et = !0, CS(o)) : et = !1, o.memoizedState = J.state !== null && J.state !== void 0 ? J.state : null, VS(o), CT(o, J), oE(o, m, C, S), AR(null, o, m, !0, et, S);
      } else {
        if (o.tag = p, o.mode & ui) {
          xa(!0);
          try {
            J = Cx(null, o, m, C, F, S), ne = ty();
          } finally {
            xa(!1);
          }
        }
        return js() && ne && jb(o), kh(null, o, J, S), DR(o, m), o.child;
      }
    }
    function DR(n, o) {
      {
        if (o && o.childContextTypes && l("%s(...): childContextTypes cannot be defined on a function component.", o.displayName || o.name || "Component"), n.ref !== null) {
          var m = "", S = dl();
          S && (m += `

Check the render method of \`` + S + "`.");
          var C = S || "", F = n._debugSource;
          F && (C = F.fileName + ":" + F.lineNumber), TR[C] || (TR[C] = !0, l("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", m));
        }
        if (typeof o.getDerivedStateFromProps == "function") {
          var j = Ci(o) || "Unknown";
          MR[j] || (l("%s: Function components do not support getDerivedStateFromProps.", j), MR[j] = !0);
        }
        if (typeof o.contextType == "object" && o.contextType !== null) {
          var J = Ci(o) || "Unknown";
          ER[J] || (l("%s: Function components do not support contextType.", J), ER[J] = !0);
        }
      }
    }
    var LR = {
      dehydrated: null,
      treeContext: null,
      retryLane: pi
    };
    function PR(n) {
      return {
        baseLanes: n,
        cachePool: k4(),
        transitions: null
      };
    }
    function Q4(n, o) {
      var m = null;
      return {
        baseLanes: Qt(n.baseLanes, o),
        cachePool: m,
        transitions: n.transitions
      };
    }
    function Z4(n, o, m, S) {
      if (o !== null) {
        var C = o.memoizedState;
        if (C === null)
          return !1;
      }
      return $g(n, Z1);
    }
    function J4(n, o) {
      return jn(n.childLanes, o);
    }
    function tP(n, o, m) {
      var S = o.pendingProps;
      s5(o) && (o.flags |= Rr);
      var C = Cl.current, F = !1, j = (o.flags & Rr) !== vr;
      if (j || Z4(C, n) ? (F = !0, o.flags &= ~Rr) : (n === null || n.memoizedState !== null) && (C = mE(C, UT)), C = Ex(C), uv(o, C), n === null) {
        Jb(o);
        var J = o.memoizedState;
        if (J !== null) {
          var ne = J.dehydrated;
          if (ne !== null)
            return nI(o, ne);
        }
        var Se = S.children, Ce = S.fallback;
        if (F) {
          var nt = K4(o, Se, Ce, m), et = o.child;
          return et.memoizedState = PR(m), o.memoizedState = LR, nt;
        } else
          return OR(o, Se);
      } else {
        var Pt = n.memoizedState;
        if (Pt !== null) {
          var Ut = Pt.dehydrated;
          if (Ut !== null)
            return rI(n, o, j, S, Ut, Pt, m);
        }
        if (F) {
          var Xt = S.fallback, tr = S.children, Dr = eI(n, o, tr, Xt, m), Sr = o.child, ma = n.child.memoizedState;
          return Sr.memoizedState = ma === null ? PR(m) : Q4(ma, m), Sr.childLanes = J4(n, m), o.memoizedState = LR, Dr;
        } else {
          var ta = S.children, bt = $4(n, o, ta, m);
          return o.memoizedState = null, bt;
        }
      }
    }
    function OR(n, o, m) {
      var S = n.mode, C = {
        mode: "visible",
        children: o
      }, F = UR(C, S);
      return F.return = n, n.child = F, F;
    }
    function K4(n, o, m, S) {
      var C = n.mode, F = n.child, j = {
        mode: "hidden",
        children: o
      }, J, ne;
      return (C & Gr) === hr && F !== null ? (J = F, J.childLanes = Ht, J.pendingProps = j, n.mode & fr && (J.actualDuration = 0, J.actualStartTime = -1, J.selfBaseDuration = 0, J.treeBaseDuration = 0), ne = Fx(m, C, S, null)) : (J = UR(j, C), ne = Fx(m, C, S, null)), J.return = n, ne.return = n, J.sibling = ne, n.child = J, ne;
    }
    function UR(n, o, m) {
      return nO(n, o, Ht, null);
    }
    function nP(n, o) {
      return h_(n, o);
    }
    function $4(n, o, m, S) {
      var C = n.child, F = C.sibling, j = nP(C, {
        mode: "visible",
        children: m
      });
      if ((o.mode & Gr) === hr && (j.lanes = S), j.return = o, j.sibling = null, F !== null) {
        var J = o.deletions;
        J === null ? (o.deletions = [F], o.flags |= wi) : J.push(F);
      }
      return o.child = j, j;
    }
    function eI(n, o, m, S, C) {
      var F = o.mode, j = n.child, J = j.sibling, ne = {
        mode: "hidden",
        children: m
      }, Se;
      if ((F & Gr) === hr && o.child !== j) {
        var Ce = o.child;
        Se = Ce, Se.childLanes = Ht, Se.pendingProps = ne, o.mode & fr && (Se.actualDuration = 0, Se.actualStartTime = -1, Se.selfBaseDuration = j.selfBaseDuration, Se.treeBaseDuration = j.treeBaseDuration), o.deletions = null;
      } else
        Se = nP(j, ne), Se.subtreeFlags = j.subtreeFlags & vn;
      var nt;
      return J !== null ? nt = h_(J, S) : (nt = Fx(S, F, C, null), nt.flags |= si), nt.return = o, Se.return = o, Se.sibling = nt, o.child = Se, nt;
    }
    function HT(n, o, m, S) {
      S !== null && vm(S), xx(o, n.child, null, m);
      var C = o.pendingProps, F = C.children, j = OR(o, F);
      return j.flags |= si, o.memoizedState = null, j;
    }
    function tI(n, o, m, S, C) {
      var F = o.mode, j = {
        mode: "visible",
        children: m
      }, J = UR(j, F), ne = Fx(S, F, C, null);
      return ne.flags |= si, J.return = o, ne.return = o, J.sibling = ne, o.child = J, (o.mode & Gr) !== hr && xx(o, n.child, null, C), ne;
    }
    function nI(n, o, m) {
      return (n.mode & Gr) === hr ? (l("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), n.lanes = lr) : L1(o) ? n.lanes = Yo : n.lanes = yu, null;
    }
    function rI(n, o, m, S, C, F, j) {
      if (m)
        if (o.flags & ps) {
          o.flags &= ~ps;
          var bt = _R(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
          return HT(n, o, j, bt);
        } else {
          if (o.memoizedState !== null)
            return o.child = n.child, o.flags |= Rr, null;
          var qt = S.children, Et = S.fallback, xn = tI(n, o, qt, Et, j), nr = o.child;
          return nr.memoizedState = PR(j), o.memoizedState = LR, xn;
        }
      else {
        if (Yb(), (o.mode & Gr) === hr)
          return HT(
            n,
            o,
            j,
            null
          );
        if (L1(C)) {
          var J, ne, Se;
          {
            var Ce = xS(C);
            J = Ce.digest, ne = Ce.message, Se = Ce.stack;
          }
          var nt;
          ne ? nt = new Error(ne) : nt = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
          var et = _R(nt, J, Se);
          return HT(n, o, j, et);
        }
        var Pt = Ze(j, n.childLanes);
        if (Zv || Pt) {
          var Ut = KT();
          if (Ut !== null) {
            var Xt = Yp(Ut, j);
            if (Xt !== pi && Xt !== F.retryLane) {
              F.retryLane = Xt;
              var tr = ti;
              $c(n, Xt), lf(Ut, n, Xt, tr);
            }
          }
          tA();
          var Dr = _R(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
          return HT(n, o, j, Dr);
        } else if (D1(C)) {
          o.flags |= Rr, o.child = n.child;
          var Sr = RB.bind(null, n);
          return zb(C, Sr), null;
        } else {
          sR(o, C, F.treeContext);
          var ma = S.children, ta = OR(o, ma);
          return ta.flags |= Il, ta;
        }
      }
    }
    function rP(n, o, m) {
      n.lanes = Qt(n.lanes, o);
      var S = n.alternate;
      S !== null && (S.lanes = Qt(S.lanes, o)), Qg(n.return, o, m);
    }
    function iI(n, o, m) {
      for (var S = o; S !== null; ) {
        if (S.tag === Q) {
          var C = S.memoizedState;
          C !== null && rP(S, m, n);
        } else if (S.tag === ce)
          rP(S, m, n);
        else if (S.child !== null) {
          S.child.return = S, S = S.child;
          continue;
        }
        if (S === n)
          return;
        for (; S.sibling === null; ) {
          if (S.return === null || S.return === n)
            return;
          S = S.return;
        }
        S.sibling.return = S.return, S = S.sibling;
      }
    }
    function aI(n) {
      for (var o = n, m = null; o !== null; ) {
        var S = o.alternate;
        S !== null && ew(S) === null && (m = o), o = o.sibling;
      }
      return m;
    }
    function sI(n) {
      if (n !== void 0 && n !== "forwards" && n !== "backwards" && n !== "together" && !CR[n])
        if (CR[n] = !0, typeof n == "string")
          switch (n.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              l('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', n, n.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              l('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', n, n.toLowerCase());
              break;
            }
            default:
              l('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', n);
              break;
          }
        else
          l('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', n);
    }
    function oI(n, o) {
      n !== void 0 && !BT[n] && (n !== "collapsed" && n !== "hidden" ? (BT[n] = !0, l('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', n)) : o !== "forwards" && o !== "backwards" && (BT[n] = !0, l('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', n)));
    }
    function iP(n, o) {
      {
        var m = Zs(n), S = !m && typeof us(n) == "function";
        if (m || S) {
          var C = m ? "array" : "iterable";
          return l("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", C, o, C), !1;
        }
      }
      return !0;
    }
    function lI(n, o) {
      if ((o === "forwards" || o === "backwards") && n !== void 0 && n !== null && n !== !1)
        if (Zs(n)) {
          for (var m = 0; m < n.length; m++)
            if (!iP(n[m], m))
              return;
        } else {
          var S = us(n);
          if (typeof S == "function") {
            var C = S.call(n);
            if (C)
              for (var F = C.next(), j = 0; !F.done; F = C.next()) {
                if (!iP(F.value, j))
                  return;
                j++;
              }
          } else
            l('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', o);
        }
    }
    function zR(n, o, m, S, C) {
      var F = n.memoizedState;
      F === null ? n.memoizedState = {
        isBackwards: o,
        rendering: null,
        renderingStartTime: 0,
        last: S,
        tail: m,
        tailMode: C
      } : (F.isBackwards = o, F.rendering = null, F.renderingStartTime = 0, F.last = S, F.tail = m, F.tailMode = C);
    }
    function aP(n, o, m) {
      var S = o.pendingProps, C = S.revealOrder, F = S.tail, j = S.children;
      sI(C), oI(F, C), lI(j, C), kh(n, o, j, m);
      var J = Cl.current, ne = $g(J, Z1);
      if (ne)
        J = ey(J, Z1), o.flags |= Rr;
      else {
        var Se = n !== null && (n.flags & Rr) !== vr;
        Se && iI(o, o.child, m), J = Ex(J);
      }
      if (uv(o, J), (o.mode & Gr) === hr)
        o.memoizedState = null;
      else
        switch (C) {
          case "forwards": {
            var Ce = aI(o.child), nt;
            Ce === null ? (nt = o.child, o.child = null) : (nt = Ce.sibling, Ce.sibling = null), zR(
              o,
              !1,
              nt,
              Ce,
              F
            );
            break;
          }
          case "backwards": {
            var et = null, Pt = o.child;
            for (o.child = null; Pt !== null; ) {
              var Ut = Pt.alternate;
              if (Ut !== null && ew(Ut) === null) {
                o.child = Pt;
                break;
              }
              var Xt = Pt.sibling;
              Pt.sibling = et, et = Pt, Pt = Xt;
            }
            zR(
              o,
              !0,
              et,
              null,
              F
            );
            break;
          }
          case "together": {
            zR(
              o,
              !1,
              null,
              null,
              void 0
            );
            break;
          }
          default:
            o.memoizedState = null;
        }
      return o.child;
    }
    function uI(n, o, m) {
      Q1(o, o.stateNode.containerInfo);
      var S = o.pendingProps;
      return n === null ? o.child = xx(o, null, S, m) : kh(n, o, S, m), o.child;
    }
    var sP = !1;
    function cI(n, o, m) {
      var S = o.type, C = S._context, F = o.pendingProps, j = o.memoizedProps, J = F.value;
      {
        "value" in F || sP || (sP = !0, l("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var ne = o.type.propTypes;
        ne && Gs(ne, F, "prop", "Context.Provider");
      }
      if (V1(o, C, J), j !== null) {
        var Se = j.value;
        if (Zn(Se, J)) {
          if (j.children === F.children && !cx())
            return m0(n, o, m);
        } else
          a0(o, C, m);
      }
      var Ce = F.children;
      return kh(n, o, Ce, m), o.child;
    }
    var oP = !1;
    function fI(n, o, m) {
      var S = o.type;
      S._context === void 0 ? S !== S.Consumer && (oP || (oP = !0, l("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : S = S._context;
      var C = o.pendingProps, F = C.children;
      typeof F != "function" && l("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), av(o, m);
      var j = Ml(S);
      Ra(o);
      var J;
      return LE.current = o, hi(!0), J = F(j), hi(!1), Ba(), o.flags |= Vi, kh(n, o, J, m), o.child;
    }
    function OE() {
      Zv = !0;
    }
    function VT(n, o) {
      (o.mode & Gr) === hr && n !== null && (n.alternate = null, o.alternate = null, o.flags |= si);
    }
    function m0(n, o, m) {
      return n !== null && (o.dependencies = n.dependencies), fw(), jE(o.lanes), Ze(m, o.childLanes) ? (dR(n, o), o.child) : null;
    }
    function dI(n, o, m) {
      {
        var S = o.return;
        if (S === null)
          throw new Error("Cannot swap the root fiber.");
        if (n.alternate = null, o.alternate = null, m.index = o.index, m.sibling = o.sibling, m.return = o.return, m.ref = o.ref, o === S.child)
          S.child = m;
        else {
          var C = S.child;
          if (C === null)
            throw new Error("Expected parent to have a child.");
          for (; C.sibling !== o; )
            if (C = C.sibling, C === null)
              throw new Error("Expected to find the previous sibling.");
          C.sibling = m;
        }
        var F = S.deletions;
        return F === null ? (S.deletions = [n], S.flags |= wi) : F.push(n), m.flags |= si, m;
      }
    }
    function NR(n, o) {
      var m = n.lanes;
      return !!Ze(m, o);
    }
    function hI(n, o, m) {
      switch (o.tag) {
        case w:
          $L(o), o.stateNode, Yg();
          break;
        case R:
          $S(o);
          break;
        case g: {
          var S = o.type;
          fm(S) && CS(o);
          break;
        }
        case T:
          Q1(o, o.stateNode.containerInfo);
          break;
        case I: {
          var C = o.memoizedProps.value, F = o.type._context;
          V1(o, F, C);
          break;
        }
        case B:
          {
            var j = Ze(m, o.childLanes);
            j && (o.flags |= Wn);
            {
              var J = o.stateNode;
              J.effectDuration = 0, J.passiveEffectDuration = 0;
            }
          }
          break;
        case Q: {
          var ne = o.memoizedState;
          if (ne !== null) {
            if (ne.dehydrated !== null)
              return uv(o, Ex(Cl.current)), o.flags |= Rr, null;
            var Se = o.child, Ce = Se.childLanes;
            if (Ze(m, Ce))
              return tP(n, o, m);
            uv(o, Ex(Cl.current));
            var nt = m0(n, o, m);
            return nt !== null ? nt.sibling : null;
          } else
            uv(o, Ex(Cl.current));
          break;
        }
        case ce: {
          var et = (n.flags & Rr) !== vr, Pt = Ze(m, o.childLanes);
          if (et) {
            if (Pt)
              return aP(n, o, m);
            o.flags |= Rr;
          }
          var Ut = o.memoizedState;
          if (Ut !== null && (Ut.rendering = null, Ut.tail = null, Ut.lastEffect = null), uv(o, Cl.current), Pt)
            break;
          return null;
        }
        case Me:
        case me:
          return o.lanes = Ht, ZL(n, o, m);
      }
      return m0(n, o, m);
    }
    function lP(n, o, m) {
      if (o._debugNeedsRemount && n !== null)
        return dI(n, o, dA(o.type, o.key, o.pendingProps, o._debugOwner || null, o.mode, o.lanes));
      if (n !== null) {
        var S = n.memoizedProps, C = o.pendingProps;
        if (S !== C || cx() || o.type !== n.type)
          Zv = !0;
        else {
          var F = NR(n, m);
          if (!F && (o.flags & Rr) === vr)
            return Zv = !1, hI(n, o, m);
          (n.flags & tp) !== vr ? Zv = !0 : Zv = !1;
        }
      } else if (Zv = !1, js() && hT(o)) {
        var j = o.index, J = Tp();
        pT(o, J, j);
      }
      switch (o.lanes = Ht, o.tag) {
        case _:
          return q4(n, o, o.type, m);
        case Y: {
          var ne = o.elementType;
          return Y4(n, o, ne, m);
        }
        case p: {
          var Se = o.type, Ce = o.pendingProps, nt = o.elementType === Se ? Ce : Md(Se, Ce);
          return RR(n, o, Se, nt, m);
        }
        case g: {
          var et = o.type, Pt = o.pendingProps, Ut = o.elementType === et ? Pt : Md(et, Pt);
          return KL(n, o, et, Ut, m);
        }
        case w:
          return G4(n, o, m);
        case R:
          return W4(n, o, m);
        case D:
          return j4(n, o);
        case Q:
          return tP(n, o, m);
        case T:
          return uI(n, o, m);
        case G: {
          var Xt = o.type, tr = o.pendingProps, Dr = o.elementType === Xt ? tr : Md(Xt, tr);
          return XL(n, o, Xt, Dr, m);
        }
        case O:
          return B4(n, o, m);
        case U:
          return H4(n, o, m);
        case B:
          return V4(n, o, m);
        case I:
          return cI(n, o, m);
        case H:
          return fI(n, o, m);
        case K: {
          var Sr = o.type, ma = o.pendingProps, ta = Md(Sr, ma);
          if (o.type !== o.elementType) {
            var bt = Sr.propTypes;
            bt && Gs(
              bt,
              ta,
              "prop",
              Ci(Sr)
            );
          }
          return ta = Md(Sr.type, ta), qL(n, o, Sr, ta, m);
        }
        case te:
          return QL(n, o, o.type, o.pendingProps, m);
        case re: {
          var qt = o.type, Et = o.pendingProps, xn = o.elementType === qt ? Et : Md(qt, Et);
          return X4(n, o, qt, xn, m);
        }
        case ce:
          return aP(n, o, m);
        case ue:
          break;
        case Me:
          return ZL(n, o, m);
      }
      throw new Error("Unknown unit of work tag (" + o.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function dw(n) {
      n.flags |= Wn;
    }
    function uP(n) {
      n.flags |= es, n.flags |= du;
    }
    var cP, FR, fP, dP;
    cP = function(n, o, m, S) {
      for (var C = o.child; C !== null; ) {
        if (C.tag === R || C.tag === D)
          Eb(n, C.stateNode);
        else if (C.tag !== T) {
          if (C.child !== null) {
            C.child.return = C, C = C.child;
            continue;
          }
        }
        if (C === o)
          return;
        for (; C.sibling === null; ) {
          if (C.return === null || C.return === o)
            return;
          C = C.return;
        }
        C.sibling.return = C.return, C = C.sibling;
      }
    }, FR = function(n, o) {
    }, fP = function(n, o, m, S, C) {
      var F = n.memoizedProps;
      if (F !== S) {
        var j = o.stateNode, J = u0(), ne = Mb(j, m, F, S, C, J);
        o.updateQueue = ne, ne && dw(o);
      }
    }, dP = function(n, o, m, S) {
      m !== S && dw(o);
    };
    function UE(n, o) {
      if (!js())
        switch (n.tailMode) {
          case "hidden": {
            for (var m = n.tail, S = null; m !== null; )
              m.alternate !== null && (S = m), m = m.sibling;
            S === null ? n.tail = null : S.sibling = null;
            break;
          }
          case "collapsed": {
            for (var C = n.tail, F = null; C !== null; )
              C.alternate !== null && (F = C), C = C.sibling;
            F === null ? !o && n.tail !== null ? n.tail.sibling = null : n.tail = null : F.sibling = null;
            break;
          }
        }
    }
    function Td(n) {
      var o = n.alternate !== null && n.alternate.child === n.child, m = Ht, S = vr;
      if (o) {
        if ((n.mode & fr) !== hr) {
          for (var ne = n.selfBaseDuration, Se = n.child; Se !== null; )
            m = Qt(m, Qt(Se.lanes, Se.childLanes)), S |= Se.subtreeFlags & vn, S |= Se.flags & vn, ne += Se.treeBaseDuration, Se = Se.sibling;
          n.treeBaseDuration = ne;
        } else
          for (var Ce = n.child; Ce !== null; )
            m = Qt(m, Qt(Ce.lanes, Ce.childLanes)), S |= Ce.subtreeFlags & vn, S |= Ce.flags & vn, Ce.return = n, Ce = Ce.sibling;
        n.subtreeFlags |= S;
      } else {
        if ((n.mode & fr) !== hr) {
          for (var C = n.actualDuration, F = n.selfBaseDuration, j = n.child; j !== null; )
            m = Qt(m, Qt(j.lanes, j.childLanes)), S |= j.subtreeFlags, S |= j.flags, C += j.actualDuration, F += j.treeBaseDuration, j = j.sibling;
          n.actualDuration = C, n.treeBaseDuration = F;
        } else
          for (var J = n.child; J !== null; )
            m = Qt(m, Qt(J.lanes, J.childLanes)), S |= J.subtreeFlags, S |= J.flags, J.return = n, J = J.sibling;
        n.subtreeFlags |= S;
      }
      return n.childLanes = m, o;
    }
    function pI(n, o, m) {
      if (mm() && (o.mode & Gr) !== hr && (o.flags & Rr) === vr)
        return eu(o), Yg(), o.flags |= ps | gl | wo, !1;
      var S = oo(o);
      if (m !== null && m.dehydrated !== null)
        if (n === null) {
          if (!S)
            throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
          if (lR(o), Td(o), (o.mode & fr) !== hr) {
            var C = m !== null;
            if (C) {
              var F = o.child;
              F !== null && (o.treeBaseDuration -= F.treeBaseDuration);
            }
          }
          return !1;
        } else {
          if (Yg(), (o.flags & Rr) === vr && (o.memoizedState = null), o.flags |= Wn, Td(o), (o.mode & fr) !== hr) {
            var j = m !== null;
            if (j) {
              var J = o.child;
              J !== null && (o.treeBaseDuration -= J.treeBaseDuration);
            }
          }
          return !1;
        }
      else
        return Jc(), !0;
    }
    function hP(n, o, m) {
      var S = o.pendingProps;
      switch (px(o), o.tag) {
        case _:
        case Y:
        case te:
        case p:
        case G:
        case O:
        case U:
        case B:
        case H:
        case K:
          return Td(o), null;
        case g: {
          var C = o.type;
          return fm(C) && TS(o), Td(o), null;
        }
        case w: {
          var F = o.stateNode;
          if (wx(o), fx(o), J1(), F.pendingContext && (F.context = F.pendingContext, F.pendingContext = null), n === null || n.child === null) {
            var j = oo(o);
            if (j)
              dw(o);
            else if (n !== null) {
              var J = n.memoizedState;
              (!J.isDehydrated || (o.flags & ps) !== vr) && (o.flags |= kl, Jc());
            }
          }
          return FR(n, o), Td(o), null;
        }
        case R: {
          bx(o);
          var ne = hE(), Se = o.type;
          if (n !== null && o.stateNode != null)
            fP(n, o, Se, S, ne), n.ref !== o.ref && uP(o);
          else {
            if (!S) {
              if (o.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return Td(o), null;
            }
            var Ce = u0(), nt = oo(o);
            if (nt)
              oR(o, ne, Ce) && dw(o);
            else {
              var et = dS(Se, S, ne, Ce, o);
              cP(et, o, !1, !1), o.stateNode = et, hS(et, Se, S, ne) && dw(o);
            }
            o.ref !== null && uP(o);
          }
          return Td(o), null;
        }
        case D: {
          var Pt = S;
          if (n && o.stateNode != null) {
            var Ut = n.memoizedProps;
            dP(n, o, Ut, Pt);
          } else {
            if (typeof Pt != "string" && o.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var Xt = hE(), tr = u0(), Dr = oo(o);
            Dr ? yT(o) && dw(o) : o.stateNode = Tb(Pt, Xt, tr, o);
          }
          return Td(o), null;
        }
        case Q: {
          c0(o);
          var Sr = o.memoizedState;
          if (n === null || n.memoizedState !== null && n.memoizedState.dehydrated !== null) {
            var ma = pI(n, o, Sr);
            if (!ma)
              return o.flags & wo ? o : null;
          }
          if ((o.flags & Rr) !== vr)
            return o.lanes = m, (o.mode & fr) !== hr && xR(o), o;
          var ta = Sr !== null, bt = n !== null && n.memoizedState !== null;
          if (ta !== bt && ta) {
            var qt = o.child;
            if (qt.flags |= bf, (o.mode & Gr) !== hr) {
              var Et = n === null && (o.memoizedProps.unstable_avoidThisFallback !== !0 || !ye);
              Et || $g(Cl.current, UT) ? mB() : tA();
            }
          }
          var xn = o.updateQueue;
          if (xn !== null && (o.flags |= Wn), Td(o), (o.mode & fr) !== hr && ta) {
            var nr = o.child;
            nr !== null && (o.treeBaseDuration -= nr.treeBaseDuration);
          }
          return null;
        }
        case T:
          return wx(o), FR(n, o), n === null && Hg(o.stateNode.containerInfo), Td(o), null;
        case I:
          var Xn = o.type._context;
          return G1(Xn, o), Td(o), null;
        case re: {
          var Yr = o.type;
          return fm(Yr) && TS(o), Td(o), null;
        }
        case ce: {
          c0(o);
          var fi = o.memoizedState;
          if (fi === null)
            return Td(o), null;
          var Ds = (o.flags & Rr) !== vr, ja = fi.rendering;
          if (ja === null)
            if (Ds)
              UE(fi, !1);
            else {
              var qu = gB() && (n === null || (n.flags & Rr) === vr);
              if (!qu)
                for (var Ya = o.child; Ya !== null; ) {
                  var bu = ew(Ya);
                  if (bu !== null) {
                    Ds = !0, o.flags |= Rr, UE(fi, !1);
                    var sh = bu.updateQueue;
                    return sh !== null && (o.updateQueue = sh, o.flags |= Wn), o.subtreeFlags = vr, PT(o, m), uv(o, ey(Cl.current, Z1)), o.child;
                  }
                  Ya = Ya.sibling;
                }
              fi.tail !== null && fa() > UP() && (o.flags |= Rr, Ds = !0, UE(fi, !1), o.lanes = hd);
            }
          else {
            if (!Ds) {
              var Ld = ew(ja);
              if (Ld !== null) {
                o.flags |= Rr, Ds = !0;
                var xm = Ld.updateQueue;
                if (xm !== null && (o.updateQueue = xm, o.flags |= Wn), UE(fi, !0), fi.tail === null && fi.tailMode === "hidden" && !ja.alternate && !js())
                  return Td(o), null;
              } else
                fa() * 2 - fi.renderingStartTime > UP() && m !== yu && (o.flags |= Rr, Ds = !0, UE(fi, !1), o.lanes = hd);
            }
            if (fi.isBackwards)
              ja.sibling = o.child, o.child = ja;
            else {
              var Hh = fi.last;
              Hh !== null ? Hh.sibling = ja : o.child = ja, fi.last = ja;
            }
          }
          if (fi.tail !== null) {
            var Vh = fi.tail;
            fi.rendering = Vh, fi.tail = Vh.sibling, fi.renderingStartTime = fa(), Vh.sibling = null;
            var oh = Cl.current;
            return Ds ? oh = ey(oh, Z1) : oh = Ex(oh), uv(o, oh), Vh;
          }
          return Td(o), null;
        }
        case ue:
          break;
        case Me:
        case me: {
          eA(o);
          var _0 = o.memoizedState, _w = _0 !== null;
          if (n !== null) {
            var ZE = n.memoizedState, ay = ZE !== null;
            ay !== _w && !he && (o.flags |= bf);
          }
          return !_w || (o.mode & Gr) === hr ? Td(o) : Ze(iy, yu) && (Td(o), o.subtreeFlags & (si | Wn) && (o.flags |= bf)), null;
        }
        case De:
          return null;
        case Re:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + o.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function mI(n, o, m) {
      switch (px(o), o.tag) {
        case g: {
          var S = o.type;
          fm(S) && TS(o);
          var C = o.flags;
          return C & wo ? (o.flags = C & ~wo | Rr, (o.mode & fr) !== hr && xR(o), o) : null;
        }
        case w: {
          o.stateNode, wx(o), fx(o), J1();
          var F = o.flags;
          return (F & wo) !== vr && (F & Rr) === vr ? (o.flags = F & ~wo | Rr, o) : null;
        }
        case R:
          return bx(o), null;
        case Q: {
          c0(o);
          var j = o.memoizedState;
          if (j !== null && j.dehydrated !== null) {
            if (o.alternate === null)
              throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            Yg();
          }
          var J = o.flags;
          return J & wo ? (o.flags = J & ~wo | Rr, (o.mode & fr) !== hr && xR(o), o) : null;
        }
        case ce:
          return c0(o), null;
        case T:
          return wx(o), null;
        case I:
          var ne = o.type._context;
          return G1(ne, o), null;
        case Me:
        case me:
          return eA(o), null;
        case De:
          return null;
        default:
          return null;
      }
    }
    function pP(n, o, m) {
      switch (px(o), o.tag) {
        case g: {
          var S = o.type.childContextTypes;
          S != null && TS(o);
          break;
        }
        case w: {
          o.stateNode, wx(o), fx(o), J1();
          break;
        }
        case R: {
          bx(o);
          break;
        }
        case T:
          wx(o);
          break;
        case Q:
          c0(o);
          break;
        case ce:
          c0(o);
          break;
        case I:
          var C = o.type._context;
          G1(C, o);
          break;
        case Me:
        case me:
          eA(o);
          break;
      }
    }
    var mP = null;
    mP = /* @__PURE__ */ new Set();
    var GT = !1, Cd = !1, vI = typeof WeakSet == "function" ? WeakSet : Set, cr = null, hw = null, pw = null;
    function gI(n) {
      Uu(null, function() {
        throw n;
      }), oc();
    }
    var yI = function(n, o) {
      if (o.props = n.memoizedProps, o.state = n.memoizedState, n.mode & fr)
        try {
          ny(), o.componentWillUnmount();
        } finally {
          pv(n);
        }
      else
        o.componentWillUnmount();
    };
    function vP(n, o) {
      try {
        Px(ru, n);
      } catch (m) {
        Do(n, o, m);
      }
    }
    function kR(n, o, m) {
      try {
        yI(n, m);
      } catch (S) {
        Do(n, o, S);
      }
    }
    function xI(n, o, m) {
      try {
        m.componentDidMount();
      } catch (S) {
        Do(n, o, S);
      }
    }
    function gP(n, o) {
      try {
        xP(n);
      } catch (m) {
        Do(n, o, m);
      }
    }
    function mw(n, o) {
      var m = n.ref;
      if (m !== null)
        if (typeof m == "function") {
          var S;
          try {
            if (Ne && ct && n.mode & fr)
              try {
                ny(), S = m(null);
              } finally {
                pv(n);
              }
            else
              S = m(null);
          } catch (C) {
            Do(n, o, C);
          }
          typeof S == "function" && l("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", xr(n));
        } else
          m.current = null;
    }
    function WT(n, o, m) {
      try {
        m();
      } catch (S) {
        Do(n, o, S);
      }
    }
    var yP = !1;
    function _I(n, o) {
      fS(n.containerInfo), cr = o, SI();
      var m = yP;
      return yP = !1, m;
    }
    function SI() {
      for (; cr !== null; ) {
        var n = cr, o = n.child;
        (n.subtreeFlags & Ur) !== vr && o !== null ? (o.return = n, cr = o) : wI();
      }
    }
    function wI() {
      for (; cr !== null; ) {
        var n = cr;
        Xi(n);
        try {
          bI(n);
        } catch (m) {
          Do(n, n.return, m);
        }
        Ka();
        var o = n.sibling;
        if (o !== null) {
          o.return = n.return, cr = o;
          return;
        }
        cr = n.return;
      }
    }
    function bI(n) {
      var o = n.alternate, m = n.flags;
      if ((m & kl) !== vr) {
        switch (Xi(n), n.tag) {
          case p:
          case G:
          case te:
            break;
          case g: {
            if (o !== null) {
              var S = o.memoizedProps, C = o.memoizedState, F = n.stateNode;
              n.type === n.elementType && !l_ && (F.props !== n.memoizedProps && l("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", xr(n) || "instance"), F.state !== n.memoizedState && l("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", xr(n) || "instance"));
              var j = F.getSnapshotBeforeUpdate(n.elementType === n.type ? S : Md(n.type, S), C);
              {
                var J = mP;
                j === void 0 && !J.has(n.type) && (J.add(n.type), l("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", xr(n)));
              }
              F.__reactInternalSnapshotBeforeUpdate = j;
            }
            break;
          }
          case w: {
            {
              var ne = n.stateNode;
              Ob(ne.containerInfo);
            }
            break;
          }
          case R:
          case D:
          case T:
          case re:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        Ka();
      }
    }
    function Jv(n, o, m) {
      var S = o.updateQueue, C = S !== null ? S.lastEffect : null;
      if (C !== null) {
        var F = C.next, j = F;
        do {
          if ((j.tag & n) === n) {
            var J = j.destroy;
            j.destroy = void 0, J !== void 0 && ((n & tf) !== nh ? ud(o) : (n & ru) !== nh && cc(o), (n & cv) !== nh && XE(!0), WT(o, m, J), (n & cv) !== nh && XE(!1), (n & tf) !== nh ? Es() : (n & ru) !== nh && Qd());
          }
          j = j.next;
        } while (j !== F);
      }
    }
    function Px(n, o) {
      var m = o.updateQueue, S = m !== null ? m.lastEffect : null;
      if (S !== null) {
        var C = S.next, F = C;
        do {
          if ((F.tag & n) === n) {
            (n & tf) !== nh ? li(o) : (n & ru) !== nh && qd(o);
            var j = F.create;
            (n & cv) !== nh && XE(!0), F.destroy = j(), (n & cv) !== nh && XE(!1), (n & tf) !== nh ? Gl() : (n & ru) !== nh && Nc();
            {
              var J = F.destroy;
              if (J !== void 0 && typeof J != "function") {
                var ne = void 0;
                (F.tag & ru) !== vr ? ne = "useLayoutEffect" : (F.tag & cv) !== vr ? ne = "useInsertionEffect" : ne = "useEffect";
                var Se = void 0;
                J === null ? Se = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof J.then == "function" ? Se = `

It looks like you wrote ` + ne + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + ne + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : Se = " You returned: " + J, l("%s must not return anything besides a function, which is used for clean-up.%s", ne, Se);
              }
            }
          }
          F = F.next;
        } while (F !== C);
      }
    }
    function EI(n, o) {
      if ((o.flags & Wn) !== vr)
        switch (o.tag) {
          case B: {
            var m = o.stateNode.passiveEffectDuration, S = o.memoizedProps, C = S.id, F = S.onPostCommit, j = p0(), J = o.alternate === null ? "mount" : "update";
            ih() && (J = "nested-update"), typeof F == "function" && F(C, J, m, j);
            var ne = o.return;
            e:
              for (; ne !== null; ) {
                switch (ne.tag) {
                  case w:
                    var Se = ne.stateNode;
                    Se.passiveEffectDuration += m;
                    break e;
                  case B:
                    var Ce = ne.stateNode;
                    Ce.passiveEffectDuration += m;
                    break e;
                }
                ne = ne.return;
              }
            break;
          }
        }
    }
    function MI(n, o, m, S) {
      if ((m.flags & ms) !== vr)
        switch (m.tag) {
          case p:
          case G:
          case te: {
            if (!Cd)
              if (m.mode & fr)
                try {
                  ny(), Px(ru | nu, m);
                } finally {
                  pv(m);
                }
              else
                Px(ru | nu, m);
            break;
          }
          case g: {
            var C = m.stateNode;
            if (m.flags & Wn && !Cd)
              if (o === null)
                if (m.type === m.elementType && !l_ && (C.props !== m.memoizedProps && l("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", xr(m) || "instance"), C.state !== m.memoizedState && l("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", xr(m) || "instance")), m.mode & fr)
                  try {
                    ny(), C.componentDidMount();
                  } finally {
                    pv(m);
                  }
                else
                  C.componentDidMount();
              else {
                var F = m.elementType === m.type ? o.memoizedProps : Md(m.type, o.memoizedProps), j = o.memoizedState;
                if (m.type === m.elementType && !l_ && (C.props !== m.memoizedProps && l("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", xr(m) || "instance"), C.state !== m.memoizedState && l("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", xr(m) || "instance")), m.mode & fr)
                  try {
                    ny(), C.componentDidUpdate(F, j, C.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    pv(m);
                  }
                else
                  C.componentDidUpdate(F, j, C.__reactInternalSnapshotBeforeUpdate);
              }
            var J = m.updateQueue;
            J !== null && (m.type === m.elementType && !l_ && (C.props !== m.memoizedProps && l("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", xr(m) || "instance"), C.state !== m.memoizedState && l("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", xr(m) || "instance")), j1(m, J, C));
            break;
          }
          case w: {
            var ne = m.updateQueue;
            if (ne !== null) {
              var Se = null;
              if (m.child !== null)
                switch (m.child.tag) {
                  case R:
                    Se = m.child.stateNode;
                    break;
                  case g:
                    Se = m.child.stateNode;
                    break;
                }
              j1(m, ne, Se);
            }
            break;
          }
          case R: {
            var Ce = m.stateNode;
            if (o === null && m.flags & Wn) {
              var nt = m.type, et = m.memoizedProps;
              mS(Ce, nt, et);
            }
            break;
          }
          case D:
            break;
          case T:
            break;
          case B: {
            {
              var Pt = m.memoizedProps, Ut = Pt.onCommit, Xt = Pt.onRender, tr = m.stateNode.effectDuration, Dr = p0(), Sr = o === null ? "mount" : "update";
              ih() && (Sr = "nested-update"), typeof Xt == "function" && Xt(m.memoizedProps.id, Sr, m.actualDuration, m.treeBaseDuration, m.actualStartTime, Dr);
              {
                typeof Ut == "function" && Ut(m.memoizedProps.id, Sr, tr, Dr), wB(m);
                var ma = m.return;
                e:
                  for (; ma !== null; ) {
                    switch (ma.tag) {
                      case w:
                        var ta = ma.stateNode;
                        ta.effectDuration += tr;
                        break e;
                      case B:
                        var bt = ma.stateNode;
                        bt.effectDuration += tr;
                        break e;
                    }
                    ma = ma.return;
                  }
              }
            }
            break;
          }
          case Q: {
            OI(n, m);
            break;
          }
          case ce:
          case re:
          case ue:
          case Me:
          case me:
          case Re:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      Cd || m.flags & es && xP(m);
    }
    function TI(n) {
      switch (n.tag) {
        case p:
        case G:
        case te: {
          if (n.mode & fr)
            try {
              ny(), vP(n, n.return);
            } finally {
              pv(n);
            }
          else
            vP(n, n.return);
          break;
        }
        case g: {
          var o = n.stateNode;
          typeof o.componentDidMount == "function" && xI(n, n.return, o), gP(n, n.return);
          break;
        }
        case R: {
          gP(n, n.return);
          break;
        }
      }
    }
    function CI(n, o) {
      for (var m = null, S = n; ; ) {
        if (S.tag === R) {
          if (m === null) {
            m = S;
            try {
              var C = S.stateNode;
              o ? ix(C) : Lb(S.stateNode, S.memoizedProps);
            } catch (j) {
              Do(n, n.return, j);
            }
          }
        } else if (S.tag === D) {
          if (m === null)
            try {
              var F = S.stateNode;
              o ? Db(F) : Pb(F, S.memoizedProps);
            } catch (j) {
              Do(n, n.return, j);
            }
        } else if (!((S.tag === Me || S.tag === me) && S.memoizedState !== null && S !== n)) {
          if (S.child !== null) {
            S.child.return = S, S = S.child;
            continue;
          }
        }
        if (S === n)
          return;
        for (; S.sibling === null; ) {
          if (S.return === null || S.return === n)
            return;
          m === S && (m = null), S = S.return;
        }
        m === S && (m = null), S.sibling.return = S.return, S = S.sibling;
      }
    }
    function xP(n) {
      var o = n.ref;
      if (o !== null) {
        var m = n.stateNode, S;
        switch (n.tag) {
          case R:
            S = m;
            break;
          default:
            S = m;
        }
        if (typeof o == "function") {
          var C;
          if (n.mode & fr)
            try {
              ny(), C = o(S);
            } finally {
              pv(n);
            }
          else
            C = o(S);
          typeof C == "function" && l("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", xr(n));
        } else
          o.hasOwnProperty("current") || l("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", xr(n)), o.current = S;
      }
    }
    function RI(n) {
      var o = n.alternate;
      o !== null && (o.return = null), n.return = null;
    }
    function _P(n) {
      var o = n.alternate;
      o !== null && (n.alternate = null, _P(o));
      {
        if (n.child = null, n.deletions = null, n.sibling = null, n.tag === R) {
          var m = n.stateNode;
          m !== null && ke(m);
        }
        n.stateNode = null, n._debugOwner = null, n.return = null, n.dependencies = null, n.memoizedProps = null, n.memoizedState = null, n.pendingProps = null, n.stateNode = null, n.updateQueue = null;
      }
    }
    function AI(n) {
      for (var o = n.return; o !== null; ) {
        if (SP(o))
          return o;
        o = o.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function SP(n) {
      return n.tag === R || n.tag === w || n.tag === T;
    }
    function wP(n) {
      var o = n;
      e:
        for (; ; ) {
          for (; o.sibling === null; ) {
            if (o.return === null || SP(o.return))
              return null;
            o = o.return;
          }
          for (o.sibling.return = o.return, o = o.sibling; o.tag !== R && o.tag !== D && o.tag !== se; ) {
            if (o.flags & si || o.child === null || o.tag === T)
              continue e;
            o.child.return = o, o = o.child;
          }
          if (!(o.flags & si))
            return o.stateNode;
        }
    }
    function DI(n) {
      var o = AI(n);
      switch (o.tag) {
        case R: {
          var m = o.stateNode;
          o.flags & zi && (Yy(m), o.flags &= ~zi);
          var S = wP(n);
          BR(n, S, m);
          break;
        }
        case w:
        case T: {
          var C = o.stateNode.containerInfo, F = wP(n);
          IR(n, F, C);
          break;
        }
        default:
          throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function IR(n, o, m) {
      var S = n.tag, C = S === R || S === D;
      if (C) {
        var F = n.stateNode;
        o ? nx(m, F, o) : gS(m, F);
      } else if (S !== T) {
        var j = n.child;
        if (j !== null) {
          IR(j, o, m);
          for (var J = j.sibling; J !== null; )
            IR(J, o, m), J = J.sibling;
        }
      }
    }
    function BR(n, o, m) {
      var S = n.tag, C = S === R || S === D;
      if (C) {
        var F = n.stateNode;
        o ? yS(m, F, o) : R1(m, F);
      } else if (S !== T) {
        var j = n.child;
        if (j !== null) {
          BR(j, o, m);
          for (var J = j.sibling; J !== null; )
            BR(J, o, m), J = J.sibling;
        }
      }
    }
    var Rd = null, Kv = !1;
    function LI(n, o, m) {
      {
        var S = o;
        e:
          for (; S !== null; ) {
            switch (S.tag) {
              case R: {
                Rd = S.stateNode, Kv = !1;
                break e;
              }
              case w: {
                Rd = S.stateNode.containerInfo, Kv = !0;
                break e;
              }
              case T: {
                Rd = S.stateNode.containerInfo, Kv = !0;
                break e;
              }
            }
            S = S.return;
          }
        if (Rd === null)
          throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        bP(n, o, m), Rd = null, Kv = !1;
      }
      RI(m);
    }
    function Ox(n, o, m) {
      for (var S = m.child; S !== null; )
        bP(n, o, S), S = S.sibling;
    }
    function bP(n, o, m) {
      switch (An(m), m.tag) {
        case R:
          Cd || mw(m, o);
        case D: {
          {
            var S = Rd, C = Kv;
            Rd = null, Ox(n, o, m), Rd = S, Kv = C, Rd !== null && (Kv ? Ab(Rd, m.stateNode) : rx(Rd, m.stateNode));
          }
          return;
        }
        case se: {
          Rd !== null && (Kv ? Vf(Rd, m.stateNode) : A1(Rd, m.stateNode));
          return;
        }
        case T: {
          {
            var F = Rd, j = Kv;
            Rd = m.stateNode.containerInfo, Kv = !0, Ox(n, o, m), Rd = F, Kv = j;
          }
          return;
        }
        case p:
        case G:
        case K:
        case te: {
          if (!Cd) {
            var J = m.updateQueue;
            if (J !== null) {
              var ne = J.lastEffect;
              if (ne !== null) {
                var Se = ne.next, Ce = Se;
                do {
                  var nt = Ce, et = nt.destroy, Pt = nt.tag;
                  et !== void 0 && ((Pt & cv) !== nh ? WT(m, o, et) : (Pt & ru) !== nh && (cc(m), m.mode & fr ? (ny(), WT(m, o, et), pv(m)) : WT(m, o, et), Qd())), Ce = Ce.next;
                } while (Ce !== Se);
              }
            }
          }
          Ox(n, o, m);
          return;
        }
        case g: {
          if (!Cd) {
            mw(m, o);
            var Ut = m.stateNode;
            typeof Ut.componentWillUnmount == "function" && kR(m, o, Ut);
          }
          Ox(n, o, m);
          return;
        }
        case ue: {
          Ox(n, o, m);
          return;
        }
        case Me: {
          if (m.mode & Gr) {
            var Xt = Cd;
            Cd = Xt || m.memoizedState !== null, Ox(n, o, m), Cd = Xt;
          } else
            Ox(n, o, m);
          break;
        }
        default: {
          Ox(n, o, m);
          return;
        }
      }
    }
    function PI(n) {
      n.memoizedState;
    }
    function OI(n, o) {
      var m = o.memoizedState;
      if (m === null) {
        var S = o.alternate;
        if (S !== null) {
          var C = S.memoizedState;
          if (C !== null) {
            var F = C.dehydrated;
            F !== null && wS(F);
          }
        }
      }
    }
    function EP(n) {
      var o = n.updateQueue;
      if (o !== null) {
        n.updateQueue = null;
        var m = n.stateNode;
        m === null && (m = n.stateNode = new vI()), o.forEach(function(S) {
          var C = AB.bind(null, n, S);
          if (!m.has(S)) {
            if (m.add(S), ya)
              if (hw !== null && pw !== null)
                YE(pw, hw);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            S.then(C, C);
          }
        });
      }
    }
    function UI(n, o, m) {
      hw = m, pw = n, Xi(o), MP(o, n), Xi(o), hw = null, pw = null;
    }
    function $v(n, o, m) {
      var S = o.deletions;
      if (S !== null)
        for (var C = 0; C < S.length; C++) {
          var F = S[C];
          try {
            LI(n, o, F);
          } catch (ne) {
            Do(F, o, ne);
          }
        }
      var j = Lm();
      if (o.subtreeFlags & $s)
        for (var J = o.child; J !== null; )
          Xi(J), MP(J, n), J = J.sibling;
      Xi(j);
    }
    function MP(n, o, m) {
      var S = n.alternate, C = n.flags;
      switch (n.tag) {
        case p:
        case G:
        case K:
        case te: {
          if ($v(o, n), ry(n), C & Wn) {
            try {
              Jv(cv | nu, n, n.return), Px(cv | nu, n);
            } catch (Yr) {
              Do(n, n.return, Yr);
            }
            if (n.mode & fr) {
              try {
                ny(), Jv(ru | nu, n, n.return);
              } catch (Yr) {
                Do(n, n.return, Yr);
              }
              pv(n);
            } else
              try {
                Jv(ru | nu, n, n.return);
              } catch (Yr) {
                Do(n, n.return, Yr);
              }
          }
          return;
        }
        case g: {
          $v(o, n), ry(n), C & es && S !== null && mw(S, S.return);
          return;
        }
        case R: {
          $v(o, n), ry(n), C & es && S !== null && mw(S, S.return);
          {
            if (n.flags & zi) {
              var F = n.stateNode;
              try {
                Yy(F);
              } catch (Yr) {
                Do(n, n.return, Yr);
              }
            }
            if (C & Wn) {
              var j = n.stateNode;
              if (j != null) {
                var J = n.memoizedProps, ne = S !== null ? S.memoizedProps : J, Se = n.type, Ce = n.updateQueue;
                if (n.updateQueue = null, Ce !== null)
                  try {
                    tx(j, Ce, Se, ne, J, n);
                  } catch (Yr) {
                    Do(n, n.return, Yr);
                  }
              }
            }
          }
          return;
        }
        case D: {
          if ($v(o, n), ry(n), C & Wn) {
            if (n.stateNode === null)
              throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            var nt = n.stateNode, et = n.memoizedProps, Pt = S !== null ? S.memoizedProps : et;
            try {
              vS(nt, Pt, et);
            } catch (Yr) {
              Do(n, n.return, Yr);
            }
          }
          return;
        }
        case w: {
          if ($v(o, n), ry(n), C & Wn && S !== null) {
            var Ut = S.memoizedState;
            if (Ut.isDehydrated)
              try {
                SS(o.containerInfo);
              } catch (Yr) {
                Do(n, n.return, Yr);
              }
          }
          return;
        }
        case T: {
          $v(o, n), ry(n);
          return;
        }
        case Q: {
          $v(o, n), ry(n);
          var Xt = n.child;
          if (Xt.flags & bf) {
            var tr = Xt.stateNode, Dr = Xt.memoizedState, Sr = Dr !== null;
            if (tr.isHidden = Sr, Sr) {
              var ma = Xt.alternate !== null && Xt.alternate.memoizedState !== null;
              ma || pB();
            }
          }
          if (C & Wn) {
            try {
              PI(n);
            } catch (Yr) {
              Do(n, n.return, Yr);
            }
            EP(n);
          }
          return;
        }
        case Me: {
          var ta = S !== null && S.memoizedState !== null;
          if (n.mode & Gr) {
            var bt = Cd;
            Cd = bt || ta, $v(o, n), Cd = bt;
          } else
            $v(o, n);
          if (ry(n), C & bf) {
            var qt = n.stateNode, Et = n.memoizedState, xn = Et !== null, nr = n;
            if (qt.isHidden = xn, xn && !ta && (nr.mode & Gr) !== hr) {
              cr = nr;
              for (var Xn = nr.child; Xn !== null; )
                cr = Xn, NI(Xn), Xn = Xn.sibling;
            }
            CI(nr, xn);
          }
          return;
        }
        case ce: {
          $v(o, n), ry(n), C & Wn && EP(n);
          return;
        }
        case ue:
          return;
        default: {
          $v(o, n), ry(n);
          return;
        }
      }
    }
    function ry(n) {
      var o = n.flags;
      if (o & si) {
        try {
          DI(n);
        } catch (m) {
          Do(n, n.return, m);
        }
        n.flags &= ~si;
      }
      o & Il && (n.flags &= ~Il);
    }
    function zI(n, o, m) {
      hw = m, pw = o, cr = n, TP(n, o, m), hw = null, pw = null;
    }
    function TP(n, o, m) {
      for (var S = (n.mode & Gr) !== hr; cr !== null; ) {
        var C = cr, F = C.child;
        if (C.tag === Me && S) {
          var j = C.memoizedState !== null, J = j || GT;
          if (J) {
            HR(n, o, m);
            continue;
          } else {
            var ne = C.alternate, Se = ne !== null && ne.memoizedState !== null, Ce = Se || Cd, nt = GT, et = Cd;
            GT = J, Cd = Ce, Cd && !et && (cr = C, FI(C));
            for (var Pt = F; Pt !== null; )
              cr = Pt, TP(
                Pt,
                o,
                m
              ), Pt = Pt.sibling;
            cr = C, GT = nt, Cd = et, HR(n, o, m);
            continue;
          }
        }
        (C.subtreeFlags & ms) !== vr && F !== null ? (F.return = C, cr = F) : HR(n, o, m);
      }
    }
    function HR(n, o, m) {
      for (; cr !== null; ) {
        var S = cr;
        if ((S.flags & ms) !== vr) {
          var C = S.alternate;
          Xi(S);
          try {
            MI(o, C, S, m);
          } catch (j) {
            Do(S, S.return, j);
          }
          Ka();
        }
        if (S === n) {
          cr = null;
          return;
        }
        var F = S.sibling;
        if (F !== null) {
          F.return = S.return, cr = F;
          return;
        }
        cr = S.return;
      }
    }
    function NI(n) {
      for (; cr !== null; ) {
        var o = cr, m = o.child;
        switch (o.tag) {
          case p:
          case G:
          case K:
          case te: {
            if (o.mode & fr)
              try {
                ny(), Jv(ru, o, o.return);
              } finally {
                pv(o);
              }
            else
              Jv(ru, o, o.return);
            break;
          }
          case g: {
            mw(o, o.return);
            var S = o.stateNode;
            typeof S.componentWillUnmount == "function" && kR(o, o.return, S);
            break;
          }
          case R: {
            mw(o, o.return);
            break;
          }
          case Me: {
            var C = o.memoizedState !== null;
            if (C) {
              CP(n);
              continue;
            }
            break;
          }
        }
        m !== null ? (m.return = o, cr = m) : CP(n);
      }
    }
    function CP(n) {
      for (; cr !== null; ) {
        var o = cr;
        if (o === n) {
          cr = null;
          return;
        }
        var m = o.sibling;
        if (m !== null) {
          m.return = o.return, cr = m;
          return;
        }
        cr = o.return;
      }
    }
    function FI(n) {
      for (; cr !== null; ) {
        var o = cr, m = o.child;
        if (o.tag === Me) {
          var S = o.memoizedState !== null;
          if (S) {
            RP(n);
            continue;
          }
        }
        m !== null ? (m.return = o, cr = m) : RP(n);
      }
    }
    function RP(n) {
      for (; cr !== null; ) {
        var o = cr;
        Xi(o);
        try {
          TI(o);
        } catch (S) {
          Do(o, o.return, S);
        }
        if (Ka(), o === n) {
          cr = null;
          return;
        }
        var m = o.sibling;
        if (m !== null) {
          m.return = o.return, cr = m;
          return;
        }
        cr = o.return;
      }
    }
    function kI(n, o, m, S) {
      cr = o, II(o, n, m, S);
    }
    function II(n, o, m, S) {
      for (; cr !== null; ) {
        var C = cr, F = C.child;
        (C.subtreeFlags & zc) !== vr && F !== null ? (F.return = C, cr = F) : BI(n, o, m, S);
      }
    }
    function BI(n, o, m, S) {
      for (; cr !== null; ) {
        var C = cr;
        if ((C.flags & Ia) !== vr) {
          Xi(C);
          try {
            HI(o, C, m, S);
          } catch (j) {
            Do(C, C.return, j);
          }
          Ka();
        }
        if (C === n) {
          cr = null;
          return;
        }
        var F = C.sibling;
        if (F !== null) {
          F.return = C.return, cr = F;
          return;
        }
        cr = C.return;
      }
    }
    function HI(n, o, m, S) {
      switch (o.tag) {
        case p:
        case G:
        case te: {
          if (o.mode & fr) {
            yR();
            try {
              Px(tf | nu, o);
            } finally {
              DE(o);
            }
          } else
            Px(tf | nu, o);
          break;
        }
      }
    }
    function VI(n) {
      cr = n, GI();
    }
    function GI() {
      for (; cr !== null; ) {
        var n = cr, o = n.child;
        if ((cr.flags & wi) !== vr) {
          var m = n.deletions;
          if (m !== null) {
            for (var S = 0; S < m.length; S++) {
              var C = m[S];
              cr = C, YI(C, n);
            }
            {
              var F = n.alternate;
              if (F !== null) {
                var j = F.child;
                if (j !== null) {
                  F.child = null;
                  do {
                    var J = j.sibling;
                    j.sibling = null, j = J;
                  } while (j !== null);
                }
              }
            }
            cr = n;
          }
        }
        (n.subtreeFlags & zc) !== vr && o !== null ? (o.return = n, cr = o) : WI();
      }
    }
    function WI() {
      for (; cr !== null; ) {
        var n = cr;
        (n.flags & Ia) !== vr && (Xi(n), jI(n), Ka());
        var o = n.sibling;
        if (o !== null) {
          o.return = n.return, cr = o;
          return;
        }
        cr = n.return;
      }
    }
    function jI(n) {
      switch (n.tag) {
        case p:
        case G:
        case te: {
          n.mode & fr ? (yR(), Jv(tf | nu, n, n.return), DE(n)) : Jv(tf | nu, n, n.return);
          break;
        }
      }
    }
    function YI(n, o) {
      for (; cr !== null; ) {
        var m = cr;
        Xi(m), qI(m, o), Ka();
        var S = m.child;
        S !== null ? (S.return = m, cr = S) : XI(n);
      }
    }
    function XI(n) {
      for (; cr !== null; ) {
        var o = cr, m = o.sibling, S = o.return;
        if (_P(o), o === n) {
          cr = null;
          return;
        }
        if (m !== null) {
          m.return = S, cr = m;
          return;
        }
        cr = S;
      }
    }
    function qI(n, o) {
      switch (n.tag) {
        case p:
        case G:
        case te: {
          n.mode & fr ? (yR(), Jv(tf, n, o), DE(n)) : Jv(tf, n, o);
          break;
        }
      }
    }
    function QI(n) {
      switch (n.tag) {
        case p:
        case G:
        case te: {
          try {
            Px(ru | nu, n);
          } catch (m) {
            Do(n, n.return, m);
          }
          break;
        }
        case g: {
          var o = n.stateNode;
          try {
            o.componentDidMount();
          } catch (m) {
            Do(n, n.return, m);
          }
          break;
        }
      }
    }
    function ZI(n) {
      switch (n.tag) {
        case p:
        case G:
        case te: {
          try {
            Px(tf | nu, n);
          } catch (o) {
            Do(n, n.return, o);
          }
          break;
        }
      }
    }
    function JI(n) {
      switch (n.tag) {
        case p:
        case G:
        case te: {
          try {
            Jv(ru | nu, n, n.return);
          } catch (m) {
            Do(n, n.return, m);
          }
          break;
        }
        case g: {
          var o = n.stateNode;
          typeof o.componentWillUnmount == "function" && kR(n, n.return, o);
          break;
        }
      }
    }
    function KI(n) {
      switch (n.tag) {
        case p:
        case G:
        case te:
          try {
            Jv(tf | nu, n, n.return);
          } catch (o) {
            Do(n, n.return, o);
          }
      }
    }
    if (typeof Symbol == "function" && Symbol.for) {
      var zE = Symbol.for;
      zE("selector.component"), zE("selector.has_pseudo_class"), zE("selector.role"), zE("selector.test_id"), zE("selector.text");
    }
    var $I = [];
    function eB() {
      $I.forEach(function(n) {
        return n();
      });
    }
    var tB = t.ReactCurrentActQueue;
    function nB(n) {
      {
        var o = typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0, m = typeof jest < "u";
        return m && o !== !1;
      }
    }
    function AP() {
      {
        var n = typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0;
        return !n && tB.current !== null && l("The current testing environment is not configured to support act(...)"), n;
      }
    }
    var rB = Math.ceil, VR = t.ReactCurrentDispatcher, GR = t.ReactCurrentOwner, Ad = t.ReactCurrentBatchConfig, eg = t.ReactCurrentActQueue, af = 0, DP = 1, Dd = 2, mv = 4, v0 = 0, NE = 1, u_ = 2, jT = 3, FE = 4, LP = 5, WR = 6, pa = af, Ih = null, iu = null, sf = Ht, iy = Ht, jR = Wu(Ht), of = v0, kE = null, YT = Ht, IE = Ht, XT = Ht, BE = null, Dp = null, YR = 0, PP = 500, OP = 1 / 0, iB = 500, g0 = null;
    function HE() {
      OP = fa() + iB;
    }
    function UP() {
      return OP;
    }
    var qT = !1, XR = null, vw = null, c_ = !1, Ux = null, VE = Ht, qR = [], QR = null, aB = 50, GE = 0, ZR = null, JR = !1, QT = !1, sB = 50, gw = 0, ZT = null, WE = ti, JT = Ht, zP = !1;
    function KT() {
      return Ih;
    }
    function Bh() {
      return (pa & (Dd | mv)) !== af ? fa() : (WE !== ti || (WE = fa()), WE);
    }
    function zx(n) {
      var o = n.mode;
      if ((o & Gr) === hr)
        return lr;
      if ((pa & Dd) !== af && sf !== Ht)
        return Li(sf);
      var m = NS() !== t0;
      if (m) {
        if (Ad.transition !== null) {
          var S = Ad.transition;
          S._updatedFibers || (S._updatedFibers = /* @__PURE__ */ new Set()), S._updatedFibers.add(n);
        }
        return JT === pi && (JT = ur()), JT;
      }
      var C = pc();
      if (C !== pi)
        return C;
      var F = Cb();
      return F;
    }
    function oB(n) {
      var o = n.mode;
      return (o & Gr) === hr ? lr : Sa();
    }
    function lf(n, o, m, S) {
      LB(), zP && l("useInsertionEffect must not schedule updates."), JR && (QT = !0), Zr(n, m, S), (pa & Dd) !== Ht && n === Ih ? UB(o) : (ya && Hm(n, o, m), zB(o), n === Ih && ((pa & Dd) === af && (IE = Qt(IE, m)), of === FE && Nx(n, sf)), Lp(n, S), m === lr && pa === af && (o.mode & Gr) === hr && !eg.isBatchingLegacy && (HE(), dT()));
    }
    function lB(n, o, m) {
      var S = n.current;
      S.lanes = o, Zr(n, o, m), Lp(n, m);
    }
    function uB(n) {
      return (pa & Dd) !== af;
    }
    function Lp(n, o) {
      var m = n.callbackNode;
      x(n, o);
      var S = Uf(n, n === Ih ? sf : Ht);
      if (S === Ht) {
        m !== null && JP(m), n.callbackNode = null, n.callbackPriority = pi;
        return;
      }
      var C = Tn(S), F = n.callbackPriority;
      if (F === C && !(eg.current !== null && m !== iA)) {
        m == null && F !== lr && l("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      m != null && JP(m);
      var j;
      if (C === lr)
        n.tag === Gg ? (eg.isBatchingLegacy !== null && (eg.didScheduleLegacyUpdate = !0), fT(kP.bind(null, n))) : cT(kP.bind(null, n)), eg.current !== null ? eg.current.push(Wg) : pS(function() {
          (pa & (Dd | mv)) === af && Wg();
        }), j = null;
      else {
        var J;
        switch (Iu(S)) {
          case qo:
            J = Wp;
            break;
          case Qo:
            J = pu;
            break;
          case rs:
            J = Vl;
            break;
          case Xp:
            J = Ef;
            break;
          default:
            J = Vl;
            break;
        }
        j = aA(J, NP.bind(null, n));
      }
      n.callbackPriority = C, n.callbackNode = j;
    }
    function NP(n, o) {
      if (hv(), WE = ti, JT = Ht, (pa & (Dd | mv)) !== af)
        throw new Error("Should not already be working.");
      var m = n.callbackNode, S = x0();
      if (S && n.callbackNode !== m)
        return null;
      var C = Uf(n, n === Ih ? sf : Ht);
      if (C === Ht)
        return null;
      var F = !hn(n, C) && !wn(n, C) && !o, j = F ? xB(n, C) : e2(n, C);
      if (j !== v0) {
        if (j === u_) {
          var J = k(n);
          J !== Ht && (C = J, j = KR(n, J));
        }
        if (j === NE) {
          var ne = kE;
          throw f_(n, Ht), Nx(n, C), Lp(n, fa()), ne;
        }
        if (j === WR)
          Nx(n, C);
        else {
          var Se = !hn(n, C), Ce = n.current.alternate;
          if (Se && !fB(Ce)) {
            if (j = e2(n, C), j === u_) {
              var nt = k(n);
              nt !== Ht && (C = nt, j = KR(n, nt));
            }
            if (j === NE) {
              var et = kE;
              throw f_(n, Ht), Nx(n, C), Lp(n, fa()), et;
            }
          }
          n.finishedWork = Ce, n.finishedLanes = C, cB(n, j, C);
        }
      }
      return Lp(n, fa()), n.callbackNode === m ? NP.bind(null, n) : null;
    }
    function KR(n, o) {
      var m = BE;
      if (Wi(n)) {
        var S = f_(n, o);
        S.flags |= ps, Vn(n.containerInfo);
      }
      var C = e2(n, o);
      if (C !== u_) {
        var F = Dp;
        Dp = m, F !== null && FP(F);
      }
      return C;
    }
    function FP(n) {
      Dp === null ? Dp = n : Dp.push.apply(Dp, n);
    }
    function cB(n, o, m) {
      switch (o) {
        case v0:
        case NE:
          throw new Error("Root did not complete. This is a bug in React.");
        case u_: {
          d_(n, Dp, g0);
          break;
        }
        case jT: {
          if (Nx(n, m), Ae(m) && !KP()) {
            var S = YR + PP - fa();
            if (S > 10) {
              var C = Uf(n, Ht);
              if (C !== Ht)
                break;
              var F = n.suspendedLanes;
              if (!Lt(F, m)) {
                Bh(), md(n, F);
                break;
              }
              n.timeoutHandle = T1(d_.bind(null, n, Dp, g0), S);
              break;
            }
          }
          d_(n, Dp, g0);
          break;
        }
        case FE: {
          if (Nx(n, m), kt(m))
            break;
          if (!KP()) {
            var j = jp(n, m), J = j, ne = fa() - J, Se = DB(ne) - ne;
            if (Se > 10) {
              n.timeoutHandle = T1(d_.bind(null, n, Dp, g0), Se);
              break;
            }
          }
          d_(n, Dp, g0);
          break;
        }
        case LP: {
          d_(n, Dp, g0);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function fB(n) {
      for (var o = n; ; ) {
        if (o.flags & jd) {
          var m = o.updateQueue;
          if (m !== null) {
            var S = m.stores;
            if (S !== null)
              for (var C = 0; C < S.length; C++) {
                var F = S[C], j = F.getSnapshot, J = F.value;
                try {
                  if (!Zn(j(), J))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var ne = o.child;
        if (o.subtreeFlags & jd && ne !== null) {
          ne.return = o, o = ne;
          continue;
        }
        if (o === n)
          return !0;
        for (; o.sibling === null; ) {
          if (o.return === null || o.return === n)
            return !0;
          o = o.return;
        }
        o.sibling.return = o.return, o = o.sibling;
      }
      return !0;
    }
    function Nx(n, o) {
      o = jn(o, XT), o = jn(o, IE), hc(n, o);
    }
    function kP(n) {
      if (Lx(), (pa & (Dd | mv)) !== af)
        throw new Error("Should not already be working.");
      x0();
      var o = Uf(n, Ht);
      if (!Ze(o, lr))
        return Lp(n, fa()), null;
      var m = e2(n, o);
      if (n.tag !== Gg && m === u_) {
        var S = k(n);
        S !== Ht && (o = S, m = KR(n, S));
      }
      if (m === NE) {
        var C = kE;
        throw f_(n, Ht), Nx(n, o), Lp(n, fa()), C;
      }
      if (m === WR)
        throw new Error("Root did not complete. This is a bug in React.");
      var F = n.current.alternate;
      return n.finishedWork = F, n.finishedLanes = o, d_(n, Dp, g0), Lp(n, fa()), null;
    }
    function dB(n, o) {
      o !== Ht && (gr(n, Qt(o, lr)), Lp(n, fa()), (pa & (Dd | mv)) === af && (HE(), Wg()));
    }
    function $R(n, o) {
      var m = pa;
      pa |= DP;
      try {
        return n(o);
      } finally {
        pa = m, pa === af && !eg.isBatchingLegacy && (HE(), dT());
      }
    }
    function hB(n, o, m, S, C) {
      var F = pc(), j = Ad.transition;
      try {
        return Ad.transition = null, ro(qo), n(o, m, S, C);
      } finally {
        ro(F), Ad.transition = j, pa === af && HE();
      }
    }
    function y0(n) {
      Ux !== null && Ux.tag === Gg && (pa & (Dd | mv)) === af && x0();
      var o = pa;
      pa |= DP;
      var m = Ad.transition, S = pc();
      try {
        return Ad.transition = null, ro(qo), n ? n() : void 0;
      } finally {
        ro(S), Ad.transition = m, pa = o, (pa & (Dd | mv)) === af && Wg();
      }
    }
    function IP() {
      return (pa & (Dd | mv)) !== af;
    }
    function $T(n, o) {
      Gf(jR, iy, n), iy = Qt(iy, o);
    }
    function eA(n) {
      iy = jR.current, ju(jR, n);
    }
    function f_(n, o) {
      n.finishedWork = null, n.finishedLanes = Ht;
      var m = n.timeoutHandle;
      if (m !== Ig && (n.timeoutHandle = Ig, C1(m)), iu !== null)
        for (var S = iu.return; S !== null; ) {
          var C = S.alternate;
          pP(C, S), S = S.return;
        }
      Ih = n;
      var F = h_(n.current, null);
      return iu = F, sf = iy = o, of = v0, kE = null, YT = Ht, IE = Ht, XT = Ht, BE = null, Dp = null, eE(), Ed.discardPendingWarnings(), F;
    }
    function BP(n, o) {
      do {
        var m = iu;
        try {
          if (kS(), xE(), Ka(), GR.current = null, m === null || m.return === null) {
            of = NE, kE = o, iu = null;
            return;
          }
          if (Ne && m.mode & fr && s_(m, !0), rt)
            if (Ba(), o !== null && typeof o == "object" && typeof o.then == "function") {
              var S = o;
              al(m, S, sf);
            } else
              cd(m, o, sf);
          F4(n, m.return, m, o, sf), WP(m);
        } catch (C) {
          o = C, iu === m && m !== null ? (m = m.return, iu = m) : m = iu;
          continue;
        }
        return;
      } while (!0);
    }
    function HP() {
      var n = VR.current;
      return VR.current = Ct, n === null ? Ct : n;
    }
    function VP(n) {
      VR.current = n;
    }
    function pB() {
      YR = fa();
    }
    function jE(n) {
      YT = Qt(n, YT);
    }
    function mB() {
      of === v0 && (of = jT);
    }
    function tA() {
      (of === v0 || of === jT || of === u_) && (of = FE), Ih !== null && ($(YT) || $(IE)) && Nx(Ih, sf);
    }
    function vB(n) {
      of !== FE && (of = u_), BE === null ? BE = [n] : BE.push(n);
    }
    function gB() {
      return of === v0;
    }
    function e2(n, o) {
      var m = pa;
      pa |= Dd;
      var S = HP();
      if (Ih !== n || sf !== o) {
        if (ya) {
          var C = n.memoizedUpdaters;
          C.size > 0 && (YE(n, sf), C.clear()), zf(n, o);
        }
        g0 = vg(), f_(n, o);
      }
      Wl(o);
      do
        try {
          yB();
          break;
        } catch (F) {
          BP(n, F);
        }
      while (!0);
      if (kS(), pa = m, VP(S), iu !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return fd(), Ih = null, sf = Ht, of;
    }
    function yB() {
      for (; iu !== null; )
        GP(iu);
    }
    function xB(n, o) {
      var m = pa;
      pa |= Dd;
      var S = HP();
      if (Ih !== n || sf !== o) {
        if (ya) {
          var C = n.memoizedUpdaters;
          C.size > 0 && (YE(n, sf), C.clear()), zf(n, o);
        }
        g0 = vg(), HE(), f_(n, o);
      }
      Wl(o);
      do
        try {
          _B();
          break;
        } catch (F) {
          BP(n, F);
        }
      while (!0);
      return kS(), VP(S), pa = m, iu !== null ? (jl(), v0) : (fd(), Ih = null, sf = Ht, of);
    }
    function _B() {
      for (; iu !== null && !il(); )
        GP(iu);
    }
    function GP(n) {
      var o = n.alternate;
      Xi(n);
      var m;
      (n.mode & fr) !== hr ? (Qv(n), m = nA(o, n, iy), s_(n, !0)) : m = nA(o, n, iy), Ka(), n.memoizedProps = n.pendingProps, m === null ? WP(n) : iu = m, GR.current = null;
    }
    function WP(n) {
      var o = n;
      do {
        var m = o.alternate, S = o.return;
        if ((o.flags & gl) === vr) {
          Xi(o);
          var C = void 0;
          if ((o.mode & fr) === hr ? C = hP(m, o, iy) : (Qv(o), C = hP(m, o, iy), s_(o, !1)), Ka(), C !== null) {
            iu = C;
            return;
          }
        } else {
          var F = mI(m, o);
          if (F !== null) {
            F.flags &= bv, iu = F;
            return;
          }
          if ((o.mode & fr) !== hr) {
            s_(o, !1);
            for (var j = o.actualDuration, J = o.child; J !== null; )
              j += J.actualDuration, J = J.sibling;
            o.actualDuration = j;
          }
          if (S !== null)
            S.flags |= gl, S.subtreeFlags = vr, S.deletions = null;
          else {
            of = WR, iu = null;
            return;
          }
        }
        var ne = o.sibling;
        if (ne !== null) {
          iu = ne;
          return;
        }
        o = S, iu = o;
      } while (o !== null);
      of === v0 && (of = LP);
    }
    function d_(n, o, m) {
      var S = pc(), C = Ad.transition;
      try {
        Ad.transition = null, ro(qo), SB(n, o, m, S);
      } finally {
        Ad.transition = C, ro(S);
      }
      return null;
    }
    function SB(n, o, m, S) {
      do
        x0();
      while (Ux !== null);
      if (PB(), (pa & (Dd | mv)) !== af)
        throw new Error("Should not already be working.");
      var C = n.finishedWork, F = n.finishedLanes;
      if (_a(F), C === null)
        return Qr(), null;
      if (F === Ht && l("root.finishedLanes should not be empty during a commit. This is a bug in React."), n.finishedWork = null, n.finishedLanes = Ht, C === n.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      n.callbackNode = null, n.callbackPriority = pi;
      var j = Qt(C.lanes, C.childLanes);
      ap(n, j), n === Ih && (Ih = null, iu = null, sf = Ht), ((C.subtreeFlags & zc) !== vr || (C.flags & zc) !== vr) && (c_ || (c_ = !0, QR = m, aA(Vl, function() {
        return x0(), null;
      })));
      var J = (C.subtreeFlags & (Ur | $s | ms | zc)) !== vr, ne = (C.flags & (Ur | $s | ms | zc)) !== vr;
      if (J || ne) {
        var Se = Ad.transition;
        Ad.transition = null;
        var Ce = pc();
        ro(qo);
        var nt = pa;
        pa |= mv, GR.current = null, _I(n, C), ah(), UI(n, C, F), E1(n.containerInfo), n.current = C, Bm(F), zI(C, n, F), Tf(), Ns(), pa = nt, ro(Ce), Ad.transition = Se;
      } else
        n.current = C, ah();
      var et = c_;
      if (c_ ? (c_ = !1, Ux = n, VE = F) : (gw = 0, ZT = null), j = n.pendingLanes, j === Ht && (vw = null), et || qP(n.current, !1), jo(C.stateNode, S), ya && n.memoizedUpdaters.clear(), eB(), Lp(n, fa()), o !== null)
        for (var Pt = n.onRecoverableError, Ut = 0; Ut < o.length; Ut++) {
          var Xt = o[Ut], tr = Xt.stack, Dr = Xt.digest;
          Pt(Xt.value, {
            componentStack: tr,
            digest: Dr
          });
        }
      if (qT) {
        qT = !1;
        var Sr = XR;
        throw XR = null, Sr;
      }
      return Ze(VE, lr) && n.tag !== Gg && x0(), j = n.pendingLanes, Ze(j, lr) ? (Fh(), n === ZR ? GE++ : (GE = 0, ZR = n)) : GE = 0, Wg(), Qr(), null;
    }
    function x0() {
      if (Ux !== null) {
        var n = Iu(VE), o = _y(rs, n), m = Ad.transition, S = pc();
        try {
          return Ad.transition = null, ro(o), bB();
        } finally {
          ro(S), Ad.transition = m;
        }
      }
      return !1;
    }
    function wB(n) {
      qR.push(n), c_ || (c_ = !0, aA(Vl, function() {
        return x0(), null;
      }));
    }
    function bB() {
      if (Ux === null)
        return !1;
      var n = QR;
      QR = null;
      var o = Ux, m = VE;
      if (Ux = null, VE = Ht, (pa & (Dd | mv)) !== af)
        throw new Error("Cannot flush passive effects while already rendering.");
      JR = !0, QT = !1, Zd(m);
      var S = pa;
      pa |= mv, VI(o.current), kI(o, o.current, m, n);
      {
        var C = qR;
        qR = [];
        for (var F = 0; F < C.length; F++) {
          var j = C[F];
          EI(o, j);
        }
      }
      Cf(), qP(o.current, !0), pa = S, Wg(), QT ? o === ZT ? gw++ : (gw = 0, ZT = o) : gw = 0, JR = !1, QT = !1, ts(o);
      {
        var J = o.current.stateNode;
        J.effectDuration = 0, J.passiveEffectDuration = 0;
      }
      return !0;
    }
    function jP(n) {
      return vw !== null && vw.has(n);
    }
    function EB(n) {
      vw === null ? vw = /* @__PURE__ */ new Set([n]) : vw.add(n);
    }
    function MB(n) {
      qT || (qT = !0, XR = n);
    }
    var TB = MB;
    function YP(n, o, m) {
      var S = o_(m, o), C = GL(n, S, lr), F = Zg(n, C, lr), j = Bh();
      F !== null && (Zr(F, lr, j), Lp(F, j));
    }
    function Do(n, o, m) {
      if (gI(m), XE(!1), n.tag === w) {
        YP(n, n, m);
        return;
      }
      var S = null;
      for (S = o; S !== null; ) {
        if (S.tag === w) {
          YP(S, n, m);
          return;
        } else if (S.tag === g) {
          var C = S.type, F = S.stateNode;
          if (typeof C.getDerivedStateFromError == "function" || typeof F.componentDidCatch == "function" && !jP(F)) {
            var j = o_(m, n), J = wR(S, j, lr), ne = Zg(S, J, lr), Se = Bh();
            ne !== null && (Zr(ne, lr, Se), Lp(ne, Se));
            return;
          }
        }
        S = S.return;
      }
      l(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, m);
    }
    function CB(n, o, m) {
      var S = n.pingCache;
      S !== null && S.delete(o);
      var C = Bh();
      md(n, m), NB(n), Ih === n && Lt(sf, m) && (of === FE || of === jT && Ae(sf) && fa() - YR < PP ? f_(n, Ht) : XT = Qt(XT, m)), Lp(n, C);
    }
    function XP(n, o) {
      o === pi && (o = oB(n));
      var m = Bh(), S = $c(n, o);
      S !== null && (Zr(S, o, m), Lp(S, m));
    }
    function RB(n) {
      var o = n.memoizedState, m = pi;
      o !== null && (m = o.retryLane), XP(n, m);
    }
    function AB(n, o) {
      var m = pi, S;
      switch (n.tag) {
        case Q:
          S = n.stateNode;
          var C = n.memoizedState;
          C !== null && (m = C.retryLane);
          break;
        case ce:
          S = n.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      S !== null && S.delete(o), XP(n, m);
    }
    function DB(n) {
      return n < 120 ? 120 : n < 480 ? 480 : n < 1080 ? 1080 : n < 1920 ? 1920 : n < 3e3 ? 3e3 : n < 4320 ? 4320 : rB(n / 1960) * 1960;
    }
    function LB() {
      if (GE > aB)
        throw GE = 0, ZR = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      gw > sB && (gw = 0, ZT = null, l("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function PB() {
      Ed.flushLegacyContextWarning(), Ed.flushPendingUnsafeLifecycleWarnings();
    }
    function qP(n, o) {
      Xi(n), t2(n, Vr, JI), o && t2(n, uc, KI), t2(n, Vr, QI), o && t2(n, uc, ZI), Ka();
    }
    function t2(n, o, m) {
      for (var S = n, C = null; S !== null; ) {
        var F = S.subtreeFlags & o;
        S !== C && S.child !== null && F !== vr ? S = S.child : ((S.flags & o) !== vr && m(S), S.sibling !== null ? S = S.sibling : S = C = S.return);
      }
    }
    var n2 = null;
    function QP(n) {
      {
        if ((pa & Dd) !== af || !(n.mode & Gr))
          return;
        var o = n.tag;
        if (o !== _ && o !== w && o !== g && o !== p && o !== G && o !== K && o !== te)
          return;
        var m = xr(n) || "ReactComponent";
        if (n2 !== null) {
          if (n2.has(m))
            return;
          n2.add(m);
        } else
          n2 = /* @__PURE__ */ new Set([m]);
        var S = ua;
        try {
          Xi(n), l("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          S ? Xi(n) : Ka();
        }
      }
    }
    var nA;
    {
      var OB = null;
      nA = function(n, o, m) {
        var S = rO(OB, o);
        try {
          return lP(n, o, m);
        } catch (F) {
          if (Xb() || F !== null && typeof F == "object" && typeof F.then == "function")
            throw F;
          if (kS(), xE(), pP(n, o), rO(o, S), o.mode & fr && Qv(o), Uu(null, lP, null, n, o, m), xe()) {
            var C = oc();
            typeof C == "object" && C !== null && C._suppressLogging && typeof F == "object" && F !== null && !F._suppressLogging && (F._suppressLogging = !0);
          }
          throw F;
        }
      };
    }
    var ZP = !1, rA;
    rA = /* @__PURE__ */ new Set();
    function UB(n) {
      if (Cr && !It())
        switch (n.tag) {
          case p:
          case G:
          case te: {
            var o = iu && xr(iu) || "Unknown", m = o;
            if (!rA.has(m)) {
              rA.add(m);
              var S = xr(n) || "Unknown";
              l("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", S, o, o);
            }
            break;
          }
          case g: {
            ZP || (l("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), ZP = !0);
            break;
          }
        }
    }
    function YE(n, o) {
      if (ya) {
        var m = n.memoizedUpdaters;
        m.forEach(function(S) {
          Hm(n, S, o);
        });
      }
    }
    var iA = {};
    function aA(n, o) {
      {
        var m = eg.current;
        return m !== null ? (m.push(o), iA) : Go(n, o);
      }
    }
    function JP(n) {
      if (n !== iA)
        return Yd(n);
    }
    function KP() {
      return eg.current !== null;
    }
    function zB(n) {
      {
        if (n.mode & Gr) {
          if (!AP())
            return;
        } else if (!nB() || pa !== af || n.tag !== p && n.tag !== G && n.tag !== te)
          return;
        if (eg.current === null) {
          var o = ua;
          try {
            Xi(n), l(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, xr(n));
          } finally {
            o ? Xi(n) : Ka();
          }
        }
      }
    }
    function NB(n) {
      n.tag !== Gg && AP() && eg.current === null && l(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    function XE(n) {
      zP = n;
    }
    var vv = null, yw = null, FB = function(n) {
      vv = n;
    };
    function xw(n) {
      {
        if (vv === null)
          return n;
        var o = vv(n);
        return o === void 0 ? n : o.current;
      }
    }
    function sA(n) {
      return xw(n);
    }
    function oA(n) {
      {
        if (vv === null)
          return n;
        var o = vv(n);
        if (o === void 0) {
          if (n != null && typeof n.render == "function") {
            var m = xw(n.render);
            if (n.render !== m) {
              var S = {
                $$typeof: $t,
                render: m
              };
              return n.displayName !== void 0 && (S.displayName = n.displayName), S;
            }
          }
          return n;
        }
        return o.current;
      }
    }
    function $P(n, o) {
      {
        if (vv === null)
          return !1;
        var m = n.elementType, S = o.type, C = !1, F = typeof S == "object" && S !== null ? S.$$typeof : null;
        switch (n.tag) {
          case g: {
            typeof S == "function" && (C = !0);
            break;
          }
          case p: {
            (typeof S == "function" || F === yn) && (C = !0);
            break;
          }
          case G: {
            (F === $t || F === yn) && (C = !0);
            break;
          }
          case K:
          case te: {
            (F === gn || F === yn) && (C = !0);
            break;
          }
          default:
            return !1;
        }
        if (C) {
          var j = vv(m);
          if (j !== void 0 && j === vv(S))
            return !0;
        }
        return !1;
      }
    }
    function eO(n) {
      {
        if (vv === null || typeof WeakSet != "function")
          return;
        yw === null && (yw = /* @__PURE__ */ new WeakSet()), yw.add(n);
      }
    }
    var kB = function(n, o) {
      {
        if (vv === null)
          return;
        var m = o.staleFamilies, S = o.updatedFamilies;
        x0(), y0(function() {
          lA(n.current, S, m);
        });
      }
    }, IB = function(n, o) {
      {
        if (n.context !== eh)
          return;
        x0(), y0(function() {
          qE(o, n, null, null);
        });
      }
    };
    function lA(n, o, m) {
      {
        var S = n.alternate, C = n.child, F = n.sibling, j = n.tag, J = n.type, ne = null;
        switch (j) {
          case p:
          case te:
          case g:
            ne = J;
            break;
          case G:
            ne = J.render;
            break;
        }
        if (vv === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var Se = !1, Ce = !1;
        if (ne !== null) {
          var nt = vv(ne);
          nt !== void 0 && (m.has(nt) ? Ce = !0 : o.has(nt) && (j === g ? Ce = !0 : Se = !0));
        }
        if (yw !== null && (yw.has(n) || S !== null && yw.has(S)) && (Ce = !0), Ce && (n._debugNeedsRemount = !0), Ce || Se) {
          var et = $c(n, lr);
          et !== null && lf(et, n, lr, ti);
        }
        C !== null && !Ce && lA(C, o, m), F !== null && lA(F, o, m);
      }
    }
    var BB = function(n, o) {
      {
        var m = /* @__PURE__ */ new Set(), S = new Set(o.map(function(C) {
          return C.current;
        }));
        return uA(n.current, S, m), m;
      }
    };
    function uA(n, o, m) {
      {
        var S = n.child, C = n.sibling, F = n.tag, j = n.type, J = null;
        switch (F) {
          case p:
          case te:
          case g:
            J = j;
            break;
          case G:
            J = j.render;
            break;
        }
        var ne = !1;
        J !== null && o.has(J) && (ne = !0), ne ? HB(n, m) : S !== null && uA(S, o, m), C !== null && uA(C, o, m);
      }
    }
    function HB(n, o) {
      {
        var m = VB(n, o);
        if (m)
          return;
        for (var S = n; ; ) {
          switch (S.tag) {
            case R:
              o.add(S.stateNode);
              return;
            case T:
              o.add(S.stateNode.containerInfo);
              return;
            case w:
              o.add(S.stateNode.containerInfo);
              return;
          }
          if (S.return === null)
            throw new Error("Expected to reach root first.");
          S = S.return;
        }
      }
    }
    function VB(n, o) {
      for (var m = n, S = !1; ; ) {
        if (m.tag === R)
          S = !0, o.add(m.stateNode);
        else if (m.child !== null) {
          m.child.return = m, m = m.child;
          continue;
        }
        if (m === n)
          return S;
        for (; m.sibling === null; ) {
          if (m.return === null || m.return === n)
            return S;
          m = m.return;
        }
        m.sibling.return = m.return, m = m.sibling;
      }
      return !1;
    }
    var cA;
    {
      cA = !1;
      try {
        var tO = Object.preventExtensions({});
      } catch {
        cA = !0;
      }
    }
    function GB(n, o, m, S) {
      this.tag = n, this.key = m, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = o, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = S, this.flags = vr, this.subtreeFlags = vr, this.deletions = null, this.lanes = Ht, this.childLanes = Ht, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !cA && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var ym = function(n, o, m, S) {
      return new GB(n, o, m, S);
    };
    function fA(n) {
      var o = n.prototype;
      return !!(o && o.isReactComponent);
    }
    function WB(n) {
      return typeof n == "function" && !fA(n) && n.defaultProps === void 0;
    }
    function jB(n) {
      if (typeof n == "function")
        return fA(n) ? g : p;
      if (n != null) {
        var o = n.$$typeof;
        if (o === $t)
          return G;
        if (o === gn)
          return K;
      }
      return _;
    }
    function h_(n, o) {
      var m = n.alternate;
      m === null ? (m = ym(n.tag, o, n.key, n.mode), m.elementType = n.elementType, m.type = n.type, m.stateNode = n.stateNode, m._debugSource = n._debugSource, m._debugOwner = n._debugOwner, m._debugHookTypes = n._debugHookTypes, m.alternate = n, n.alternate = m) : (m.pendingProps = o, m.type = n.type, m.flags = vr, m.subtreeFlags = vr, m.deletions = null, m.actualDuration = 0, m.actualStartTime = -1), m.flags = n.flags & vn, m.childLanes = n.childLanes, m.lanes = n.lanes, m.child = n.child, m.memoizedProps = n.memoizedProps, m.memoizedState = n.memoizedState, m.updateQueue = n.updateQueue;
      var S = n.dependencies;
      switch (m.dependencies = S === null ? null : {
        lanes: S.lanes,
        firstContext: S.firstContext
      }, m.sibling = n.sibling, m.index = n.index, m.ref = n.ref, m.selfBaseDuration = n.selfBaseDuration, m.treeBaseDuration = n.treeBaseDuration, m._debugNeedsRemount = n._debugNeedsRemount, m.tag) {
        case _:
        case p:
        case te:
          m.type = xw(n.type);
          break;
        case g:
          m.type = sA(n.type);
          break;
        case G:
          m.type = oA(n.type);
          break;
      }
      return m;
    }
    function YB(n, o) {
      n.flags &= vn | si;
      var m = n.alternate;
      if (m === null)
        n.childLanes = Ht, n.lanes = o, n.child = null, n.subtreeFlags = vr, n.memoizedProps = null, n.memoizedState = null, n.updateQueue = null, n.dependencies = null, n.stateNode = null, n.selfBaseDuration = 0, n.treeBaseDuration = 0;
      else {
        n.childLanes = m.childLanes, n.lanes = m.lanes, n.child = m.child, n.subtreeFlags = vr, n.deletions = null, n.memoizedProps = m.memoizedProps, n.memoizedState = m.memoizedState, n.updateQueue = m.updateQueue, n.type = m.type;
        var S = m.dependencies;
        n.dependencies = S === null ? null : {
          lanes: S.lanes,
          firstContext: S.firstContext
        }, n.selfBaseDuration = m.selfBaseDuration, n.treeBaseDuration = m.treeBaseDuration;
      }
      return n;
    }
    function XB(n, o, m) {
      var S;
      return n === N1 ? (S = Gr, o === !0 && (S |= ui, S |= Fs)) : S = hr, ya && (S |= fr), ym(w, null, null, S);
    }
    function dA(n, o, m, S, C, F) {
      var j = _, J = n;
      if (typeof n == "function")
        fA(n) ? (j = g, J = sA(J)) : J = xw(J);
      else if (typeof n == "string")
        j = R;
      else {
        e:
          switch (n) {
            case Te:
              return Fx(m.children, C, F, o);
            case ot:
              j = U, C |= ui, (C & Gr) !== hr && (C |= Fs);
              break;
            case de:
              return qB(m, C, F, o);
            case mn:
              return QB(m, C, F, o);
            case Rn:
              return ZB(m, C, F, o);
            case wr:
              return nO(m, C, F, o);
            case Yi:
            case Jn:
            case La:
            case qs:
            case rr:
            default: {
              if (typeof n == "object" && n !== null)
                switch (n.$$typeof) {
                  case Le:
                    j = I;
                    break e;
                  case Ye:
                    j = H;
                    break e;
                  case $t:
                    j = G, J = oA(J);
                    break e;
                  case gn:
                    j = K;
                    break e;
                  case yn:
                    j = Y, J = null;
                    break e;
                }
              var ne = "";
              {
                (n === void 0 || typeof n == "object" && n !== null && Object.keys(n).length === 0) && (ne += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
                var Se = S ? xr(S) : null;
                Se && (ne += `

Check the render method of \`` + Se + "`.");
              }
              throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (n == null ? n : typeof n) + "." + ne));
            }
          }
      }
      var Ce = ym(j, m, o, C);
      return Ce.elementType = n, Ce.type = J, Ce.lanes = F, Ce._debugOwner = S, Ce;
    }
    function hA(n, o, m) {
      var S = null;
      S = n._owner;
      var C = n.type, F = n.key, j = n.props, J = dA(C, F, j, S, o, m);
      return J._debugSource = n._source, J._debugOwner = n._owner, J;
    }
    function Fx(n, o, m, S) {
      var C = ym(O, n, S, o);
      return C.lanes = m, C;
    }
    function qB(n, o, m, S) {
      typeof n.id != "string" && l('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof n.id);
      var C = ym(B, n, S, o | fr);
      return C.elementType = de, C.lanes = m, C.stateNode = {
        effectDuration: 0,
        passiveEffectDuration: 0
      }, C;
    }
    function QB(n, o, m, S) {
      var C = ym(Q, n, S, o);
      return C.elementType = mn, C.lanes = m, C;
    }
    function ZB(n, o, m, S) {
      var C = ym(ce, n, S, o);
      return C.elementType = Rn, C.lanes = m, C;
    }
    function nO(n, o, m, S) {
      var C = ym(Me, n, S, o);
      C.elementType = wr, C.lanes = m;
      var F = {
        isHidden: !1
      };
      return C.stateNode = F, C;
    }
    function pA(n, o, m) {
      var S = ym(D, n, null, o);
      return S.lanes = m, S;
    }
    function JB() {
      var n = ym(R, null, null, hr);
      return n.elementType = "DELETED", n;
    }
    function KB(n) {
      var o = ym(se, null, null, hr);
      return o.stateNode = n, o;
    }
    function mA(n, o, m) {
      var S = n.children !== null ? n.children : [], C = ym(T, S, n.key, o);
      return C.lanes = m, C.stateNode = {
        containerInfo: n.containerInfo,
        pendingChildren: null,
        implementation: n.implementation
      }, C;
    }
    function rO(n, o) {
      return n === null && (n = ym(_, null, null, hr)), n.tag = o.tag, n.key = o.key, n.elementType = o.elementType, n.type = o.type, n.stateNode = o.stateNode, n.return = o.return, n.child = o.child, n.sibling = o.sibling, n.index = o.index, n.ref = o.ref, n.pendingProps = o.pendingProps, n.memoizedProps = o.memoizedProps, n.updateQueue = o.updateQueue, n.memoizedState = o.memoizedState, n.dependencies = o.dependencies, n.mode = o.mode, n.flags = o.flags, n.subtreeFlags = o.subtreeFlags, n.deletions = o.deletions, n.lanes = o.lanes, n.childLanes = o.childLanes, n.alternate = o.alternate, n.actualDuration = o.actualDuration, n.actualStartTime = o.actualStartTime, n.selfBaseDuration = o.selfBaseDuration, n.treeBaseDuration = o.treeBaseDuration, n._debugSource = o._debugSource, n._debugOwner = o._debugOwner, n._debugNeedsRemount = o._debugNeedsRemount, n._debugHookTypes = o._debugHookTypes, n;
    }
    function $B(n, o, m, S, C) {
      this.tag = o, this.containerInfo = n, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = Ig, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = pi, this.eventTimes = Va(Ht), this.expirationTimes = Va(ti), this.pendingLanes = Ht, this.suspendedLanes = Ht, this.pingedLanes = Ht, this.expiredLanes = Ht, this.mutableReadLanes = Ht, this.finishedLanes = Ht, this.entangledLanes = Ht, this.entanglements = Va(Ht), this.identifierPrefix = S, this.onRecoverableError = C, this.mutableSourceEagerHydrationData = null, this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var F = this.pendingUpdatersLaneMap = [], j = 0; j < Ai; j++)
          F.push(/* @__PURE__ */ new Set());
      }
      switch (o) {
        case N1:
          this._debugRootType = m ? "hydrateRoot()" : "createRoot()";
          break;
        case Gg:
          this._debugRootType = m ? "hydrate()" : "render()";
          break;
      }
    }
    function iO(n, o, m, S, C, F, j, J, ne, Se) {
      var Ce = new $B(n, o, m, J, ne), nt = XB(o, F);
      Ce.current = nt, nt.stateNode = Ce;
      {
        var et = {
          element: S,
          isDehydrated: m,
          cache: null,
          transitions: null,
          pendingSuspenseBoundaries: null
        };
        nt.memoizedState = et;
      }
      return VS(nt), Ce;
    }
    var vA = "18.2.0";
    function e5(n, o, m) {
      var S = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return Nt(S), {
        $$typeof: ai,
        key: S == null ? null : "" + S,
        children: n,
        containerInfo: o,
        implementation: m
      };
    }
    var gA, yA;
    gA = !1, yA = {};
    function aO(n) {
      if (!n)
        return eh;
      var o = Ks(n), m = iR(o);
      if (o.tag === g) {
        var S = o.type;
        if (fm(S))
          return lT(o, S, m);
      }
      return m;
    }
    function t5(n, o) {
      {
        var m = Ks(n);
        if (m === void 0) {
          if (typeof n.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var S = Object.keys(n).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + S);
        }
        var C = hu(m);
        if (C === null)
          return null;
        if (C.mode & ui) {
          var F = xr(m) || "Component";
          if (!yA[F]) {
            yA[F] = !0;
            var j = ua;
            try {
              Xi(C), m.mode & ui ? l("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", o, o, F) : l("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", o, o, F);
            } finally {
              j ? Xi(j) : Ka();
            }
          }
        }
        return C.stateNode;
      }
    }
    function sO(n, o, m, S, C, F, j, J) {
      var ne = !1, Se = null;
      return iO(n, o, ne, Se, m, S, C, F, j);
    }
    function oO(n, o, m, S, C, F, j, J, ne, Se) {
      var Ce = !0, nt = iO(m, S, Ce, n, C, F, j, J, ne);
      nt.context = aO(null);
      var et = nt.current, Pt = Bh(), Ut = zx(et), Xt = sv(Pt, Ut);
      return Xt.callback = o != null ? o : null, Zg(et, Xt, Ut), lB(nt, Ut, Pt), nt;
    }
    function qE(n, o, m, S) {
      Wo(o, n);
      var C = o.current, F = Bh(), j = zx(C);
      Yl(j);
      var J = aO(m);
      o.context === null ? o.context = J : o.pendingContext = J, Cr && ua !== null && !gA && (gA = !0, l(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, xr(ua) || "Unknown"));
      var ne = sv(F, j);
      ne.payload = {
        element: n
      }, S = S === void 0 ? null : S, S !== null && (typeof S != "function" && l("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", S), ne.callback = S);
      var Se = Zg(C, ne, j);
      return Se !== null && (lf(Se, C, j, F), WS(Se, C, j)), j;
    }
    function r2(n) {
      var o = n.current;
      if (!o.child)
        return null;
      switch (o.child.tag) {
        case R:
          return o.child.stateNode;
        default:
          return o.child.stateNode;
      }
    }
    function n5(n) {
      switch (n.tag) {
        case w: {
          var o = n.stateNode;
          if (Wi(o)) {
            var m = L(o);
            dB(o, m);
          }
          break;
        }
        case Q: {
          y0(function() {
            var C = $c(n, lr);
            if (C !== null) {
              var F = Bh();
              lf(C, n, lr, F);
            }
          });
          var S = lr;
          xA(n, S);
          break;
        }
      }
    }
    function lO(n, o) {
      var m = n.memoizedState;
      m !== null && m.dehydrated !== null && (m.retryLane = Ar(m.retryLane, o));
    }
    function xA(n, o) {
      lO(n, o);
      var m = n.alternate;
      m && lO(m, o);
    }
    function r5(n) {
      if (n.tag === Q) {
        var o = gu, m = $c(n, o);
        if (m !== null) {
          var S = Bh();
          lf(m, n, o, S);
        }
        xA(n, o);
      }
    }
    function i5(n) {
      if (n.tag === Q) {
        var o = zx(n), m = $c(n, o);
        if (m !== null) {
          var S = Bh();
          lf(m, n, o, S);
        }
        xA(n, o);
      }
    }
    function uO(n) {
      var o = ld(n);
      return o === null ? null : o.stateNode;
    }
    var cO = function(n) {
      return null;
    };
    function a5(n) {
      return cO(n);
    }
    var fO = function(n) {
      return !1;
    };
    function s5(n) {
      return fO(n);
    }
    var dO = null, hO = null, pO = null, mO = null, vO = null, gO = null, yO = null, xO = null, _O = null;
    {
      var SO = function(n, o, m) {
        var S = o[m], C = Zs(n) ? n.slice() : qn({}, n);
        return m + 1 === o.length ? (Zs(C) ? C.splice(S, 1) : delete C[S], C) : (C[S] = SO(n[S], o, m + 1), C);
      }, wO = function(n, o) {
        return SO(n, o, 0);
      }, bO = function(n, o, m, S) {
        var C = o[S], F = Zs(n) ? n.slice() : qn({}, n);
        if (S + 1 === o.length) {
          var j = m[S];
          F[j] = F[C], Zs(F) ? F.splice(C, 1) : delete F[C];
        } else
          F[C] = bO(
            n[C],
            o,
            m,
            S + 1
          );
        return F;
      }, EO = function(n, o, m) {
        if (o.length !== m.length) {
          s("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var S = 0; S < m.length - 1; S++)
            if (o[S] !== m[S]) {
              s("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return bO(n, o, m, 0);
      }, MO = function(n, o, m, S) {
        if (m >= o.length)
          return S;
        var C = o[m], F = Zs(n) ? n.slice() : qn({}, n);
        return F[C] = MO(n[C], o, m + 1, S), F;
      }, TO = function(n, o, m) {
        return MO(n, o, 0, m);
      }, _A = function(n, o) {
        for (var m = n.memoizedState; m !== null && o > 0; )
          m = m.next, o--;
        return m;
      };
      dO = function(n, o, m, S) {
        var C = _A(n, o);
        if (C !== null) {
          var F = TO(C.memoizedState, m, S);
          C.memoizedState = F, C.baseState = F, n.memoizedProps = qn({}, n.memoizedProps);
          var j = $c(n, lr);
          j !== null && lf(j, n, lr, ti);
        }
      }, hO = function(n, o, m) {
        var S = _A(n, o);
        if (S !== null) {
          var C = wO(S.memoizedState, m);
          S.memoizedState = C, S.baseState = C, n.memoizedProps = qn({}, n.memoizedProps);
          var F = $c(n, lr);
          F !== null && lf(F, n, lr, ti);
        }
      }, pO = function(n, o, m, S) {
        var C = _A(n, o);
        if (C !== null) {
          var F = EO(C.memoizedState, m, S);
          C.memoizedState = F, C.baseState = F, n.memoizedProps = qn({}, n.memoizedProps);
          var j = $c(n, lr);
          j !== null && lf(j, n, lr, ti);
        }
      }, mO = function(n, o, m) {
        n.pendingProps = TO(n.memoizedProps, o, m), n.alternate && (n.alternate.pendingProps = n.pendingProps);
        var S = $c(n, lr);
        S !== null && lf(S, n, lr, ti);
      }, vO = function(n, o) {
        n.pendingProps = wO(n.memoizedProps, o), n.alternate && (n.alternate.pendingProps = n.pendingProps);
        var m = $c(n, lr);
        m !== null && lf(m, n, lr, ti);
      }, gO = function(n, o, m) {
        n.pendingProps = EO(n.memoizedProps, o, m), n.alternate && (n.alternate.pendingProps = n.pendingProps);
        var S = $c(n, lr);
        S !== null && lf(S, n, lr, ti);
      }, yO = function(n) {
        var o = $c(n, lr);
        o !== null && lf(o, n, lr, ti);
      }, xO = function(n) {
        cO = n;
      }, _O = function(n) {
        fO = n;
      };
    }
    function o5(n) {
      var o = hu(n);
      return o === null ? null : o.stateNode;
    }
    function l5(n) {
      return null;
    }
    function u5() {
      return ua;
    }
    function c5(n) {
      var o = n.findFiberByHostInstance, m = t.ReactCurrentDispatcher;
      return rp({
        bundleType: n.bundleType,
        version: n.version,
        rendererPackageName: n.rendererPackageName,
        rendererConfig: n.rendererConfig,
        overrideHookState: dO,
        overrideHookStateDeletePath: hO,
        overrideHookStateRenamePath: pO,
        overrideProps: mO,
        overridePropsDeletePath: vO,
        overridePropsRenamePath: gO,
        setErrorHandler: xO,
        setSuspenseHandler: _O,
        scheduleUpdate: yO,
        currentDispatcherRef: m,
        findHostInstanceByFiber: o5,
        findFiberByHostInstance: o || l5,
        findHostInstancesForRefresh: BB,
        scheduleRefresh: kB,
        scheduleRoot: IB,
        setRefreshHandler: FB,
        getCurrentFiber: u5,
        reconcilerVersion: vA
      });
    }
    var CO = typeof reportError == "function" ? reportError : function(n) {
      console.error(n);
    };
    function SA(n) {
      this._internalRoot = n;
    }
    i2.prototype.render = SA.prototype.render = function(n) {
      var o = this._internalRoot;
      if (o === null)
        throw new Error("Cannot update an unmounted root.");
      {
        typeof arguments[1] == "function" ? l("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : a2(arguments[1]) ? l("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : typeof arguments[1] < "u" && l("You passed a second argument to root.render(...) but it only accepts one argument.");
        var m = o.containerInfo;
        if (m.nodeType !== Oi) {
          var S = uO(o.current);
          S && S.parentNode !== m && l("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
        }
      }
      qE(n, o, null, null);
    }, i2.prototype.unmount = SA.prototype.unmount = function() {
      typeof arguments[0] == "function" && l("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
      var n = this._internalRoot;
      if (n !== null) {
        this._internalRoot = null;
        var o = n.containerInfo;
        IP() && l("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."), y0(function() {
          qE(null, n, null, null);
        }), nn(o);
      }
    };
    function f5(n, o) {
      if (!a2(n))
        throw new Error("createRoot(...): Target container is not a DOM element.");
      RO(n);
      var m = !1, S = !1, C = "", F = CO;
      o != null && (o.hydrate ? s("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : typeof o == "object" && o !== null && o.$$typeof === $r && l(`You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`), o.unstable_strictMode === !0 && (m = !0), o.identifierPrefix !== void 0 && (C = o.identifierPrefix), o.onRecoverableError !== void 0 && (F = o.onRecoverableError), o.transitionCallbacks !== void 0 && o.transitionCallbacks);
      var j = sO(n, N1, null, m, S, C, F);
      lt(j.current, n);
      var J = n.nodeType === Oi ? n.parentNode : n;
      return Yc(J), new SA(j);
    }
    function i2(n) {
      this._internalRoot = n;
    }
    function d5(n) {
      n && Mv(n);
    }
    i2.prototype.unstable_scheduleHydration = d5;
    function h5(n, o, m) {
      if (!a2(n))
        throw new Error("hydrateRoot(...): Target container is not a DOM element.");
      RO(n), o === void 0 && l("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
      var S = m != null ? m : null, C = m != null && m.hydratedSources || null, F = !1, j = !1, J = "", ne = CO;
      m != null && (m.unstable_strictMode === !0 && (F = !0), m.identifierPrefix !== void 0 && (J = m.identifierPrefix), m.onRecoverableError !== void 0 && (ne = m.onRecoverableError));
      var Se = oO(o, null, n, N1, S, F, j, J, ne);
      if (lt(Se.current, n), Yc(n), C)
        for (var Ce = 0; Ce < C.length; Ce++) {
          var nt = C[Ce];
          NT(Se, nt);
        }
      return new i2(Se);
    }
    function a2(n) {
      return !!(n && (n.nodeType === zl || n.nodeType === Za || n.nodeType === Ma || !Ee));
    }
    function QE(n) {
      return !!(n && (n.nodeType === zl || n.nodeType === Za || n.nodeType === Ma || n.nodeType === Oi && n.nodeValue === " react-mount-point-unstable "));
    }
    function RO(n) {
      n.nodeType === zl && n.tagName && n.tagName.toUpperCase() === "BODY" && l("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app."), Kt(n) && (n._reactRootContainer ? l("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : l("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."));
    }
    var p5 = t.ReactCurrentOwner, AO;
    AO = function(n) {
      if (n._reactRootContainer && n.nodeType !== Oi) {
        var o = uO(n._reactRootContainer.current);
        o && o.parentNode !== n && l("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
      }
      var m = !!n._reactRootContainer, S = wA(n), C = !!(S && Cn(S));
      C && !m && l("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render."), n.nodeType === zl && n.tagName && n.tagName.toUpperCase() === "BODY" && l("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
    };
    function wA(n) {
      return n ? n.nodeType === Za ? n.documentElement : n.firstChild : null;
    }
    function DO() {
    }
    function m5(n, o, m, S, C) {
      if (C) {
        if (typeof S == "function") {
          var F = S;
          S = function() {
            var et = r2(j);
            F.call(et);
          };
        }
        var j = oO(
          o,
          S,
          n,
          Gg,
          null,
          !1,
          !1,
          "",
          DO
        );
        n._reactRootContainer = j, lt(j.current, n);
        var J = n.nodeType === Oi ? n.parentNode : n;
        return Yc(J), y0(), j;
      } else {
        for (var ne; ne = n.lastChild; )
          n.removeChild(ne);
        if (typeof S == "function") {
          var Se = S;
          S = function() {
            var et = r2(Ce);
            Se.call(et);
          };
        }
        var Ce = sO(
          n,
          Gg,
          null,
          !1,
          !1,
          "",
          DO
        );
        n._reactRootContainer = Ce, lt(Ce.current, n);
        var nt = n.nodeType === Oi ? n.parentNode : n;
        return Yc(nt), y0(function() {
          qE(o, Ce, m, S);
        }), Ce;
      }
    }
    function v5(n, o) {
      n !== null && typeof n != "function" && l("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", o, n);
    }
    function s2(n, o, m, S, C) {
      AO(m), v5(C === void 0 ? null : C, "render");
      var F = m._reactRootContainer, j;
      if (!F)
        j = m5(m, o, n, C, S);
      else {
        if (j = F, typeof C == "function") {
          var J = C;
          C = function() {
            var ne = r2(j);
            J.call(ne);
          };
        }
        qE(o, j, n, C);
      }
      return r2(j);
    }
    function g5(n) {
      {
        var o = p5.current;
        if (o !== null && o.stateNode !== null) {
          var m = o.stateNode._warnedAboutRefsInRender;
          m || l("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", Ci(o.type) || "A component"), o.stateNode._warnedAboutRefsInRender = !0;
        }
      }
      return n == null ? null : n.nodeType === zl ? n : t5(n, "findDOMNode");
    }
    function y5(n, o, m) {
      if (l("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !QE(o))
        throw new Error("Target container is not a DOM element.");
      {
        var S = Kt(o) && o._reactRootContainer === void 0;
        S && l("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
      }
      return s2(null, n, o, !0, m);
    }
    function x5(n, o, m) {
      if (l("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !QE(o))
        throw new Error("Target container is not a DOM element.");
      {
        var S = Kt(o) && o._reactRootContainer === void 0;
        S && l("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
      }
      return s2(null, n, o, !1, m);
    }
    function _5(n, o, m, S) {
      if (l("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !QE(m))
        throw new Error("Target container is not a DOM element.");
      if (n == null || !ka(n))
        throw new Error("parentComponent must be a valid React Component");
      return s2(n, o, m, !1, S);
    }
    function S5(n) {
      if (!QE(n))
        throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
      {
        var o = Kt(n) && n._reactRootContainer === void 0;
        o && l("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
      }
      if (n._reactRootContainer) {
        {
          var m = wA(n), S = m && !Cn(m);
          S && l("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
        }
        return y0(function() {
          s2(null, null, n, !1, function() {
            n._reactRootContainer = null, nn(n);
          });
        }), !0;
      } else {
        {
          var C = wA(n), F = !!(C && Cn(C)), j = n.nodeType === zl && QE(n.parentNode) && !!n.parentNode._reactRootContainer;
          F && l("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", j ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
        }
        return !1;
      }
    }
    Kn(n5), z0(r5), op(i5), Sy(pc), Qp(sp), (typeof Map != "function" || Map.prototype == null || typeof Map.prototype.forEach != "function" || typeof Set != "function" || Set.prototype == null || typeof Set.prototype.clear != "function" || typeof Set.prototype.forEach != "function") && l("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), ac(y1), Gd($R, hB, y0);
    function w5(n, o) {
      var m = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (!a2(o))
        throw new Error("Target container is not a DOM element.");
      return e5(n, o, null, m);
    }
    function b5(n, o, m, S) {
      return _5(n, o, m, S);
    }
    var bA = {
      usingClientEntryPoint: !1,
      Events: [Cn, On, dr, Pu, _f, $R]
    };
    function E5(n, o) {
      return bA.usingClientEntryPoint || l('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), f5(n, o);
    }
    function M5(n, o, m) {
      return bA.usingClientEntryPoint || l('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), h5(n, o, m);
    }
    function T5(n) {
      return IP() && l("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."), y0(n);
    }
    var C5 = c5({
      findFiberByHostInstance: on,
      bundleType: 1,
      version: vA,
      rendererPackageName: "react-dom"
    });
    if (!C5 && qe && window.top === window.self && (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1)) {
      var LO = window.location.protocol;
      /^(https?|file):$/.test(LO) && console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (LO === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq` : ""), "font-weight:bold");
    }
    Op.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = bA, Op.createPortal = w5, Op.createRoot = E5, Op.findDOMNode = g5, Op.flushSync = T5, Op.hydrate = y5, Op.hydrateRoot = M5, Op.render = x5, Op.unmountComponentAtNode = S5, Op.unstable_batchedUpdates = $R, Op.unstable_renderSubtreeIntoContainer = b5, Op.version = vA, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), Op;
}
(function(a) {
  function e() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("^_^");
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (t) {
        console.error(t);
      }
    }
  }
  process.env.NODE_ENV === "production" ? (e(), a.exports = gj()) : a.exports = yj();
})(Zk);
var A3, K2 = Zk.exports;
if (process.env.NODE_ENV === "production")
  A3 = K2.createRoot, K2.hydrateRoot;
else {
  var Rz = K2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  A3 = function(a, e) {
    Rz.usingClientEntryPoint = !0;
    try {
      return K2.createRoot(a, e);
    } finally {
      Rz.usingClientEntryPoint = !1;
    }
  };
}
const aT = new ge(), EL = new ge(), xj = new ge();
function _j(a, e, t) {
  const r = aT.setFromMatrixPosition(a.matrixWorld);
  r.project(e);
  const i = t.width / 2, s = t.height / 2;
  return [r.x * i + i, -(r.y * s) + s];
}
function Sj(a, e) {
  const t = aT.setFromMatrixPosition(a.matrixWorld), r = EL.setFromMatrixPosition(e.matrixWorld), i = t.sub(r), s = e.getWorldDirection(xj);
  return i.angleTo(s) > Math.PI / 2;
}
function wj(a, e, t, r) {
  const i = aT.setFromMatrixPosition(a.matrixWorld), s = i.clone();
  s.project(e), t.setFromCamera(s, e);
  const l = t.intersectObjects(r, !0);
  if (l.length) {
    const d = l[0].distance;
    return i.distanceTo(t.ray.origin) < d;
  }
  return !0;
}
function bj(a, e) {
  if (e instanceof dy)
    return e.zoom;
  if (e instanceof ho) {
    const t = aT.setFromMatrixPosition(a.matrixWorld), r = EL.setFromMatrixPosition(e.matrixWorld), i = e.fov * Math.PI / 180, s = t.distanceTo(r), l = 2 * Math.tan(i / 2) * s;
    return 1 / l;
  } else
    return 1;
}
function Ej(a, e, t) {
  if (e instanceof ho || e instanceof dy) {
    const r = aT.setFromMatrixPosition(a.matrixWorld), i = EL.setFromMatrixPosition(e.matrixWorld), s = r.distanceTo(i), l = (t[1] - t[0]) / (e.far - e.near), d = t[1] - l * e.far;
    return Math.round(l * s + d);
  }
}
const D3 = (a) => Math.abs(a) < 1e-10 ? 0 : a;
function Kk(a, e, t = "") {
  let r = "matrix3d(";
  for (let i = 0; i !== 16; i++)
    r += D3(e[i] * a.elements[i]) + (i !== 15 ? "," : ")");
  return t + r;
}
const Mj = ((a) => (e) => Kk(e, a))([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]), Tj = ((a) => (e, t) => Kk(e, a(t), "translate(-50%,-50%)"))((a) => [1 / a, 1 / a, 1 / a, 1, -1 / a, -1 / a, -1 / a, -1, 1 / a, 1 / a, 1 / a, 1, 1, 1, 1, 1]);
function Cj(a) {
  return a && typeof a == "object" && "current" in a;
}
const $k = /* @__PURE__ */ Ln.forwardRef(({
  children: a,
  eps: e = 1e-3,
  style: t,
  className: r,
  prepend: i,
  center: s,
  fullscreen: l,
  portal: d,
  distanceFactor: p,
  sprite: g = !1,
  transform: _ = !1,
  occlude: w,
  onOcclude: T,
  castShadow: R,
  receiveShadow: D,
  material: O,
  geometry: U,
  zIndexRange: H = [16777271, 0],
  calculatePosition: I = _j,
  as: G = "div",
  wrapperClass: B,
  pointerEvents: Q = "auto",
  ...K
}, te) => {
  const {
    gl: Y,
    camera: re,
    scene: se,
    size: ce,
    raycaster: ue,
    events: Me,
    viewport: me
  } = jf(), [De] = Ln.useState(() => document.createElement(G)), Re = Ln.useRef(), He = Ln.useRef(null), ve = Ln.useRef(0), fe = Ln.useRef([0, 0]), he = Ln.useRef(null), ye = Ln.useRef(null), Ee = (d == null ? void 0 : d.current) || Me.connected || Y.domElement.parentNode, Ve = Ln.useRef(null), Je = Ln.useRef(!1), rt = Ln.useMemo(() => w && w !== "blending" || Array.isArray(w) && w.length && Cj(w[0]), [w]);
  Ln.useLayoutEffect(() => {
    const gt = Y.domElement;
    w && w === "blending" ? (gt.style.zIndex = `${Math.floor(H[0] / 2)}`, gt.style.position = "absolute", gt.style.pointerEvents = "none") : (gt.style.zIndex = null, gt.style.position = null, gt.style.pointerEvents = null);
  }, [w]), Ln.useLayoutEffect(() => {
    if (He.current) {
      const gt = Re.current = A3(De);
      if (se.updateMatrixWorld(), _)
        De.style.cssText = "position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";
      else {
        const ft = I(He.current, re, ce);
        De.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${ft[0]}px,${ft[1]}px,0);transform-origin:0 0;`;
      }
      return Ee && (i ? Ee.prepend(De) : Ee.appendChild(De)), () => {
        Ee && Ee.removeChild(De), gt.unmount();
      };
    }
  }, [Ee, _]), Ln.useLayoutEffect(() => {
    B && (De.className = B);
  }, [B]);
  const Ne = Ln.useMemo(() => _ ? {
    position: "absolute",
    top: 0,
    left: 0,
    width: ce.width,
    height: ce.height,
    transformStyle: "preserve-3d",
    pointerEvents: "none"
  } : {
    position: "absolute",
    transform: s ? "translate3d(-50%,-50%,0)" : "none",
    ...l && {
      top: -ce.height / 2,
      left: -ce.width / 2,
      width: ce.width,
      height: ce.height
    },
    ...t
  }, [t, s, l, ce, _]), ct = Ln.useMemo(() => ({
    position: "absolute",
    pointerEvents: Q
  }), [Q]);
  Ln.useLayoutEffect(() => {
    if (Je.current = !1, _) {
      var gt;
      (gt = Re.current) == null || gt.render(
        /* @__PURE__ */ ln("div", {
          ref: he,
          style: Ne,
          children: /* @__PURE__ */ ln("div", {
            ref: ye,
            style: ct,
            children: /* @__PURE__ */ ln("div", {
              ref: te,
              className: r,
              style: t,
              children: a
            })
          })
        })
      );
    } else {
      var ft;
      (ft = Re.current) == null || ft.render(
        /* @__PURE__ */ ln("div", {
          ref: te,
          style: Ne,
          className: r,
          children: a
        })
      );
    }
  });
  const tt = Ln.useRef(!0);
  Am((gt) => {
    if (He.current) {
      re.updateMatrixWorld(), He.current.updateWorldMatrix(!0, !1);
      const ft = _ ? fe.current : I(He.current, re, ce);
      if (_ || Math.abs(ve.current - re.zoom) > e || Math.abs(fe.current[0] - ft[0]) > e || Math.abs(fe.current[1] - ft[1]) > e) {
        const Ie = Sj(He.current, re);
        let qe = !1;
        rt && (w !== "blending" ? qe = [se] : Array.isArray(w) && (qe = w.map((Vt) => Vt.current)));
        const dt = tt.current;
        if (qe) {
          const Vt = wj(He.current, re, ue, qe);
          tt.current = Vt && !Ie;
        } else
          tt.current = !Ie;
        dt !== tt.current && (T ? T(!tt.current) : De.style.display = tt.current ? "block" : "none");
        const ht = Math.floor(H[0] / 2), xt = w ? rt ? [H[0], ht] : [ht - 1, 0] : H;
        if (De.style.zIndex = `${Ej(He.current, re, xt)}`, _) {
          const [Vt, yt] = [ce.width / 2, ce.height / 2], Nt = re.projectionMatrix.elements[5] * yt, {
            isOrthographicCamera: Zt,
            top: Rt,
            left: we,
            bottom: oe,
            right: Qe
          } = re, ut = Mj(re.matrixWorldInverse), Ft = Zt ? `scale(${Nt})translate(${D3(-(Qe + we) / 2)}px,${D3((Rt + oe) / 2)}px)` : `translateZ(${Nt}px)`;
          let Ot = He.current.matrixWorld;
          g && (Ot = re.matrixWorldInverse.clone().transpose().copyPosition(Ot).scale(He.current.scale), Ot.elements[3] = Ot.elements[7] = Ot.elements[11] = 0, Ot.elements[15] = 1), De.style.width = ce.width + "px", De.style.height = ce.height + "px", De.style.perspective = Zt ? "" : `${Nt}px`, he.current && ye.current && (he.current.style.transform = `${Ft}${ut}translate(${Vt}px,${yt}px)`, ye.current.style.transform = Tj(Ot, 1 / ((p || 10) / 400)));
        } else {
          const Vt = p === void 0 ? 1 : bj(He.current, re) * p;
          De.style.transform = `translate3d(${ft[0]}px,${ft[1]}px,0) scale(${Vt})`;
        }
        fe.current = ft, ve.current = re.zoom;
      }
    }
    if (!rt && Ve.current && !Je.current)
      if (_) {
        if (he.current) {
          const ft = he.current.children[0];
          if (ft != null && ft.clientWidth && ft != null && ft.clientHeight) {
            const {
              isOrthographicCamera: Ie
            } = re;
            if (Ie || U)
              K.scale && (Array.isArray(K.scale) ? K.scale instanceof ge ? Ve.current.scale.copy(K.scale.clone().divideScalar(1)) : Ve.current.scale.set(1 / K.scale[0], 1 / K.scale[1], 1 / K.scale[2]) : Ve.current.scale.setScalar(1 / K.scale));
            else {
              const qe = (p || 10) / 400, dt = ft.clientWidth * qe, ht = ft.clientHeight * qe;
              Ve.current.scale.set(dt, ht, 1);
            }
            Je.current = !0;
          }
        }
      } else {
        const ft = De.children[0];
        if (ft != null && ft.clientWidth && ft != null && ft.clientHeight) {
          const Ie = 1 / me.factor, qe = ft.clientWidth * Ie, dt = ft.clientHeight * Ie;
          Ve.current.scale.set(qe, dt, 1), Je.current = !0;
        }
        Ve.current.lookAt(gt.camera.position);
      }
  });
  const Tt = Ln.useMemo(() => ({
    vertexShader: _ ? void 0 : `
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom" 
            is false. 
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;
            
            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,
    fragmentShader: `
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `
  }), [_]);
  return /* @__PURE__ */ ln("group", {
    ...K,
    ref: He,
    children: w && !rt && /* @__PURE__ */ _c("mesh", {
      castShadow: R,
      receiveShadow: D,
      ref: Ve,
      children: [U || /* @__PURE__ */ ln("planeGeometry", {}), O || /* @__PURE__ */ ln("shaderMaterial", {
        side: Yh,
        vertexShader: Tt.vertexShader,
        fragmentShader: Tt.fragmentShader
      })]
    })
  });
});
function ML(a) {
  return function(e) {
    a.forEach(function(t) {
      typeof t == "function" ? t(e) : t != null && (t.current = e);
    });
  };
}
const gC = 0, Rj = 1, Aj = new ge(), Az = new SL(), xD = new R0(), Dz = new ge(), $2 = new wm();
class Lz {
  constructor() {
    this.tolerance = -1, this.faces = [], this.newFaces = [], this.assigned = new Pz(), this.unassigned = new Pz(), this.vertices = [];
  }
  setFromPoints(e) {
    if (e.length >= 4) {
      this.makeEmpty();
      for (let t = 0, r = e.length; t < r; t++)
        this.vertices.push(new Dj(e[t]));
      this.compute();
    }
    return this;
  }
  setFromObject(e) {
    const t = [];
    return e.updateMatrixWorld(!0), e.traverse(function(r) {
      const i = r.geometry;
      if (i !== void 0) {
        if (i.isGeometry) {
          console.error("THREE.ConvexHull no longer supports Geometry. Use THREE.BufferGeometry instead.");
          return;
        } else if (i.isBufferGeometry) {
          const s = i.attributes.position;
          if (s !== void 0)
            for (let l = 0, d = s.count; l < d; l++) {
              const p = new ge();
              p.fromBufferAttribute(s, l).applyMatrix4(r.matrixWorld), t.push(p);
            }
        }
      }
    }), this.setFromPoints(t);
  }
  containsPoint(e) {
    const t = this.faces;
    for (let r = 0, i = t.length; r < i; r++)
      if (t[r].distanceToPoint(e) > this.tolerance)
        return !1;
    return !0;
  }
  intersectRay(e, t) {
    const r = this.faces;
    let i = -1 / 0, s = 1 / 0;
    for (let l = 0, d = r.length; l < d; l++) {
      const p = r[l], g = p.distanceToPoint(e.origin), _ = p.normal.dot(e.direction);
      if (g > 0 && _ >= 0)
        return null;
      const w = _ !== 0 ? -g / _ : 0;
      if (!(w <= 0) && (_ > 0 ? s = Math.min(w, s) : i = Math.max(w, i), i > s))
        return null;
    }
    return i !== -1 / 0 ? e.at(i, t) : e.at(s, t), t;
  }
  intersectsRay(e) {
    return this.intersectRay(e, Aj) !== null;
  }
  makeEmpty() {
    return this.faces = [], this.vertices = [], this;
  }
  addVertexToFace(e, t) {
    return e.face = t, t.outside === null ? this.assigned.append(e) : this.assigned.insertBefore(t.outside, e), t.outside = e, this;
  }
  removeVertexFromFace(e, t) {
    return e === t.outside && (e.next !== null && e.next.face === t ? t.outside = e.next : t.outside = null), this.assigned.remove(e), this;
  }
  removeAllVerticesFromFace(e) {
    if (e.outside !== null) {
      const t = e.outside;
      let r = e.outside;
      for (; r.next !== null && r.next.face === e; )
        r = r.next;
      return this.assigned.removeSubList(t, r), t.prev = r.next = null, e.outside = null, t;
    }
  }
  deleteFaceVertices(e, t) {
    const r = this.removeAllVerticesFromFace(e);
    if (r !== void 0)
      if (t === void 0)
        this.unassigned.appendChain(r);
      else {
        let i = r;
        do {
          const s = i.next;
          t.distanceToPoint(i.point) > this.tolerance ? this.addVertexToFace(i, t) : this.unassigned.append(i), i = s;
        } while (i !== null);
      }
    return this;
  }
  resolveUnassignedPoints(e) {
    if (this.unassigned.isEmpty() === !1) {
      let t = this.unassigned.first();
      do {
        const r = t.next;
        let i = this.tolerance, s = null;
        for (let l = 0; l < e.length; l++) {
          const d = e[l];
          if (d.mark === gC) {
            const p = d.distanceToPoint(t.point);
            if (p > i && (i = p, s = d), i > 1e3 * this.tolerance)
              break;
          }
        }
        s !== null && this.addVertexToFace(t, s), t = r;
      } while (t !== null);
    }
    return this;
  }
  computeExtremes() {
    const e = new ge(), t = new ge(), r = [], i = [];
    for (let s = 0; s < 3; s++)
      r[s] = i[s] = this.vertices[0];
    e.copy(this.vertices[0].point), t.copy(this.vertices[0].point);
    for (let s = 0, l = this.vertices.length; s < l; s++) {
      const d = this.vertices[s], p = d.point;
      for (let g = 0; g < 3; g++)
        p.getComponent(g) < e.getComponent(g) && (e.setComponent(g, p.getComponent(g)), r[g] = d);
      for (let g = 0; g < 3; g++)
        p.getComponent(g) > t.getComponent(g) && (t.setComponent(g, p.getComponent(g)), i[g] = d);
    }
    return this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(e.x), Math.abs(t.x)) + Math.max(Math.abs(e.y), Math.abs(t.y)) + Math.max(Math.abs(e.z), Math.abs(t.z))), {
      min: r,
      max: i
    };
  }
  computeInitialHull() {
    const e = this.vertices, t = this.computeExtremes(), r = t.min, i = t.max;
    let s = 0, l = 0;
    for (let T = 0; T < 3; T++) {
      const R = i[T].point.getComponent(T) - r[T].point.getComponent(T);
      R > s && (s = R, l = T);
    }
    const d = r[l], p = i[l];
    let g, _;
    s = 0, Az.set(d.point, p.point);
    for (let T = 0, R = this.vertices.length; T < R; T++) {
      const D = e[T];
      if (D !== d && D !== p) {
        Az.closestPointToPoint(D.point, !0, Dz);
        const O = Dz.distanceToSquared(D.point);
        O > s && (s = O, g = D);
      }
    }
    s = -1, xD.setFromCoplanarPoints(d.point, p.point, g.point);
    for (let T = 0, R = this.vertices.length; T < R; T++) {
      const D = e[T];
      if (D !== d && D !== p && D !== g) {
        const O = Math.abs(xD.distanceToPoint(D.point));
        O > s && (s = O, _ = D);
      }
    }
    const w = [];
    if (xD.distanceToPoint(_.point) < 0) {
      w.push(ig.create(d, p, g), ig.create(_, p, d), ig.create(_, g, p), ig.create(_, d, g));
      for (let T = 0; T < 3; T++) {
        const R = (T + 1) % 3;
        w[T + 1].getEdge(2).setTwin(w[0].getEdge(R)), w[T + 1].getEdge(1).setTwin(w[R + 1].getEdge(0));
      }
    } else {
      w.push(ig.create(d, g, p), ig.create(_, d, p), ig.create(_, p, g), ig.create(_, g, d));
      for (let T = 0; T < 3; T++) {
        const R = (T + 1) % 3;
        w[T + 1].getEdge(2).setTwin(w[0].getEdge((3 - T) % 3)), w[T + 1].getEdge(0).setTwin(w[R + 1].getEdge(1));
      }
    }
    for (let T = 0; T < 4; T++)
      this.faces.push(w[T]);
    for (let T = 0, R = e.length; T < R; T++) {
      const D = e[T];
      if (D !== d && D !== p && D !== g && D !== _) {
        s = this.tolerance;
        let O = null;
        for (let U = 0; U < 4; U++) {
          const H = this.faces[U].distanceToPoint(D.point);
          H > s && (s = H, O = this.faces[U]);
        }
        O !== null && this.addVertexToFace(D, O);
      }
    }
    return this;
  }
  reindexFaces() {
    const e = [];
    for (let t = 0; t < this.faces.length; t++) {
      const r = this.faces[t];
      r.mark === gC && e.push(r);
    }
    return this.faces = e, this;
  }
  nextVertexToAdd() {
    if (this.assigned.isEmpty() === !1) {
      let e, t = 0;
      const r = this.assigned.first().face;
      let i = r.outside;
      do {
        const s = r.distanceToPoint(i.point);
        s > t && (t = s, e = i), i = i.next;
      } while (i !== null && i.face === r);
      return e;
    }
  }
  computeHorizon(e, t, r, i) {
    this.deleteFaceVertices(r), r.mark = Rj;
    let s;
    t === null ? s = t = r.getEdge(0) : s = t.next;
    do {
      const l = s.twin, d = l.face;
      d.mark === gC && (d.distanceToPoint(e) > this.tolerance ? this.computeHorizon(e, l, d, i) : i.push(s)), s = s.next;
    } while (s !== t);
    return this;
  }
  addAdjoiningFace(e, t) {
    const r = ig.create(e, t.tail(), t.head());
    return this.faces.push(r), r.getEdge(-1).setTwin(t.twin), r.getEdge(0);
  }
  addNewFaces(e, t) {
    this.newFaces = [];
    let r = null, i = null;
    for (let s = 0; s < t.length; s++) {
      const l = t[s], d = this.addAdjoiningFace(e, l);
      r === null ? r = d : d.next.setTwin(i), this.newFaces.push(d.face), i = d;
    }
    return r.next.setTwin(i), this;
  }
  addVertexToHull(e) {
    const t = [];
    return this.unassigned.clear(), this.removeVertexFromFace(e, e.face), this.computeHorizon(e.point, null, e.face, t), this.addNewFaces(e, t), this.resolveUnassignedPoints(this.newFaces), this;
  }
  cleanup() {
    return this.assigned.clear(), this.unassigned.clear(), this.newFaces = [], this;
  }
  compute() {
    let e;
    for (this.computeInitialHull(); (e = this.nextVertexToAdd()) !== void 0; )
      this.addVertexToHull(e);
    return this.reindexFaces(), this.cleanup(), this;
  }
}
class ig {
  constructor() {
    this.normal = new ge(), this.midpoint = new ge(), this.area = 0, this.constant = 0, this.outside = null, this.mark = gC, this.edge = null;
  }
  static create(e, t, r) {
    const i = new ig(), s = new _D(e, i), l = new _D(t, i), d = new _D(r, i);
    return s.next = d.prev = l, l.next = s.prev = d, d.next = l.prev = s, i.edge = s, i.compute();
  }
  getEdge(e) {
    let t = this.edge;
    for (; e > 0; )
      t = t.next, e--;
    for (; e < 0; )
      t = t.prev, e++;
    return t;
  }
  compute() {
    const e = this.edge.tail(), t = this.edge.head(), r = this.edge.next.head();
    return $2.set(e.point, t.point, r.point), $2.getNormal(this.normal), $2.getMidpoint(this.midpoint), this.area = $2.getArea(), this.constant = this.normal.dot(this.midpoint), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) - this.constant;
  }
}
class _D {
  constructor(e, t) {
    this.vertex = e, this.prev = null, this.next = null, this.twin = null, this.face = t;
  }
  head() {
    return this.vertex;
  }
  tail() {
    return this.prev ? this.prev.vertex : null;
  }
  length() {
    const e = this.head(), t = this.tail();
    return t !== null ? t.point.distanceTo(e.point) : -1;
  }
  lengthSquared() {
    const e = this.head(), t = this.tail();
    return t !== null ? t.point.distanceToSquared(e.point) : -1;
  }
  setTwin(e) {
    return this.twin = e, e.twin = this, this;
  }
}
class Dj {
  constructor(e) {
    this.point = e, this.prev = null, this.next = null, this.face = null;
  }
}
class Pz {
  constructor() {
    this.head = null, this.tail = null;
  }
  first() {
    return this.head;
  }
  last() {
    return this.tail;
  }
  clear() {
    return this.head = this.tail = null, this;
  }
  insertBefore(e, t) {
    return t.prev = e.prev, t.next = e, t.prev === null ? this.head = t : t.prev.next = t, e.prev = t, this;
  }
  insertAfter(e, t) {
    return t.prev = e, t.next = e.next, t.next === null ? this.tail = t : t.next.prev = t, e.next = t, this;
  }
  append(e) {
    return this.head === null ? this.head = e : this.tail.next = e, e.prev = this.tail, e.next = null, this.tail = e, this;
  }
  appendChain(e) {
    for (this.head === null ? this.head = e : this.tail.next = e, e.prev = this.tail; e.next !== null; )
      e = e.next;
    return this.tail = e, this;
  }
  remove(e) {
    return e.prev === null ? this.head = e.next : e.prev.next = e.next, e.next === null ? this.tail = e.prev : e.next.prev = e.prev, this;
  }
  removeSubList(e, t) {
    return e.prev === null ? this.head = t.next : e.prev.next = t.next, t.next === null ? this.tail = e.prev : t.next.prev = e.prev, this;
  }
  isEmpty() {
    return this.head === null;
  }
}
class Oz extends oi {
  constructor(e = []) {
    super();
    const t = [], r = [];
    Lz === void 0 && console.error("THREE.ConvexGeometry: ConvexGeometry relies on ConvexHull");
    const s = new Lz().setFromPoints(e).faces;
    for (let l = 0; l < s.length; l++) {
      const d = s[l];
      let p = d.edge;
      do {
        const g = p.head().point;
        t.push(g.x, g.y, g.z), r.push(d.normal.x, d.normal.y, d.normal.z), p = p.next;
      } while (p !== d.edge);
    }
    this.setAttribute("position", new sr(t, 3)), this.setAttribute("normal", new sr(r, 3));
  }
}
function Pi(a, e, t) {
  return e in a ? Object.defineProperty(a, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : a[e] = t, a;
}
const e4 = (a, e) => {
  const t = a[0].index !== null, r = new Set(Object.keys(a[0].attributes)), i = new Set(Object.keys(a[0].morphAttributes)), s = {}, l = {}, d = a[0].morphTargetsRelative, p = new oi();
  let g = 0;
  if (a.forEach((_, w) => {
    let T = 0;
    if (t !== (_.index !== null))
      return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + w + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."), null;
    for (let R in _.attributes) {
      if (!r.has(R))
        return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + w + '. All geometries must have compatible attributes; make sure "' + R + '" attribute exists among all geometries, or in none of them.'), null;
      s[R] === void 0 && (s[R] = []), s[R].push(_.attributes[R]), T++;
    }
    if (T !== r.size)
      return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + w + ". Make sure all geometries have the same number of attributes."), null;
    if (d !== _.morphTargetsRelative)
      return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + w + ". .morphTargetsRelative must be consistent throughout all geometries."), null;
    for (let R in _.morphAttributes) {
      if (!i.has(R))
        return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + w + ".  .morphAttributes must be consistent throughout all geometries."), null;
      l[R] === void 0 && (l[R] = []), l[R].push(_.morphAttributes[R]);
    }
    if (p.userData.mergedUserData = p.userData.mergedUserData || [], p.userData.mergedUserData.push(_.userData), e) {
      let R;
      if (_.index)
        R = _.index.count;
      else if (_.attributes.position !== void 0)
        R = _.attributes.position.count;
      else
        return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + w + ". The geometry must have either an index or a position attribute"), null;
      p.addGroup(g, R, w), g += R;
    }
  }), t) {
    let _ = 0;
    const w = [];
    a.forEach((T) => {
      const R = T.index;
      for (let D = 0; D < R.count; ++D)
        w.push(R.getX(D) + _);
      _ += T.attributes.position.count;
    }), p.setIndex(w);
  }
  for (let _ in s) {
    const w = Uz(s[_]);
    if (!w)
      return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " + _ + " attribute."), null;
    p.setAttribute(_, w);
  }
  for (let _ in l) {
    const w = l[_][0].length;
    if (w === 0)
      break;
    p.morphAttributes = p.morphAttributes || {}, p.morphAttributes[_] = [];
    for (let T = 0; T < w; ++T) {
      const R = [];
      for (let O = 0; O < l[_].length; ++O)
        R.push(l[_][O][T]);
      const D = Uz(R);
      if (!D)
        return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " + _ + " morphAttribute."), null;
      p.morphAttributes[_].push(D);
    }
  }
  return p;
}, Uz = (a) => {
  let e, t, r, i = 0;
  if (a.forEach((s) => {
    if (e === void 0 && (e = s.array.constructor), e !== s.array.constructor)
      return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."), null;
    if (t === void 0 && (t = s.itemSize), t !== s.itemSize)
      return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."), null;
    if (r === void 0 && (r = s.normalized), r !== s.normalized)
      return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."), null;
    i += s.array.length;
  }), e && t) {
    const s = new e(i);
    let l = 0;
    return a.forEach((d) => {
      s.set(d.array, l), l += d.array.length;
    }), new ls(s, t, r);
  }
}, zz = (a, e) => (a % e + e) % e;
class Lj extends Cm {
  constructor(e, t) {
    super(), Pi(this, "object", void 0), Pi(this, "domElement", void 0), Pi(this, "enabled", !0), Pi(this, "target", new ge()), Pi(this, "minDistance", 0), Pi(this, "maxDistance", 1 / 0), Pi(this, "minZoom", 0), Pi(this, "maxZoom", 1 / 0), Pi(this, "minPolarAngle", 0), Pi(this, "maxPolarAngle", Math.PI), Pi(this, "minAzimuthAngle", -1 / 0), Pi(this, "maxAzimuthAngle", 1 / 0), Pi(this, "enableDamping", !1), Pi(this, "dampingFactor", 0.05), Pi(this, "enableZoom", !0), Pi(this, "zoomSpeed", 1), Pi(this, "enableRotate", !0), Pi(this, "rotateSpeed", 1), Pi(this, "enablePan", !0), Pi(this, "panSpeed", 1), Pi(this, "screenSpacePanning", !0), Pi(this, "keyPanSpeed", 7), Pi(this, "autoRotate", !1), Pi(this, "autoRotateSpeed", 2), Pi(this, "reverseOrbit", !1), Pi(this, "keys", {
      LEFT: "ArrowLeft",
      UP: "ArrowUp",
      RIGHT: "ArrowRight",
      BOTTOM: "ArrowDown"
    }), Pi(this, "mouseButtons", {
      LEFT: T_.ROTATE,
      MIDDLE: T_.DOLLY,
      RIGHT: T_.PAN
    }), Pi(this, "touches", {
      ONE: C_.ROTATE,
      TWO: C_.DOLLY_PAN
    }), Pi(this, "target0", void 0), Pi(this, "position0", void 0), Pi(this, "zoom0", void 0), Pi(this, "_domElementKeyEvents", null), Pi(this, "getPolarAngle", void 0), Pi(this, "getAzimuthalAngle", void 0), Pi(this, "setPolarAngle", void 0), Pi(this, "setAzimuthalAngle", void 0), Pi(this, "getDistance", void 0), Pi(this, "listenToKeyEvents", void 0), Pi(this, "saveState", void 0), Pi(this, "reset", void 0), Pi(this, "update", void 0), Pi(this, "connect", void 0), Pi(this, "dispose", void 0), this.object = e, this.domElement = t, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object instanceof ho ? this.object.zoom : 1, this.getPolarAngle = () => _.phi, this.getAzimuthalAngle = () => _.theta, this.setPolarAngle = (pe) => {
      let Fe = zz(pe, 2 * Math.PI), at = _.phi;
      at < 0 && (at += 2 * Math.PI), Fe < 0 && (Fe += 2 * Math.PI);
      let st = Math.abs(Fe - at);
      2 * Math.PI - st < st && (Fe < at ? Fe += 2 * Math.PI : at += 2 * Math.PI), w.phi = Fe - at, r.update();
    }, this.setAzimuthalAngle = (pe) => {
      let Fe = zz(pe, 2 * Math.PI), at = _.theta;
      at < 0 && (at += 2 * Math.PI), Fe < 0 && (Fe += 2 * Math.PI);
      let st = Math.abs(Fe - at);
      2 * Math.PI - st < st && (Fe < at ? Fe += 2 * Math.PI : at += 2 * Math.PI), w.theta = Fe - at, r.update();
    }, this.getDistance = () => r.object.position.distanceTo(r.target), this.listenToKeyEvents = (pe) => {
      pe.addEventListener("keydown", Qe), this._domElementKeyEvents = pe;
    }, this.saveState = () => {
      r.target0.copy(r.target), r.position0.copy(r.object.position), r.zoom0 = r.object instanceof ho ? r.object.zoom : 1;
    }, this.reset = () => {
      r.target.copy(r.target0), r.object.position.copy(r.position0), r.object instanceof ho && (r.object.zoom = r.zoom0, r.object.updateProjectionMatrix()), r.dispatchEvent(i), r.update(), p = d.NONE;
    }, this.update = (() => {
      const pe = new ge(), Fe = new Po().setFromUnitVectors(e.up, new ge(0, 1, 0)), at = Fe.clone().invert(), st = new ge(), dn = new Po(), ze = 2 * Math.PI;
      return function() {
        const Pe = r.object.position;
        pe.copy(Pe).sub(r.target), pe.applyQuaternion(Fe), _.setFromVector3(pe), r.autoRotate && p === d.NONE && ue(se()), r.enableDamping ? (_.theta += w.theta * r.dampingFactor, _.phi += w.phi * r.dampingFactor) : (_.theta += w.theta, _.phi += w.phi);
        let Gt = r.minAzimuthAngle, At = r.maxAzimuthAngle;
        return isFinite(Gt) && isFinite(At) && (Gt < -Math.PI ? Gt += ze : Gt > Math.PI && (Gt -= ze), At < -Math.PI ? At += ze : At > Math.PI && (At -= ze), Gt <= At ? _.theta = Math.max(Gt, Math.min(At, _.theta)) : _.theta = _.theta > (Gt + At) / 2 ? Math.max(Gt, _.theta) : Math.min(At, _.theta)), _.phi = Math.max(r.minPolarAngle, Math.min(r.maxPolarAngle, _.phi)), _.makeSafe(), _.radius *= T, _.radius = Math.max(r.minDistance, Math.min(r.maxDistance, _.radius)), r.enableDamping === !0 ? r.target.addScaledVector(R, r.dampingFactor) : r.target.add(R), pe.setFromSpherical(_), pe.applyQuaternion(at), Pe.copy(r.target).add(pe), r.object.lookAt(r.target), r.enableDamping === !0 ? (w.theta *= 1 - r.dampingFactor, w.phi *= 1 - r.dampingFactor, R.multiplyScalar(1 - r.dampingFactor)) : (w.set(0, 0, 0), R.set(0, 0, 0)), T = 1, D || st.distanceToSquared(r.object.position) > g || 8 * (1 - dn.dot(r.object.quaternion)) > g ? (r.dispatchEvent(i), st.copy(r.object.position), dn.copy(r.object.quaternion), D = !1, !0) : !1;
      };
    })(), this.connect = (pe) => {
      pe === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'), r.domElement = pe, r.domElement.style.touchAction = "none", r.domElement.addEventListener("contextmenu", Ot), r.domElement.addEventListener("pointerdown", Vt), r.domElement.addEventListener("pointercancel", Zt), r.domElement.addEventListener("wheel", oe);
    }, this.dispose = () => {
      var pe, Fe, at, st, dn, ze;
      (pe = r.domElement) === null || pe === void 0 || pe.removeEventListener("contextmenu", Ot), (Fe = r.domElement) === null || Fe === void 0 || Fe.removeEventListener("pointerdown", Vt), (at = r.domElement) === null || at === void 0 || at.removeEventListener("pointercancel", Zt), (st = r.domElement) === null || st === void 0 || st.removeEventListener("wheel", oe), (dn = r.domElement) === null || dn === void 0 || dn.ownerDocument.removeEventListener("pointermove", yt), (ze = r.domElement) === null || ze === void 0 || ze.ownerDocument.removeEventListener("pointerup", Nt), r._domElementKeyEvents !== null && r._domElementKeyEvents.removeEventListener("keydown", Qe);
    };
    const r = this, i = {
      type: "change"
    }, s = {
      type: "start"
    }, l = {
      type: "end"
    }, d = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6
    };
    let p = d.NONE;
    const g = 1e-6, _ = new E3(), w = new E3();
    let T = 1;
    const R = new ge();
    let D = !1;
    const O = new zt(), U = new zt(), H = new zt(), I = new zt(), G = new zt(), B = new zt(), Q = new zt(), K = new zt(), te = new zt(), Y = [], re = {};
    function se() {
      return 2 * Math.PI / 60 / 60 * r.autoRotateSpeed;
    }
    function ce() {
      return Math.pow(0.95, r.zoomSpeed);
    }
    function ue(pe) {
      r.reverseOrbit ? w.theta += pe : w.theta -= pe;
    }
    function Me(pe) {
      r.reverseOrbit ? w.phi += pe : w.phi -= pe;
    }
    const me = (() => {
      const pe = new ge();
      return function(at, st) {
        pe.setFromMatrixColumn(st, 0), pe.multiplyScalar(-at), R.add(pe);
      };
    })(), De = (() => {
      const pe = new ge();
      return function(at, st) {
        r.screenSpacePanning === !0 ? pe.setFromMatrixColumn(st, 1) : (pe.setFromMatrixColumn(st, 0), pe.crossVectors(r.object.up, pe)), pe.multiplyScalar(at), R.add(pe);
      };
    })(), Re = (() => {
      const pe = new ge();
      return function(at, st) {
        const dn = r.domElement;
        if (dn && r.object instanceof ho && r.object.isPerspectiveCamera) {
          const ze = r.object.position;
          pe.copy(ze).sub(r.target);
          let wt = pe.length();
          wt *= Math.tan(r.object.fov / 2 * Math.PI / 180), me(2 * at * wt / dn.clientHeight, r.object.matrix), De(2 * st * wt / dn.clientHeight, r.object.matrix);
        } else
          dn && r.object instanceof dy && r.object.isOrthographicCamera ? (me(at * (r.object.right - r.object.left) / r.object.zoom / dn.clientWidth, r.object.matrix), De(st * (r.object.top - r.object.bottom) / r.object.zoom / dn.clientHeight, r.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), r.enablePan = !1);
      };
    })();
    function He(pe) {
      r.object instanceof ho && r.object.isPerspectiveCamera ? T /= pe : r.object instanceof dy && r.object.isOrthographicCamera ? (r.object.zoom = Math.max(r.minZoom, Math.min(r.maxZoom, r.object.zoom * pe)), r.object.updateProjectionMatrix(), D = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), r.enableZoom = !1);
    }
    function ve(pe) {
      r.object instanceof ho && r.object.isPerspectiveCamera ? T *= pe : r.object instanceof dy && r.object.isOrthographicCamera ? (r.object.zoom = Math.max(r.minZoom, Math.min(r.maxZoom, r.object.zoom / pe)), r.object.updateProjectionMatrix(), D = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), r.enableZoom = !1);
    }
    function fe(pe) {
      O.set(pe.clientX, pe.clientY);
    }
    function he(pe) {
      Q.set(pe.clientX, pe.clientY);
    }
    function ye(pe) {
      I.set(pe.clientX, pe.clientY);
    }
    function Ee(pe) {
      U.set(pe.clientX, pe.clientY), H.subVectors(U, O).multiplyScalar(r.rotateSpeed);
      const Fe = r.domElement;
      Fe && (ue(2 * Math.PI * H.x / Fe.clientHeight), Me(2 * Math.PI * H.y / Fe.clientHeight)), O.copy(U), r.update();
    }
    function Ve(pe) {
      K.set(pe.clientX, pe.clientY), te.subVectors(K, Q), te.y > 0 ? He(ce()) : te.y < 0 && ve(ce()), Q.copy(K), r.update();
    }
    function Je(pe) {
      G.set(pe.clientX, pe.clientY), B.subVectors(G, I).multiplyScalar(r.panSpeed), Re(B.x, B.y), I.copy(G), r.update();
    }
    function rt(pe) {
      pe.deltaY < 0 ? ve(ce()) : pe.deltaY > 0 && He(ce()), r.update();
    }
    function Ne(pe) {
      let Fe = !1;
      switch (pe.code) {
        case r.keys.UP:
          Re(0, r.keyPanSpeed), Fe = !0;
          break;
        case r.keys.BOTTOM:
          Re(0, -r.keyPanSpeed), Fe = !0;
          break;
        case r.keys.LEFT:
          Re(r.keyPanSpeed, 0), Fe = !0;
          break;
        case r.keys.RIGHT:
          Re(-r.keyPanSpeed, 0), Fe = !0;
          break;
      }
      Fe && (pe.preventDefault(), r.update());
    }
    function ct() {
      if (Y.length == 1)
        O.set(Y[0].pageX, Y[0].pageY);
      else {
        const pe = 0.5 * (Y[0].pageX + Y[1].pageX), Fe = 0.5 * (Y[0].pageY + Y[1].pageY);
        O.set(pe, Fe);
      }
    }
    function tt() {
      if (Y.length == 1)
        I.set(Y[0].pageX, Y[0].pageY);
      else {
        const pe = 0.5 * (Y[0].pageX + Y[1].pageX), Fe = 0.5 * (Y[0].pageY + Y[1].pageY);
        I.set(pe, Fe);
      }
    }
    function Tt() {
      const pe = Y[0].pageX - Y[1].pageX, Fe = Y[0].pageY - Y[1].pageY, at = Math.sqrt(pe * pe + Fe * Fe);
      Q.set(0, at);
    }
    function gt() {
      r.enableZoom && Tt(), r.enablePan && tt();
    }
    function ft() {
      r.enableZoom && Tt(), r.enableRotate && ct();
    }
    function Ie(pe) {
      if (Y.length == 1)
        U.set(pe.pageX, pe.pageY);
      else {
        const at = Be(pe), st = 0.5 * (pe.pageX + at.x), dn = 0.5 * (pe.pageY + at.y);
        U.set(st, dn);
      }
      H.subVectors(U, O).multiplyScalar(r.rotateSpeed);
      const Fe = r.domElement;
      Fe && (ue(2 * Math.PI * H.x / Fe.clientHeight), Me(2 * Math.PI * H.y / Fe.clientHeight)), O.copy(U);
    }
    function qe(pe) {
      if (Y.length == 1)
        G.set(pe.pageX, pe.pageY);
      else {
        const Fe = Be(pe), at = 0.5 * (pe.pageX + Fe.x), st = 0.5 * (pe.pageY + Fe.y);
        G.set(at, st);
      }
      B.subVectors(G, I).multiplyScalar(r.panSpeed), Re(B.x, B.y), I.copy(G);
    }
    function dt(pe) {
      const Fe = Be(pe), at = pe.pageX - Fe.x, st = pe.pageY - Fe.y, dn = Math.sqrt(at * at + st * st);
      K.set(0, dn), te.set(0, Math.pow(K.y / Q.y, r.zoomSpeed)), He(te.y), Q.copy(K);
    }
    function ht(pe) {
      r.enableZoom && dt(pe), r.enablePan && qe(pe);
    }
    function xt(pe) {
      r.enableZoom && dt(pe), r.enableRotate && Ie(pe);
    }
    function Vt(pe) {
      if (r.enabled !== !1) {
        if (Y.length === 0) {
          var Fe, at;
          (Fe = r.domElement) === null || Fe === void 0 || Fe.ownerDocument.addEventListener("pointermove", yt), (at = r.domElement) === null || at === void 0 || at.ownerDocument.addEventListener("pointerup", Nt);
        }
        Wt(pe), pe.pointerType === "touch" ? ut(pe) : Rt(pe);
      }
    }
    function yt(pe) {
      r.enabled !== !1 && (pe.pointerType === "touch" ? Ft(pe) : we(pe));
    }
    function Nt(pe) {
      if (it(pe), Y.length === 0) {
        var Fe, at, st;
        (Fe = r.domElement) === null || Fe === void 0 || Fe.releasePointerCapture(pe.pointerId), (at = r.domElement) === null || at === void 0 || at.ownerDocument.removeEventListener("pointermove", yt), (st = r.domElement) === null || st === void 0 || st.ownerDocument.removeEventListener("pointerup", Nt);
      }
      r.dispatchEvent(l), p = d.NONE;
    }
    function Zt(pe) {
      it(pe);
    }
    function Rt(pe) {
      let Fe;
      switch (pe.button) {
        case 0:
          Fe = r.mouseButtons.LEFT;
          break;
        case 1:
          Fe = r.mouseButtons.MIDDLE;
          break;
        case 2:
          Fe = r.mouseButtons.RIGHT;
          break;
        default:
          Fe = -1;
      }
      switch (Fe) {
        case T_.DOLLY:
          if (r.enableZoom === !1)
            return;
          he(pe), p = d.DOLLY;
          break;
        case T_.ROTATE:
          if (pe.ctrlKey || pe.metaKey || pe.shiftKey) {
            if (r.enablePan === !1)
              return;
            ye(pe), p = d.PAN;
          } else {
            if (r.enableRotate === !1)
              return;
            fe(pe), p = d.ROTATE;
          }
          break;
        case T_.PAN:
          if (pe.ctrlKey || pe.metaKey || pe.shiftKey) {
            if (r.enableRotate === !1)
              return;
            fe(pe), p = d.ROTATE;
          } else {
            if (r.enablePan === !1)
              return;
            ye(pe), p = d.PAN;
          }
          break;
        default:
          p = d.NONE;
      }
      p !== d.NONE && r.dispatchEvent(s);
    }
    function we(pe) {
      if (r.enabled !== !1)
        switch (p) {
          case d.ROTATE:
            if (r.enableRotate === !1)
              return;
            Ee(pe);
            break;
          case d.DOLLY:
            if (r.enableZoom === !1)
              return;
            Ve(pe);
            break;
          case d.PAN:
            if (r.enablePan === !1)
              return;
            Je(pe);
            break;
        }
    }
    function oe(pe) {
      r.enabled === !1 || r.enableZoom === !1 || p !== d.NONE && p !== d.ROTATE || (pe.preventDefault(), r.dispatchEvent(s), rt(pe), r.dispatchEvent(l));
    }
    function Qe(pe) {
      r.enabled === !1 || r.enablePan === !1 || Ne(pe);
    }
    function ut(pe) {
      switch (an(pe), Y.length) {
        case 1:
          switch (r.touches.ONE) {
            case C_.ROTATE:
              if (r.enableRotate === !1)
                return;
              ct(), p = d.TOUCH_ROTATE;
              break;
            case C_.PAN:
              if (r.enablePan === !1)
                return;
              tt(), p = d.TOUCH_PAN;
              break;
            default:
              p = d.NONE;
          }
          break;
        case 2:
          switch (r.touches.TWO) {
            case C_.DOLLY_PAN:
              if (r.enableZoom === !1 && r.enablePan === !1)
                return;
              gt(), p = d.TOUCH_DOLLY_PAN;
              break;
            case C_.DOLLY_ROTATE:
              if (r.enableZoom === !1 && r.enableRotate === !1)
                return;
              ft(), p = d.TOUCH_DOLLY_ROTATE;
              break;
            default:
              p = d.NONE;
          }
          break;
        default:
          p = d.NONE;
      }
      p !== d.NONE && r.dispatchEvent(s);
    }
    function Ft(pe) {
      switch (an(pe), p) {
        case d.TOUCH_ROTATE:
          if (r.enableRotate === !1)
            return;
          Ie(pe), r.update();
          break;
        case d.TOUCH_PAN:
          if (r.enablePan === !1)
            return;
          qe(pe), r.update();
          break;
        case d.TOUCH_DOLLY_PAN:
          if (r.enableZoom === !1 && r.enablePan === !1)
            return;
          ht(pe), r.update();
          break;
        case d.TOUCH_DOLLY_ROTATE:
          if (r.enableZoom === !1 && r.enableRotate === !1)
            return;
          xt(pe), r.update();
          break;
        default:
          p = d.NONE;
      }
    }
    function Ot(pe) {
      r.enabled !== !1 && pe.preventDefault();
    }
    function Wt(pe) {
      Y.push(pe);
    }
    function it(pe) {
      delete re[pe.pointerId];
      for (let Fe = 0; Fe < Y.length; Fe++)
        if (Y[Fe].pointerId == pe.pointerId) {
          Y.splice(Fe, 1);
          return;
        }
    }
    function an(pe) {
      let Fe = re[pe.pointerId];
      Fe === void 0 && (Fe = new zt(), re[pe.pointerId] = Fe), Fe.set(pe.pageX, pe.pageY);
    }
    function Be(pe) {
      const Fe = pe.pointerId === Y[0].pointerId ? Y[1] : Y[0];
      return re[Fe.pointerId];
    }
    t !== void 0 && this.connect(t), this.update();
  }
}
const uM = new ge();
function yv(a, e, t, r, i, s) {
  const l = 2 * Math.PI * i / 4, d = Math.max(s - 2 * i, 0), p = Math.PI / 4;
  uM.copy(e), uM[r] = 0, uM.normalize();
  const g = 0.5 * l / (l + d), _ = 1 - uM.angleTo(a) / p;
  return Math.sign(uM[t]) === 1 ? _ * g : d / (l + d) + g + g * (1 - _);
}
class Pj extends fl {
  constructor(e = 1, t = 1, r = 1, i = 2, s = 0.1) {
    if (i = i * 2 + 1, s = Math.min(e / 2, t / 2, r / 2, s), super(1, 1, 1, i, i, i), i === 1)
      return;
    const l = this.toNonIndexed();
    this.index = null, this.attributes.position = l.attributes.position, this.attributes.normal = l.attributes.normal, this.attributes.uv = l.attributes.uv;
    const d = new ge(), p = new ge(), g = new ge(e, t, r).divideScalar(2).subScalar(s), _ = this.attributes.position.array, w = this.attributes.normal.array, T = this.attributes.uv.array, R = _.length / 6, D = new ge(), O = 0.5 / i;
    for (let U = 0, H = 0; U < _.length; U += 3, H += 2)
      switch (d.fromArray(_, U), p.copy(d), p.x -= Math.sign(p.x) * O, p.y -= Math.sign(p.y) * O, p.z -= Math.sign(p.z) * O, p.normalize(), _[U + 0] = g.x * Math.sign(d.x) + p.x * s, _[U + 1] = g.y * Math.sign(d.y) + p.y * s, _[U + 2] = g.z * Math.sign(d.z) + p.z * s, w[U + 0] = p.x, w[U + 1] = p.y, w[U + 2] = p.z, Math.floor(U / R)) {
        case 0:
          D.set(1, 0, 0), T[H + 0] = yv(D, p, "z", "y", s, r), T[H + 1] = 1 - yv(D, p, "y", "z", s, t);
          break;
        case 1:
          D.set(-1, 0, 0), T[H + 0] = 1 - yv(D, p, "z", "y", s, r), T[H + 1] = 1 - yv(D, p, "y", "z", s, t);
          break;
        case 2:
          D.set(0, 1, 0), T[H + 0] = 1 - yv(D, p, "x", "z", s, e), T[H + 1] = yv(D, p, "z", "x", s, r);
          break;
        case 3:
          D.set(0, -1, 0), T[H + 0] = 1 - yv(D, p, "x", "z", s, e), T[H + 1] = 1 - yv(D, p, "z", "x", s, r);
          break;
        case 4:
          D.set(0, 0, 1), T[H + 0] = 1 - yv(D, p, "x", "y", s, e), T[H + 1] = 1 - yv(D, p, "y", "x", s, t);
          break;
        case 5:
          D.set(0, 0, -1), T[H + 0] = yv(D, p, "x", "y", s, e), T[H + 1] = 1 - yv(D, p, "y", "x", s, t);
          break;
      }
  }
}
const Nz = new cg(), eC = new ge();
class TL extends $C {
  constructor() {
    super(), this.isLineSegmentsGeometry = !0, this.type = "LineSegmentsGeometry";
    const e = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], t = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], r = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
    this.setIndex(r), this.setAttribute("position", new sr(e, 3)), this.setAttribute("uv", new sr(t, 2));
  }
  applyMatrix4(e) {
    const t = this.attributes.instanceStart, r = this.attributes.instanceEnd;
    return t !== void 0 && (t.applyMatrix4(e), r.applyMatrix4(e), t.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  setPositions(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const r = new RC(t, 6, 1);
    return this.setAttribute("instanceStart", new bm(r, 3, 0)), this.setAttribute("instanceEnd", new bm(r, 3, 3)), this.computeBoundingBox(), this.computeBoundingSphere(), this;
  }
  setColors(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const r = new RC(t, 6, 1);
    return this.setAttribute("instanceColorStart", new bm(r, 3, 0)), this.setAttribute("instanceColorEnd", new bm(r, 3, 3)), this;
  }
  fromWireframeGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromEdgesGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  fromMesh(e) {
    return this.fromWireframeGeometry(new lL(e.geometry)), this;
  }
  fromLineSegments(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new cg());
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    e !== void 0 && t !== void 0 && (this.boundingBox.setFromBufferAttribute(e), Nz.setFromBufferAttribute(t), this.boundingBox.union(Nz));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new yy()), this.boundingBox === null && this.computeBoundingBox();
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    if (e !== void 0 && t !== void 0) {
      const r = this.boundingSphere.center;
      this.boundingBox.getCenter(r);
      let i = 0;
      for (let s = 0, l = e.count; s < l; s++)
        eC.fromBufferAttribute(e, s), i = Math.max(i, r.distanceToSquared(eC)), eC.fromBufferAttribute(t, s), i = Math.max(i, r.distanceToSquared(eC));
      this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
    }
  }
  toJSON() {
  }
  applyMatrix(e) {
    return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."), this.applyMatrix4(e);
  }
}
class t4 extends TL {
  constructor() {
    super(), this.isLineGeometry = !0, this.type = "LineGeometry";
  }
  setPositions(e) {
    const t = e.length - 3, r = new Float32Array(2 * t);
    for (let i = 0; i < t; i += 3)
      r[2 * i] = e[i], r[2 * i + 1] = e[i + 1], r[2 * i + 2] = e[i + 2], r[2 * i + 3] = e[i + 3], r[2 * i + 4] = e[i + 4], r[2 * i + 5] = e[i + 5];
    return super.setPositions(r), this;
  }
  setColors(e) {
    const t = e.length - 3, r = new Float32Array(2 * t);
    for (let i = 0; i < t; i += 3)
      r[2 * i] = e[i], r[2 * i + 1] = e[i + 1], r[2 * i + 2] = e[i + 2], r[2 * i + 3] = e[i + 3], r[2 * i + 4] = e[i + 4], r[2 * i + 5] = e[i + 5];
    return super.setColors(r), this;
  }
  fromLine(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
}
In.line = {
  worldUnits: {
    value: 1
  },
  linewidth: {
    value: 1
  },
  resolution: {
    value: new zt(1, 1)
  },
  dashOffset: {
    value: 0
  },
  dashScale: {
    value: 1
  },
  dashSize: {
    value: 1
  },
  gapSize: {
    value: 1
  }
};
Wh.line = {
  uniforms: $M.merge([In.common, In.fog, In.line]),
  vertexShader: `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				// get the offset direction as perpendicular to the view vector
				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 offset;
				if ( position.y < 0.5 ) {

					offset = normalize( cross( start.xyz, worldDir ) );

				} else {

					offset = normalize( cross( end.xyz, worldDir ) );

				}

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// extend the line bounds to encompass  endcaps
					start.xyz += - worldDir * linewidth * 0.5;
					end.xyz += worldDir * linewidth * 0.5;

					// shift the position of the quad so it hugs the forward edge of the line
					offset.xy -= dir * forwardOffset;
					offset.z += 0.5;

				#endif

				// endcaps
				if ( position.y > 1.0 || position.y < 0.0 ) {

					offset.xy += dir * 2.0 * forwardOffset;

				}

				// adjust for linewidth
				offset *= linewidth * 0.5;

				// set the world position
				worldPos = ( position.y < 0.5 ) ? start : end;
				worldPos.xyz += offset;

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`,
  fragmentShader: `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
};
class CL extends Mu {
  constructor(e) {
    super({
      type: "LineMaterial",
      uniforms: $M.clone(Wh.line.uniforms),
      vertexShader: Wh.line.vertexShader,
      fragmentShader: Wh.line.fragmentShader,
      clipping: !0
    }), this.isLineMaterial = !0, Object.defineProperties(this, {
      color: {
        enumerable: !0,
        get: function() {
          return this.uniforms.diffuse.value;
        },
        set: function(t) {
          this.uniforms.diffuse.value = t;
        }
      },
      worldUnits: {
        enumerable: !0,
        get: function() {
          return "WORLD_UNITS" in this.defines;
        },
        set: function(t) {
          t === !0 ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS;
        }
      },
      linewidth: {
        enumerable: !0,
        get: function() {
          return this.uniforms.linewidth.value;
        },
        set: function(t) {
          this.uniforms.linewidth.value = t;
        }
      },
      dashed: {
        enumerable: !0,
        get: function() {
          return Boolean("USE_DASH" in this.defines);
        },
        set(t) {
          Boolean(t) !== Boolean("USE_DASH" in this.defines) && (this.needsUpdate = !0), t === !0 ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH;
        }
      },
      dashScale: {
        enumerable: !0,
        get: function() {
          return this.uniforms.dashScale.value;
        },
        set: function(t) {
          this.uniforms.dashScale.value = t;
        }
      },
      dashSize: {
        enumerable: !0,
        get: function() {
          return this.uniforms.dashSize.value;
        },
        set: function(t) {
          this.uniforms.dashSize.value = t;
        }
      },
      dashOffset: {
        enumerable: !0,
        get: function() {
          return this.uniforms.dashOffset.value;
        },
        set: function(t) {
          this.uniforms.dashOffset.value = t;
        }
      },
      gapSize: {
        enumerable: !0,
        get: function() {
          return this.uniforms.gapSize.value;
        },
        set: function(t) {
          this.uniforms.gapSize.value = t;
        }
      },
      opacity: {
        enumerable: !0,
        get: function() {
          return this.uniforms.opacity.value;
        },
        set: function(t) {
          this.uniforms.opacity.value = t;
        }
      },
      resolution: {
        enumerable: !0,
        get: function() {
          return this.uniforms.resolution.value;
        },
        set: function(t) {
          this.uniforms.resolution.value.copy(t);
        }
      },
      alphaToCoverage: {
        enumerable: !0,
        get: function() {
          return Boolean("USE_ALPHA_TO_COVERAGE" in this.defines);
        },
        set: function(t) {
          Boolean(t) !== Boolean("USE_ALPHA_TO_COVERAGE" in this.defines) && (this.needsUpdate = !0), t === !0 ? (this.defines.USE_ALPHA_TO_COVERAGE = "", this.extensions.derivatives = !0) : (delete this.defines.USE_ALPHA_TO_COVERAGE, this.extensions.derivatives = !1);
        }
      }
    }), this.setValues(e);
  }
}
const Fz = new ge(), kz = new ge(), Pd = new ra(), Od = new ra(), sy = new ra(), SD = new ge(), wD = new Kr(), ch = new SL(), Iz = new ge(), tC = new cg(), nC = new yy(), oy = new ra();
let cy, L3, n4, j_;
function Bz(a, e, t) {
  return oy.set(0, 0, -e, 1).applyMatrix4(a.projectionMatrix), oy.multiplyScalar(1 / oy.w), oy.x = j_ / t.width, oy.y = j_ / t.height, oy.applyMatrix4(a.projectionMatrixInverse), oy.multiplyScalar(1 / oy.w), Math.abs(Math.max(oy.x, oy.y));
}
function Oj(a, e) {
  for (let t = 0, r = L3.count; t < r; t++) {
    ch.start.fromBufferAttribute(L3, t), ch.end.fromBufferAttribute(n4, t);
    const i = new ge(), s = new ge();
    cy.distanceSqToSegment(ch.start, ch.end, s, i), s.distanceTo(i) < j_ * 0.5 && e.push({
      point: s,
      pointOnLine: i,
      distance: cy.origin.distanceTo(s),
      object: a,
      face: null,
      faceIndex: t,
      uv: null,
      uv2: null
    });
  }
}
function Uj(a, e, t) {
  const r = e.projectionMatrix, s = a.material.resolution, l = a.matrixWorld, d = a.geometry, p = d.attributes.instanceStart, g = d.attributes.instanceEnd, _ = -e.near;
  cy.at(1, sy), sy.w = 1, sy.applyMatrix4(e.matrixWorldInverse), sy.applyMatrix4(r), sy.multiplyScalar(1 / sy.w), sy.x *= s.x / 2, sy.y *= s.y / 2, sy.z = 0, SD.copy(sy), wD.multiplyMatrices(e.matrixWorldInverse, l);
  for (let w = 0, T = p.count; w < T; w++) {
    if (Pd.fromBufferAttribute(p, w), Od.fromBufferAttribute(g, w), Pd.w = 1, Od.w = 1, Pd.applyMatrix4(wD), Od.applyMatrix4(wD), Pd.z > _ && Od.z > _)
      continue;
    if (Pd.z > _) {
      const I = Pd.z - Od.z, G = (Pd.z - _) / I;
      Pd.lerp(Od, G);
    } else if (Od.z > _) {
      const I = Od.z - Pd.z, G = (Od.z - _) / I;
      Od.lerp(Pd, G);
    }
    Pd.applyMatrix4(r), Od.applyMatrix4(r), Pd.multiplyScalar(1 / Pd.w), Od.multiplyScalar(1 / Od.w), Pd.x *= s.x / 2, Pd.y *= s.y / 2, Od.x *= s.x / 2, Od.y *= s.y / 2, ch.start.copy(Pd), ch.start.z = 0, ch.end.copy(Od), ch.end.z = 0;
    const D = ch.closestPointToPointParameter(SD, !0);
    ch.at(D, Iz);
    const O = DF.lerp(Pd.z, Od.z, D), U = O >= -1 && O <= 1, H = SD.distanceTo(Iz) < j_ * 0.5;
    if (U && H) {
      ch.start.fromBufferAttribute(p, w), ch.end.fromBufferAttribute(g, w), ch.start.applyMatrix4(l), ch.end.applyMatrix4(l);
      const I = new ge(), G = new ge();
      cy.distanceSqToSegment(ch.start, ch.end, G, I), t.push({
        point: G,
        pointOnLine: I,
        distance: cy.origin.distanceTo(G),
        object: a,
        face: null,
        faceIndex: w,
        uv: null,
        uv2: null
      });
    }
  }
}
class r4 extends Fn {
  constructor(e = new TL(), t = new CL({
    color: Math.random() * 16777215
  })) {
    super(e, t), this.isLineSegments2 = !0, this.type = "LineSegments2";
  }
  computeLineDistances() {
    const e = this.geometry, t = e.attributes.instanceStart, r = e.attributes.instanceEnd, i = new Float32Array(2 * t.count);
    for (let l = 0, d = 0, p = t.count; l < p; l++, d += 2)
      Fz.fromBufferAttribute(t, l), kz.fromBufferAttribute(r, l), i[d] = d === 0 ? 0 : i[d - 1], i[d + 1] = i[d] + Fz.distanceTo(kz);
    const s = new RC(i, 2, 1);
    return e.setAttribute("instanceDistanceStart", new bm(s, 1, 0)), e.setAttribute("instanceDistanceEnd", new bm(s, 1, 1)), this;
  }
  raycast(e, t) {
    const r = this.material.worldUnits, i = e.camera;
    i === null && !r && console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');
    const s = e.params.Line2 !== void 0 && e.params.Line2.threshold || 0;
    cy = e.ray;
    const l = this.matrixWorld, d = this.geometry, p = this.material;
    j_ = p.linewidth + s, L3 = d.attributes.instanceStart, n4 = d.attributes.instanceEnd, d.boundingSphere === null && d.computeBoundingSphere(), nC.copy(d.boundingSphere).applyMatrix4(l);
    let g;
    if (r)
      g = j_ * 0.5;
    else {
      const w = Math.max(i.near, nC.distanceToPoint(cy.origin));
      g = Bz(i, w, p.resolution);
    }
    if (nC.radius += g, cy.intersectsSphere(nC) === !1)
      return;
    d.boundingBox === null && d.computeBoundingBox(), tC.copy(d.boundingBox).applyMatrix4(l);
    let _;
    if (r)
      _ = j_ * 0.5;
    else {
      const w = Math.max(i.near, tC.distanceToPoint(cy.origin));
      _ = Bz(i, w, p.resolution);
    }
    tC.expandByScalar(_), cy.intersectsBox(tC) !== !1 && (r ? Oj(this, t) : Uj(this, i, t));
  }
}
class zj extends r4 {
  constructor(e = new t4(), t = new CL({
    color: Math.random() * 16777215
  })) {
    super(e, t), this.isLine2 = !0, this.type = "Line2";
  }
}
const Nj = /* @__PURE__ */ Ln.forwardRef(function({
  follow: e = !0,
  lockX: t = !1,
  lockY: r = !1,
  lockZ: i = !1,
  ...s
}, l) {
  const d = Ln.useRef();
  return Am(({
    camera: p
  }) => {
    if (!e || !d.current)
      return;
    const g = d.current.rotation.clone();
    p.getWorldQuaternion(d.current.quaternion), t && (d.current.rotation.x = g.x), r && (d.current.rotation.y = g.y), i && (d.current.rotation.z = g.z);
  }), /* @__PURE__ */ ln("group", {
    ref: ML([d, l]),
    ...s
  });
}), Fj = /* @__PURE__ */ Ln.forwardRef(function({
  points: e,
  color: t = "black",
  vertexColors: r,
  linewidth: i,
  lineWidth: s,
  segments: l,
  dashed: d,
  ...p
}, g) {
  const _ = jf((D) => D.size), w = Ln.useMemo(() => l ? new r4() : new zj(), [l]), [T] = Ln.useState(() => new CL()), R = Ln.useMemo(() => {
    const D = l ? new TL() : new t4(), O = e.map((U) => {
      const H = Array.isArray(U);
      return U instanceof ge ? [U.x, U.y, U.z] : U instanceof zt ? [U.x, U.y, 0] : H && U.length === 3 ? [U[0], U[1], U[2]] : H && U.length === 2 ? [U[0], U[1], 0] : U;
    });
    if (D.setPositions(O.flat()), r) {
      const U = r.map((H) => H instanceof Un ? H.toArray() : H);
      D.setColors(U.flat());
    }
    return D;
  }, [e, l, r]);
  return Ln.useLayoutEffect(() => {
    w.computeLineDistances();
  }, [e, w]), Ln.useLayoutEffect(() => {
    d ? T.defines.USE_DASH = "" : delete T.defines.USE_DASH, T.needsUpdate = !0;
  }, [d, T]), Ln.useEffect(() => () => R.dispose(), [R]), /* @__PURE__ */ _c("primitive", {
    object: w,
    ref: g,
    ...p,
    children: [/* @__PURE__ */ ln("primitive", {
      object: R,
      attach: "geometry"
    }), /* @__PURE__ */ ln("primitive", {
      object: T,
      attach: "material",
      color: t,
      vertexColors: Boolean(r),
      resolution: [_.width, _.height],
      linewidth: i != null ? i : s,
      dashed: d,
      ...p
    })]
  });
});
function kj() {
  var a = /* @__PURE__ */ Object.create(null);
  function e(i, s) {
    var l = i.id, d = i.name, p = i.dependencies;
    p === void 0 && (p = []);
    var g = i.init;
    g === void 0 && (g = function() {
    });
    var _ = i.getTransferables;
    if (_ === void 0 && (_ = null), !a[l])
      try {
        p = p.map(function(T) {
          return T && T.isWorkerModule && (e(T, function(R) {
            if (R instanceof Error)
              throw R;
          }), T = a[T.id].value), T;
        }), g = r("<" + d + ">.init", g), _ && (_ = r("<" + d + ">.getTransferables", _));
        var w = null;
        typeof g == "function" ? w = g.apply(void 0, p) : console.error("worker module init function failed to rehydrate"), a[l] = {
          id: l,
          value: w,
          getTransferables: _
        }, s(w);
      } catch (T) {
        T && T.noLog || console.error(T), s(T);
      }
  }
  function t(i, s) {
    var l, d = i.id, p = i.args;
    (!a[d] || typeof a[d].value != "function") && s(new Error("Worker module " + d + ": not found or its 'init' did not return a function"));
    try {
      var g = (l = a[d]).value.apply(l, p);
      g && typeof g.then == "function" ? g.then(_, function(w) {
        return s(w instanceof Error ? w : new Error("" + w));
      }) : _(g);
    } catch (w) {
      s(w);
    }
    function _(w) {
      try {
        var T = a[d].getTransferables && a[d].getTransferables(w);
        (!T || !Array.isArray(T) || !T.length) && (T = void 0), s(w, T);
      } catch (R) {
        console.error(R), s(R);
      }
    }
  }
  function r(i, s) {
    var l = void 0;
    self.troikaDefine = function(p) {
      return l = p;
    };
    var d = URL.createObjectURL(
      new Blob(
        ["/** " + i.replace(/\*/g, "") + ` **/

troikaDefine(
` + s + `
)`],
        { type: "application/javascript" }
      )
    );
    try {
      importScripts(d);
    } catch (p) {
      console.error(p);
    }
    return URL.revokeObjectURL(d), delete self.troikaDefine, l;
  }
  self.addEventListener("message", function(i) {
    var s = i.data, l = s.messageId, d = s.action, p = s.data;
    try {
      d === "registerModule" && e(p, function(g) {
        g instanceof Error ? postMessage({
          messageId: l,
          success: !1,
          error: g.message
        }) : postMessage({
          messageId: l,
          success: !0,
          result: { isCallable: typeof g == "function" }
        });
      }), d === "callModule" && t(p, function(g, _) {
        g instanceof Error ? postMessage({
          messageId: l,
          success: !1,
          error: g.message
        }) : postMessage({
          messageId: l,
          success: !0,
          result: g
        }, _ || void 0);
      });
    } catch (g) {
      postMessage({
        messageId: l,
        success: !1,
        error: g.stack
      });
    }
  });
}
function Ij(a) {
  var e = function() {
    for (var t = [], r = arguments.length; r--; )
      t[r] = arguments[r];
    return e._getInitResult().then(function(i) {
      if (typeof i == "function")
        return i.apply(void 0, t);
      throw new Error("Worker module function was called but `init` did not return a callable function");
    });
  };
  return e._getInitResult = function() {
    var t = a.dependencies, r = a.init;
    t = Array.isArray(t) ? t.map(
      function(s) {
        return s && s._getInitResult ? s._getInitResult() : s;
      }
    ) : [];
    var i = Promise.all(t).then(function(s) {
      return r.apply(null, s);
    });
    return e._getInitResult = function() {
      return i;
    }, i;
  }, e;
}
var i4 = function() {
  var a = !1;
  if (typeof window < "u" && typeof window.document < "u")
    try {
      var e = new Worker(
        URL.createObjectURL(new Blob([""], { type: "application/javascript" }))
      );
      e.terminate(), a = !0;
    } catch (t) {
      typeof process < "u" && process.env.NODE_ENV === "test" || console.log(
        "Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" + t.message + "]"
      );
    }
  return i4 = function() {
    return a;
  }, a;
}, Bj = 0, Hj = 0, bD = !1, EM = /* @__PURE__ */ Object.create(null), MM = /* @__PURE__ */ Object.create(null), P3 = /* @__PURE__ */ Object.create(null);
function sT(a) {
  if ((!a || typeof a.init != "function") && !bD)
    throw new Error("requires `options.init` function");
  var e = a.dependencies, t = a.init, r = a.getTransferables, i = a.workerId;
  if (!i4())
    return Ij(a);
  i == null && (i = "#default");
  var s = "workerModule" + ++Bj, l = a.name || s, d = null;
  e = e && e.map(function(g) {
    return typeof g == "function" && !g.workerModuleData && (bD = !0, g = sT({
      workerId: i,
      name: "<" + l + "> function dependency: " + g.name,
      init: `function(){return (
` + yC(g) + `
)}`
    }), bD = !1), g && g.workerModuleData && (g = g.workerModuleData), g;
  });
  function p() {
    for (var g = [], _ = arguments.length; _--; )
      g[_] = arguments[_];
    if (!d) {
      d = Hz(i, "registerModule", p.workerModuleData);
      var w = function() {
        d = null, MM[i].delete(w);
      };
      (MM[i] || (MM[i] = /* @__PURE__ */ new Set())).add(w);
    }
    return d.then(function(T) {
      var R = T.isCallable;
      if (R)
        return Hz(i, "callModule", { id: s, args: g });
      throw new Error("Worker module function was called but `init` did not return a callable function");
    });
  }
  return p.workerModuleData = {
    isWorkerModule: !0,
    id: s,
    name: l,
    dependencies: e,
    init: yC(t),
    getTransferables: r && yC(r)
  }, p;
}
function Vj(a) {
  MM[a] && MM[a].forEach(function(e) {
    e();
  }), EM[a] && (EM[a].terminate(), delete EM[a]);
}
function yC(a) {
  var e = a.toString();
  return !/^function/.test(e) && /^\w+\s*\(/.test(e) && (e = "function " + e), e;
}
function Gj(a) {
  var e = EM[a];
  if (!e) {
    var t = yC(kj);
    e = EM[a] = new Worker(
      URL.createObjectURL(
        new Blob(
          ["/** Worker Module Bootstrap: " + a.replace(/\*/g, "") + ` **/

;(` + t + ")()"],
          { type: "application/javascript" }
        )
      )
    ), e.onmessage = function(r) {
      var i = r.data, s = i.messageId, l = P3[s];
      if (!l)
        throw new Error("WorkerModule response with empty or unknown messageId");
      delete P3[s], l(i);
    };
  }
  return e;
}
function Hz(a, e, t) {
  return new Promise(function(r, i) {
    var s = ++Hj;
    P3[s] = function(l) {
      l.success ? r(l.result) : i(new Error("Error in worker " + e + " call: " + l.error));
    }, Gj(a).postMessage({
      messageId: s,
      action: e,
      data: t
    });
  });
}
function a4() {
  var a = function(e) {
    function t(fe, he, ye, Ee, Ve, Je, rt, Ne) {
      var ct = 1 - rt;
      Ne.x = ct * ct * fe + 2 * ct * rt * ye + rt * rt * Ve, Ne.y = ct * ct * he + 2 * ct * rt * Ee + rt * rt * Je;
    }
    function r(fe, he, ye, Ee, Ve, Je, rt, Ne, ct, tt) {
      var Tt = 1 - ct;
      tt.x = Tt * Tt * Tt * fe + 3 * Tt * Tt * ct * ye + 3 * Tt * ct * ct * Ve + ct * ct * ct * rt, tt.y = Tt * Tt * Tt * he + 3 * Tt * Tt * ct * Ee + 3 * Tt * ct * ct * Je + ct * ct * ct * Ne;
    }
    function i(fe, he) {
      for (var ye = /([MLQCZ])([^MLQCZ]*)/g, Ee, Ve, Je, rt, Ne; Ee = ye.exec(fe); ) {
        var ct = Ee[2].replace(/^\s*|\s*$/g, "").split(/[,\s]+/).map(function(tt) {
          return parseFloat(tt);
        });
        switch (Ee[1]) {
          case "M":
            rt = Ve = ct[0], Ne = Je = ct[1];
            break;
          case "L":
            (ct[0] !== rt || ct[1] !== Ne) && he("L", rt, Ne, rt = ct[0], Ne = ct[1]);
            break;
          case "Q": {
            he("Q", rt, Ne, rt = ct[2], Ne = ct[3], ct[0], ct[1]);
            break;
          }
          case "C": {
            he("C", rt, Ne, rt = ct[4], Ne = ct[5], ct[0], ct[1], ct[2], ct[3]);
            break;
          }
          case "Z":
            (rt !== Ve || Ne !== Je) && he("L", rt, Ne, Ve, Je);
            break;
        }
      }
    }
    function s(fe, he, ye) {
      ye === void 0 && (ye = 16);
      var Ee = { x: 0, y: 0 };
      i(fe, function(Ve, Je, rt, Ne, ct, tt, Tt, gt, ft) {
        switch (Ve) {
          case "L":
            he(Je, rt, Ne, ct);
            break;
          case "Q": {
            for (var Ie = Je, qe = rt, dt = 1; dt < ye; dt++)
              t(
                Je,
                rt,
                tt,
                Tt,
                Ne,
                ct,
                dt / (ye - 1),
                Ee
              ), he(Ie, qe, Ee.x, Ee.y), Ie = Ee.x, qe = Ee.y;
            break;
          }
          case "C": {
            for (var ht = Je, xt = rt, Vt = 1; Vt < ye; Vt++)
              r(
                Je,
                rt,
                tt,
                Tt,
                gt,
                ft,
                Ne,
                ct,
                Vt / (ye - 1),
                Ee
              ), he(ht, xt, Ee.x, Ee.y), ht = Ee.x, xt = Ee.y;
            break;
          }
        }
      });
    }
    var l = "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}", d = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}", p = /* @__PURE__ */ new WeakMap(), g = {
      premultipliedAlpha: !1,
      preserveDrawingBuffer: !0,
      antialias: !1,
      depth: !1
    };
    function _(fe, he) {
      var ye = fe.getContext ? fe.getContext("webgl", g) : fe, Ee = p.get(ye);
      if (!Ee) {
        let Tt = function(ht) {
          var xt = Je[ht];
          if (!xt && (xt = Je[ht] = ye.getExtension(ht), !xt))
            throw new Error(ht + " not supported");
          return xt;
        }, gt = function(ht, xt) {
          var Vt = ye.createShader(xt);
          return ye.shaderSource(Vt, ht), ye.compileShader(Vt), Vt;
        }, ft = function(ht, xt, Vt, yt) {
          if (!rt[ht]) {
            var Nt = {}, Zt = {}, Rt = ye.createProgram();
            ye.attachShader(Rt, gt(xt, ye.VERTEX_SHADER)), ye.attachShader(Rt, gt(Vt, ye.FRAGMENT_SHADER)), ye.linkProgram(Rt), rt[ht] = {
              program: Rt,
              transaction: function(oe) {
                ye.useProgram(Rt), oe({
                  setUniform: function(ut, Ft) {
                    for (var Ot = [], Wt = arguments.length - 2; Wt-- > 0; )
                      Ot[Wt] = arguments[Wt + 2];
                    var it = Zt[Ft] || (Zt[Ft] = ye.getUniformLocation(Rt, Ft));
                    ye["uniform" + ut].apply(ye, [it].concat(Ot));
                  },
                  setAttribute: function(ut, Ft, Ot, Wt, it) {
                    var an = Nt[ut];
                    an || (an = Nt[ut] = {
                      buf: ye.createBuffer(),
                      loc: ye.getAttribLocation(Rt, ut),
                      data: null
                    }), ye.bindBuffer(ye.ARRAY_BUFFER, an.buf), ye.vertexAttribPointer(an.loc, Ft, ye.FLOAT, !1, 0, 0), ye.enableVertexAttribArray(an.loc), Ve ? ye.vertexAttribDivisor(an.loc, Wt) : Tt("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(an.loc, Wt), it !== an.data && (ye.bufferData(ye.ARRAY_BUFFER, it, Ot), an.data = it);
                  }
                });
              }
            };
          }
          rt[ht].transaction(yt);
        }, Ie = function(ht, xt) {
          ct++;
          try {
            ye.activeTexture(ye.TEXTURE0 + ct);
            var Vt = Ne[ht];
            Vt || (Vt = Ne[ht] = ye.createTexture(), ye.bindTexture(ye.TEXTURE_2D, Vt), ye.texParameteri(ye.TEXTURE_2D, ye.TEXTURE_MIN_FILTER, ye.NEAREST), ye.texParameteri(ye.TEXTURE_2D, ye.TEXTURE_MAG_FILTER, ye.NEAREST)), ye.bindTexture(ye.TEXTURE_2D, Vt), xt(Vt, ct);
          } finally {
            ct--;
          }
        }, qe = function(ht, xt, Vt) {
          var yt = ye.createFramebuffer();
          tt.push(yt), ye.bindFramebuffer(ye.FRAMEBUFFER, yt), ye.activeTexture(ye.TEXTURE0 + xt), ye.bindTexture(ye.TEXTURE_2D, ht), ye.framebufferTexture2D(ye.FRAMEBUFFER, ye.COLOR_ATTACHMENT0, ye.TEXTURE_2D, ht, 0);
          try {
            Vt(yt);
          } finally {
            ye.deleteFramebuffer(yt), ye.bindFramebuffer(ye.FRAMEBUFFER, tt[--tt.length - 1] || null);
          }
        }, dt = function() {
          Je = {}, rt = {}, Ne = {}, ct = -1, tt.length = 0;
        };
        var Ve = typeof WebGL2RenderingContext < "u" && ye instanceof WebGL2RenderingContext, Je = {}, rt = {}, Ne = {}, ct = -1, tt = [];
        ye.canvas.addEventListener("webglcontextlost", function(ht) {
          dt(), ht.preventDefault();
        }, !1), p.set(ye, Ee = {
          gl: ye,
          isWebGL2: Ve,
          getExtension: Tt,
          withProgram: ft,
          withTexture: Ie,
          withTextureFramebuffer: qe,
          handleContextLoss: dt
        });
      }
      he(Ee);
    }
    function w(fe, he, ye, Ee, Ve, Je, rt, Ne) {
      rt === void 0 && (rt = 15), Ne === void 0 && (Ne = null), _(fe, function(ct) {
        var tt = ct.gl, Tt = ct.withProgram, gt = ct.withTexture;
        gt("copy", function(ft, Ie) {
          tt.texImage2D(tt.TEXTURE_2D, 0, tt.RGBA, Ve, Je, 0, tt.RGBA, tt.UNSIGNED_BYTE, he), Tt("copy", l, d, function(qe) {
            var dt = qe.setUniform, ht = qe.setAttribute;
            ht("aUV", 2, tt.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2])), dt("1i", "image", Ie), tt.bindFramebuffer(tt.FRAMEBUFFER, Ne || null), tt.disable(tt.BLEND), tt.colorMask(rt & 8, rt & 4, rt & 2, rt & 1), tt.viewport(ye, Ee, Ve, Je), tt.scissor(ye, Ee, Ve, Je), tt.drawArrays(tt.TRIANGLES, 0, 3);
          });
        });
      });
    }
    function T(fe, he, ye) {
      var Ee = fe.width, Ve = fe.height;
      _(fe, function(Je) {
        var rt = Je.gl, Ne = new Uint8Array(Ee * Ve * 4);
        rt.readPixels(0, 0, Ee, Ve, rt.RGBA, rt.UNSIGNED_BYTE, Ne), fe.width = he, fe.height = ye, w(rt, Ne, 0, 0, Ee, Ve);
      });
    }
    var R = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      withWebGLContext: _,
      renderImageData: w,
      resizeWebGLCanvasWithoutClearing: T
    });
    function D(fe, he, ye, Ee, Ve, Je) {
      Je === void 0 && (Je = 1);
      var rt = new Uint8Array(fe * he), Ne = Ee[2] - Ee[0], ct = Ee[3] - Ee[1], tt = [];
      s(ye, function(ht, xt, Vt, yt) {
        tt.push({
          x1: ht,
          y1: xt,
          x2: Vt,
          y2: yt,
          minX: Math.min(ht, Vt),
          minY: Math.min(xt, yt),
          maxX: Math.max(ht, Vt),
          maxY: Math.max(xt, yt)
        });
      }), tt.sort(function(ht, xt) {
        return ht.maxX - xt.maxX;
      });
      for (var Tt = 0; Tt < fe; Tt++)
        for (var gt = 0; gt < he; gt++) {
          var ft = qe(
            Ee[0] + Ne * (Tt + 0.5) / fe,
            Ee[1] + ct * (gt + 0.5) / he
          ), Ie = Math.pow(1 - Math.abs(ft) / Ve, Je) / 2;
          ft < 0 && (Ie = 1 - Ie), Ie = Math.max(0, Math.min(255, Math.round(Ie * 255))), rt[gt * fe + Tt] = Ie;
        }
      return rt;
      function qe(ht, xt) {
        for (var Vt = 1 / 0, yt = 1 / 0, Nt = tt.length; Nt--; ) {
          var Zt = tt[Nt];
          if (Zt.maxX + yt <= ht)
            break;
          if (ht + yt > Zt.minX && xt - yt < Zt.maxY && xt + yt > Zt.minY) {
            var Rt = H(ht, xt, Zt.x1, Zt.y1, Zt.x2, Zt.y2);
            Rt < Vt && (Vt = Rt, yt = Math.sqrt(Vt));
          }
        }
        return dt(ht, xt) && (yt = -yt), yt;
      }
      function dt(ht, xt) {
        for (var Vt = 0, yt = tt.length; yt--; ) {
          var Nt = tt[yt];
          if (Nt.maxX <= ht)
            break;
          var Zt = Nt.y1 > xt != Nt.y2 > xt && ht < (Nt.x2 - Nt.x1) * (xt - Nt.y1) / (Nt.y2 - Nt.y1) + Nt.x1;
          Zt && (Vt += Nt.y1 < Nt.y2 ? 1 : -1);
        }
        return Vt !== 0;
      }
    }
    function O(fe, he, ye, Ee, Ve, Je, rt, Ne, ct, tt) {
      Je === void 0 && (Je = 1), Ne === void 0 && (Ne = 0), ct === void 0 && (ct = 0), tt === void 0 && (tt = 0), U(fe, he, ye, Ee, Ve, Je, rt, null, Ne, ct, tt);
    }
    function U(fe, he, ye, Ee, Ve, Je, rt, Ne, ct, tt, Tt) {
      Je === void 0 && (Je = 1), ct === void 0 && (ct = 0), tt === void 0 && (tt = 0), Tt === void 0 && (Tt = 0);
      for (var gt = D(fe, he, ye, Ee, Ve, Je), ft = new Uint8Array(gt.length * 4), Ie = 0; Ie < gt.length; Ie++)
        ft[Ie * 4 + Tt] = gt[Ie];
      w(rt, ft, ct, tt, fe, he, 1 << 3 - Tt, Ne);
    }
    function H(fe, he, ye, Ee, Ve, Je) {
      var rt = Ve - ye, Ne = Je - Ee, ct = rt * rt + Ne * Ne, tt = ct ? Math.max(0, Math.min(1, ((fe - ye) * rt + (he - Ee) * Ne) / ct)) : 0, Tt = fe - (ye + tt * rt), gt = he - (Ee + tt * Ne);
      return Tt * Tt + gt * gt;
    }
    var I = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      generate: D,
      generateIntoCanvas: O,
      generateIntoFramebuffer: U
    }), G = "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}", B = "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}", Q = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}", K = new Float32Array([0, 0, 2, 0, 0, 2]), te = null, Y = !1, re = {}, se = /* @__PURE__ */ new WeakMap();
    function ce(fe) {
      if (!Y && !De(fe))
        throw new Error("WebGL generation not supported");
    }
    function ue(fe, he, ye, Ee, Ve, Je, rt) {
      if (Je === void 0 && (Je = 1), rt === void 0 && (rt = null), !rt && (rt = te, !rt)) {
        var Ne = typeof OffscreenCanvas == "function" ? new OffscreenCanvas(1, 1) : typeof document < "u" ? document.createElement("canvas") : null;
        if (!Ne)
          throw new Error("OffscreenCanvas or DOM canvas not supported");
        rt = te = Ne.getContext("webgl", { depth: !1 });
      }
      ce(rt);
      var ct = new Uint8Array(fe * he * 4);
      _(rt, function(ft) {
        var Ie = ft.gl, qe = ft.withTexture, dt = ft.withTextureFramebuffer;
        qe("readable", function(ht, xt) {
          Ie.texImage2D(Ie.TEXTURE_2D, 0, Ie.RGBA, fe, he, 0, Ie.RGBA, Ie.UNSIGNED_BYTE, null), dt(ht, xt, function(Vt) {
            me(
              fe,
              he,
              ye,
              Ee,
              Ve,
              Je,
              Ie,
              Vt,
              0,
              0,
              0
            ), Ie.readPixels(0, 0, fe, he, Ie.RGBA, Ie.UNSIGNED_BYTE, ct);
          });
        });
      });
      for (var tt = new Uint8Array(fe * he), Tt = 0, gt = 0; Tt < ct.length; Tt += 4)
        tt[gt++] = ct[Tt];
      return tt;
    }
    function Me(fe, he, ye, Ee, Ve, Je, rt, Ne, ct, tt) {
      Je === void 0 && (Je = 1), Ne === void 0 && (Ne = 0), ct === void 0 && (ct = 0), tt === void 0 && (tt = 0), me(fe, he, ye, Ee, Ve, Je, rt, null, Ne, ct, tt);
    }
    function me(fe, he, ye, Ee, Ve, Je, rt, Ne, ct, tt, Tt) {
      Je === void 0 && (Je = 1), ct === void 0 && (ct = 0), tt === void 0 && (tt = 0), Tt === void 0 && (Tt = 0), ce(rt);
      var gt = [];
      s(ye, function(ft, Ie, qe, dt) {
        gt.push(ft, Ie, qe, dt);
      }), gt = new Float32Array(gt), _(rt, function(ft) {
        var Ie = ft.gl, qe = ft.isWebGL2, dt = ft.getExtension, ht = ft.withProgram, xt = ft.withTexture, Vt = ft.withTextureFramebuffer, yt = ft.handleContextLoss;
        if (xt("rawDistances", function(Nt, Zt) {
          (fe !== Nt._lastWidth || he !== Nt._lastHeight) && Ie.texImage2D(
            Ie.TEXTURE_2D,
            0,
            Ie.RGBA,
            Nt._lastWidth = fe,
            Nt._lastHeight = he,
            0,
            Ie.RGBA,
            Ie.UNSIGNED_BYTE,
            null
          ), ht("main", G, B, function(Rt) {
            var we = Rt.setAttribute, oe = Rt.setUniform, Qe = !qe && dt("ANGLE_instanced_arrays"), ut = !qe && dt("EXT_blend_minmax");
            we("aUV", 2, Ie.STATIC_DRAW, 0, K), we("aLineSegment", 4, Ie.DYNAMIC_DRAW, 1, gt), oe.apply(void 0, ["4f", "uGlyphBounds"].concat(Ee)), oe("1f", "uMaxDistance", Ve), oe("1f", "uExponent", Je), Vt(Nt, Zt, function(Ft) {
              Ie.enable(Ie.BLEND), Ie.colorMask(!0, !0, !0, !0), Ie.viewport(0, 0, fe, he), Ie.scissor(0, 0, fe, he), Ie.blendFunc(Ie.ONE, Ie.ONE), Ie.blendEquationSeparate(Ie.FUNC_ADD, qe ? Ie.MAX : ut.MAX_EXT), Ie.clear(Ie.COLOR_BUFFER_BIT), qe ? Ie.drawArraysInstanced(Ie.TRIANGLES, 0, 3, gt.length / 4) : Qe.drawArraysInstancedANGLE(Ie.TRIANGLES, 0, 3, gt.length / 4);
            });
          }), ht("post", l, Q, function(Rt) {
            Rt.setAttribute("aUV", 2, Ie.STATIC_DRAW, 0, K), Rt.setUniform("1i", "tex", Zt), Ie.bindFramebuffer(Ie.FRAMEBUFFER, Ne), Ie.disable(Ie.BLEND), Ie.colorMask(Tt === 0, Tt === 1, Tt === 2, Tt === 3), Ie.viewport(ct, tt, fe, he), Ie.scissor(ct, tt, fe, he), Ie.drawArrays(Ie.TRIANGLES, 0, 3);
          });
        }), Ie.isContextLost())
          throw yt(), new Error("webgl context lost");
      });
    }
    function De(fe) {
      var he = !fe || fe === te ? re : fe.canvas || fe, ye = se.get(he);
      if (ye === void 0) {
        Y = !0;
        var Ee = null;
        try {
          var Ve = [
            97,
            106,
            97,
            61,
            99,
            137,
            118,
            80,
            80,
            118,
            137,
            99,
            61,
            97,
            106,
            97
          ], Je = ue(
            4,
            4,
            "M8,8L16,8L24,24L16,24Z",
            [0, 0, 32, 32],
            24,
            1,
            fe
          );
          ye = Je && Ve.length === Je.length && Je.every(function(rt, Ne) {
            return rt === Ve[Ne];
          }), ye || (Ee = "bad trial run results", console.info(Ve, Je));
        } catch (rt) {
          ye = !1, Ee = rt.message;
        }
        Ee && console.warn("WebGL SDF generation not supported:", Ee), Y = !1, se.set(he, ye);
      }
      return ye;
    }
    var Re = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      generate: ue,
      generateIntoCanvas: Me,
      generateIntoFramebuffer: me,
      isSupported: De
    });
    function He(fe, he, ye, Ee, Ve, Je) {
      Ve === void 0 && (Ve = Math.max(Ee[2] - Ee[0], Ee[3] - Ee[1]) / 2), Je === void 0 && (Je = 1);
      try {
        return ue.apply(Re, arguments);
      } catch (rt) {
        return console.info("WebGL SDF generation failed, falling back to JS", rt), D.apply(I, arguments);
      }
    }
    function ve(fe, he, ye, Ee, Ve, Je, rt, Ne, ct, tt) {
      Ve === void 0 && (Ve = Math.max(Ee[2] - Ee[0], Ee[3] - Ee[1]) / 2), Je === void 0 && (Je = 1), Ne === void 0 && (Ne = 0), ct === void 0 && (ct = 0), tt === void 0 && (tt = 0);
      try {
        return Me.apply(Re, arguments);
      } catch (Tt) {
        return console.info("WebGL SDF generation failed, falling back to JS", Tt), O.apply(I, arguments);
      }
    }
    return e.forEachPathCommand = i, e.generate = He, e.generateIntoCanvas = ve, e.javascript = I, e.pathToLineSegments = s, e.webgl = Re, e.webglUtils = R, Object.defineProperty(e, "__esModule", { value: !0 }), e;
  }({});
  return a;
}
function Wj() {
  var a = function(e) {
    var t = {
      R: "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
      EN: "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
      ES: "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
      ET: "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
      AN: "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
      CS: "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
      B: "a,3,f+2,2v,690",
      S: "9,2,k",
      WS: "c,k,4f4,1vk+a,u,1j,335",
      ON: "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
      BN: "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
      NSM: "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
      AL: "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
      LRO: "6ct",
      RLO: "6cu",
      LRE: "6cq",
      RLE: "6cr",
      PDF: "6cs",
      LRI: "6ee",
      RLI: "6ef",
      FSI: "6eg",
      PDI: "6eh"
    }, r = {}, i = {};
    r.L = 1, i[1] = "L", Object.keys(t).forEach(function(yt, Nt) {
      r[yt] = 1 << Nt + 1, i[r[yt]] = yt;
    }), Object.freeze(r);
    var s = r.LRI | r.RLI | r.FSI, l = r.L | r.R | r.AL, d = r.B | r.S | r.WS | r.ON | r.FSI | r.LRI | r.RLI | r.PDI, p = r.BN | r.RLE | r.LRE | r.RLO | r.LRO | r.PDF, g = r.S | r.WS | r.B | s | r.PDI | p, _ = null;
    function w() {
      if (!_) {
        _ = /* @__PURE__ */ new Map();
        var yt = function(Zt) {
          if (t.hasOwnProperty(Zt)) {
            var Rt = 0;
            t[Zt].split(",").forEach(function(we) {
              var oe = we.split("+"), Qe = oe[0], ut = oe[1];
              Qe = parseInt(Qe, 36), ut = ut ? parseInt(ut, 36) : 0, _.set(Rt += Qe, r[Zt]);
              for (var Ft = 0; Ft < ut; Ft++)
                _.set(++Rt, r[Zt]);
            });
          }
        };
        for (var Nt in t)
          yt(Nt);
      }
    }
    function T(yt) {
      return w(), _.get(yt.codePointAt(0)) || r.L;
    }
    function R(yt) {
      return i[T(yt)];
    }
    var D = {
      pairs: "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
      canonical: "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye"
    };
    function O(yt, Nt) {
      var Zt = 36, Rt = 0, we = /* @__PURE__ */ new Map(), oe = Nt && /* @__PURE__ */ new Map(), Qe;
      return yt.split(",").forEach(function ut(Ft) {
        if (Ft.indexOf("+") !== -1)
          for (var Ot = +Ft; Ot--; )
            ut(Qe);
        else {
          Qe = Ft;
          var Wt = Ft.split(">"), it = Wt[0], an = Wt[1];
          it = String.fromCodePoint(Rt += parseInt(it, Zt)), an = String.fromCodePoint(Rt += parseInt(an, Zt)), we.set(it, an), Nt && oe.set(an, it);
        }
      }), { map: we, reverseMap: oe };
    }
    var U, H, I;
    function G() {
      if (!U) {
        var yt = O(D.pairs, !0), Nt = yt.map, Zt = yt.reverseMap;
        U = Nt, H = Zt, I = O(D.canonical, !1).map;
      }
    }
    function B(yt) {
      return G(), U.get(yt) || null;
    }
    function Q(yt) {
      return G(), H.get(yt) || null;
    }
    function K(yt) {
      return G(), I.get(yt) || null;
    }
    var te = r.L, Y = r.R, re = r.EN, se = r.ES, ce = r.ET, ue = r.AN, Me = r.CS, me = r.B, De = r.S, Re = r.ON, He = r.BN, ve = r.NSM, fe = r.AL, he = r.LRO, ye = r.RLO, Ee = r.LRE, Ve = r.RLE, Je = r.PDF, rt = r.LRI, Ne = r.RLI, ct = r.FSI, tt = r.PDI;
    function Tt(yt, Nt) {
      for (var Zt = 125, Rt = new Uint32Array(yt.length), we = 0; we < yt.length; we++)
        Rt[we] = T(yt[we]);
      var oe = /* @__PURE__ */ new Map();
      function Qe(za, Qs) {
        var qr = Rt[za];
        Rt[za] = Qs, oe.set(qr, oe.get(qr) - 1), qr & d && oe.set(d, oe.get(d) - 1), oe.set(Qs, (oe.get(Qs) || 0) + 1), Qs & d && oe.set(d, (oe.get(d) || 0) + 1);
      }
      for (var ut = new Uint8Array(yt.length), Ft = /* @__PURE__ */ new Map(), Ot = [], Wt = null, it = 0; it < yt.length; it++)
        Wt || Ot.push(Wt = {
          start: it,
          end: yt.length - 1,
          level: Nt === "rtl" ? 1 : Nt === "ltr" ? 0 : xo(it, !1)
        }), Rt[it] & me && (Wt.end = it, Wt = null);
      for (var an = Ve | Ee | ye | he | s | tt | Je | me, Be = function(za) {
        return za + (za & 1 ? 1 : 2);
      }, pe = function(za) {
        return za + (za & 1 ? 2 : 1);
      }, Fe = 0; Fe < Ot.length; Fe++) {
        Wt = Ot[Fe];
        var at = [{
          _level: Wt.level,
          _override: 0,
          _isolate: 0
        }], st = void 0, dn = 0, ze = 0, wt = 0;
        oe.clear();
        for (var Pe = Wt.start; Pe <= Wt.end; Pe++) {
          var Gt = Rt[Pe];
          if (st = at[at.length - 1], oe.set(Gt, (oe.get(Gt) || 0) + 1), Gt & d && oe.set(d, (oe.get(d) || 0) + 1), Gt & an)
            if (Gt & (Ve | Ee)) {
              ut[Pe] = st._level;
              var At = (Gt === Ve ? pe : Be)(st._level);
              At <= Zt && !dn && !ze ? at.push({
                _level: At,
                _override: 0,
                _isolate: 0
              }) : dn || ze++;
            } else if (Gt & (ye | he)) {
              ut[Pe] = st._level;
              var cn = (Gt === ye ? pe : Be)(st._level);
              cn <= Zt && !dn && !ze ? at.push({
                _level: cn,
                _override: Gt & ye ? Y : te,
                _isolate: 0
              }) : dn || ze++;
            } else if (Gt & s) {
              Gt & ct && (Gt = xo(Pe + 1, !0) === 1 ? Ne : rt), ut[Pe] = st._level, st._override && Qe(Pe, st._override);
              var ki = (Gt === Ne ? pe : Be)(st._level);
              ki <= Zt && dn === 0 && ze === 0 ? (wt++, at.push({
                _level: ki,
                _override: 0,
                _isolate: 1,
                _isolInitIndex: Pe
              })) : dn++;
            } else if (Gt & tt) {
              if (dn > 0)
                dn--;
              else if (wt > 0) {
                for (ze = 0; !at[at.length - 1]._isolate; )
                  at.pop();
                var Or = at[at.length - 1]._isolInitIndex;
                Or != null && (Ft.set(Or, Pe), Ft.set(Pe, Or)), at.pop(), wt--;
              }
              st = at[at.length - 1], ut[Pe] = st._level, st._override && Qe(Pe, st._override);
            } else
              Gt & Je ? (dn === 0 && (ze > 0 ? ze-- : !st._isolate && at.length > 1 && (at.pop(), st = at[at.length - 1])), ut[Pe] = st._level) : Gt & me && (ut[Pe] = Wt.level);
          else
            ut[Pe] = st._level, st._override && Gt !== He && Qe(Pe, st._override);
        }
        for (var Ii = [], Ir = null, Bn = Wt.start; Bn <= Wt.end; Bn++) {
          var Mi = Rt[Bn];
          if (!(Mi & p)) {
            var yi = ut[Bn], ii = Mi & s, Bi = Mi === tt;
            Ir && yi === Ir._level ? (Ir._end = Bn, Ir._endsWithIsolInit = ii) : Ii.push(Ir = {
              _start: Bn,
              _end: Bn,
              _level: yi,
              _startsWithPDI: Bi,
              _endsWithIsolInit: ii
            });
          }
        }
        for (var xi = [], $r = 0; $r < Ii.length; $r++) {
          var ai = Ii[$r];
          if (!ai._startsWithPDI || ai._startsWithPDI && !Ft.has(ai._start)) {
            for (var Te = [Ir = ai], ot = void 0; Ir && Ir._endsWithIsolInit && (ot = Ft.get(Ir._end)) != null; )
              for (var de = $r + 1; de < Ii.length; de++)
                if (Ii[de]._start === ot) {
                  Te.push(Ir = Ii[de]);
                  break;
                }
            for (var Le = [], Ye = 0; Ye < Te.length; Ye++)
              for (var $t = Te[Ye], mn = $t._start; mn <= $t._end; mn++)
                Le.push(mn);
            for (var Rn = ut[Le[0]], gn = Wt.level, yn = Le[0] - 1; yn >= 0; yn--)
              if (!(Rt[yn] & p)) {
                gn = ut[yn];
                break;
              }
            var Jn = Le[Le.length - 1], rr = ut[Jn], wr = Wt.level;
            if (!(Rt[Jn] & s)) {
              for (var Yi = Jn + 1; Yi <= Wt.end; Yi++)
                if (!(Rt[Yi] & p)) {
                  wr = ut[Yi];
                  break;
                }
            }
            xi.push({
              _seqIndices: Le,
              _sosType: Math.max(gn, Rn) % 2 ? Y : te,
              _eosType: Math.max(wr, rr) % 2 ? Y : te
            });
          }
        }
        for (var La = 0; La < xi.length; La++) {
          var qs = xi[La], en = qs._seqIndices, Xr = qs._sosType, us = qs._eosType;
          if (oe.get(ve))
            for (var qn = 0; qn < en.length; qn++) {
              var qa = en[qn];
              if (Rt[qa] & ve) {
                for (var mo = Xr, Ls = qn - 1; Ls >= 0; Ls--)
                  if (!(Rt[en[Ls]] & p)) {
                    mo = Rt[en[Ls]];
                    break;
                  }
                Qe(qa, mo & (s | tt) ? Re : mo);
              }
            }
          if (oe.get(re))
            for (var cs = 0; cs < en.length; cs++) {
              var mr = en[cs];
              if (Rt[mr] & re)
                for (var di = cs - 1; di >= -1; di--) {
                  var Ea = di === -1 ? Xr : Rt[en[di]];
                  if (Ea & l) {
                    Ea === fe && Qe(mr, ue);
                    break;
                  }
                }
            }
          if (oe.get(fe))
            for (var Si = 0; Si < en.length; Si++) {
              var Ti = en[Si];
              Rt[Ti] & fe && Qe(Ti, Y);
            }
          if (oe.get(se) || oe.get(Me))
            for (var Uo = 1; Uo < en.length - 1; Uo++) {
              var zo = en[Uo];
              if (Rt[zo] & (se | Me)) {
                for (var Pa = 0, Dl = 0, vo = Uo - 1; vo >= 0 && (Pa = Rt[en[vo]], !!(Pa & p)); vo--)
                  ;
                for (var Yf = Uo + 1; Yf < en.length && (Dl = Rt[en[Yf]], !!(Dl & p)); Yf++)
                  ;
                Pa === Dl && (Rt[zo] === se ? Pa === re : Pa & (re | ue)) && Qe(zo, Pa);
              }
            }
          if (oe.get(re))
            for (var Ll = 0; Ll < en.length; Ll++) {
              var Nd = en[Ll];
              if (Rt[Nd] & re) {
                for (var Ps = Ll - 1; Ps >= 0 && Rt[en[Ps]] & (ce | p); Ps--)
                  Qe(en[Ps], re);
                for (var Ju = Ll + 1; Ju < en.length && Rt[en[Ju]] & (ce | p); Ju++)
                  Qe(en[Ju], re);
              }
            }
          if (oe.get(ce) || oe.get(se) || oe.get(Me))
            for (var ou = 0; ou < en.length; ou++) {
              var Jh = en[ou];
              if (Rt[Jh] & (ce | se | Me)) {
                Qe(Jh, Re);
                for (var Pl = ou - 1; Pl >= 0 && Rt[en[Pl]] & p; Pl--)
                  Qe(en[Pl], Re);
                for (var ei = ou + 1; ei < en.length && Rt[en[ei]] & p; ei++)
                  Qe(en[ei], Re);
              }
            }
          if (oe.get(re))
            for (var go = 0, Xf = Xr; go < en.length; go++) {
              var No = en[go], Ci = Rt[No];
              Ci & re ? Xf === te && Qe(No, te) : Ci & l && (Xf = Ci);
            }
          if (oe.get(d)) {
            var fs = Y | re | ue, qf = fs | te, xr = [];
            {
              for (var Tu = [], ua = 0; ua < en.length; ua++)
                if (Rt[en[ua]] & d) {
                  var Cr = yt[en[ua]], dl = void 0;
                  if (B(Cr) !== null)
                    if (Tu.length < 63)
                      Tu.push({ char: Cr, seqIndex: ua });
                    else
                      break;
                  else if ((dl = Q(Cr)) !== null)
                    for (var yo = Tu.length - 1; yo >= 0; yo--) {
                      var Ka = Tu[yo].char;
                      if (Ka === dl || Ka === Q(K(Cr)) || B(K(Ka)) === Cr) {
                        xr.push([Tu[yo].seqIndex, ua]), Tu.length = yo;
                        break;
                      }
                    }
                }
              xr.sort(function(za, Qs) {
                return za[0] - Qs[0];
              });
            }
            for (var Xi = 0; Xi < xr.length; Xi++) {
              for (var Lm = xr[Xi], hi = Lm[0], Qa = Lm[1], Sc = !1, hl = 0, pf = hi + 1; pf < Qa; pf++) {
                var mf = en[pf];
                if (Rt[mf] & qf) {
                  Sc = !0;
                  var lu = Rt[mf] & fs ? Y : te;
                  if (lu === Ul(mf)) {
                    hl = lu;
                    break;
                  }
                }
              }
              if (Sc && !hl) {
                hl = Xr;
                for (var Hi = hi - 1; Hi >= 0; Hi--) {
                  var Ri = en[Hi];
                  if (Rt[Ri] & qf) {
                    var Fo = Rt[Ri] & fs ? Y : te;
                    Fo !== Ul(Ri) ? hl = Fo : hl = Ul(Ri);
                    break;
                  }
                }
              }
              if (hl) {
                if (Rt[en[hi]] = Rt[en[Qa]] = hl, hl !== Ul(en[hi])) {
                  for (var Os = hi + 1; Os < en.length; Os++)
                    if (!(Rt[en[Os]] & p)) {
                      T(yt[en[Os]]) & ve && (Rt[en[Os]] = hl);
                      break;
                    }
                }
                if (hl !== Ul(en[Qa])) {
                  for (var wc = Qa + 1; wc < en.length; wc++)
                    if (!(Rt[en[wc]] & p)) {
                      T(yt[en[wc]]) & ve && (Rt[en[wc]] = hl);
                      break;
                    }
                }
              }
            }
            for (var Ol = 0; Ol < en.length; Ol++)
              if (Rt[en[Ol]] & d) {
                for (var Qf = Ol, Zf = Ol, ko = Xr, Jf = Ol - 1; Jf >= 0; Jf--)
                  if (Rt[en[Jf]] & p)
                    Qf = Jf;
                  else {
                    ko = Rt[en[Jf]] & fs ? Y : te;
                    break;
                  }
                for (var Ki = us, Cu = Ol + 1; Cu < en.length; Cu++)
                  if (Rt[en[Cu]] & (d | p))
                    Zf = Cu;
                  else {
                    Ki = Rt[en[Cu]] & fs ? Y : te;
                    break;
                  }
                for (var Oa = Qf; Oa <= Zf; Oa++)
                  Rt[en[Oa]] = ko === Ki ? ko : Ul(en[Oa]);
                Ol = Zf;
              }
          }
        }
        for (var xs = Wt.start; xs <= Wt.end; xs++) {
          var uu = ut[xs], Ua = Rt[xs];
          if (uu & 1 ? Ua & (te | re | ue) && ut[xs]++ : Ua & Y ? ut[xs]++ : Ua & (ue | re) && (ut[xs] += 2), Ua & p && (ut[xs] = xs === 0 ? Wt.level : ut[xs - 1]), xs === Wt.end || T(yt[xs]) & (De | me))
            for (var bc = xs; bc >= 0 && T(yt[bc]) & g; bc--)
              ut[bc] = Wt.level;
        }
      }
      return {
        levels: ut,
        paragraphs: Ot
      };
      function xo(za, Qs) {
        for (var qr = za; qr < yt.length; qr++) {
          var _s = Rt[qr];
          if (_s & (Y | fe))
            return 1;
          if (_s & (me | te) || Qs && _s === tt)
            return 0;
          if (_s & s) {
            var va = Ru(qr);
            qr = va === -1 ? yt.length : va;
          }
        }
        return 0;
      }
      function Ru(za) {
        for (var Qs = 1, qr = za + 1; qr < yt.length; qr++) {
          var _s = Rt[qr];
          if (_s & me)
            break;
          if (_s & tt) {
            if (--Qs === 0)
              return qr;
          } else
            _s & s && Qs++;
        }
        return -1;
      }
      function Ul(za) {
        return ut[za] & 1 ? Y : te;
      }
    }
    var gt = "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1", ft;
    function Ie() {
      if (!ft) {
        var yt = O(gt, !0), Nt = yt.map, Zt = yt.reverseMap;
        Zt.forEach(function(Rt, we) {
          Nt.set(we, Rt);
        }), ft = Nt;
      }
    }
    function qe(yt) {
      return Ie(), ft.get(yt) || null;
    }
    function dt(yt, Nt, Zt, Rt) {
      var we = yt.length;
      Zt = Math.max(0, Zt == null ? 0 : +Zt), Rt = Math.min(we - 1, Rt == null ? we - 1 : +Rt);
      for (var oe = /* @__PURE__ */ new Map(), Qe = Zt; Qe <= Rt; Qe++)
        if (Nt[Qe] & 1) {
          var ut = qe(yt[Qe]);
          ut !== null && oe.set(Qe, ut);
        }
      return oe;
    }
    function ht(yt, Nt, Zt, Rt) {
      var we = yt.length;
      Zt = Math.max(0, Zt == null ? 0 : +Zt), Rt = Math.min(we - 1, Rt == null ? we - 1 : +Rt);
      var oe = [];
      return Nt.paragraphs.forEach(function(Qe) {
        var ut = Math.max(Zt, Qe.start), Ft = Math.min(Rt, Qe.end);
        if (ut < Ft) {
          for (var Ot = Nt.levels.slice(ut, Ft + 1), Wt = Ft; Wt >= ut && T(yt[Wt]) & g; Wt--)
            Ot[Wt] = Qe.level;
          for (var it = Qe.level, an = 1 / 0, Be = 0; Be < Ot.length; Be++) {
            var pe = Ot[Be];
            pe > it && (it = pe), pe < an && (an = pe | 1);
          }
          for (var Fe = it; Fe >= an; Fe--)
            for (var at = 0; at < Ot.length; at++)
              if (Ot[at] >= Fe) {
                for (var st = at; at + 1 < Ot.length && Ot[at + 1] >= Fe; )
                  at++;
                at > st && oe.push([st + Zt, at + Zt]);
              }
        }
      }), oe;
    }
    function xt(yt, Nt, Zt, Rt) {
      var we = Vt(yt, Nt, Zt, Rt), oe = [].concat(yt);
      return we.forEach(function(Qe, ut) {
        oe[ut] = (Nt.levels[Qe] & 1 ? qe(yt[Qe]) : null) || yt[Qe];
      }), oe.join("");
    }
    function Vt(yt, Nt, Zt, Rt) {
      for (var we = ht(yt, Nt, Zt, Rt), oe = [], Qe = 0; Qe < yt.length; Qe++)
        oe[Qe] = Qe;
      return we.forEach(function(ut) {
        for (var Ft = ut[0], Ot = ut[1], Wt = oe.slice(Ft, Ot + 1), it = Wt.length; it--; )
          oe[Ot - it] = Wt[it];
      }), oe;
    }
    return e.closingToOpeningBracket = Q, e.getBidiCharType = T, e.getBidiCharTypeName = R, e.getCanonicalBracket = K, e.getEmbeddingLevels = Tt, e.getMirroredCharacter = qe, e.getMirroredCharactersMap = dt, e.getReorderSegments = ht, e.getReorderedIndices = Vt, e.getReorderedString = xt, e.openingToClosingBracket = B, Object.defineProperty(e, "__esModule", { value: !0 }), e;
  }({});
  return a;
}
const s4 = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function O3(a) {
  const e = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function t(r, i) {
    let s = na[i];
    return s ? O3(s) : r;
  }
  return a.replace(e, t);
}
const Ud = [];
for (let a = 0; a < 256; a++)
  Ud[a] = (a < 16 ? "0" : "") + a.toString(16);
function jj() {
  const a = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, r = Math.random() * 4294967295 | 0;
  return (Ud[a & 255] + Ud[a >> 8 & 255] + Ud[a >> 16 & 255] + Ud[a >> 24 & 255] + "-" + Ud[e & 255] + Ud[e >> 8 & 255] + "-" + Ud[e >> 16 & 15 | 64] + Ud[e >> 24 & 255] + "-" + Ud[t & 63 | 128] + Ud[t >> 8 & 255] + "-" + Ud[t >> 16 & 255] + Ud[t >> 24 & 255] + Ud[r & 255] + Ud[r >> 8 & 255] + Ud[r >> 16 & 255] + Ud[r >> 24 & 255]).toUpperCase();
}
const w_ = Object.assign || function() {
  let a = arguments[0];
  for (let e = 1, t = arguments.length; e < t; e++) {
    let r = arguments[e];
    if (r)
      for (let i in r)
        r.hasOwnProperty(i) && (a[i] = r[i]);
  }
  return a;
}, Yj = Date.now(), Vz = /* @__PURE__ */ new WeakMap(), Gz = /* @__PURE__ */ new Map();
let Xj = 1e10;
function U3(a, e) {
  const t = Jj(e);
  let r = Vz.get(a);
  if (r || Vz.set(a, r = /* @__PURE__ */ Object.create(null)), r[t])
    return new r[t]();
  const i = `_onBeforeCompile${t}`, s = function(g) {
    a.onBeforeCompile.call(this, g);
    const _ = this.customProgramCacheKey() + "|" + g.vertexShader + "|" + g.fragmentShader;
    let w = Gz[_];
    if (!w) {
      const T = qj(g, e, t);
      w = Gz[_] = T;
    }
    g.vertexShader = w.vertexShader, g.fragmentShader = w.fragmentShader, w_(g.uniforms, this.uniforms), e.timeUniform && (g.uniforms[e.timeUniform] = {
      get value() {
        return Date.now() - Yj;
      }
    }), this[i] && this[i](g);
  }, l = function() {
    return d(e.chained ? a : a.clone());
  }, d = function(g) {
    const _ = Object.create(g, p);
    return Object.defineProperty(_, "baseMaterial", { value: a }), Object.defineProperty(_, "id", { value: Xj++ }), _.uuid = jj(), _.uniforms = w_({}, g.uniforms, e.uniforms), _.defines = w_({}, g.defines, e.defines), _.defines[`TROIKA_DERIVED_MATERIAL_${t}`] = "", _.extensions = w_({}, g.extensions, e.extensions), _._listeners = void 0, _;
  }, p = {
    constructor: { value: l },
    isDerivedMaterial: { value: !0 },
    customProgramCacheKey: {
      writable: !0,
      configurable: !0,
      value: function() {
        return a.customProgramCacheKey() + "|" + t;
      }
    },
    onBeforeCompile: {
      get() {
        return s;
      },
      set(g) {
        this[i] = g;
      }
    },
    copy: {
      writable: !0,
      configurable: !0,
      value: function(g) {
        return a.copy.call(this, g), !a.isShaderMaterial && !a.isDerivedMaterial && (w_(this.extensions, g.extensions), w_(this.defines, g.defines), w_(this.uniforms, $M.clone(g.uniforms))), this;
      }
    },
    clone: {
      writable: !0,
      configurable: !0,
      value: function() {
        const g = new a.constructor();
        return d(g).copy(this);
      }
    },
    getDepthMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let g = this._depthMaterial;
        return g || (g = this._depthMaterial = U3(
          a.isDerivedMaterial ? a.getDepthMaterial() : new tT({ depthPacking: Jw }),
          e
        ), g.defines.IS_DEPTH_MATERIAL = "", g.uniforms = this.uniforms), g;
      }
    },
    getDistanceMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let g = this._distanceMaterial;
        return g || (g = this._distanceMaterial = U3(
          a.isDerivedMaterial ? a.getDistanceMaterial() : new VC(),
          e
        ), g.defines.IS_DISTANCE_MATERIAL = "", g.uniforms = this.uniforms), g;
      }
    },
    dispose: {
      writable: !0,
      configurable: !0,
      value() {
        const { _depthMaterial: g, _distanceMaterial: _ } = this;
        g && g.dispose(), _ && _.dispose(), a.dispose.call(this);
      }
    }
  };
  return r[t] = l, new l();
}
function qj({ vertexShader: a, fragmentShader: e }, t, r) {
  let {
    vertexDefs: i,
    vertexMainIntro: s,
    vertexMainOutro: l,
    vertexTransform: d,
    fragmentDefs: p,
    fragmentMainIntro: g,
    fragmentMainOutro: _,
    fragmentColorTransform: w,
    customRewriter: T,
    timeUniform: R
  } = t;
  if (i = i || "", s = s || "", l = l || "", p = p || "", g = g || "", _ = _ || "", (d || T) && (a = O3(a)), (w || T) && (e = e.replace(
    /^[ \t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,
    `
//!BEGIN_POST_CHUNK $1
$&
//!END_POST_CHUNK
`
  ), e = O3(e)), T) {
    let D = T({ vertexShader: a, fragmentShader: e });
    a = D.vertexShader, e = D.fragmentShader;
  }
  if (w) {
    let D = [];
    e = e.replace(
      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
      (O) => (D.push(O), "")
    ), _ = `${w}
${D.join(`
`)}
${_}`;
  }
  if (R) {
    const D = `
uniform float ${R};
`;
    i = D + i, p = D + p;
  }
  return d && (a = `vec3 troika_position_${r};
vec3 troika_normal_${r};
vec2 troika_uv_${r};
${a}
`, i = `${i}
void troikaVertexTransform${r}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${d}
}
`, s = `
troika_position_${r} = vec3(position);
troika_normal_${r} = vec3(normal);
troika_uv_${r} = vec2(uv);
troikaVertexTransform${r}(troika_position_${r}, troika_normal_${r}, troika_uv_${r});
${s}
`, a = a.replace(/\b(position|normal|uv)\b/g, (D, O, U, H) => /\battribute\s+vec[23]\s+$/.test(H.substr(0, U)) ? O : `troika_${O}_${r}`)), a = Wz(a, r, i, s, l), e = Wz(e, r, p, g, _), {
    vertexShader: a,
    fragmentShader: e
  };
}
function Wz(a, e, t, r, i) {
  return (r || i || t) && (a = a.replace(
    s4,
    `
${t}
void troikaOrigMain${e}() {`
  ), a += `
void main() {
  ${r}
  troikaOrigMain${e}();
  ${i}
}`), a;
}
function Qj(a, e) {
  return a === "uniforms" ? void 0 : typeof e == "function" ? e.toString() : e;
}
let Zj = 0;
const jz = /* @__PURE__ */ new Map();
function Jj(a) {
  const e = JSON.stringify(a, Qj);
  let t = jz.get(e);
  return t == null && jz.set(e, t = ++Zj), t;
}
function Kj(a, e, t) {
  const {
    defaultFontURL: r
  } = t, i = /* @__PURE__ */ Object.create(null), s = 1 / 0, l = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/, d = "[^\\S\\u00A0]", p = new RegExp(`${d}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`);
  function g(I, G) {
    function B() {
      const Q = (K) => {
        console.error(`Failure loading font ${I}${I === r ? "" : "; trying fallback"}`, K), I !== r && (I = r, B());
      };
      try {
        const K = new XMLHttpRequest();
        K.open("get", I, !0), K.responseType = "arraybuffer", K.onload = function() {
          if (K.status >= 400)
            Q(new Error(K.statusText));
          else if (K.status > 0)
            try {
              const te = a(K.response);
              G(te);
            } catch (te) {
              Q(te);
            }
        }, K.onerror = Q, K.send();
      } catch (K) {
        Q(K);
      }
    }
    B();
  }
  function _(I, G) {
    I || (I = r);
    let B = i[I];
    B ? B.pending ? B.pending.push(G) : G(B) : (i[I] = { pending: [G] }, g(I, (Q) => {
      let K = i[I].pending;
      i[I] = Q, K.forEach((te) => te(Q));
    }));
  }
  function w({
    text: I = "",
    font: G = r,
    sdfGlyphSize: B = 64,
    fontSize: Q = 1,
    letterSpacing: K = 0,
    lineHeight: te = "normal",
    maxWidth: Y = s,
    direction: re,
    textAlign: se = "left",
    textIndent: ce = 0,
    whiteSpace: ue = "normal",
    overflowWrap: Me = "normal",
    anchorX: me = 0,
    anchorY: De = 0,
    includeCaretPositions: Re = !1,
    chunkedBoundsSize: He = 8192,
    colorRanges: ve = null
  }, fe, he = !1) {
    const ye = O(), Ee = { fontLoad: 0, typesetting: 0 };
    I.indexOf("\r") > -1 && (console.info("Typesetter: got text with \\r chars; normalizing to \\n"), I = I.replace(/\r\n/g, `
`).replace(/\r/g, `
`)), Q = +Q, K = +K, Y = +Y, te = te || "normal", ce = +ce, _(G, (Ve) => {
      const Je = isFinite(Y);
      let rt = null, Ne = null, ct = null, tt = null, Tt = null, gt = null, ft = null, Ie = 0, qe = 0, dt = ue !== "nowrap";
      const { ascender: ht, descender: xt, unitsPerEm: Vt, lineGap: yt, capHeight: Nt, xHeight: Zt } = Ve;
      Ee.fontLoad = O() - ye;
      const Rt = O(), we = Q / Vt;
      te === "normal" && (te = (ht - xt + yt) / Vt), te = te * Q;
      const oe = (te - (ht - xt) * we) / 2, Qe = -(ht * we + oe), ut = Math.min(te, (ht - xt) * we), Ft = (ht + xt) / 2 * we - ut / 2;
      let Ot = ce, Wt = new U();
      const it = [Wt];
      Ve.forEachGlyph(I, Q, K, (pe, Fe, at) => {
        const st = I.charAt(at), dn = pe.advanceWidth * we, ze = Wt.count;
        let wt;
        if ("isEmpty" in pe || (pe.isWhitespace = !!st && new RegExp(d).test(st), pe.canBreakAfter = !!st && p.test(st), pe.isEmpty = pe.xMin === pe.xMax || pe.yMin === pe.yMax || l.test(st)), !pe.isWhitespace && !pe.isEmpty && qe++, dt && Je && !pe.isWhitespace && Fe + dn + Ot > Y && ze) {
          if (Wt.glyphAt(ze - 1).glyphObj.canBreakAfter)
            wt = new U(), Ot = -Fe;
          else
            for (let Gt = ze; Gt--; )
              if (Gt === 0 && Me === "break-word") {
                wt = new U(), Ot = -Fe;
                break;
              } else if (Wt.glyphAt(Gt).glyphObj.canBreakAfter) {
                wt = Wt.splitAt(Gt + 1);
                const At = wt.glyphAt(0).x;
                Ot -= At;
                for (let cn = wt.count; cn--; )
                  wt.glyphAt(cn).x -= At;
                break;
              }
          wt && (Wt.isSoftWrapped = !0, Wt = wt, it.push(Wt), Ie = Y);
        }
        let Pe = Wt.glyphAt(Wt.count);
        Pe.glyphObj = pe, Pe.x = Fe + Ot, Pe.width = dn, Pe.charIndex = at, st === `
` && (Wt = new U(), it.push(Wt), Ot = -(Fe + dn + K * Q) + ce);
      }), it.forEach((pe) => {
        for (let Fe = pe.count; Fe--; ) {
          let { glyphObj: at, x: st, width: dn } = pe.glyphAt(Fe);
          if (!at.isWhitespace) {
            pe.width = st + dn, pe.width > Ie && (Ie = pe.width);
            return;
          }
        }
      });
      let an = 0, Be = 0;
      if (me && (typeof me == "number" ? an = -me : typeof me == "string" && (an = -Ie * (me === "left" ? 0 : me === "center" ? 0.5 : me === "right" ? 1 : R(me)))), De) {
        if (typeof De == "number")
          Be = -De;
        else if (typeof De == "string") {
          let pe = it.length * te;
          Be = De === "top" ? 0 : De === "top-baseline" ? -Qe : De === "top-cap" ? -Qe - Nt * we : De === "top-ex" ? -Qe - Zt * we : De === "middle" ? pe / 2 : De === "bottom" ? pe : De === "bottom-baseline" ? pe - oe + xt * we : R(De) * pe;
        }
      }
      if (!he) {
        const pe = e.getEmbeddingLevels(I, re);
        rt = new Uint16Array(qe), Ne = new Float32Array(qe * 2), ct = {}, gt = [s, s, -s, -s], ft = [];
        let Fe = Qe;
        Re && (Tt = new Float32Array(I.length * 3)), ve && (tt = new Uint8Array(qe * 3));
        let at = 0, st = -1, dn = -1, ze, wt;
        if (it.forEach((Pe, Gt) => {
          let { count: At, width: cn } = Pe;
          if (At > 0) {
            let ki = 0;
            for (let yi = At; yi-- && Pe.glyphAt(yi).glyphObj.isWhitespace; )
              ki++;
            let Or = 0, Ii = 0;
            if (se === "center")
              Or = (Ie - cn) / 2;
            else if (se === "right")
              Or = Ie - cn;
            else if (se === "justify" && Pe.isSoftWrapped) {
              let yi = 0;
              for (let ii = At - ki; ii--; )
                Pe.glyphAt(ii).glyphObj.isWhitespace && yi++;
              Ii = (Ie - cn) / yi;
            }
            if (Ii || Or) {
              let yi = 0;
              for (let ii = 0; ii < At; ii++) {
                let Bi = Pe.glyphAt(ii);
                const xi = Bi.glyphObj;
                Bi.x += Or + yi, Ii !== 0 && xi.isWhitespace && ii < At - ki && (yi += Ii, Bi.width += Ii);
              }
            }
            const Ir = e.getReorderSegments(
              I,
              pe,
              Pe.glyphAt(0).charIndex,
              Pe.glyphAt(Pe.count - 1).charIndex
            );
            for (let yi = 0; yi < Ir.length; yi++) {
              const [ii, Bi] = Ir[yi];
              let xi = 1 / 0, $r = -1 / 0;
              for (let ai = 0; ai < At; ai++)
                if (Pe.glyphAt(ai).charIndex >= ii) {
                  let Te = ai, ot = ai;
                  for (; ot < At; ot++) {
                    let de = Pe.glyphAt(ot);
                    if (de.charIndex > Bi)
                      break;
                    ot < At - ki && (xi = Math.min(xi, de.x), $r = Math.max($r, de.x + de.width));
                  }
                  for (let de = Te; de < ot; de++) {
                    const Le = Pe.glyphAt(de);
                    Le.x = $r - (Le.x + Le.width - xi);
                  }
                  break;
                }
            }
            let Bn;
            const Mi = (yi) => Bn = yi;
            for (let yi = 0; yi < At; yi++) {
              let ii = Pe.glyphAt(yi);
              Bn = ii.glyphObj;
              const Bi = Bn.index, xi = pe.levels[ii.charIndex] & 1;
              if (xi) {
                const $r = e.getMirroredCharacter(I[ii.charIndex]);
                $r && Ve.forEachGlyph($r, 0, 0, Mi);
              }
              if (Re) {
                const { charIndex: $r } = ii, ai = ii.x + an, Te = ii.x + ii.width + an;
                Tt[$r * 3] = xi ? Te : ai, Tt[$r * 3 + 1] = xi ? ai : Te, Tt[$r * 3 + 2] = Fe + Ft + Be;
                const ot = $r - st;
                ot > 1 && D(Tt, st, ot), st = $r;
              }
              if (ve) {
                const { charIndex: $r } = ii;
                for (; $r > dn; )
                  dn++, ve.hasOwnProperty(dn) && (wt = ve[dn]);
              }
              if (!Bn.isWhitespace && !Bn.isEmpty) {
                const $r = at++;
                ct[Bi] || (ct[Bi] = {
                  path: Bn.path,
                  pathBounds: [Bn.xMin, Bn.yMin, Bn.xMax, Bn.yMax]
                });
                const ai = ii.x + an, Te = Fe + Be;
                Ne[$r * 2] = ai, Ne[$r * 2 + 1] = Te;
                const ot = ai + Bn.xMin * we, de = Te + Bn.yMin * we, Le = ai + Bn.xMax * we, Ye = Te + Bn.yMax * we;
                ot < gt[0] && (gt[0] = ot), de < gt[1] && (gt[1] = de), Le > gt[2] && (gt[2] = Le), Ye > gt[3] && (gt[3] = Ye), $r % He === 0 && (ze = { start: $r, end: $r, rect: [s, s, -s, -s] }, ft.push(ze)), ze.end++;
                const $t = ze.rect;
                if (ot < $t[0] && ($t[0] = ot), de < $t[1] && ($t[1] = de), Le > $t[2] && ($t[2] = Le), Ye > $t[3] && ($t[3] = Ye), rt[$r] = Bi, ve) {
                  const mn = $r * 3;
                  tt[mn] = wt >> 16 & 255, tt[mn + 1] = wt >> 8 & 255, tt[mn + 2] = wt & 255;
                }
              }
            }
          }
          Fe -= te;
        }), Tt) {
          const Pe = I.length - st;
          Pe > 1 && D(Tt, st, Pe);
        }
      }
      Ee.typesetting = O() - Rt, fe({
        glyphIds: rt,
        glyphPositions: Ne,
        glyphData: ct,
        caretPositions: Tt,
        caretHeight: ut,
        glyphColors: tt,
        chunkedBounds: ft,
        fontSize: Q,
        unitsPerEm: Vt,
        ascender: ht * we,
        descender: xt * we,
        capHeight: Nt * we,
        xHeight: Zt * we,
        lineHeight: te,
        topBaseline: Qe,
        blockBounds: [
          an,
          Be - it.length * te,
          an + Ie,
          Be
        ],
        visibleBounds: gt,
        timings: Ee
      });
    });
  }
  function T(I, G) {
    w(I, (B) => {
      const [Q, K, te, Y] = B.blockBounds;
      G({
        width: te - Q,
        height: Y - K
      });
    }, { metricsOnly: !0 });
  }
  function R(I) {
    let G = I.match(/^([\d.]+)%$/), B = G ? parseFloat(G[1]) : NaN;
    return isNaN(B) ? 0 : B / 100;
  }
  function D(I, G, B) {
    const Q = I[G * 3], K = I[G * 3 + 1], te = I[G * 3 + 2], Y = (K - Q) / B;
    for (let re = 0; re < B; re++) {
      const se = (G + re) * 3;
      I[se] = Q + Y * re, I[se + 1] = Q + Y * (re + 1), I[se + 2] = te;
    }
  }
  function O() {
    return (self.performance || Date).now();
  }
  function U() {
    this.data = [];
  }
  const H = ["glyphObj", "x", "width", "charIndex"];
  return U.prototype = {
    width: 0,
    isSoftWrapped: !1,
    get count() {
      return Math.ceil(this.data.length / H.length);
    },
    glyphAt(I) {
      let G = U.flyweight;
      return G.data = this.data, G.index = I, G;
    },
    splitAt(I) {
      let G = new U();
      return G.data = this.data.splice(I * H.length), G;
    }
  }, U.flyweight = H.reduce((I, G, B, Q) => (Object.defineProperty(I, G, {
    get() {
      return this.data[this.index * H.length + B];
    },
    set(K) {
      this.data[this.index * H.length + B] = K;
    }
  }), I), { data: null, index: 0 }), {
    typeset: w,
    measure: T,
    loadFont: _
  };
}
const Y_ = () => (self.performance || Date).now(), tR = /* @__PURE__ */ a4();
let Yz;
function $j(a, e, t, r, i, s, l, d, p, g, _ = !0) {
  return _ ? tY(a, e, t, r, i, s, l, d, p, g).then(
    null,
    (w) => (Yz || (console.warn("WebGL SDF generation failed, falling back to JS", w), Yz = !0), qz(a, e, t, r, i, s, l, d, p, g))
  ) : qz(a, e, t, r, i, s, l, d, p, g);
}
const xC = [], eY = 5;
let z3 = 0;
function o4() {
  const a = Y_();
  for (; xC.length && Y_() - a < eY; )
    xC.shift()();
  z3 = xC.length ? setTimeout(o4, 0) : 0;
}
const tY = (...a) => new Promise((e, t) => {
  xC.push(() => {
    const r = Y_();
    try {
      tR.webgl.generateIntoCanvas(...a), e({ timing: Y_() - r });
    } catch (i) {
      t(i);
    }
  }), z3 || (z3 = setTimeout(o4, 0));
}), nY = 4, rY = 2e3, Xz = {};
let iY = 0;
function qz(a, e, t, r, i, s, l, d, p, g) {
  const _ = "TroikaTextSDFGenerator_JS_" + iY++ % nY;
  let w = Xz[_];
  return w || (w = Xz[_] = {
    workerModule: sT({
      name: _,
      workerId: _,
      dependencies: [
        a4,
        Y_
      ],
      init(T, R) {
        const D = T().javascript.generate;
        return function(...O) {
          const U = R();
          return {
            textureData: D(...O),
            timing: R() - U
          };
        };
      },
      getTransferables(T) {
        return [T.textureData.buffer];
      }
    }),
    requests: 0,
    idleTimer: null
  }), w.requests++, clearTimeout(w.idleTimer), w.workerModule(a, e, t, r, i, s).then(({ textureData: T, timing: R }) => {
    const D = Y_(), O = new Uint8Array(T.length * 4);
    for (let U = 0; U < T.length; U++)
      O[U * 4 + g] = T[U];
    return tR.webglUtils.renderImageData(l, O, d, p, a, e, 1 << 3 - g), R += Y_() - D, --w.requests === 0 && (w.idleTimer = setTimeout(() => {
      Vj(_);
    }, rY)), { timing: R };
  });
}
function aY(a) {
  a._warm || (tR.webgl.isSupported(a), a._warm = !0);
}
const sY = tR.webglUtils.resizeWebGLCanvasWithoutClearing;
/*!
Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
*/
function oY() {
  return typeof window > "u" && (self.window = self), function(a) {
    var e = { parse: function(i) {
      var s = e._bin, l = new Uint8Array(i);
      if (s.readASCII(l, 0, 4) == "ttcf") {
        var d = 4;
        s.readUshort(l, d), d += 2, s.readUshort(l, d), d += 2;
        var p = s.readUint(l, d);
        d += 4;
        for (var g = [], _ = 0; _ < p; _++) {
          var w = s.readUint(l, d);
          d += 4, g.push(e._readFont(l, w));
        }
        return g;
      }
      return [e._readFont(l, 0)];
    }, _readFont: function(i, s) {
      var l = e._bin, d = s;
      l.readFixed(i, s), s += 4;
      var p = l.readUshort(i, s);
      s += 2, l.readUshort(i, s), s += 2, l.readUshort(i, s), s += 2, l.readUshort(i, s), s += 2;
      for (var g = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GPOS", "GSUB", "SVG "], _ = { _data: i, _offset: d }, w = {}, T = 0; T < p; T++) {
        var R = l.readASCII(i, s, 4);
        s += 4, l.readUint(i, s), s += 4;
        var D = l.readUint(i, s);
        s += 4;
        var O = l.readUint(i, s);
        s += 4, w[R] = { offset: D, length: O };
      }
      for (T = 0; T < g.length; T++) {
        var U = g[T];
        w[U] && (_[U.trim()] = e[U.trim()].parse(i, w[U].offset, w[U].length, _));
      }
      return _;
    }, _tabOffset: function(i, s, l) {
      for (var d = e._bin, p = d.readUshort(i, l + 4), g = l + 12, _ = 0; _ < p; _++) {
        var w = d.readASCII(i, g, 4);
        g += 4, d.readUint(i, g), g += 4;
        var T = d.readUint(i, g);
        if (g += 4, d.readUint(i, g), g += 4, w == s)
          return T;
      }
      return 0;
    } };
    e._bin = { readFixed: function(i, s) {
      return (i[s] << 8 | i[s + 1]) + (i[s + 2] << 8 | i[s + 3]) / 65540;
    }, readF2dot14: function(i, s) {
      return e._bin.readShort(i, s) / 16384;
    }, readInt: function(i, s) {
      return e._bin._view(i).getInt32(s);
    }, readInt8: function(i, s) {
      return e._bin._view(i).getInt8(s);
    }, readShort: function(i, s) {
      return e._bin._view(i).getInt16(s);
    }, readUshort: function(i, s) {
      return e._bin._view(i).getUint16(s);
    }, readUshorts: function(i, s, l) {
      for (var d = [], p = 0; p < l; p++)
        d.push(e._bin.readUshort(i, s + 2 * p));
      return d;
    }, readUint: function(i, s) {
      return e._bin._view(i).getUint32(s);
    }, readUint64: function(i, s) {
      return 4294967296 * e._bin.readUint(i, s) + e._bin.readUint(i, s + 4);
    }, readASCII: function(i, s, l) {
      for (var d = "", p = 0; p < l; p++)
        d += String.fromCharCode(i[s + p]);
      return d;
    }, readUnicode: function(i, s, l) {
      for (var d = "", p = 0; p < l; p++) {
        var g = i[s++] << 8 | i[s++];
        d += String.fromCharCode(g);
      }
      return d;
    }, _tdec: typeof window < "u" && window.TextDecoder ? new window.TextDecoder() : null, readUTF8: function(i, s, l) {
      var d = e._bin._tdec;
      return d && s == 0 && l == i.length ? d.decode(i) : e._bin.readASCII(i, s, l);
    }, readBytes: function(i, s, l) {
      for (var d = [], p = 0; p < l; p++)
        d.push(i[s + p]);
      return d;
    }, readASCIIArray: function(i, s, l) {
      for (var d = [], p = 0; p < l; p++)
        d.push(String.fromCharCode(i[s + p]));
      return d;
    }, _view: function(i) {
      return i._dataView || (i._dataView = i.buffer ? new DataView(i.buffer, i.byteOffset, i.byteLength) : new DataView(new Uint8Array(i).buffer));
    } }, e._lctf = {}, e._lctf.parse = function(i, s, l, d, p) {
      var g = e._bin, _ = {}, w = s;
      g.readFixed(i, s), s += 4;
      var T = g.readUshort(i, s);
      s += 2;
      var R = g.readUshort(i, s);
      s += 2;
      var D = g.readUshort(i, s);
      return s += 2, _.scriptList = e._lctf.readScriptList(i, w + T), _.featureList = e._lctf.readFeatureList(i, w + R), _.lookupList = e._lctf.readLookupList(i, w + D, p), _;
    }, e._lctf.readLookupList = function(i, s, l) {
      var d = e._bin, p = s, g = [], _ = d.readUshort(i, s);
      s += 2;
      for (var w = 0; w < _; w++) {
        var T = d.readUshort(i, s);
        s += 2;
        var R = e._lctf.readLookupTable(i, p + T, l);
        g.push(R);
      }
      return g;
    }, e._lctf.readLookupTable = function(i, s, l) {
      var d = e._bin, p = s, g = { tabs: [] };
      g.ltype = d.readUshort(i, s), s += 2, g.flag = d.readUshort(i, s), s += 2;
      var _ = d.readUshort(i, s);
      s += 2;
      for (var w = g.ltype, T = 0; T < _; T++) {
        var R = d.readUshort(i, s);
        s += 2;
        var D = l(i, w, p + R, g);
        g.tabs.push(D);
      }
      return g;
    }, e._lctf.numOfOnes = function(i) {
      for (var s = 0, l = 0; l < 32; l++)
        (i >>> l & 1) != 0 && s++;
      return s;
    }, e._lctf.readClassDef = function(i, s) {
      var l = e._bin, d = [], p = l.readUshort(i, s);
      if (s += 2, p == 1) {
        var g = l.readUshort(i, s);
        s += 2;
        var _ = l.readUshort(i, s);
        s += 2;
        for (var w = 0; w < _; w++)
          d.push(g + w), d.push(g + w), d.push(l.readUshort(i, s)), s += 2;
      }
      if (p == 2) {
        var T = l.readUshort(i, s);
        for (s += 2, w = 0; w < T; w++)
          d.push(l.readUshort(i, s)), s += 2, d.push(l.readUshort(i, s)), s += 2, d.push(l.readUshort(i, s)), s += 2;
      }
      return d;
    }, e._lctf.getInterval = function(i, s) {
      for (var l = 0; l < i.length; l += 3) {
        var d = i[l], p = i[l + 1];
        if (i[l + 2], d <= s && s <= p)
          return l;
      }
      return -1;
    }, e._lctf.readCoverage = function(i, s) {
      var l = e._bin, d = {};
      d.fmt = l.readUshort(i, s), s += 2;
      var p = l.readUshort(i, s);
      return s += 2, d.fmt == 1 && (d.tab = l.readUshorts(i, s, p)), d.fmt == 2 && (d.tab = l.readUshorts(i, s, 3 * p)), d;
    }, e._lctf.coverageIndex = function(i, s) {
      var l = i.tab;
      if (i.fmt == 1)
        return l.indexOf(s);
      if (i.fmt == 2) {
        var d = e._lctf.getInterval(l, s);
        if (d != -1)
          return l[d + 2] + (s - l[d]);
      }
      return -1;
    }, e._lctf.readFeatureList = function(i, s) {
      var l = e._bin, d = s, p = [], g = l.readUshort(i, s);
      s += 2;
      for (var _ = 0; _ < g; _++) {
        var w = l.readASCII(i, s, 4);
        s += 4;
        var T = l.readUshort(i, s);
        s += 2;
        var R = e._lctf.readFeatureTable(i, d + T);
        R.tag = w.trim(), p.push(R);
      }
      return p;
    }, e._lctf.readFeatureTable = function(i, s) {
      var l = e._bin, d = s, p = {}, g = l.readUshort(i, s);
      s += 2, g > 0 && (p.featureParams = d + g);
      var _ = l.readUshort(i, s);
      s += 2, p.tab = [];
      for (var w = 0; w < _; w++)
        p.tab.push(l.readUshort(i, s + 2 * w));
      return p;
    }, e._lctf.readScriptList = function(i, s) {
      var l = e._bin, d = s, p = {}, g = l.readUshort(i, s);
      s += 2;
      for (var _ = 0; _ < g; _++) {
        var w = l.readASCII(i, s, 4);
        s += 4;
        var T = l.readUshort(i, s);
        s += 2, p[w.trim()] = e._lctf.readScriptTable(i, d + T);
      }
      return p;
    }, e._lctf.readScriptTable = function(i, s) {
      var l = e._bin, d = s, p = {}, g = l.readUshort(i, s);
      s += 2, p.default = e._lctf.readLangSysTable(i, d + g);
      var _ = l.readUshort(i, s);
      s += 2;
      for (var w = 0; w < _; w++) {
        var T = l.readASCII(i, s, 4);
        s += 4;
        var R = l.readUshort(i, s);
        s += 2, p[T.trim()] = e._lctf.readLangSysTable(i, d + R);
      }
      return p;
    }, e._lctf.readLangSysTable = function(i, s) {
      var l = e._bin, d = {};
      l.readUshort(i, s), s += 2, d.reqFeature = l.readUshort(i, s), s += 2;
      var p = l.readUshort(i, s);
      return s += 2, d.features = l.readUshorts(i, s, p), d;
    }, e.CFF = {}, e.CFF.parse = function(i, s, l) {
      var d = e._bin;
      (i = new Uint8Array(i.buffer, s, l))[s = 0], i[++s], i[++s], i[++s], s++;
      var p = [];
      s = e.CFF.readIndex(i, s, p);
      for (var g = [], _ = 0; _ < p.length - 1; _++)
        g.push(d.readASCII(i, s + p[_], p[_ + 1] - p[_]));
      s += p[p.length - 1];
      var w = [];
      s = e.CFF.readIndex(i, s, w);
      var T = [];
      for (_ = 0; _ < w.length - 1; _++)
        T.push(e.CFF.readDict(i, s + w[_], s + w[_ + 1]));
      s += w[w.length - 1];
      var R = T[0], D = [];
      s = e.CFF.readIndex(i, s, D);
      var O = [];
      for (_ = 0; _ < D.length - 1; _++)
        O.push(d.readASCII(i, s + D[_], D[_ + 1] - D[_]));
      if (s += D[D.length - 1], e.CFF.readSubrs(i, s, R), R.CharStrings) {
        s = R.CharStrings, D = [], s = e.CFF.readIndex(i, s, D);
        var U = [];
        for (_ = 0; _ < D.length - 1; _++)
          U.push(d.readBytes(i, s + D[_], D[_ + 1] - D[_]));
        R.CharStrings = U;
      }
      if (R.ROS) {
        s = R.FDArray;
        var H = [];
        for (s = e.CFF.readIndex(i, s, H), R.FDArray = [], _ = 0; _ < H.length - 1; _++) {
          var I = e.CFF.readDict(i, s + H[_], s + H[_ + 1]);
          e.CFF._readFDict(i, I, O), R.FDArray.push(I);
        }
        s += H[H.length - 1], s = R.FDSelect, R.FDSelect = [];
        var G = i[s];
        if (s++, G != 3)
          throw G;
        var B = d.readUshort(i, s);
        for (s += 2, _ = 0; _ < B + 1; _++)
          R.FDSelect.push(d.readUshort(i, s), i[s + 2]), s += 3;
      }
      return R.Encoding && (R.Encoding = e.CFF.readEncoding(i, R.Encoding, R.CharStrings.length)), R.charset && (R.charset = e.CFF.readCharset(i, R.charset, R.CharStrings.length)), e.CFF._readFDict(i, R, O), R;
    }, e.CFF._readFDict = function(i, s, l) {
      var d;
      for (var p in s.Private && (d = s.Private[1], s.Private = e.CFF.readDict(i, d, d + s.Private[0]), s.Private.Subrs && e.CFF.readSubrs(i, d + s.Private.Subrs, s.Private)), s)
        ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(p) != -1 && (s[p] = l[s[p] - 426 + 35]);
    }, e.CFF.readSubrs = function(i, s, l) {
      var d = e._bin, p = [];
      s = e.CFF.readIndex(i, s, p);
      var g, _ = p.length;
      g = _ < 1240 ? 107 : _ < 33900 ? 1131 : 32768, l.Bias = g, l.Subrs = [];
      for (var w = 0; w < p.length - 1; w++)
        l.Subrs.push(d.readBytes(i, s + p[w], p[w + 1] - p[w]));
    }, e.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0], e.CFF.glyphByUnicode = function(i, s) {
      for (var l = 0; l < i.charset.length; l++)
        if (i.charset[l] == s)
          return l;
      return -1;
    }, e.CFF.glyphBySE = function(i, s) {
      return s < 0 || s > 255 ? -1 : e.CFF.glyphByUnicode(i, e.CFF.tableSE[s]);
    }, e.CFF.readEncoding = function(i, s, l) {
      e._bin;
      var d = [".notdef"], p = i[s];
      if (s++, p != 0)
        throw "error: unknown encoding format: " + p;
      var g = i[s];
      s++;
      for (var _ = 0; _ < g; _++)
        d.push(i[s + _]);
      return d;
    }, e.CFF.readCharset = function(i, s, l) {
      var d = e._bin, p = [".notdef"], g = i[s];
      if (s++, g == 0)
        for (var _ = 0; _ < l; _++) {
          var w = d.readUshort(i, s);
          s += 2, p.push(w);
        }
      else {
        if (g != 1 && g != 2)
          throw "error: format: " + g;
        for (; p.length < l; ) {
          w = d.readUshort(i, s), s += 2;
          var T = 0;
          for (g == 1 ? (T = i[s], s++) : (T = d.readUshort(i, s), s += 2), _ = 0; _ <= T; _++)
            p.push(w), w++;
        }
      }
      return p;
    }, e.CFF.readIndex = function(i, s, l) {
      var d = e._bin, p = d.readUshort(i, s) + 1, g = i[s += 2];
      if (s++, g == 1)
        for (var _ = 0; _ < p; _++)
          l.push(i[s + _]);
      else if (g == 2)
        for (_ = 0; _ < p; _++)
          l.push(d.readUshort(i, s + 2 * _));
      else if (g == 3)
        for (_ = 0; _ < p; _++)
          l.push(16777215 & d.readUint(i, s + 3 * _ - 1));
      else if (p != 1)
        throw "unsupported offset size: " + g + ", count: " + p;
      return (s += p * g) - 1;
    }, e.CFF.getCharString = function(i, s, l) {
      var d = e._bin, p = i[s], g = i[s + 1];
      i[s + 2], i[s + 3], i[s + 4];
      var _ = 1, w = null, T = null;
      p <= 20 && (w = p, _ = 1), p == 12 && (w = 100 * p + g, _ = 2), 21 <= p && p <= 27 && (w = p, _ = 1), p == 28 && (T = d.readShort(i, s + 1), _ = 3), 29 <= p && p <= 31 && (w = p, _ = 1), 32 <= p && p <= 246 && (T = p - 139, _ = 1), 247 <= p && p <= 250 && (T = 256 * (p - 247) + g + 108, _ = 2), 251 <= p && p <= 254 && (T = 256 * -(p - 251) - g - 108, _ = 2), p == 255 && (T = d.readInt(i, s + 1) / 65535, _ = 5), l.val = T != null ? T : "o" + w, l.size = _;
    }, e.CFF.readCharString = function(i, s, l) {
      for (var d = s + l, p = e._bin, g = []; s < d; ) {
        var _ = i[s], w = i[s + 1];
        i[s + 2], i[s + 3], i[s + 4];
        var T = 1, R = null, D = null;
        _ <= 20 && (R = _, T = 1), _ == 12 && (R = 100 * _ + w, T = 2), _ != 19 && _ != 20 || (R = _, T = 2), 21 <= _ && _ <= 27 && (R = _, T = 1), _ == 28 && (D = p.readShort(i, s + 1), T = 3), 29 <= _ && _ <= 31 && (R = _, T = 1), 32 <= _ && _ <= 246 && (D = _ - 139, T = 1), 247 <= _ && _ <= 250 && (D = 256 * (_ - 247) + w + 108, T = 2), 251 <= _ && _ <= 254 && (D = 256 * -(_ - 251) - w - 108, T = 2), _ == 255 && (D = p.readInt(i, s + 1) / 65535, T = 5), g.push(D != null ? D : "o" + R), s += T;
      }
      return g;
    }, e.CFF.readDict = function(i, s, l) {
      for (var d = e._bin, p = {}, g = []; s < l; ) {
        var _ = i[s], w = i[s + 1];
        i[s + 2], i[s + 3], i[s + 4];
        var T = 1, R = null, D = null;
        if (_ == 28 && (D = d.readShort(i, s + 1), T = 3), _ == 29 && (D = d.readInt(i, s + 1), T = 5), 32 <= _ && _ <= 246 && (D = _ - 139, T = 1), 247 <= _ && _ <= 250 && (D = 256 * (_ - 247) + w + 108, T = 2), 251 <= _ && _ <= 254 && (D = 256 * -(_ - 251) - w - 108, T = 2), _ == 255)
          throw D = d.readInt(i, s + 1) / 65535, T = 5, "unknown number";
        if (_ == 30) {
          var O = [];
          for (T = 1; ; ) {
            var U = i[s + T];
            T++;
            var H = U >> 4, I = 15 & U;
            if (H != 15 && O.push(H), I != 15 && O.push(I), I == 15)
              break;
          }
          for (var G = "", B = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], Q = 0; Q < O.length; Q++)
            G += B[O[Q]];
          D = parseFloat(G);
        }
        _ <= 21 && (R = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][_], T = 1, _ == 12 && (R = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][w], T = 2)), R != null ? (p[R] = g.length == 1 ? g[0] : g, g = []) : g.push(D), s += T;
      }
      return p;
    }, e.cmap = {}, e.cmap.parse = function(i, s, l) {
      i = new Uint8Array(i.buffer, s, l), s = 0;
      var d = e._bin, p = {};
      d.readUshort(i, s), s += 2;
      var g = d.readUshort(i, s);
      s += 2;
      var _ = [];
      p.tables = [];
      for (var w = 0; w < g; w++) {
        var T = d.readUshort(i, s);
        s += 2;
        var R = d.readUshort(i, s);
        s += 2;
        var D = d.readUint(i, s);
        s += 4;
        var O = "p" + T + "e" + R, U = _.indexOf(D);
        if (U == -1) {
          var H;
          U = p.tables.length, _.push(D);
          var I = d.readUshort(i, D);
          I == 0 ? H = e.cmap.parse0(i, D) : I == 4 ? H = e.cmap.parse4(i, D) : I == 6 ? H = e.cmap.parse6(i, D) : I == 12 ? H = e.cmap.parse12(i, D) : console.debug("unknown format: " + I, T, R, D), p.tables.push(H);
        }
        if (p[O] != null)
          throw "multiple tables for one platform+encoding";
        p[O] = U;
      }
      return p;
    }, e.cmap.parse0 = function(i, s) {
      var l = e._bin, d = {};
      d.format = l.readUshort(i, s), s += 2;
      var p = l.readUshort(i, s);
      s += 2, l.readUshort(i, s), s += 2, d.map = [];
      for (var g = 0; g < p - 6; g++)
        d.map.push(i[s + g]);
      return d;
    }, e.cmap.parse4 = function(i, s) {
      var l = e._bin, d = s, p = {};
      p.format = l.readUshort(i, s), s += 2;
      var g = l.readUshort(i, s);
      s += 2, l.readUshort(i, s), s += 2;
      var _ = l.readUshort(i, s);
      s += 2;
      var w = _ / 2;
      p.searchRange = l.readUshort(i, s), s += 2, p.entrySelector = l.readUshort(i, s), s += 2, p.rangeShift = l.readUshort(i, s), s += 2, p.endCount = l.readUshorts(i, s, w), s += 2 * w, s += 2, p.startCount = l.readUshorts(i, s, w), s += 2 * w, p.idDelta = [];
      for (var T = 0; T < w; T++)
        p.idDelta.push(l.readShort(i, s)), s += 2;
      for (p.idRangeOffset = l.readUshorts(i, s, w), s += 2 * w, p.glyphIdArray = []; s < d + g; )
        p.glyphIdArray.push(l.readUshort(i, s)), s += 2;
      return p;
    }, e.cmap.parse6 = function(i, s) {
      var l = e._bin, d = {};
      d.format = l.readUshort(i, s), s += 2, l.readUshort(i, s), s += 2, l.readUshort(i, s), s += 2, d.firstCode = l.readUshort(i, s), s += 2;
      var p = l.readUshort(i, s);
      s += 2, d.glyphIdArray = [];
      for (var g = 0; g < p; g++)
        d.glyphIdArray.push(l.readUshort(i, s)), s += 2;
      return d;
    }, e.cmap.parse12 = function(i, s) {
      var l = e._bin, d = {};
      d.format = l.readUshort(i, s), s += 2, s += 2, l.readUint(i, s), s += 4, l.readUint(i, s), s += 4;
      var p = l.readUint(i, s);
      s += 4, d.groups = [];
      for (var g = 0; g < p; g++) {
        var _ = s + 12 * g, w = l.readUint(i, _ + 0), T = l.readUint(i, _ + 4), R = l.readUint(i, _ + 8);
        d.groups.push([w, T, R]);
      }
      return d;
    }, e.glyf = {}, e.glyf.parse = function(i, s, l, d) {
      for (var p = [], g = 0; g < d.maxp.numGlyphs; g++)
        p.push(null);
      return p;
    }, e.glyf._parseGlyf = function(i, s) {
      var l = e._bin, d = i._data, p = e._tabOffset(d, "glyf", i._offset) + i.loca[s];
      if (i.loca[s] == i.loca[s + 1])
        return null;
      var g = {};
      if (g.noc = l.readShort(d, p), p += 2, g.xMin = l.readShort(d, p), p += 2, g.yMin = l.readShort(d, p), p += 2, g.xMax = l.readShort(d, p), p += 2, g.yMax = l.readShort(d, p), p += 2, g.xMin >= g.xMax || g.yMin >= g.yMax)
        return null;
      if (g.noc > 0) {
        g.endPts = [];
        for (var _ = 0; _ < g.noc; _++)
          g.endPts.push(l.readUshort(d, p)), p += 2;
        var w = l.readUshort(d, p);
        if (p += 2, d.length - p < w)
          return null;
        g.instructions = l.readBytes(d, p, w), p += w;
        var T = g.endPts[g.noc - 1] + 1;
        for (g.flags = [], _ = 0; _ < T; _++) {
          var R = d[p];
          if (p++, g.flags.push(R), (8 & R) != 0) {
            var D = d[p];
            p++;
            for (var O = 0; O < D; O++)
              g.flags.push(R), _++;
          }
        }
        for (g.xs = [], _ = 0; _ < T; _++) {
          var U = (2 & g.flags[_]) != 0, H = (16 & g.flags[_]) != 0;
          U ? (g.xs.push(H ? d[p] : -d[p]), p++) : H ? g.xs.push(0) : (g.xs.push(l.readShort(d, p)), p += 2);
        }
        for (g.ys = [], _ = 0; _ < T; _++)
          U = (4 & g.flags[_]) != 0, H = (32 & g.flags[_]) != 0, U ? (g.ys.push(H ? d[p] : -d[p]), p++) : H ? g.ys.push(0) : (g.ys.push(l.readShort(d, p)), p += 2);
        var I = 0, G = 0;
        for (_ = 0; _ < T; _++)
          I += g.xs[_], G += g.ys[_], g.xs[_] = I, g.ys[_] = G;
      } else {
        var B;
        g.parts = [];
        do {
          B = l.readUshort(d, p), p += 2;
          var Q = { m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, p1: -1, p2: -1 };
          if (g.parts.push(Q), Q.glyphIndex = l.readUshort(d, p), p += 2, 1 & B) {
            var K = l.readShort(d, p);
            p += 2;
            var te = l.readShort(d, p);
            p += 2;
          } else
            K = l.readInt8(d, p), p++, te = l.readInt8(d, p), p++;
          2 & B ? (Q.m.tx = K, Q.m.ty = te) : (Q.p1 = K, Q.p2 = te), 8 & B ? (Q.m.a = Q.m.d = l.readF2dot14(d, p), p += 2) : 64 & B ? (Q.m.a = l.readF2dot14(d, p), p += 2, Q.m.d = l.readF2dot14(d, p), p += 2) : 128 & B && (Q.m.a = l.readF2dot14(d, p), p += 2, Q.m.b = l.readF2dot14(d, p), p += 2, Q.m.c = l.readF2dot14(d, p), p += 2, Q.m.d = l.readF2dot14(d, p), p += 2);
        } while (32 & B);
        if (256 & B) {
          var Y = l.readUshort(d, p);
          for (p += 2, g.instr = [], _ = 0; _ < Y; _++)
            g.instr.push(d[p]), p++;
        }
      }
      return g;
    }, e.GPOS = {}, e.GPOS.parse = function(i, s, l, d) {
      return e._lctf.parse(i, s, l, d, e.GPOS.subt);
    }, e.GPOS.subt = function(i, s, l, d) {
      var p = e._bin, g = l, _ = {};
      if (_.fmt = p.readUshort(i, l), l += 2, s == 1 || s == 2 || s == 3 || s == 7 || s == 8 && _.fmt <= 2) {
        var w = p.readUshort(i, l);
        l += 2, _.coverage = e._lctf.readCoverage(i, w + g);
      }
      if (s == 1 && _.fmt == 1) {
        var T = p.readUshort(i, l);
        l += 2;
        var R = e._lctf.numOfOnes(T);
        T != 0 && (_.pos = e.GPOS.readValueRecord(i, l, T));
      } else if (s == 2 && _.fmt >= 1 && _.fmt <= 2) {
        T = p.readUshort(i, l), l += 2;
        var D = p.readUshort(i, l);
        l += 2, R = e._lctf.numOfOnes(T);
        var O = e._lctf.numOfOnes(D);
        if (_.fmt == 1) {
          _.pairsets = [];
          var U = p.readUshort(i, l);
          l += 2;
          for (var H = 0; H < U; H++) {
            var I = g + p.readUshort(i, l);
            l += 2;
            var G = p.readUshort(i, I);
            I += 2;
            for (var B = [], Q = 0; Q < G; Q++) {
              var K = p.readUshort(i, I);
              I += 2, T != 0 && (ue = e.GPOS.readValueRecord(i, I, T), I += 2 * R), D != 0 && (Me = e.GPOS.readValueRecord(i, I, D), I += 2 * O), B.push({ gid2: K, val1: ue, val2: Me });
            }
            _.pairsets.push(B);
          }
        }
        if (_.fmt == 2) {
          var te = p.readUshort(i, l);
          l += 2;
          var Y = p.readUshort(i, l);
          l += 2;
          var re = p.readUshort(i, l);
          l += 2;
          var se = p.readUshort(i, l);
          for (l += 2, _.classDef1 = e._lctf.readClassDef(i, g + te), _.classDef2 = e._lctf.readClassDef(i, g + Y), _.matrix = [], H = 0; H < re; H++) {
            var ce = [];
            for (Q = 0; Q < se; Q++) {
              var ue = null, Me = null;
              T != 0 && (ue = e.GPOS.readValueRecord(i, l, T), l += 2 * R), D != 0 && (Me = e.GPOS.readValueRecord(i, l, D), l += 2 * O), ce.push({ val1: ue, val2: Me });
            }
            _.matrix.push(ce);
          }
        }
      } else {
        if (s == 9 && _.fmt == 1) {
          var me = p.readUshort(i, l);
          l += 2;
          var De = p.readUint(i, l);
          if (l += 4, d.ltype == 9)
            d.ltype = me;
          else if (d.ltype != me)
            throw "invalid extension substitution";
          return e.GPOS.subt(i, d.ltype, g + De);
        }
        console.debug("unsupported GPOS table LookupType", s, "format", _.fmt);
      }
      return _;
    }, e.GPOS.readValueRecord = function(i, s, l) {
      var d = e._bin, p = [];
      return p.push(1 & l ? d.readShort(i, s) : 0), s += 1 & l ? 2 : 0, p.push(2 & l ? d.readShort(i, s) : 0), s += 2 & l ? 2 : 0, p.push(4 & l ? d.readShort(i, s) : 0), s += 4 & l ? 2 : 0, p.push(8 & l ? d.readShort(i, s) : 0), s += 8 & l ? 2 : 0, p;
    }, e.GSUB = {}, e.GSUB.parse = function(i, s, l, d) {
      return e._lctf.parse(i, s, l, d, e.GSUB.subt);
    }, e.GSUB.subt = function(i, s, l, d) {
      var p = e._bin, g = l, _ = {};
      if (_.fmt = p.readUshort(i, l), l += 2, s != 1 && s != 4 && s != 5 && s != 6)
        return null;
      if (s == 1 || s == 4 || s == 5 && _.fmt <= 2 || s == 6 && _.fmt <= 2) {
        var w = p.readUshort(i, l);
        l += 2, _.coverage = e._lctf.readCoverage(i, g + w);
      }
      if (s == 1 && _.fmt >= 1 && _.fmt <= 2) {
        if (_.fmt == 1)
          _.delta = p.readShort(i, l), l += 2;
        else if (_.fmt == 2) {
          var T = p.readUshort(i, l);
          l += 2, _.newg = p.readUshorts(i, l, T), l += 2 * _.newg.length;
        }
      } else if (s == 4) {
        _.vals = [], T = p.readUshort(i, l), l += 2;
        for (var R = 0; R < T; R++) {
          var D = p.readUshort(i, l);
          l += 2, _.vals.push(e.GSUB.readLigatureSet(i, g + D));
        }
      } else if (s == 5 && _.fmt == 2) {
        if (_.fmt == 2) {
          var O = p.readUshort(i, l);
          l += 2, _.cDef = e._lctf.readClassDef(i, g + O), _.scset = [];
          var U = p.readUshort(i, l);
          for (l += 2, R = 0; R < U; R++) {
            var H = p.readUshort(i, l);
            l += 2, _.scset.push(H == 0 ? null : e.GSUB.readSubClassSet(i, g + H));
          }
        }
      } else if (s == 6 && _.fmt == 3) {
        if (_.fmt == 3) {
          for (R = 0; R < 3; R++) {
            T = p.readUshort(i, l), l += 2;
            for (var I = [], G = 0; G < T; G++)
              I.push(e._lctf.readCoverage(i, g + p.readUshort(i, l + 2 * G)));
            l += 2 * T, R == 0 && (_.backCvg = I), R == 1 && (_.inptCvg = I), R == 2 && (_.ahedCvg = I);
          }
          T = p.readUshort(i, l), l += 2, _.lookupRec = e.GSUB.readSubstLookupRecords(i, l, T);
        }
      } else {
        if (s == 7 && _.fmt == 1) {
          var B = p.readUshort(i, l);
          l += 2;
          var Q = p.readUint(i, l);
          if (l += 4, d.ltype == 9)
            d.ltype = B;
          else if (d.ltype != B)
            throw "invalid extension substitution";
          return e.GSUB.subt(i, d.ltype, g + Q);
        }
        console.debug("unsupported GSUB table LookupType", s, "format", _.fmt);
      }
      return _;
    }, e.GSUB.readSubClassSet = function(i, s) {
      var l = e._bin.readUshort, d = s, p = [], g = l(i, s);
      s += 2;
      for (var _ = 0; _ < g; _++) {
        var w = l(i, s);
        s += 2, p.push(e.GSUB.readSubClassRule(i, d + w));
      }
      return p;
    }, e.GSUB.readSubClassRule = function(i, s) {
      var l = e._bin.readUshort, d = {}, p = l(i, s), g = l(i, s += 2);
      s += 2, d.input = [];
      for (var _ = 0; _ < p - 1; _++)
        d.input.push(l(i, s)), s += 2;
      return d.substLookupRecords = e.GSUB.readSubstLookupRecords(i, s, g), d;
    }, e.GSUB.readSubstLookupRecords = function(i, s, l) {
      for (var d = e._bin.readUshort, p = [], g = 0; g < l; g++)
        p.push(d(i, s), d(i, s + 2)), s += 4;
      return p;
    }, e.GSUB.readChainSubClassSet = function(i, s) {
      var l = e._bin, d = s, p = [], g = l.readUshort(i, s);
      s += 2;
      for (var _ = 0; _ < g; _++) {
        var w = l.readUshort(i, s);
        s += 2, p.push(e.GSUB.readChainSubClassRule(i, d + w));
      }
      return p;
    }, e.GSUB.readChainSubClassRule = function(i, s) {
      for (var l = e._bin, d = {}, p = ["backtrack", "input", "lookahead"], g = 0; g < p.length; g++) {
        var _ = l.readUshort(i, s);
        s += 2, g == 1 && _--, d[p[g]] = l.readUshorts(i, s, _), s += 2 * d[p[g]].length;
      }
      return _ = l.readUshort(i, s), s += 2, d.subst = l.readUshorts(i, s, 2 * _), s += 2 * d.subst.length, d;
    }, e.GSUB.readLigatureSet = function(i, s) {
      var l = e._bin, d = s, p = [], g = l.readUshort(i, s);
      s += 2;
      for (var _ = 0; _ < g; _++) {
        var w = l.readUshort(i, s);
        s += 2, p.push(e.GSUB.readLigature(i, d + w));
      }
      return p;
    }, e.GSUB.readLigature = function(i, s) {
      var l = e._bin, d = { chain: [] };
      d.nglyph = l.readUshort(i, s), s += 2;
      var p = l.readUshort(i, s);
      s += 2;
      for (var g = 0; g < p - 1; g++)
        d.chain.push(l.readUshort(i, s)), s += 2;
      return d;
    }, e.head = {}, e.head.parse = function(i, s, l) {
      var d = e._bin, p = {};
      return d.readFixed(i, s), s += 4, p.fontRevision = d.readFixed(i, s), s += 4, d.readUint(i, s), s += 4, d.readUint(i, s), s += 4, p.flags = d.readUshort(i, s), s += 2, p.unitsPerEm = d.readUshort(i, s), s += 2, p.created = d.readUint64(i, s), s += 8, p.modified = d.readUint64(i, s), s += 8, p.xMin = d.readShort(i, s), s += 2, p.yMin = d.readShort(i, s), s += 2, p.xMax = d.readShort(i, s), s += 2, p.yMax = d.readShort(i, s), s += 2, p.macStyle = d.readUshort(i, s), s += 2, p.lowestRecPPEM = d.readUshort(i, s), s += 2, p.fontDirectionHint = d.readShort(i, s), s += 2, p.indexToLocFormat = d.readShort(i, s), s += 2, p.glyphDataFormat = d.readShort(i, s), s += 2, p;
    }, e.hhea = {}, e.hhea.parse = function(i, s, l) {
      var d = e._bin, p = {};
      return d.readFixed(i, s), s += 4, p.ascender = d.readShort(i, s), s += 2, p.descender = d.readShort(i, s), s += 2, p.lineGap = d.readShort(i, s), s += 2, p.advanceWidthMax = d.readUshort(i, s), s += 2, p.minLeftSideBearing = d.readShort(i, s), s += 2, p.minRightSideBearing = d.readShort(i, s), s += 2, p.xMaxExtent = d.readShort(i, s), s += 2, p.caretSlopeRise = d.readShort(i, s), s += 2, p.caretSlopeRun = d.readShort(i, s), s += 2, p.caretOffset = d.readShort(i, s), s += 2, s += 8, p.metricDataFormat = d.readShort(i, s), s += 2, p.numberOfHMetrics = d.readUshort(i, s), s += 2, p;
    }, e.hmtx = {}, e.hmtx.parse = function(i, s, l, d) {
      for (var p = e._bin, g = { aWidth: [], lsBearing: [] }, _ = 0, w = 0, T = 0; T < d.maxp.numGlyphs; T++)
        T < d.hhea.numberOfHMetrics && (_ = p.readUshort(i, s), s += 2, w = p.readShort(i, s), s += 2), g.aWidth.push(_), g.lsBearing.push(w);
      return g;
    }, e.kern = {}, e.kern.parse = function(i, s, l, d) {
      var p = e._bin, g = p.readUshort(i, s);
      if (s += 2, g == 1)
        return e.kern.parseV1(i, s - 2, l, d);
      var _ = p.readUshort(i, s);
      s += 2;
      for (var w = { glyph1: [], rval: [] }, T = 0; T < _; T++) {
        s += 2, l = p.readUshort(i, s), s += 2;
        var R = p.readUshort(i, s);
        s += 2;
        var D = R >>> 8;
        if ((D &= 15) != 0)
          throw "unknown kern table format: " + D;
        s = e.kern.readFormat0(i, s, w);
      }
      return w;
    }, e.kern.parseV1 = function(i, s, l, d) {
      var p = e._bin;
      p.readFixed(i, s), s += 4;
      var g = p.readUint(i, s);
      s += 4;
      for (var _ = { glyph1: [], rval: [] }, w = 0; w < g; w++) {
        p.readUint(i, s), s += 4;
        var T = p.readUshort(i, s);
        s += 2, p.readUshort(i, s), s += 2;
        var R = T >>> 8;
        if ((R &= 15) != 0)
          throw "unknown kern table format: " + R;
        s = e.kern.readFormat0(i, s, _);
      }
      return _;
    }, e.kern.readFormat0 = function(i, s, l) {
      var d = e._bin, p = -1, g = d.readUshort(i, s);
      s += 2, d.readUshort(i, s), s += 2, d.readUshort(i, s), s += 2, d.readUshort(i, s), s += 2;
      for (var _ = 0; _ < g; _++) {
        var w = d.readUshort(i, s);
        s += 2;
        var T = d.readUshort(i, s);
        s += 2;
        var R = d.readShort(i, s);
        s += 2, w != p && (l.glyph1.push(w), l.rval.push({ glyph2: [], vals: [] }));
        var D = l.rval[l.rval.length - 1];
        D.glyph2.push(T), D.vals.push(R), p = w;
      }
      return s;
    }, e.loca = {}, e.loca.parse = function(i, s, l, d) {
      var p = e._bin, g = [], _ = d.head.indexToLocFormat, w = d.maxp.numGlyphs + 1;
      if (_ == 0)
        for (var T = 0; T < w; T++)
          g.push(p.readUshort(i, s + (T << 1)) << 1);
      if (_ == 1)
        for (T = 0; T < w; T++)
          g.push(p.readUint(i, s + (T << 2)));
      return g;
    }, e.maxp = {}, e.maxp.parse = function(i, s, l) {
      var d = e._bin, p = {}, g = d.readUint(i, s);
      return s += 4, p.numGlyphs = d.readUshort(i, s), s += 2, g == 65536 && (p.maxPoints = d.readUshort(i, s), s += 2, p.maxContours = d.readUshort(i, s), s += 2, p.maxCompositePoints = d.readUshort(i, s), s += 2, p.maxCompositeContours = d.readUshort(i, s), s += 2, p.maxZones = d.readUshort(i, s), s += 2, p.maxTwilightPoints = d.readUshort(i, s), s += 2, p.maxStorage = d.readUshort(i, s), s += 2, p.maxFunctionDefs = d.readUshort(i, s), s += 2, p.maxInstructionDefs = d.readUshort(i, s), s += 2, p.maxStackElements = d.readUshort(i, s), s += 2, p.maxSizeOfInstructions = d.readUshort(i, s), s += 2, p.maxComponentElements = d.readUshort(i, s), s += 2, p.maxComponentDepth = d.readUshort(i, s), s += 2), p;
    }, e.name = {}, e.name.parse = function(i, s, l) {
      var d = e._bin, p = {};
      d.readUshort(i, s), s += 2;
      var g = d.readUshort(i, s);
      s += 2, d.readUshort(i, s);
      for (var _, w = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], T = s += 2, R = 0; R < g; R++) {
        var D = d.readUshort(i, s);
        s += 2;
        var O = d.readUshort(i, s);
        s += 2;
        var U = d.readUshort(i, s);
        s += 2;
        var H = d.readUshort(i, s);
        s += 2;
        var I = d.readUshort(i, s);
        s += 2;
        var G = d.readUshort(i, s);
        s += 2;
        var B, Q = w[H], K = T + 12 * g + G;
        if (D == 0)
          B = d.readUnicode(i, K, I / 2);
        else if (D == 3 && O == 0)
          B = d.readUnicode(i, K, I / 2);
        else if (O == 0)
          B = d.readASCII(i, K, I);
        else if (O == 1)
          B = d.readUnicode(i, K, I / 2);
        else if (O == 3)
          B = d.readUnicode(i, K, I / 2);
        else {
          if (D != 1)
            throw "unknown encoding " + O + ", platformID: " + D;
          B = d.readASCII(i, K, I), console.debug("reading unknown MAC encoding " + O + " as ASCII");
        }
        var te = "p" + D + "," + U.toString(16);
        p[te] == null && (p[te] = {}), p[te][Q !== void 0 ? Q : H] = B, p[te]._lang = U;
      }
      for (var Y in p)
        if (p[Y].postScriptName != null && p[Y]._lang == 1033)
          return p[Y];
      for (var Y in p)
        if (p[Y].postScriptName != null && p[Y]._lang == 0)
          return p[Y];
      for (var Y in p)
        if (p[Y].postScriptName != null && p[Y]._lang == 3084)
          return p[Y];
      for (var Y in p)
        if (p[Y].postScriptName != null)
          return p[Y];
      for (var Y in p) {
        _ = Y;
        break;
      }
      return console.debug("returning name table with languageID " + p[_]._lang), p[_];
    }, e["OS/2"] = {}, e["OS/2"].parse = function(i, s, l) {
      var d = e._bin.readUshort(i, s);
      s += 2;
      var p = {};
      if (d == 0)
        e["OS/2"].version0(i, s, p);
      else if (d == 1)
        e["OS/2"].version1(i, s, p);
      else if (d == 2 || d == 3 || d == 4)
        e["OS/2"].version2(i, s, p);
      else {
        if (d != 5)
          throw "unknown OS/2 table version: " + d;
        e["OS/2"].version5(i, s, p);
      }
      return p;
    }, e["OS/2"].version0 = function(i, s, l) {
      var d = e._bin;
      return l.xAvgCharWidth = d.readShort(i, s), s += 2, l.usWeightClass = d.readUshort(i, s), s += 2, l.usWidthClass = d.readUshort(i, s), s += 2, l.fsType = d.readUshort(i, s), s += 2, l.ySubscriptXSize = d.readShort(i, s), s += 2, l.ySubscriptYSize = d.readShort(i, s), s += 2, l.ySubscriptXOffset = d.readShort(i, s), s += 2, l.ySubscriptYOffset = d.readShort(i, s), s += 2, l.ySuperscriptXSize = d.readShort(i, s), s += 2, l.ySuperscriptYSize = d.readShort(i, s), s += 2, l.ySuperscriptXOffset = d.readShort(i, s), s += 2, l.ySuperscriptYOffset = d.readShort(i, s), s += 2, l.yStrikeoutSize = d.readShort(i, s), s += 2, l.yStrikeoutPosition = d.readShort(i, s), s += 2, l.sFamilyClass = d.readShort(i, s), s += 2, l.panose = d.readBytes(i, s, 10), s += 10, l.ulUnicodeRange1 = d.readUint(i, s), s += 4, l.ulUnicodeRange2 = d.readUint(i, s), s += 4, l.ulUnicodeRange3 = d.readUint(i, s), s += 4, l.ulUnicodeRange4 = d.readUint(i, s), s += 4, l.achVendID = [d.readInt8(i, s), d.readInt8(i, s + 1), d.readInt8(i, s + 2), d.readInt8(i, s + 3)], s += 4, l.fsSelection = d.readUshort(i, s), s += 2, l.usFirstCharIndex = d.readUshort(i, s), s += 2, l.usLastCharIndex = d.readUshort(i, s), s += 2, l.sTypoAscender = d.readShort(i, s), s += 2, l.sTypoDescender = d.readShort(i, s), s += 2, l.sTypoLineGap = d.readShort(i, s), s += 2, l.usWinAscent = d.readUshort(i, s), s += 2, l.usWinDescent = d.readUshort(i, s), s += 2;
    }, e["OS/2"].version1 = function(i, s, l) {
      var d = e._bin;
      return s = e["OS/2"].version0(i, s, l), l.ulCodePageRange1 = d.readUint(i, s), s += 4, l.ulCodePageRange2 = d.readUint(i, s), s += 4;
    }, e["OS/2"].version2 = function(i, s, l) {
      var d = e._bin;
      return s = e["OS/2"].version1(i, s, l), l.sxHeight = d.readShort(i, s), s += 2, l.sCapHeight = d.readShort(i, s), s += 2, l.usDefault = d.readUshort(i, s), s += 2, l.usBreak = d.readUshort(i, s), s += 2, l.usMaxContext = d.readUshort(i, s), s += 2;
    }, e["OS/2"].version5 = function(i, s, l) {
      var d = e._bin;
      return s = e["OS/2"].version2(i, s, l), l.usLowerOpticalPointSize = d.readUshort(i, s), s += 2, l.usUpperOpticalPointSize = d.readUshort(i, s), s += 2;
    }, e.post = {}, e.post.parse = function(i, s, l) {
      var d = e._bin, p = {};
      return p.version = d.readFixed(i, s), s += 4, p.italicAngle = d.readFixed(i, s), s += 4, p.underlinePosition = d.readShort(i, s), s += 2, p.underlineThickness = d.readShort(i, s), s += 2, p;
    }, e == null && (e = {}), e.U == null && (e.U = {}), e.U.codeToGlyph = function(i, s) {
      var l = i.cmap, d = -1;
      if (l.p0e4 != null ? d = l.p0e4 : l.p3e1 != null ? d = l.p3e1 : l.p1e0 != null ? d = l.p1e0 : l.p0e3 != null && (d = l.p0e3), d == -1)
        throw "no familiar platform and encoding!";
      var p = l.tables[d];
      if (p.format == 0)
        return s >= p.map.length ? 0 : p.map[s];
      if (p.format == 4) {
        for (var g = -1, _ = 0; _ < p.endCount.length; _++)
          if (s <= p.endCount[_]) {
            g = _;
            break;
          }
        return g == -1 || p.startCount[g] > s ? 0 : 65535 & (p.idRangeOffset[g] != 0 ? p.glyphIdArray[s - p.startCount[g] + (p.idRangeOffset[g] >> 1) - (p.idRangeOffset.length - g)] : s + p.idDelta[g]);
      }
      if (p.format == 12) {
        if (s > p.groups[p.groups.length - 1][1])
          return 0;
        for (_ = 0; _ < p.groups.length; _++) {
          var w = p.groups[_];
          if (w[0] <= s && s <= w[1])
            return w[2] + (s - w[0]);
        }
        return 0;
      }
      throw "unknown cmap table format " + p.format;
    }, e.U.glyphToPath = function(i, s) {
      var l = { cmds: [], crds: [] };
      if (i.SVG && i.SVG.entries[s]) {
        var d = i.SVG.entries[s];
        return d == null ? l : (typeof d == "string" && (d = e.SVG.toPath(d), i.SVG.entries[s] = d), d);
      }
      if (i.CFF) {
        var p = { x: 0, y: 0, stack: [], nStems: 0, haveWidth: !1, width: i.CFF.Private ? i.CFF.Private.defaultWidthX : 0, open: !1 }, g = i.CFF, _ = i.CFF.Private;
        if (g.ROS) {
          for (var w = 0; g.FDSelect[w + 2] <= s; )
            w += 2;
          _ = g.FDArray[g.FDSelect[w + 1]].Private;
        }
        e.U._drawCFF(i.CFF.CharStrings[s], p, g, _, l);
      } else
        i.glyf && e.U._drawGlyf(s, i, l);
      return l;
    }, e.U._drawGlyf = function(i, s, l) {
      var d = s.glyf[i];
      d == null && (d = s.glyf[i] = e.glyf._parseGlyf(s, i)), d != null && (d.noc > -1 ? e.U._simpleGlyph(d, l) : e.U._compoGlyph(d, s, l));
    }, e.U._simpleGlyph = function(i, s) {
      for (var l = 0; l < i.noc; l++) {
        for (var d = l == 0 ? 0 : i.endPts[l - 1] + 1, p = i.endPts[l], g = d; g <= p; g++) {
          var _ = g == d ? p : g - 1, w = g == p ? d : g + 1, T = 1 & i.flags[g], R = 1 & i.flags[_], D = 1 & i.flags[w], O = i.xs[g], U = i.ys[g];
          if (g == d)
            if (T) {
              if (!R) {
                e.U.P.moveTo(s, O, U);
                continue;
              }
              e.U.P.moveTo(s, i.xs[_], i.ys[_]);
            } else
              R ? e.U.P.moveTo(s, i.xs[_], i.ys[_]) : e.U.P.moveTo(s, (i.xs[_] + O) / 2, (i.ys[_] + U) / 2);
          T ? R && e.U.P.lineTo(s, O, U) : D ? e.U.P.qcurveTo(s, O, U, i.xs[w], i.ys[w]) : e.U.P.qcurveTo(s, O, U, (O + i.xs[w]) / 2, (U + i.ys[w]) / 2);
        }
        e.U.P.closePath(s);
      }
    }, e.U._compoGlyph = function(i, s, l) {
      for (var d = 0; d < i.parts.length; d++) {
        var p = { cmds: [], crds: [] }, g = i.parts[d];
        e.U._drawGlyf(g.glyphIndex, s, p);
        for (var _ = g.m, w = 0; w < p.crds.length; w += 2) {
          var T = p.crds[w], R = p.crds[w + 1];
          l.crds.push(T * _.a + R * _.b + _.tx), l.crds.push(T * _.c + R * _.d + _.ty);
        }
        for (w = 0; w < p.cmds.length; w++)
          l.cmds.push(p.cmds[w]);
      }
    }, e.U._getGlyphClass = function(i, s) {
      var l = e._lctf.getInterval(s, i);
      return l == -1 ? 0 : s[l + 2];
    }, e.U.getPairAdjustment = function(i, s, l) {
      var d = !1;
      if (i.GPOS)
        for (var p = i.GPOS, g = p.lookupList, _ = p.featureList, w = [], T = 0; T < _.length; T++) {
          var R = _[T];
          if (R.tag == "kern") {
            d = !0;
            for (var D = 0; D < R.tab.length; D++)
              if (!w[R.tab[D]]) {
                w[R.tab[D]] = !0;
                for (var O = g[R.tab[D]], U = 0; U < O.tabs.length; U++)
                  if (O.tabs[U] != null) {
                    var H, I = O.tabs[U];
                    if ((!I.coverage || (H = e._lctf.coverageIndex(I.coverage, s)) != -1) && O.ltype != 1) {
                      if (O.ltype == 2) {
                        var G = null;
                        if (I.fmt == 1) {
                          var B = I.pairsets[H];
                          for (T = 0; T < B.length; T++)
                            B[T].gid2 == l && (G = B[T]);
                        } else if (I.fmt == 2) {
                          var Q = e.U._getGlyphClass(s, I.classDef1), K = e.U._getGlyphClass(l, I.classDef2);
                          G = I.matrix[Q][K];
                        }
                        if (G) {
                          var te = 0;
                          return G.val1 && G.val1[2] && (te += G.val1[2]), G.val2 && G.val2[0] && (te += G.val2[0]), te;
                        }
                      }
                    }
                  }
              }
          }
        }
      if (i.kern && !d) {
        var Y = i.kern.glyph1.indexOf(s);
        if (Y != -1) {
          var re = i.kern.rval[Y].glyph2.indexOf(l);
          if (re != -1)
            return i.kern.rval[Y].vals[re];
        }
      }
      return 0;
    }, e.U._applySubs = function(i, s, l, d) {
      for (var p = i.length - s - 1, g = 0; g < l.tabs.length; g++)
        if (l.tabs[g] != null) {
          var _, w = l.tabs[g];
          if (!w.coverage || (_ = e._lctf.coverageIndex(w.coverage, i[s])) != -1) {
            if (l.ltype == 1)
              i[s], w.fmt == 1 ? i[s] = i[s] + w.delta : i[s] = w.newg[_];
            else if (l.ltype == 4)
              for (var T = w.vals[_], R = 0; R < T.length; R++) {
                var D = T[R], O = D.chain.length;
                if (!(O > p)) {
                  for (var U = !0, H = 0, I = 0; I < O; I++) {
                    for (; i[s + H + (1 + I)] == -1; )
                      H++;
                    D.chain[I] != i[s + H + (1 + I)] && (U = !1);
                  }
                  if (U) {
                    for (i[s] = D.nglyph, I = 0; I < O + H; I++)
                      i[s + I + 1] = -1;
                    break;
                  }
                }
              }
            else if (l.ltype == 5 && w.fmt == 2)
              for (var G = e._lctf.getInterval(w.cDef, i[s]), B = w.cDef[G + 2], Q = w.scset[B], K = 0; K < Q.length; K++) {
                var te = Q[K], Y = te.input;
                if (!(Y.length > p)) {
                  for (U = !0, I = 0; I < Y.length; I++) {
                    var re = e._lctf.getInterval(w.cDef, i[s + 1 + I]);
                    if (G == -1 && w.cDef[re + 2] != Y[I]) {
                      U = !1;
                      break;
                    }
                  }
                  if (U) {
                    var se = te.substLookupRecords;
                    for (R = 0; R < se.length; R += 2)
                      se[R], se[R + 1];
                  }
                }
              }
            else if (l.ltype == 6 && w.fmt == 3) {
              if (!e.U._glsCovered(i, w.backCvg, s - w.backCvg.length) || !e.U._glsCovered(i, w.inptCvg, s) || !e.U._glsCovered(i, w.ahedCvg, s + w.inptCvg.length))
                continue;
              var ce = w.lookupRec;
              for (K = 0; K < ce.length; K += 2) {
                G = ce[K];
                var ue = d[ce[K + 1]];
                e.U._applySubs(i, s + G, ue, d);
              }
            }
          }
        }
    }, e.U._glsCovered = function(i, s, l) {
      for (var d = 0; d < s.length; d++)
        if (e._lctf.coverageIndex(s[d], i[l + d]) == -1)
          return !1;
      return !0;
    }, e.U.glyphsToPath = function(i, s, l) {
      for (var d = { cmds: [], crds: [] }, p = 0, g = 0; g < s.length; g++) {
        var _ = s[g];
        if (_ != -1) {
          for (var w = g < s.length - 1 && s[g + 1] != -1 ? s[g + 1] : 0, T = e.U.glyphToPath(i, _), R = 0; R < T.crds.length; R += 2)
            d.crds.push(T.crds[R] + p), d.crds.push(T.crds[R + 1]);
          for (l && d.cmds.push(l), R = 0; R < T.cmds.length; R++)
            d.cmds.push(T.cmds[R]);
          l && d.cmds.push("X"), p += i.hmtx.aWidth[_], g < s.length - 1 && (p += e.U.getPairAdjustment(i, _, w));
        }
      }
      return d;
    }, e.U.P = {}, e.U.P.moveTo = function(i, s, l) {
      i.cmds.push("M"), i.crds.push(s, l);
    }, e.U.P.lineTo = function(i, s, l) {
      i.cmds.push("L"), i.crds.push(s, l);
    }, e.U.P.curveTo = function(i, s, l, d, p, g, _) {
      i.cmds.push("C"), i.crds.push(s, l, d, p, g, _);
    }, e.U.P.qcurveTo = function(i, s, l, d, p) {
      i.cmds.push("Q"), i.crds.push(s, l, d, p);
    }, e.U.P.closePath = function(i) {
      i.cmds.push("Z");
    }, e.U._drawCFF = function(i, s, l, d, p) {
      for (var g = s.stack, _ = s.nStems, w = s.haveWidth, T = s.width, R = s.open, D = 0, O = s.x, U = s.y, H = 0, I = 0, G = 0, B = 0, Q = 0, K = 0, te = 0, Y = 0, re = 0, se = 0, ce = { val: 0, size: 0 }; D < i.length; ) {
        e.CFF.getCharString(i, D, ce);
        var ue = ce.val;
        if (D += ce.size, ue == "o1" || ue == "o18")
          g.length % 2 != 0 && !w && (T = g.shift() + d.nominalWidthX), _ += g.length >> 1, g.length = 0, w = !0;
        else if (ue == "o3" || ue == "o23")
          g.length % 2 != 0 && !w && (T = g.shift() + d.nominalWidthX), _ += g.length >> 1, g.length = 0, w = !0;
        else if (ue == "o4")
          g.length > 1 && !w && (T = g.shift() + d.nominalWidthX, w = !0), R && e.U.P.closePath(p), U += g.pop(), e.U.P.moveTo(p, O, U), R = !0;
        else if (ue == "o5")
          for (; g.length > 0; )
            O += g.shift(), U += g.shift(), e.U.P.lineTo(p, O, U);
        else if (ue == "o6" || ue == "o7")
          for (var Me = g.length, me = ue == "o6", De = 0; De < Me; De++) {
            var Re = g.shift();
            me ? O += Re : U += Re, me = !me, e.U.P.lineTo(p, O, U);
          }
        else if (ue == "o8" || ue == "o24") {
          Me = g.length;
          for (var He = 0; He + 6 <= Me; )
            H = O + g.shift(), I = U + g.shift(), G = H + g.shift(), B = I + g.shift(), O = G + g.shift(), U = B + g.shift(), e.U.P.curveTo(p, H, I, G, B, O, U), He += 6;
          ue == "o24" && (O += g.shift(), U += g.shift(), e.U.P.lineTo(p, O, U));
        } else {
          if (ue == "o11")
            break;
          if (ue == "o1234" || ue == "o1235" || ue == "o1236" || ue == "o1237")
            ue == "o1234" && (I = U, G = (H = O + g.shift()) + g.shift(), se = B = I + g.shift(), K = B, Y = U, O = (te = (Q = (re = G + g.shift()) + g.shift()) + g.shift()) + g.shift(), e.U.P.curveTo(p, H, I, G, B, re, se), e.U.P.curveTo(p, Q, K, te, Y, O, U)), ue == "o1235" && (H = O + g.shift(), I = U + g.shift(), G = H + g.shift(), B = I + g.shift(), re = G + g.shift(), se = B + g.shift(), Q = re + g.shift(), K = se + g.shift(), te = Q + g.shift(), Y = K + g.shift(), O = te + g.shift(), U = Y + g.shift(), g.shift(), e.U.P.curveTo(p, H, I, G, B, re, se), e.U.P.curveTo(p, Q, K, te, Y, O, U)), ue == "o1236" && (H = O + g.shift(), I = U + g.shift(), G = H + g.shift(), se = B = I + g.shift(), K = B, te = (Q = (re = G + g.shift()) + g.shift()) + g.shift(), Y = K + g.shift(), O = te + g.shift(), e.U.P.curveTo(p, H, I, G, B, re, se), e.U.P.curveTo(p, Q, K, te, Y, O, U)), ue == "o1237" && (H = O + g.shift(), I = U + g.shift(), G = H + g.shift(), B = I + g.shift(), re = G + g.shift(), se = B + g.shift(), Q = re + g.shift(), K = se + g.shift(), te = Q + g.shift(), Y = K + g.shift(), Math.abs(te - O) > Math.abs(Y - U) ? O = te + g.shift() : U = Y + g.shift(), e.U.P.curveTo(p, H, I, G, B, re, se), e.U.P.curveTo(p, Q, K, te, Y, O, U));
          else if (ue == "o14") {
            if (g.length > 0 && !w && (T = g.shift() + l.nominalWidthX, w = !0), g.length == 4) {
              var ve = g.shift(), fe = g.shift(), he = g.shift(), ye = g.shift(), Ee = e.CFF.glyphBySE(l, he), Ve = e.CFF.glyphBySE(l, ye);
              e.U._drawCFF(l.CharStrings[Ee], s, l, d, p), s.x = ve, s.y = fe, e.U._drawCFF(l.CharStrings[Ve], s, l, d, p);
            }
            R && (e.U.P.closePath(p), R = !1);
          } else if (ue == "o19" || ue == "o20")
            g.length % 2 != 0 && !w && (T = g.shift() + d.nominalWidthX), _ += g.length >> 1, g.length = 0, w = !0, D += _ + 7 >> 3;
          else if (ue == "o21")
            g.length > 2 && !w && (T = g.shift() + d.nominalWidthX, w = !0), U += g.pop(), O += g.pop(), R && e.U.P.closePath(p), e.U.P.moveTo(p, O, U), R = !0;
          else if (ue == "o22")
            g.length > 1 && !w && (T = g.shift() + d.nominalWidthX, w = !0), O += g.pop(), R && e.U.P.closePath(p), e.U.P.moveTo(p, O, U), R = !0;
          else if (ue == "o25") {
            for (; g.length > 6; )
              O += g.shift(), U += g.shift(), e.U.P.lineTo(p, O, U);
            H = O + g.shift(), I = U + g.shift(), G = H + g.shift(), B = I + g.shift(), O = G + g.shift(), U = B + g.shift(), e.U.P.curveTo(p, H, I, G, B, O, U);
          } else if (ue == "o26")
            for (g.length % 2 && (O += g.shift()); g.length > 0; )
              H = O, I = U + g.shift(), O = G = H + g.shift(), U = (B = I + g.shift()) + g.shift(), e.U.P.curveTo(p, H, I, G, B, O, U);
          else if (ue == "o27")
            for (g.length % 2 && (U += g.shift()); g.length > 0; )
              I = U, G = (H = O + g.shift()) + g.shift(), B = I + g.shift(), O = G + g.shift(), U = B, e.U.P.curveTo(p, H, I, G, B, O, U);
          else if (ue == "o10" || ue == "o29") {
            var Je = ue == "o10" ? d : l;
            if (g.length == 0)
              console.debug("error: empty stack");
            else {
              var rt = g.pop(), Ne = Je.Subrs[rt + Je.Bias];
              s.x = O, s.y = U, s.nStems = _, s.haveWidth = w, s.width = T, s.open = R, e.U._drawCFF(Ne, s, l, d, p), O = s.x, U = s.y, _ = s.nStems, w = s.haveWidth, T = s.width, R = s.open;
            }
          } else if (ue == "o30" || ue == "o31") {
            var ct = g.length, tt = (He = 0, ue == "o31");
            for (He += ct - (Me = -3 & ct); He < Me; )
              tt ? (I = U, G = (H = O + g.shift()) + g.shift(), U = (B = I + g.shift()) + g.shift(), Me - He == 5 ? (O = G + g.shift(), He++) : O = G, tt = !1) : (H = O, I = U + g.shift(), G = H + g.shift(), B = I + g.shift(), O = G + g.shift(), Me - He == 5 ? (U = B + g.shift(), He++) : U = B, tt = !0), e.U.P.curveTo(p, H, I, G, B, O, U), He += 4;
          } else {
            if ((ue + "").charAt(0) == "o")
              throw console.debug("Unknown operation: " + ue, i), ue;
            g.push(ue);
          }
        }
      }
      s.x = O, s.y = U, s.nStems = _, s.haveWidth = w, s.width = T, s.open = R;
    };
    var t = e, r = { Typr: t };
    return a.Typr = t, a.default = r, Object.defineProperty(a, "__esModule", { value: !0 }), a;
  }({}).Typr;
}
/*!
Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
(https://github.com/101arrowz/fflate) for use in Troika text rendering. 
Original licenses apply: 
- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
*/
function lY() {
  return function(a) {
    var e = Uint8Array, t = Uint16Array, r = Uint32Array, i = new e([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), s = new e([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), l = new e([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), d = function(ue, Me) {
      for (var me = new t(31), De = 0; De < 31; ++De)
        me[De] = Me += 1 << ue[De - 1];
      var Re = new r(me[30]);
      for (De = 1; De < 30; ++De)
        for (var He = me[De]; He < me[De + 1]; ++He)
          Re[He] = He - me[De] << 5 | De;
      return [me, Re];
    }, p = d(i, 2), g = p[0], _ = p[1];
    g[28] = 258, _[258] = 28;
    for (var w = d(s, 0)[0], T = new t(32768), R = 0; R < 32768; ++R) {
      var D = (43690 & R) >>> 1 | (21845 & R) << 1;
      D = (61680 & (D = (52428 & D) >>> 2 | (13107 & D) << 2)) >>> 4 | (3855 & D) << 4, T[R] = ((65280 & D) >>> 8 | (255 & D) << 8) >>> 1;
    }
    var O = function(ue, Me, me) {
      for (var De = ue.length, Re = 0, He = new t(Me); Re < De; ++Re)
        ++He[ue[Re] - 1];
      var ve, fe = new t(Me);
      for (Re = 0; Re < Me; ++Re)
        fe[Re] = fe[Re - 1] + He[Re - 1] << 1;
      if (me) {
        ve = new t(1 << Me);
        var he = 15 - Me;
        for (Re = 0; Re < De; ++Re)
          if (ue[Re])
            for (var ye = Re << 4 | ue[Re], Ee = Me - ue[Re], Ve = fe[ue[Re] - 1]++ << Ee, Je = Ve | (1 << Ee) - 1; Ve <= Je; ++Ve)
              ve[T[Ve] >>> he] = ye;
      } else
        for (ve = new t(De), Re = 0; Re < De; ++Re)
          ue[Re] && (ve[Re] = T[fe[ue[Re] - 1]++] >>> 15 - ue[Re]);
      return ve;
    }, U = new e(288);
    for (R = 0; R < 144; ++R)
      U[R] = 8;
    for (R = 144; R < 256; ++R)
      U[R] = 9;
    for (R = 256; R < 280; ++R)
      U[R] = 7;
    for (R = 280; R < 288; ++R)
      U[R] = 8;
    var H = new e(32);
    for (R = 0; R < 32; ++R)
      H[R] = 5;
    var I = O(U, 9, 1), G = O(H, 5, 1), B = function(ue) {
      for (var Me = ue[0], me = 1; me < ue.length; ++me)
        ue[me] > Me && (Me = ue[me]);
      return Me;
    }, Q = function(ue, Me, me) {
      var De = Me / 8 | 0;
      return (ue[De] | ue[De + 1] << 8) >> (7 & Me) & me;
    }, K = function(ue, Me) {
      var me = Me / 8 | 0;
      return (ue[me] | ue[me + 1] << 8 | ue[me + 2] << 16) >> (7 & Me);
    }, te = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], Y = function(ue, Me, me) {
      var De = new Error(Me || te[ue]);
      if (De.code = ue, Error.captureStackTrace && Error.captureStackTrace(De, Y), !me)
        throw De;
      return De;
    }, re = function(ue, Me, me) {
      var De = ue.length;
      if (!De || me && !me.l && De < 5)
        return Me || new e(0);
      var Re = !Me || me, He = !me || me.i;
      me || (me = {}), Me || (Me = new e(3 * De));
      var ve, fe = function(st) {
        var dn = Me.length;
        if (st > dn) {
          var ze = new e(Math.max(2 * dn, st));
          ze.set(Me), Me = ze;
        }
      }, he = me.f || 0, ye = me.p || 0, Ee = me.b || 0, Ve = me.l, Je = me.d, rt = me.m, Ne = me.n, ct = 8 * De;
      do {
        if (!Ve) {
          me.f = he = Q(ue, ye, 1);
          var tt = Q(ue, ye + 1, 3);
          if (ye += 3, !tt) {
            var Tt = ue[(Zt = ((ve = ye) / 8 | 0) + (7 & ve && 1) + 4) - 4] | ue[Zt - 3] << 8, gt = Zt + Tt;
            if (gt > De) {
              He && Y(0);
              break;
            }
            Re && fe(Ee + Tt), Me.set(ue.subarray(Zt, gt), Ee), me.b = Ee += Tt, me.p = ye = 8 * gt;
            continue;
          }
          if (tt == 1)
            Ve = I, Je = G, rt = 9, Ne = 5;
          else if (tt == 2) {
            var ft = Q(ue, ye, 31) + 257, Ie = Q(ue, ye + 10, 15) + 4, qe = ft + Q(ue, ye + 5, 31) + 1;
            ye += 14;
            for (var dt = new e(qe), ht = new e(19), xt = 0; xt < Ie; ++xt)
              ht[l[xt]] = Q(ue, ye + 3 * xt, 7);
            ye += 3 * Ie;
            var Vt = B(ht), yt = (1 << Vt) - 1, Nt = O(ht, Vt, 1);
            for (xt = 0; xt < qe; ) {
              var Zt, Rt = Nt[Q(ue, ye, yt)];
              if (ye += 15 & Rt, (Zt = Rt >>> 4) < 16)
                dt[xt++] = Zt;
              else {
                var we = 0, oe = 0;
                for (Zt == 16 ? (oe = 3 + Q(ue, ye, 3), ye += 2, we = dt[xt - 1]) : Zt == 17 ? (oe = 3 + Q(ue, ye, 7), ye += 3) : Zt == 18 && (oe = 11 + Q(ue, ye, 127), ye += 7); oe--; )
                  dt[xt++] = we;
              }
            }
            var Qe = dt.subarray(0, ft), ut = dt.subarray(ft);
            rt = B(Qe), Ne = B(ut), Ve = O(Qe, rt, 1), Je = O(ut, Ne, 1);
          } else
            Y(1);
          if (ye > ct) {
            He && Y(0);
            break;
          }
        }
        Re && fe(Ee + 131072);
        for (var Ft = (1 << rt) - 1, Ot = (1 << Ne) - 1, Wt = ye; ; Wt = ye) {
          var it = (we = Ve[K(ue, ye) & Ft]) >>> 4;
          if ((ye += 15 & we) > ct) {
            He && Y(0);
            break;
          }
          if (we || Y(2), it < 256)
            Me[Ee++] = it;
          else {
            if (it == 256) {
              Wt = ye, Ve = null;
              break;
            }
            var an = it - 254;
            if (it > 264) {
              var Be = i[xt = it - 257];
              an = Q(ue, ye, (1 << Be) - 1) + g[xt], ye += Be;
            }
            var pe = Je[K(ue, ye) & Ot], Fe = pe >>> 4;
            if (pe || Y(3), ye += 15 & pe, ut = w[Fe], Fe > 3 && (Be = s[Fe], ut += K(ue, ye) & (1 << Be) - 1, ye += Be), ye > ct) {
              He && Y(0);
              break;
            }
            Re && fe(Ee + 131072);
            for (var at = Ee + an; Ee < at; Ee += 4)
              Me[Ee] = Me[Ee - ut], Me[Ee + 1] = Me[Ee + 1 - ut], Me[Ee + 2] = Me[Ee + 2 - ut], Me[Ee + 3] = Me[Ee + 3 - ut];
            Ee = at;
          }
        }
        me.l = Ve, me.p = Wt, me.b = Ee, Ve && (he = 1, me.m = rt, me.d = Je, me.n = Ne);
      } while (!he);
      return Ee == Me.length ? Me : function(st, dn, ze) {
        (dn == null || dn < 0) && (dn = 0), (ze == null || ze > st.length) && (ze = st.length);
        var wt = new (st instanceof t ? t : st instanceof r ? r : e)(ze - dn);
        return wt.set(st.subarray(dn, ze)), wt;
      }(Me, 0, Ee);
    }, se = new e(0), ce = typeof TextDecoder < "u" && new TextDecoder();
    try {
      ce.decode(se, { stream: !0 });
    } catch {
    }
    return a.convert_streams = function(ue) {
      var Me = new DataView(ue), me = 0;
      function De() {
        var ft = Me.getUint16(me);
        return me += 2, ft;
      }
      function Re() {
        var ft = Me.getUint32(me);
        return me += 4, ft;
      }
      function He(ft) {
        Tt.setUint16(gt, ft), gt += 2;
      }
      function ve(ft) {
        Tt.setUint32(gt, ft), gt += 4;
      }
      for (var fe = { signature: Re(), flavor: Re(), length: Re(), numTables: De(), reserved: De(), totalSfntSize: Re(), majorVersion: De(), minorVersion: De(), metaOffset: Re(), metaLength: Re(), metaOrigLength: Re(), privOffset: Re(), privLength: Re() }, he = 0; Math.pow(2, he) <= fe.numTables; )
        he++;
      he--;
      for (var ye = 16 * Math.pow(2, he), Ee = 16 * fe.numTables - ye, Ve = 12, Je = [], rt = 0; rt < fe.numTables; rt++)
        Je.push({ tag: Re(), offset: Re(), compLength: Re(), origLength: Re(), origChecksum: Re() }), Ve += 16;
      var Ne, ct = new Uint8Array(12 + 16 * Je.length + Je.reduce(function(ft, Ie) {
        return ft + Ie.origLength + 4;
      }, 0)), tt = ct.buffer, Tt = new DataView(tt), gt = 0;
      return ve(fe.flavor), He(fe.numTables), He(ye), He(he), He(Ee), Je.forEach(function(ft) {
        ve(ft.tag), ve(ft.origChecksum), ve(Ve), ve(ft.origLength), ft.outOffset = Ve, (Ve += ft.origLength) % 4 != 0 && (Ve += 4 - Ve % 4);
      }), Je.forEach(function(ft) {
        var Ie, qe = ue.slice(ft.offset, ft.offset + ft.compLength);
        if (ft.compLength != ft.origLength) {
          var dt = new Uint8Array(ft.origLength);
          Ie = new Uint8Array(qe, 2), re(Ie, dt);
        } else
          dt = new Uint8Array(qe);
        ct.set(dt, ft.outOffset);
        var ht = 0;
        (Ve = ft.outOffset + ft.origLength) % 4 != 0 && (ht = 4 - Ve % 4), ct.set(new Uint8Array(ht).buffer, ft.outOffset + ft.origLength), Ne = Ve + ht;
      }), tt.slice(0, Ne);
    }, Object.defineProperty(a, "__esModule", { value: !0 }), a;
  }({}).convert_streams;
}
function uY(a, e) {
  const t = {
    M: 2,
    L: 2,
    Q: 4,
    C: 6,
    Z: 0
  }, r = { C: "18g,ca,368,1kz", D: "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v", R: "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6", L: "x9u,jff,a,fd,jv", T: "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n" }, i = 1, s = 2, l = 4, d = 8, p = 16, g = 32;
  let _;
  function w(Q) {
    if (!_) {
      const K = {
        R: s,
        L: i,
        D: l,
        C: p,
        U: g,
        T: d
      };
      _ = /* @__PURE__ */ new Map();
      for (let te in r) {
        let Y = 0;
        r[te].split(",").forEach((re) => {
          let [se, ce] = re.split("+");
          se = parseInt(se, 36), ce = ce ? parseInt(ce, 36) : 0, _.set(Y += se, K[te]);
          for (let ue = ce; ue--; )
            _.set(++Y, K[te]);
        });
      }
    }
    return _.get(Q) || g;
  }
  const T = 1, R = 2, D = 3, O = 4, U = [null, "isol", "init", "fina", "medi"];
  function H(Q) {
    const K = new Uint8Array(Q.length);
    let te = g, Y = T, re = -1;
    for (let se = 0; se < Q.length; se++) {
      const ce = Q.codePointAt(se);
      let ue = w(ce) | 0, Me = T;
      ue & d || (te & (i | l | p) ? ue & (s | l | p) ? (Me = D, (Y === T || Y === D) && K[re]++) : ue & (i | g) && (Y === R || Y === O) && K[re]-- : te & (s | g) && (Y === R || Y === O) && K[re]--, Y = K[se] = Me, te = ue, re = se, ce > 65535 && se++);
    }
    return K;
  }
  function I(Q, K) {
    const te = [];
    for (let re = 0; re < K.length; re++) {
      const se = K.codePointAt(re);
      se > 65535 && re++, te.push(a.U.codeToGlyph(Q, se));
    }
    const Y = Q.GSUB;
    if (Y) {
      const { lookupList: re, featureList: se } = Y;
      let ce;
      const ue = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws)$/, Me = [];
      se.forEach((me) => {
        if (ue.test(me.tag))
          for (let De = 0; De < me.tab.length; De++) {
            if (Me[me.tab[De]])
              continue;
            Me[me.tab[De]] = !0;
            const Re = re[me.tab[De]], He = /^(isol|init|fina|medi)$/.test(me.tag);
            He && !ce && (ce = H(K));
            for (let ve = 0; ve < te.length; ve++)
              (!ce || !He || U[ce[ve]] === me.tag) && a.U._applySubs(te, ve, Re, re);
          }
      });
    }
    return te;
  }
  function G(...Q) {
    for (let K = 0; K < Q.length; K++)
      if (typeof Q[K] == "number")
        return Q[K];
  }
  function B(Q) {
    const K = /* @__PURE__ */ Object.create(null), te = Q["OS/2"], Y = Q.hhea, re = Q.head.unitsPerEm, se = G(te && te.sTypoAscender, Y && Y.ascender, re), ce = {
      unitsPerEm: re,
      ascender: se,
      descender: G(te && te.sTypoDescender, Y && Y.descender, 0),
      capHeight: G(te && te.sCapHeight, se),
      xHeight: G(te && te.sxHeight, se),
      lineGap: G(te && te.sTypoLineGap, Y && Y.lineGap),
      forEachGlyph(ue, Me, me, De) {
        let Re = 0;
        const He = 1 / ce.unitsPerEm * Me, ve = I(Q, ue);
        let fe = 0, he = -1;
        return ve.forEach((ye, Ee) => {
          if (ye !== -1) {
            let Ve = K[ye];
            if (!Ve) {
              const { cmds: Je, crds: rt } = a.U.glyphToPath(Q, ye);
              let Ne = "", ct = 0;
              for (let Ie = 0, qe = Je.length; Ie < qe; Ie++) {
                const dt = t[Je[Ie]];
                Ne += Je[Ie];
                for (let ht = 1; ht <= dt; ht++)
                  Ne += (ht > 1 ? "," : "") + rt[ct++];
              }
              let tt, Tt, gt, ft;
              if (rt.length) {
                tt = Tt = 1 / 0, gt = ft = -1 / 0;
                for (let Ie = 0, qe = rt.length; Ie < qe; Ie += 2) {
                  let dt = rt[Ie], ht = rt[Ie + 1];
                  dt < tt && (tt = dt), ht < Tt && (Tt = ht), dt > gt && (gt = dt), ht > ft && (ft = ht);
                }
              } else
                tt = gt = Tt = ft = 0;
              Ve = K[ye] = {
                index: ye,
                advanceWidth: Q.hmtx.aWidth[ye],
                xMin: tt,
                yMin: Tt,
                xMax: gt,
                yMax: ft,
                path: Ne,
                pathCommandCount: Je.length
              };
            }
            he !== -1 && (Re += a.U.getPairAdjustment(Q, he, ye) * He), De.call(null, Ve, Re, fe), Ve.advanceWidth && (Re += Ve.advanceWidth * He), me && (Re += me * Me), he = ye;
          }
          fe += ue.codePointAt(fe) > 65535 ? 2 : 1;
        }), Re;
      }
    };
    return ce;
  }
  return function(K) {
    const te = new Uint8Array(K, 0, 4), Y = a._bin.readASCII(te, 0, 4);
    if (Y === "wOFF")
      K = e(K);
    else if (Y === "wOF2")
      throw new Error("woff2 fonts not supported");
    return B(a.parse(K)[0]);
  };
}
const cY = /* @__PURE__ */ sT({
  name: "Typr Font Parser",
  dependencies: [oY, lY, uY],
  init(a, e, t) {
    const r = a(), i = e();
    return t(r, i);
  }
}), Xw = {
  defaultFontURL: "https://fonts.gstatic.com/s/roboto/v18/KFOmCnqEu92Fr1Mu4mxM.woff",
  sdfGlyphSize: 64,
  sdfMargin: 1 / 16,
  sdfExponent: 9,
  textureWidth: 2048
}, fY = /* @__PURE__ */ new Un();
function Bw() {
  return (self.performance || Date).now();
}
const Qz = /* @__PURE__ */ Object.create(null);
function l4(a, e) {
  a = pY({}, a);
  const t = Bw();
  if (a.font = mY(a.font || Xw.defaultFontURL), a.text = "" + a.text, a.sdfGlyphSize = a.sdfGlyphSize || Xw.sdfGlyphSize, a.colorRanges != null) {
    let w = {};
    for (let T in a.colorRanges)
      if (a.colorRanges.hasOwnProperty(T)) {
        let R = a.colorRanges[T];
        typeof R != "number" && (R = fY.set(R).getHex()), w[T] = R;
      }
    a.colorRanges = w;
  }
  Object.freeze(a);
  const { textureWidth: r, sdfExponent: i } = Xw, { sdfGlyphSize: s } = a, l = r / s * 4;
  let d = Qz[s];
  if (!d) {
    const w = document.createElement("canvas");
    w.width = r, w.height = s * 256 / l, d = Qz[s] = {
      glyphCount: 0,
      sdfGlyphSize: s,
      sdfCanvas: w,
      sdfTexture: new su(
        w,
        void 0,
        void 0,
        void 0,
        Oo,
        Oo
      ),
      contextLost: !1,
      glyphsByFont: /* @__PURE__ */ new Map()
    }, d.sdfTexture.generateMipmaps = !1, dY(d);
  }
  const { sdfTexture: p, sdfCanvas: g } = d;
  let _ = d.glyphsByFont.get(a.font);
  _ || d.glyphsByFont.set(a.font, _ = /* @__PURE__ */ new Map()), gY(a).then((w) => {
    const { glyphIds: T, glyphPositions: R, fontSize: D, unitsPerEm: O, timings: U } = w, H = [], I = new Float32Array(T.length * 4), G = D / O;
    let B = 0, Q = 0;
    const K = Bw();
    T.forEach((ce, ue) => {
      let Me = _.get(ce);
      if (!Me) {
        const { path: He, pathBounds: ve } = w.glyphData[ce], fe = Math.max(ve[2] - ve[0], ve[3] - ve[1]) / s * (Xw.sdfMargin * s + 0.5), he = d.glyphCount++, ye = [
          ve[0] - fe,
          ve[1] - fe,
          ve[2] + fe,
          ve[3] + fe
        ];
        _.set(ce, Me = { path: He, atlasIndex: he, sdfViewBox: ye }), H.push(Me);
      }
      const { sdfViewBox: me } = Me, De = R[Q++], Re = R[Q++];
      I[B++] = De + me[0] * G, I[B++] = Re + me[1] * G, I[B++] = De + me[2] * G, I[B++] = Re + me[3] * G, T[ue] = Me.atlasIndex;
    }), U.quads = (U.quads || 0) + (Bw() - K);
    const te = Bw();
    U.sdf = {};
    const Y = g.height, re = Math.ceil(d.glyphCount / l), se = Math.pow(2, Math.ceil(Math.log2(re * s)));
    se > Y && (console.info(`Increasing SDF texture size ${Y}->${se}`), sY(g, r, se), p.dispose()), Promise.all(H.map(
      (ce) => u4(ce, d, a.gpuAccelerateSDF).then(({ timing: ue }) => {
        U.sdf[ce.atlasIndex] = ue;
      })
    )).then(() => {
      H.length && !d.contextLost && (c4(d), p.needsUpdate = !0), U.sdfTotal = Bw() - te, U.total = Bw() - t, e(Object.freeze({
        parameters: a,
        sdfTexture: p,
        sdfGlyphSize: s,
        sdfExponent: i,
        glyphBounds: I,
        glyphAtlasIndices: T,
        glyphColors: w.glyphColors,
        caretPositions: w.caretPositions,
        caretHeight: w.caretHeight,
        chunkedBounds: w.chunkedBounds,
        ascender: w.ascender,
        descender: w.descender,
        lineHeight: w.lineHeight,
        capHeight: w.capHeight,
        xHeight: w.xHeight,
        topBaseline: w.topBaseline,
        blockBounds: w.blockBounds,
        visibleBounds: w.visibleBounds,
        timings: w.timings
      }));
    });
  }), Promise.resolve().then(() => {
    d.contextLost || aY(g);
  });
}
function u4({ path: a, atlasIndex: e, sdfViewBox: t }, { sdfGlyphSize: r, sdfCanvas: i, contextLost: s }, l) {
  if (s)
    return Promise.resolve({ timing: -1 });
  const { textureWidth: d, sdfExponent: p } = Xw, g = Math.max(t[2] - t[0], t[3] - t[1]), _ = Math.floor(e / 4), w = _ % (d / r) * r, T = Math.floor(_ / (d / r)) * r, R = e % 4;
  return $j(r, r, a, t, g, p, i, w, T, R, l);
}
function dY(a) {
  const e = a.sdfCanvas;
  e.addEventListener("webglcontextlost", (t) => {
    console.log("Context Lost", t), t.preventDefault(), a.contextLost = !0;
  }), e.addEventListener("webglcontextrestored", (t) => {
    console.log("Context Restored", t), a.contextLost = !1;
    const r = [];
    a.glyphsByFont.forEach((i) => {
      i.forEach((s) => {
        r.push(u4(s, a, !0));
      });
    }), Promise.all(r).then(() => {
      c4(a), a.sdfTexture.needsUpdate = !0;
    });
  });
}
function hY({ font: a, characters: e, sdfGlyphSize: t }, r) {
  let i = Array.isArray(e) ? e.join(`
`) : "" + e;
  l4({ font: a, sdfGlyphSize: t, text: i }, r);
}
function pY(a, e) {
  for (let t in e)
    e.hasOwnProperty(t) && (a[t] = e[t]);
  return a;
}
let rC;
function mY(a) {
  return rC || (rC = typeof document > "u" ? {} : document.createElement("a")), rC.href = a, rC.href;
}
function c4(a) {
  if (typeof createImageBitmap != "function") {
    console.info("Safari<15: applying SDF canvas workaround");
    const { sdfCanvas: e, sdfTexture: t } = a, { width: r, height: i } = e, s = a.sdfCanvas.getContext("webgl");
    let l = t.image.data;
    (!l || l.length !== r * i * 4) && (l = new Uint8Array(r * i * 4), t.image = { width: r, height: i, data: l }, t.flipY = !1, t.isDataTexture = !0), s.readPixels(0, 0, r, i, s.RGBA, s.UNSIGNED_BYTE, l);
  }
}
const vY = /* @__PURE__ */ sT({
  name: "Typesetter",
  dependencies: [
    Xw,
    cY,
    Kj,
    Wj
  ],
  init(a, e, t, r) {
    const { defaultFontURL: i } = a;
    return t(e, r(), { defaultFontURL: i });
  }
}), gY = /* @__PURE__ */ sT({
  name: "Typesetter",
  dependencies: [
    vY
  ],
  init(a) {
    return function(e) {
      return new Promise((t) => {
        a.typeset(e, t);
      });
    };
  },
  getTransferables(a) {
    const e = [
      a.glyphPositions.buffer,
      a.glyphIds.buffer
    ];
    return a.caretPositions && e.push(a.caretPositions.buffer), a.glyphColors && e.push(a.glyphColors.buffer), e;
  }
}), Zz = {};
function yY(a) {
  let e = Zz[a];
  if (!e) {
    const t = new lg(1, 1, a, a), r = t.clone(), i = t.attributes, s = r.attributes, l = new oi(), d = i.uv.count;
    for (let p = 0; p < d; p++)
      s.position.array[p * 3] *= -1, s.normal.array[p * 3 + 2] *= -1;
    ["position", "normal", "uv"].forEach((p) => {
      l.setAttribute(
        p,
        new sr(
          [...i[p].array, ...s[p].array],
          i[p].itemSize
        )
      );
    }), l.setIndex([...t.index.array, ...r.index.array.map((p) => p + d)]), l.translate(0.5, 0.5, 0), e = Zz[a] = l;
  }
  return e;
}
const xY = "aTroikaGlyphBounds", Jz = "aTroikaGlyphIndex", _Y = "aTroikaGlyphColor";
class SY extends $C {
  constructor() {
    super(), this.detail = 1, this.curveRadius = 0, this.groups = [
      { start: 0, count: 1 / 0, materialIndex: 0 },
      { start: 0, count: 1 / 0, materialIndex: 1 }
    ], this.boundingSphere = new yy(), this.boundingBox = new cg();
  }
  computeBoundingSphere() {
  }
  computeBoundingBox() {
  }
  setSide(e) {
    const t = this.getIndex().count;
    this.setDrawRange(e === cf ? t / 2 : 0, e === Yh ? t : t / 2);
  }
  set detail(e) {
    if (e !== this._detail) {
      this._detail = e, (typeof e != "number" || e < 1) && (e = 1);
      let t = yY(e);
      ["position", "normal", "uv"].forEach((r) => {
        this.attributes[r] = t.attributes[r].clone();
      }), this.setIndex(t.getIndex().clone());
    }
  }
  get detail() {
    return this._detail;
  }
  set curveRadius(e) {
    e !== this._curveRadius && (this._curveRadius = e, this._updateBounds());
  }
  get curveRadius() {
    return this._curveRadius;
  }
  updateGlyphs(e, t, r, i, s) {
    ED(this, xY, e, 4), ED(this, Jz, t, 1), ED(this, _Y, s, 3), this._blockBounds = r, this._chunkedBounds = i, this.instanceCount = t.length, this._updateBounds();
  }
  _updateBounds() {
    const e = this._blockBounds;
    if (e) {
      const { curveRadius: t, boundingBox: r } = this;
      if (t) {
        const { PI: i, floor: s, min: l, max: d, sin: p, cos: g } = Math, _ = i / 2, w = i * 2, T = Math.abs(t), R = e[0] / T, D = e[2] / T, O = s((R + _) / w) !== s((D + _) / w) ? -T : l(p(R) * T, p(D) * T), U = s((R - _) / w) !== s((D - _) / w) ? T : d(p(R) * T, p(D) * T), H = s((R + i) / w) !== s((D + i) / w) ? T * 2 : d(T - g(R) * T, T - g(D) * T);
        r.min.set(O, e[1], t < 0 ? -H : 0), r.max.set(U, e[3], t < 0 ? 0 : H);
      } else
        r.min.set(e[0], e[1], 0), r.max.set(e[2], e[3], 0);
      r.getBoundingSphere(this.boundingSphere);
    }
  }
  applyClipRect(e) {
    let t = this.getAttribute(Jz).count, r = this._chunkedBounds;
    if (r)
      for (let i = r.length; i--; ) {
        t = r[i].end;
        let s = r[i].rect;
        if (s[1] < e.w && s[3] > e.y && s[0] < e.z && s[2] > e.x)
          break;
      }
    this.instanceCount = t;
  }
}
function ED(a, e, t, r) {
  const i = a.getAttribute(e);
  t ? i && i.array.length === t.length ? (i.array.set(t), i.needsUpdate = !0) : (a.setAttribute(e, new q_(t, r)), delete a._maxInstanceCount, a.dispose()) : i && a.deleteAttribute(e);
}
const wY = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaDistanceOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`, bY = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaDistanceOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaDistanceOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);


float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`, EY = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaDistanceOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaOutlineOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`, MY = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaDistanceOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;
function TY(a) {
  const e = U3(a, {
    chained: !0,
    extensions: {
      derivatives: !0
    },
    uniforms: {
      uTroikaSDFTexture: { value: null },
      uTroikaSDFTextureSize: { value: new zt() },
      uTroikaSDFGlyphSize: { value: 0 },
      uTroikaSDFExponent: { value: 0 },
      uTroikaTotalBounds: { value: new ra(0, 0, 0, 0) },
      uTroikaClipRect: { value: new ra(0, 0, 0, 0) },
      uTroikaDistanceOffset: { value: 0 },
      uTroikaOutlineOpacity: { value: 0 },
      uTroikaFillOpacity: { value: 1 },
      uTroikaPositionOffset: { value: new zt() },
      uTroikaCurveRadius: { value: 0 },
      uTroikaBlurRadius: { value: 0 },
      uTroikaStrokeWidth: { value: 0 },
      uTroikaStrokeColor: { value: new Un() },
      uTroikaStrokeOpacity: { value: 1 },
      uTroikaOrient: { value: new Xh() },
      uTroikaUseGlyphColors: { value: !0 },
      uTroikaSDFDebug: { value: !1 }
    },
    vertexDefs: wY,
    vertexTransform: bY,
    fragmentDefs: EY,
    fragmentColorTransform: MY,
    customRewriter({ vertexShader: t, fragmentShader: r }) {
      let i = /\buniform\s+vec3\s+diffuse\b/;
      return i.test(r) && (r = r.replace(i, "varying vec3 vTroikaGlyphColor").replace(/\bdiffuse\b/g, "vTroikaGlyphColor"), i.test(t) || (t = t.replace(
        s4,
        `uniform vec3 diffuse;
$&
vTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;
`
      ))), { vertexShader: t, fragmentShader: r };
    }
  });
  return e.transparent = !0, Object.defineProperties(e, {
    isTroikaTextMaterial: { value: !0 },
    shadowSide: {
      get() {
        return this.side;
      },
      set() {
      }
    }
  }), e;
}
const RL = /* @__PURE__ */ new fg({
  color: 16777215,
  side: Yh,
  transparent: !0
}), Kz = 8421504, $z = /* @__PURE__ */ new Kr(), iC = /* @__PURE__ */ new ge(), MD = /* @__PURE__ */ new ge(), cM = [], CY = /* @__PURE__ */ new ge(), TD = "+x+y";
function eN(a) {
  return Array.isArray(a) ? a[0] : a;
}
let f4 = () => {
  const a = new Fn(
    new lg(1, 1),
    RL
  );
  return f4 = () => a, a;
}, d4 = () => {
  const a = new Fn(
    new lg(1, 1, 32, 1),
    RL
  );
  return d4 = () => a, a;
};
const RY = { type: "syncstart" }, AY = { type: "synccomplete" }, h4 = [
  "font",
  "fontSize",
  "letterSpacing",
  "lineHeight",
  "maxWidth",
  "overflowWrap",
  "text",
  "direction",
  "textAlign",
  "textIndent",
  "whiteSpace",
  "anchorX",
  "anchorY",
  "colorRanges",
  "sdfGlyphSize"
], DY = h4.concat(
  "material",
  "color",
  "depthOffset",
  "clipRect",
  "curveRadius",
  "orientation",
  "glyphGeometryDetail"
);
class p4 extends Fn {
  constructor() {
    const e = new SY();
    super(e, null), this.text = "", this.anchorX = 0, this.anchorY = 0, this.curveRadius = 0, this.direction = "auto", this.font = null, this.fontSize = 0.1, this.letterSpacing = 0, this.lineHeight = "normal", this.maxWidth = 1 / 0, this.overflowWrap = "normal", this.textAlign = "left", this.textIndent = 0, this.whiteSpace = "normal", this.material = null, this.color = null, this.colorRanges = null, this.outlineWidth = 0, this.outlineColor = 0, this.outlineOpacity = 1, this.outlineBlur = 0, this.outlineOffsetX = 0, this.outlineOffsetY = 0, this.strokeWidth = 0, this.strokeColor = Kz, this.strokeOpacity = 1, this.fillOpacity = 1, this.depthOffset = 0, this.clipRect = null, this.orientation = TD, this.glyphGeometryDetail = 1, this.sdfGlyphSize = null, this.gpuAccelerateSDF = !0, this.debugSDF = !1;
  }
  sync(e) {
    this._needsSync && (this._needsSync = !1, this._isSyncing ? (this._queuedSyncs || (this._queuedSyncs = [])).push(e) : (this._isSyncing = !0, this.dispatchEvent(RY), l4({
      text: this.text,
      font: this.font,
      fontSize: this.fontSize || 0.1,
      letterSpacing: this.letterSpacing || 0,
      lineHeight: this.lineHeight || "normal",
      maxWidth: this.maxWidth,
      direction: this.direction || "auto",
      textAlign: this.textAlign,
      textIndent: this.textIndent,
      whiteSpace: this.whiteSpace,
      overflowWrap: this.overflowWrap,
      anchorX: this.anchorX,
      anchorY: this.anchorY,
      colorRanges: this.colorRanges,
      includeCaretPositions: !0,
      sdfGlyphSize: this.sdfGlyphSize,
      gpuAccelerateSDF: this.gpuAccelerateSDF
    }, (t) => {
      this._isSyncing = !1, this._textRenderInfo = t, this.geometry.updateGlyphs(
        t.glyphBounds,
        t.glyphAtlasIndices,
        t.blockBounds,
        t.chunkedBounds,
        t.glyphColors
      );
      const r = this._queuedSyncs;
      r && (this._queuedSyncs = null, this._needsSync = !0, this.sync(() => {
        r.forEach((i) => i && i());
      })), this.dispatchEvent(AY), e && e();
    })));
  }
  onBeforeRender(e, t, r, i, s, l) {
    this.sync(), s.isTroikaTextMaterial && this._prepareForRender(s), s._hadOwnSide = s.hasOwnProperty("side"), this.geometry.setSide(s._actualSide = s.side), s.side = vy;
  }
  onAfterRender(e, t, r, i, s, l) {
    s._hadOwnSide ? s.side = s._actualSide : delete s.side;
  }
  dispose() {
    this.geometry.dispose();
  }
  get textRenderInfo() {
    return this._textRenderInfo || null;
  }
  get material() {
    let e = this._derivedMaterial;
    const t = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = RL.clone());
    if ((!e || e.baseMaterial !== t) && (e = this._derivedMaterial = TY(t), t.addEventListener("dispose", function r() {
      t.removeEventListener("dispose", r), e.dispose();
    })), this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY) {
      let r = e._outlineMtl;
      return r || (r = e._outlineMtl = Object.create(e, {
        id: { value: e.id + 0.1 }
      }), r.isTextOutlineMaterial = !0, r.depthWrite = !1, r.map = null, e.addEventListener("dispose", function i() {
        e.removeEventListener("dispose", i), r.dispose();
      })), [
        r,
        e
      ];
    } else
      return e;
  }
  set material(e) {
    e && e.isTroikaTextMaterial ? (this._derivedMaterial = e, this._baseMaterial = e.baseMaterial) : this._baseMaterial = e;
  }
  get glyphGeometryDetail() {
    return this.geometry.detail;
  }
  set glyphGeometryDetail(e) {
    this.geometry.detail = e;
  }
  get curveRadius() {
    return this.geometry.curveRadius;
  }
  set curveRadius(e) {
    this.geometry.curveRadius = e;
  }
  get customDepthMaterial() {
    return eN(this.material).getDepthMaterial();
  }
  get customDistanceMaterial() {
    return eN(this.material).getDistanceMaterial();
  }
  _prepareForRender(e) {
    const t = e.isTextOutlineMaterial, r = e.uniforms, i = this.textRenderInfo;
    if (i) {
      const { sdfTexture: d, blockBounds: p } = i;
      r.uTroikaSDFTexture.value = d, r.uTroikaSDFTextureSize.value.set(d.image.width, d.image.height), r.uTroikaSDFGlyphSize.value = i.sdfGlyphSize, r.uTroikaSDFExponent.value = i.sdfExponent, r.uTroikaTotalBounds.value.fromArray(p), r.uTroikaUseGlyphColors.value = !t && !!i.glyphColors;
      let g = 0, _ = 0, w = 0, T, R, D, O = 0, U = 0;
      if (t) {
        let { outlineWidth: I, outlineOffsetX: G, outlineOffsetY: B, outlineBlur: Q, outlineOpacity: K } = this;
        g = this._parsePercent(I) || 0, _ = Math.max(0, this._parsePercent(Q) || 0), T = K, O = this._parsePercent(G) || 0, U = this._parsePercent(B) || 0;
      } else
        w = Math.max(0, this._parsePercent(this.strokeWidth) || 0), w && (D = this.strokeColor, r.uTroikaStrokeColor.value.set(D == null ? Kz : D), R = this.strokeOpacity, R == null && (R = 1)), T = this.fillOpacity;
      r.uTroikaDistanceOffset.value = g, r.uTroikaPositionOffset.value.set(O, U), r.uTroikaBlurRadius.value = _, r.uTroikaStrokeWidth.value = w, r.uTroikaStrokeOpacity.value = R, r.uTroikaFillOpacity.value = T == null ? 1 : T, r.uTroikaCurveRadius.value = this.curveRadius || 0;
      let H = this.clipRect;
      if (H && Array.isArray(H) && H.length === 4)
        r.uTroikaClipRect.value.fromArray(H);
      else {
        const I = (this.fontSize || 0.1) * 100;
        r.uTroikaClipRect.value.set(
          p[0] - I,
          p[1] - I,
          p[2] + I,
          p[3] + I
        );
      }
      this.geometry.applyClipRect(r.uTroikaClipRect.value);
    }
    r.uTroikaSDFDebug.value = !!this.debugSDF, e.polygonOffset = !!this.depthOffset, e.polygonOffsetFactor = e.polygonOffsetUnits = this.depthOffset || 0;
    const s = t ? this.outlineColor || 0 : this.color;
    if (s == null)
      delete e.color;
    else {
      const d = e.hasOwnProperty("color") ? e.color : e.color = new Un();
      (s !== d._input || typeof s == "object") && d.set(d._input = s);
    }
    let l = this.orientation || TD;
    if (l !== e._orientation) {
      let d = r.uTroikaOrient.value;
      l = l.replace(/[^-+xyz]/g, "");
      let p = l !== TD && l.match(/^([-+])([xyz])([-+])([xyz])$/);
      if (p) {
        let [, g, _, w, T] = p;
        iC.set(0, 0, 0)[_] = g === "-" ? 1 : -1, MD.set(0, 0, 0)[T] = w === "-" ? -1 : 1, $z.lookAt(CY, iC.cross(MD), MD), d.setFromMatrix4($z);
      } else
        d.identity();
      e._orientation = l;
    }
  }
  _parsePercent(e) {
    if (typeof e == "string") {
      let t = e.match(/^(-?[\d.]+)%$/), r = t ? parseFloat(t[1]) : NaN;
      e = (isNaN(r) ? 0 : r / 100) * this.fontSize;
    }
    return e;
  }
  localPositionToTextCoords(e, t = new zt()) {
    t.copy(e);
    const r = this.curveRadius;
    return r && (t.x = Math.atan2(e.x, Math.abs(r) - Math.abs(e.z)) * Math.abs(r)), t;
  }
  worldPositionToTextCoords(e, t = new zt()) {
    return iC.copy(e), this.localPositionToTextCoords(this.worldToLocal(iC), t);
  }
  raycast(e, t) {
    const { textRenderInfo: r, curveRadius: i } = this;
    if (r) {
      const s = r.blockBounds, l = i ? d4() : f4(), d = l.geometry, { position: p, uv: g } = d.attributes;
      for (let _ = 0; _ < g.count; _++) {
        let w = s[0] + g.getX(_) * (s[2] - s[0]);
        const T = s[1] + g.getY(_) * (s[3] - s[1]);
        let R = 0;
        i && (R = i - Math.cos(w / i) * i, w = Math.sin(w / i) * i), p.setXYZ(_, w, T, R);
      }
      d.boundingSphere = this.geometry.boundingSphere, d.boundingBox = this.geometry.boundingBox, l.matrixWorld = this.matrixWorld, l.material.side = this.material.side, cM.length = 0, l.raycast(e, cM);
      for (let _ = 0; _ < cM.length; _++)
        cM[_].object = this, t.push(cM[_]);
    }
  }
  copy(e) {
    const t = this.geometry;
    return super.copy(e), this.geometry = t, DY.forEach((r) => {
      this[r] = e[r];
    }), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
h4.forEach((a) => {
  const e = "_private_" + a;
  Object.defineProperty(p4.prototype, a, {
    get() {
      return this[e];
    },
    set(t) {
      t !== this[e] && (this[e] = t, this._needsSync = !0);
    }
  });
});
const LY = /* @__PURE__ */ Ln.forwardRef(({
  anchorX: a = "center",
  anchorY: e = "middle",
  font: t,
  fontSize: r = 1,
  children: i,
  characters: s,
  onSync: l,
  ...d
}, p) => {
  const g = jf(({
    invalidate: R
  }) => R), [_] = Ln.useState(() => new p4()), [w, T] = Ln.useMemo(() => {
    const R = [];
    let D = "";
    return Ln.Children.forEach(i, (O) => {
      typeof O == "string" || typeof O == "number" ? D += O : R.push(O);
    }), [R, D];
  }, [i]);
  return P9(() => new Promise((R) => hY({
    font: t,
    characters: s
  }, R)), ["troika-text", t, s]), Ln.useLayoutEffect(() => void _.sync(() => {
    g(), l && l(_);
  })), Ln.useEffect(() => () => _.dispose(), [_]), /* @__PURE__ */ ln("primitive", {
    object: _,
    ref: p,
    font: t,
    text: T,
    anchorX: a,
    anchorY: e,
    fontSize: r,
    ...d,
    children: w
  });
});
var PY = 1 / 0, OY = 9007199254740991, UY = "[object Arguments]", zY = "[object Function]", NY = "[object GeneratorFunction]", FY = "[object Symbol]", kY = typeof D0 == "object" && D0 && D0.Object === Object && D0, IY = typeof self == "object" && self && self.Object === Object && self, BY = kY || IY || Function("return this")();
function HY(a, e, t) {
  switch (t.length) {
    case 0:
      return a.call(e);
    case 1:
      return a.call(e, t[0]);
    case 2:
      return a.call(e, t[0], t[1]);
    case 3:
      return a.call(e, t[0], t[1], t[2]);
  }
  return a.apply(e, t);
}
function VY(a, e) {
  for (var t = -1, r = a ? a.length : 0, i = Array(r); ++t < r; )
    i[t] = e(a[t], t, a);
  return i;
}
function GY(a, e) {
  for (var t = -1, r = e.length, i = a.length; ++t < r; )
    a[i + t] = e[t];
  return a;
}
var AL = Object.prototype, WY = AL.hasOwnProperty, DL = AL.toString, tN = BY.Symbol, jY = AL.propertyIsEnumerable, nN = tN ? tN.isConcatSpreadable : void 0, rN = Math.max;
function m4(a, e, t, r, i) {
  var s = -1, l = a.length;
  for (t || (t = QY), i || (i = []); ++s < l; ) {
    var d = a[s];
    e > 0 && t(d) ? e > 1 ? m4(d, e - 1, t, r, i) : GY(i, d) : r || (i[i.length] = d);
  }
  return i;
}
function YY(a, e) {
  return a = Object(a), XY(a, e, function(t, r) {
    return r in a;
  });
}
function XY(a, e, t) {
  for (var r = -1, i = e.length, s = {}; ++r < i; ) {
    var l = e[r], d = a[l];
    t(d, l) && (s[l] = d);
  }
  return s;
}
function qY(a, e) {
  return e = rN(e === void 0 ? a.length - 1 : e, 0), function() {
    for (var t = arguments, r = -1, i = rN(t.length - e, 0), s = Array(i); ++r < i; )
      s[r] = t[e + r];
    r = -1;
    for (var l = Array(e + 1); ++r < e; )
      l[r] = t[r];
    return l[e] = s, HY(a, this, l);
  };
}
function QY(a) {
  return KY(a) || JY(a) || !!(nN && a && a[nN]);
}
function ZY(a) {
  if (typeof a == "string" || iX(a))
    return a;
  var e = a + "";
  return e == "0" && 1 / a == -PY ? "-0" : e;
}
function JY(a) {
  return eX(a) && WY.call(a, "callee") && (!jY.call(a, "callee") || DL.call(a) == UY);
}
var KY = Array.isArray;
function $Y(a) {
  return a != null && nX(a.length) && !tX(a);
}
function eX(a) {
  return v4(a) && $Y(a);
}
function tX(a) {
  var e = rX(a) ? DL.call(a) : "";
  return e == zY || e == NY;
}
function nX(a) {
  return typeof a == "number" && a > -1 && a % 1 == 0 && a <= OY;
}
function rX(a) {
  var e = typeof a;
  return !!a && (e == "object" || e == "function");
}
function v4(a) {
  return !!a && typeof a == "object";
}
function iX(a) {
  return typeof a == "symbol" || v4(a) && DL.call(a) == FY;
}
var aX = qY(function(a, e) {
  return a == null ? {} : YY(a, VY(m4(e, 1), ZY));
}), CD = aX;
const sX = /* @__PURE__ */ Ln.forwardRef(({
  makeDefault: a,
  camera: e,
  regress: t,
  domElement: r,
  enableDamping: i = !0,
  onChange: s,
  onStart: l,
  onEnd: d,
  ...p
}, g) => {
  const _ = jf((Q) => Q.invalidate), w = jf((Q) => Q.camera), T = jf((Q) => Q.gl), R = jf((Q) => Q.events), D = jf((Q) => Q.setEvents), O = jf((Q) => Q.set), U = jf((Q) => Q.get), H = jf((Q) => Q.performance), I = e || w, G = r || R.connected || T.domElement, B = Ln.useMemo(() => new Lj(I), [I]);
  return Am(() => {
    B.enabled && B.update();
  }, -1), Ln.useEffect(() => (B.connect(G), () => void B.dispose()), [G, t, B, _]), Ln.useEffect(() => {
    const Q = (Y) => {
      _(), t && H.regress(), s && s(Y);
    }, K = (Y) => {
      l && l(Y);
    }, te = (Y) => {
      d && d(Y);
    };
    return B.addEventListener("change", Q), B.addEventListener("start", K), B.addEventListener("end", te), () => {
      B.removeEventListener("start", K), B.removeEventListener("end", te), B.removeEventListener("change", Q);
    };
  }, [s, l, d, B, _, D]), Ln.useEffect(() => {
    if (a) {
      const Q = U().controls;
      return O({
        controls: B
      }), () => O({
        controls: Q
      });
    }
  }, [a, B]), /* @__PURE__ */ ln("primitive", {
    ref: g,
    object: B,
    enableDamping: i,
    ...p
  });
});
class oX extends XC {
  constructor(e) {
    super(e), this.onBeforeCompile = (t, r) => {
      const {
        isWebGL2: i
      } = r.capabilities;
      t.fragmentShader = t.fragmentShader.replace("#include <output_fragment>", `
        ${i ? "#include <output_fragment>" : `#extension GL_OES_standard_derivatives : enable
#include <output_fragment>`}
      vec2 cxy = 2.0 * gl_PointCoord - 1.0;
      float r = dot(cxy, cxy);
      float delta = fwidth(r);     
      float mask = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);
      gl_FragColor = vec4(gl_FragColor.rgb, mask * gl_FragColor.a );
      #include <tonemapping_fragment>
      #include <encodings_fragment>
      `);
    };
  }
}
const lX = /* @__PURE__ */ Ln.forwardRef((a, e) => {
  const [t] = Ln.useState(() => new oX(null));
  return /* @__PURE__ */ ln("primitive", {
    ...a,
    object: t,
    ref: e,
    attach: "material"
  });
});
function uX(a) {
  const e = a + "Geometry";
  return /* @__PURE__ */ Ln.forwardRef(({
    args: t,
    children: r,
    ...i
  }, s) => /* @__PURE__ */ _c("mesh", {
    ref: s,
    ...i,
    children: [/* @__PURE__ */ ln(e, {
      attach: "geometry",
      args: t
    }), r]
  }));
}
const cX = uX("circle");
let b_, fM;
const fX = /* @__PURE__ */ Ln.createContext(null), iN = /* @__PURE__ */ new Kr(), aN = /* @__PURE__ */ new ge(), dX = /* @__PURE__ */ Ln.forwardRef(({
  children: a,
  range: e,
  limit: t = 1e3,
  ...r
}, i) => {
  const s = Ln.useRef(null), [l, d] = Ln.useState([]), [[p, g, _]] = Ln.useState(() => [new Float32Array(t * 3), Float32Array.from({
    length: t * 3
  }, () => 1), Float32Array.from({
    length: t
  }, () => 1)]);
  Ln.useEffect(() => {
    s.current.geometry.attributes.position.needsUpdate = !0;
  }), Am(() => {
    for (s.current.updateMatrix(), s.current.updateMatrixWorld(), iN.copy(s.current.matrixWorld).invert(), s.current.geometry.drawRange.count = Math.min(t, e !== void 0 ? e : t, l.length), b_ = 0; b_ < l.length; b_++)
      fM = l[b_].current, fM.getWorldPosition(aN).applyMatrix4(iN), aN.toArray(p, b_ * 3), s.current.geometry.attributes.position.needsUpdate = !0, fM.matrixWorldNeedsUpdate = !0, fM.color.toArray(g, b_ * 3), s.current.geometry.attributes.color.needsUpdate = !0, _.set([fM.size], b_), s.current.geometry.attributes.size.needsUpdate = !0;
  });
  const w = Ln.useMemo(() => ({
    getParent: () => s,
    subscribe: (T) => (d((R) => [...R, T]), () => d((R) => R.filter((D) => D.current !== T.current)))
  }), []);
  return /* @__PURE__ */ Ln.createElement(
    "points",
    C3({
      userData: {
        instances: l
      },
      matrixAutoUpdate: !1,
      ref: ML([i, s]),
      raycast: () => null
    }, r),
    /* @__PURE__ */ _c("bufferGeometry", {
      children: [/* @__PURE__ */ ln("bufferAttribute", {
        attach: "attributes-position",
        count: p.length / 3,
        array: p,
        itemSize: 3,
        usage: B_
      }), /* @__PURE__ */ ln("bufferAttribute", {
        attach: "attributes-color",
        count: g.length / 3,
        array: g,
        itemSize: 3,
        usage: B_
      }), /* @__PURE__ */ ln("bufferAttribute", {
        attach: "attributes-size",
        count: _.length,
        array: _,
        itemSize: 1,
        usage: B_
      })]
    }),
    /* @__PURE__ */ Ln.createElement(fX.Provider, {
      value: w
    }, a)
  );
}), hX = /* @__PURE__ */ Ln.forwardRef(({
  children: a,
  positions: e,
  colors: t,
  sizes: r,
  stride: i = 3,
  ...s
}, l) => {
  const d = Ln.useRef(null);
  return Am(() => {
    const p = d.current.geometry.attributes;
    p.position.needsUpdate = !0, t && (p.color.needsUpdate = !0), r && (p.size.needsUpdate = !0);
  }), /* @__PURE__ */ _c("points", {
    ref: ML([l, d]),
    ...s,
    children: [/* @__PURE__ */ _c("bufferGeometry", {
      children: [/* @__PURE__ */ ln("bufferAttribute", {
        attach: "attributes-position",
        count: e.length / i,
        array: e,
        itemSize: i,
        usage: B_
      }), t && /* @__PURE__ */ ln("bufferAttribute", {
        attach: "attributes-color",
        count: t.length / i,
        array: t,
        itemSize: 3,
        usage: B_
      }), r && /* @__PURE__ */ ln("bufferAttribute", {
        attach: "attributes-size",
        count: r.length / i,
        array: r,
        itemSize: 1,
        usage: B_
      })]
    }), a]
  });
}), pX = /* @__PURE__ */ Ln.forwardRef((a, e) => a.positions instanceof Float32Array ? /* @__PURE__ */ ln(hX, {
  ...a,
  ref: e
}) : /* @__PURE__ */ ln(dX, {
  ...a,
  ref: e
})), sN = (a) => {
  let e;
  const t = /* @__PURE__ */ new Set(), r = (p, g) => {
    const _ = typeof p == "function" ? p(e) : p;
    if (!Object.is(_, e)) {
      const w = e;
      e = (g != null ? g : typeof _ != "object") ? _ : Object.assign({}, e, _), t.forEach((T) => T(e, w));
    }
  }, i = () => e, d = { setState: r, getState: i, subscribe: (p) => (t.add(p), () => t.delete(p)), destroy: () => {
    ({ BASE_URL: "/", MODE: "production", DEV: !1, PROD: !0 } && "production") !== "production" && console.warn(
      "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
    ), t.clear();
  } };
  return e = a(r, i, d), d;
}, mX = (a) => a ? sN(a) : sN;
var g4 = { exports: {} }, RD = {}, AD = { exports: {} }, DD = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var oN;
function vX() {
  if (oN)
    return DD;
  oN = 1;
  var a = ph;
  function e(w, T) {
    return w === T && (w !== 0 || 1 / w === 1 / T) || w !== w && T !== T;
  }
  var t = typeof Object.is == "function" ? Object.is : e, r = a.useState, i = a.useEffect, s = a.useLayoutEffect, l = a.useDebugValue;
  function d(w, T) {
    var R = T(), D = r({ inst: { value: R, getSnapshot: T } }), O = D[0].inst, U = D[1];
    return s(function() {
      O.value = R, O.getSnapshot = T, p(O) && U({ inst: O });
    }, [w, R, T]), i(function() {
      return p(O) && U({ inst: O }), w(function() {
        p(O) && U({ inst: O });
      });
    }, [w]), l(R), R;
  }
  function p(w) {
    var T = w.getSnapshot;
    w = w.value;
    try {
      var R = T();
      return !t(w, R);
    } catch {
      return !0;
    }
  }
  function g(w, T) {
    return T();
  }
  var _ = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? g : d;
  return DD.useSyncExternalStore = a.useSyncExternalStore !== void 0 ? a.useSyncExternalStore : _, DD;
}
var LD = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var lN;
function gX() {
  return lN || (lN = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var a = ph, e = a.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function t(G) {
      {
        for (var B = arguments.length, Q = new Array(B > 1 ? B - 1 : 0), K = 1; K < B; K++)
          Q[K - 1] = arguments[K];
        r("error", G, Q);
      }
    }
    function r(G, B, Q) {
      {
        var K = e.ReactDebugCurrentFrame, te = K.getStackAddendum();
        te !== "" && (B += "%s", Q = Q.concat([te]));
        var Y = Q.map(function(re) {
          return String(re);
        });
        Y.unshift("Warning: " + B), Function.prototype.apply.call(console[G], console, Y);
      }
    }
    function i(G, B) {
      return G === B && (G !== 0 || 1 / G === 1 / B) || G !== G && B !== B;
    }
    var s = typeof Object.is == "function" ? Object.is : i, l = a.useState, d = a.useEffect, p = a.useLayoutEffect, g = a.useDebugValue, _ = !1, w = !1;
    function T(G, B, Q) {
      _ || a.startTransition !== void 0 && (_ = !0, t("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
      var K = B();
      if (!w) {
        var te = B();
        s(K, te) || (t("The result of getSnapshot should be cached to avoid an infinite loop"), w = !0);
      }
      var Y = l({
        inst: {
          value: K,
          getSnapshot: B
        }
      }), re = Y[0].inst, se = Y[1];
      return p(function() {
        re.value = K, re.getSnapshot = B, R(re) && se({
          inst: re
        });
      }, [G, K, B]), d(function() {
        R(re) && se({
          inst: re
        });
        var ce = function() {
          R(re) && se({
            inst: re
          });
        };
        return G(ce);
      }, [G]), g(K), K;
    }
    function R(G) {
      var B = G.getSnapshot, Q = G.value;
      try {
        var K = B();
        return !s(Q, K);
      } catch {
        return !0;
      }
    }
    function D(G, B, Q) {
      return B();
    }
    var O = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", U = !O, H = U ? D : T, I = a.useSyncExternalStore !== void 0 ? a.useSyncExternalStore : H;
    LD.useSyncExternalStore = I, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), LD;
}
var uN;
function y4() {
  return uN || (uN = 1, function(a) {
    process.env.NODE_ENV === "production" ? a.exports = vX() : a.exports = gX();
  }(AD)), AD.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var cN;
function yX() {
  if (cN)
    return RD;
  cN = 1;
  var a = ph, e = y4();
  function t(g, _) {
    return g === _ && (g !== 0 || 1 / g === 1 / _) || g !== g && _ !== _;
  }
  var r = typeof Object.is == "function" ? Object.is : t, i = e.useSyncExternalStore, s = a.useRef, l = a.useEffect, d = a.useMemo, p = a.useDebugValue;
  return RD.useSyncExternalStoreWithSelector = function(g, _, w, T, R) {
    var D = s(null);
    if (D.current === null) {
      var O = { hasValue: !1, value: null };
      D.current = O;
    } else
      O = D.current;
    D = d(function() {
      function H(K) {
        if (!I) {
          if (I = !0, G = K, K = T(K), R !== void 0 && O.hasValue) {
            var te = O.value;
            if (R(te, K))
              return B = te;
          }
          return B = K;
        }
        if (te = B, r(G, K))
          return te;
        var Y = T(K);
        return R !== void 0 && R(te, Y) ? te : (G = K, B = Y);
      }
      var I = !1, G, B, Q = w === void 0 ? null : w;
      return [function() {
        return H(_());
      }, Q === null ? void 0 : function() {
        return H(Q());
      }];
    }, [_, w, T, R]);
    var U = i(g, D[0], D[1]);
    return l(function() {
      O.hasValue = !0, O.value = U;
    }, [U]), p(U), U;
  }, RD;
}
var PD = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var fN;
function xX() {
  return fN || (fN = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var a = ph, e = y4();
    function t(_, w) {
      return _ === w && (_ !== 0 || 1 / _ === 1 / w) || _ !== _ && w !== w;
    }
    var r = typeof Object.is == "function" ? Object.is : t, i = e.useSyncExternalStore, s = a.useRef, l = a.useEffect, d = a.useMemo, p = a.useDebugValue;
    function g(_, w, T, R, D) {
      var O = s(null), U;
      O.current === null ? (U = {
        hasValue: !1,
        value: null
      }, O.current = U) : U = O.current;
      var H = d(function() {
        var Q = !1, K, te, Y = function(ue) {
          if (!Q) {
            Q = !0, K = ue;
            var Me = R(ue);
            if (D !== void 0 && U.hasValue) {
              var me = U.value;
              if (D(me, Me))
                return te = me, me;
            }
            return te = Me, Me;
          }
          var De = K, Re = te;
          if (r(De, ue))
            return Re;
          var He = R(ue);
          return D !== void 0 && D(Re, He) ? Re : (K = ue, te = He, He);
        }, re = T === void 0 ? null : T, se = function() {
          return Y(w());
        }, ce = re === null ? void 0 : function() {
          return Y(re());
        };
        return [se, ce];
      }, [w, T, R, D]), I = H[0], G = H[1], B = i(_, I, G);
      return l(function() {
        U.hasValue = !0, U.value = B;
      }, [B]), p(B), B;
    }
    PD.useSyncExternalStoreWithSelector = g, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), PD;
}
(function(a) {
  process.env.NODE_ENV === "production" ? a.exports = yX() : a.exports = xX();
})(g4);
const _X = /* @__PURE__ */ Lk(g4.exports), { useSyncExternalStoreWithSelector: SX } = _X;
function x4(a, e = a.getState, t) {
  const r = SX(
    a.subscribe,
    a.getState,
    a.getServerState || a.getState,
    e,
    t
  );
  return UN(r), r;
}
const dN = (a) => {
  ({ BASE_URL: "/", MODE: "production", DEV: !1, PROD: !0 } && "production") !== "production" && typeof a != "function" && console.warn(
    "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
  );
  const e = typeof a == "function" ? mX(a) : a, t = (r, i) => x4(e, r, i);
  return Object.assign(t, e), t;
}, wX = (a) => a ? dN(a) : dN, bX = (a) => (e, t, r) => {
  const i = r.subscribe;
  return r.subscribe = (l, d, p) => {
    let g = l;
    if (d) {
      const _ = (p == null ? void 0 : p.equalityFn) || Object.is;
      let w = l(r.getState());
      g = (T) => {
        const R = l(T);
        if (!_(w, R)) {
          const D = w;
          d(w = R, D);
        }
      }, p != null && p.fireImmediately && d(w, w);
    }
    return i(g);
  }, a(e, t, r);
}, EX = bX;
function zd(a) {
  for (var e = arguments.length, t = Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)
    t[r - 1] = arguments[r];
  if (process.env.NODE_ENV !== "production") {
    var i = PX[a], s = i ? typeof i == "function" ? i.apply(null, t) : i : "unknown error nr: " + a;
    throw Error("[Immer] " + s);
  }
  throw Error("[Immer] minified error nr: " + a + (t.length ? " " + t.map(function(l) {
    return "'" + l + "'";
  }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
}
function fb(a) {
  return !!a && !!a[Mm];
}
function J_(a) {
  return !!a && (function(e) {
    if (!e || typeof e != "object")
      return !1;
    var t = Object.getPrototypeOf(e);
    if (t === null)
      return !0;
    var r = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
    return r === Object || typeof r == "function" && Function.toString.call(r) === OX;
  }(a) || Array.isArray(a) || !!a[_N] || !!a.constructor[_N] || LL(a) || PL(a));
}
function XM(a, e, t) {
  t === void 0 && (t = !1), gb(a) === 0 ? (t ? Object.keys : FL)(a).forEach(function(r) {
    t && typeof r == "symbol" || e(r, a[r], a);
  }) : a.forEach(function(r, i) {
    return e(i, r, a);
  });
}
function gb(a) {
  var e = a[Mm];
  return e ? e.i > 3 ? e.i - 4 : e.i : Array.isArray(a) ? 1 : LL(a) ? 2 : PL(a) ? 3 : 0;
}
function N3(a, e) {
  return gb(a) === 2 ? a.has(e) : Object.prototype.hasOwnProperty.call(a, e);
}
function MX(a, e) {
  return gb(a) === 2 ? a.get(e) : a[e];
}
function _4(a, e, t) {
  var r = gb(a);
  r === 2 ? a.set(e, t) : r === 3 ? (a.delete(e), a.add(t)) : a[e] = t;
}
function TX(a, e) {
  return a === e ? a !== 0 || 1 / a == 1 / e : a != a && e != e;
}
function LL(a) {
  return DX && a instanceof Map;
}
function PL(a) {
  return LX && a instanceof Set;
}
function A_(a) {
  return a.o || a.t;
}
function OL(a) {
  if (Array.isArray(a))
    return Array.prototype.slice.call(a);
  var e = UX(a);
  delete e[Mm];
  for (var t = FL(e), r = 0; r < t.length; r++) {
    var i = t[r], s = e[i];
    s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (e[i] = { configurable: !0, writable: !0, enumerable: s.enumerable, value: a[i] });
  }
  return Object.create(Object.getPrototypeOf(a), e);
}
function UL(a, e) {
  return e === void 0 && (e = !1), zL(a) || fb(a) || !J_(a) || (gb(a) > 1 && (a.set = a.add = a.clear = a.delete = CX), Object.freeze(a), e && XM(a, function(t, r) {
    return UL(r, !0);
  }, !0)), a;
}
function CX() {
  zd(2);
}
function zL(a) {
  return a == null || typeof a != "object" || Object.isFrozen(a);
}
function py(a) {
  var e = zX[a];
  return e || zd(18, a), e;
}
function hN() {
  return process.env.NODE_ENV === "production" || db || zd(0), db;
}
function OD(a, e) {
  e && (py("Patches"), a.u = [], a.s = [], a.v = e);
}
function DC(a) {
  F3(a), a.p.forEach(RX), a.p = null;
}
function F3(a) {
  a === db && (db = a.l);
}
function pN(a) {
  return db = { p: [], l: db, h: a, m: !0, _: 0 };
}
function RX(a) {
  var e = a[Mm];
  e.i === 0 || e.i === 1 ? e.j() : e.O = !0;
}
function UD(a, e) {
  e._ = e.p.length;
  var t = e.p[0], r = a !== void 0 && a !== t;
  return e.h.g || py("ES5").S(e, a, r), r ? (t[Mm].P && (DC(e), zd(4)), J_(a) && (a = LC(e, a), e.l || PC(e, a)), e.u && py("Patches").M(t[Mm].t, a, e.u, e.s)) : a = LC(e, t, []), DC(e), e.u && e.v(e.u, e.s), a !== S4 ? a : void 0;
}
function LC(a, e, t) {
  if (zL(e))
    return e;
  var r = e[Mm];
  if (!r)
    return XM(e, function(s, l) {
      return mN(a, r, e, s, l, t);
    }, !0), e;
  if (r.A !== a)
    return e;
  if (!r.P)
    return PC(a, r.t, !0), r.t;
  if (!r.I) {
    r.I = !0, r.A._--;
    var i = r.i === 4 || r.i === 5 ? r.o = OL(r.k) : r.o;
    XM(r.i === 3 ? new Set(i) : i, function(s, l) {
      return mN(a, r, i, s, l, t);
    }), PC(a, i, !1), t && a.u && py("Patches").R(r, t, a.u, a.s);
  }
  return r.o;
}
function mN(a, e, t, r, i, s) {
  if (process.env.NODE_ENV !== "production" && i === t && zd(5), fb(i)) {
    var l = LC(a, i, s && e && e.i !== 3 && !N3(e.D, r) ? s.concat(r) : void 0);
    if (_4(t, r, l), !fb(l))
      return;
    a.m = !1;
  }
  if (J_(i) && !zL(i)) {
    if (!a.h.F && a._ < 1)
      return;
    LC(a, i), e && e.A.l || PC(a, i);
  }
}
function PC(a, e, t) {
  t === void 0 && (t = !1), a.h.F && a.m && UL(e, t);
}
function zD(a, e) {
  var t = a[Mm];
  return (t ? A_(t) : a)[e];
}
function vN(a, e) {
  if (e in a)
    for (var t = Object.getPrototypeOf(a); t; ) {
      var r = Object.getOwnPropertyDescriptor(t, e);
      if (r)
        return r;
      t = Object.getPrototypeOf(t);
    }
}
function k3(a) {
  a.P || (a.P = !0, a.l && k3(a.l));
}
function ND(a) {
  a.o || (a.o = OL(a.t));
}
function I3(a, e, t) {
  var r = LL(e) ? py("MapSet").N(e, t) : PL(e) ? py("MapSet").T(e, t) : a.g ? function(i, s) {
    var l = Array.isArray(i), d = { i: l ? 1 : 0, A: s ? s.A : hN(), P: !1, I: !1, D: {}, l: s, t: i, k: null, o: null, j: null, C: !1 }, p = d, g = B3;
    l && (p = [d], g = gM);
    var _ = Proxy.revocable(p, g), w = _.revoke, T = _.proxy;
    return d.k = T, d.j = w, T;
  }(e, t) : py("ES5").J(e, t);
  return (t ? t.A : hN()).p.push(r), r;
}
function AX(a) {
  return fb(a) || zd(22, a), function e(t) {
    if (!J_(t))
      return t;
    var r, i = t[Mm], s = gb(t);
    if (i) {
      if (!i.P && (i.i < 4 || !py("ES5").K(i)))
        return i.t;
      i.I = !0, r = gN(t, s), i.I = !1;
    } else
      r = gN(t, s);
    return XM(r, function(l, d) {
      i && MX(i.t, l) === d || _4(r, l, e(d));
    }), s === 3 ? new Set(r) : r;
  }(a);
}
function gN(a, e) {
  switch (e) {
    case 2:
      return new Map(a);
    case 3:
      return Array.from(a);
  }
  return OL(a);
}
var yN, db, NL = typeof Symbol < "u" && typeof Symbol("x") == "symbol", DX = typeof Map < "u", LX = typeof Set < "u", xN = typeof Proxy < "u" && Proxy.revocable !== void 0 && typeof Reflect < "u", S4 = NL ? Symbol.for("immer-nothing") : ((yN = {})["immer-nothing"] = !0, yN), _N = NL ? Symbol.for("immer-draftable") : "__$immer_draftable", Mm = NL ? Symbol.for("immer-state") : "__$immer_state", PX = { 0: "Illegal state", 1: "Immer drafts cannot have computed properties", 2: "This object has been frozen and should not be mutated", 3: function(a) {
  return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + a;
}, 4: "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.", 5: "Immer forbids circular references", 6: "The first or second argument to `produce` must be a function", 7: "The third argument to `produce` must be a function or undefined", 8: "First argument to `createDraft` must be a plain object, an array, or an immerable object", 9: "First argument to `finishDraft` must be a draft returned by `createDraft`", 10: "The given draft is already finalized", 11: "Object.defineProperty() cannot be used on an Immer draft", 12: "Object.setPrototypeOf() cannot be used on an Immer draft", 13: "Immer only supports deleting array indices", 14: "Immer only supports setting array indices and the 'length' property", 15: function(a) {
  return "Cannot apply patch, path doesn't resolve: " + a;
}, 16: 'Sets cannot have "replace" patches.', 17: function(a) {
  return "Unsupported patch operation: " + a;
}, 18: function(a) {
  return "The plugin for '" + a + "' has not been loaded into Immer. To enable the plugin, import and call `enable" + a + "()` when initializing your application.";
}, 20: "Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available", 21: function(a) {
  return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '" + a + "'";
}, 22: function(a) {
  return "'current' expects a draft, got: " + a;
}, 23: function(a) {
  return "'original' expects a draft, got: " + a;
}, 24: "Patching reserved attributes like __proto__, prototype and constructor is not allowed" }, OX = "" + Object.prototype.constructor, FL = typeof Reflect < "u" && Reflect.ownKeys ? Reflect.ownKeys : Object.getOwnPropertySymbols !== void 0 ? function(a) {
  return Object.getOwnPropertyNames(a).concat(Object.getOwnPropertySymbols(a));
} : Object.getOwnPropertyNames, UX = Object.getOwnPropertyDescriptors || function(a) {
  var e = {};
  return FL(a).forEach(function(t) {
    e[t] = Object.getOwnPropertyDescriptor(a, t);
  }), e;
}, zX = {}, B3 = { get: function(a, e) {
  if (e === Mm)
    return a;
  var t = A_(a);
  if (!N3(t, e))
    return function(i, s, l) {
      var d, p = vN(s, l);
      return p ? "value" in p ? p.value : (d = p.get) === null || d === void 0 ? void 0 : d.call(i.k) : void 0;
    }(a, t, e);
  var r = t[e];
  return a.I || !J_(r) ? r : r === zD(a.t, e) ? (ND(a), a.o[e] = I3(a.A.h, r, a)) : r;
}, has: function(a, e) {
  return e in A_(a);
}, ownKeys: function(a) {
  return Reflect.ownKeys(A_(a));
}, set: function(a, e, t) {
  var r = vN(A_(a), e);
  if (r != null && r.set)
    return r.set.call(a.k, t), !0;
  if (!a.P) {
    var i = zD(A_(a), e), s = i == null ? void 0 : i[Mm];
    if (s && s.t === t)
      return a.o[e] = t, a.D[e] = !1, !0;
    if (TX(t, i) && (t !== void 0 || N3(a.t, e)))
      return !0;
    ND(a), k3(a);
  }
  return a.o[e] === t && typeof t != "number" && (t !== void 0 || e in a.o) || (a.o[e] = t, a.D[e] = !0, !0);
}, deleteProperty: function(a, e) {
  return zD(a.t, e) !== void 0 || e in a.t ? (a.D[e] = !1, ND(a), k3(a)) : delete a.D[e], a.o && delete a.o[e], !0;
}, getOwnPropertyDescriptor: function(a, e) {
  var t = A_(a), r = Reflect.getOwnPropertyDescriptor(t, e);
  return r && { writable: !0, configurable: a.i !== 1 || e !== "length", enumerable: r.enumerable, value: t[e] };
}, defineProperty: function() {
  zd(11);
}, getPrototypeOf: function(a) {
  return Object.getPrototypeOf(a.t);
}, setPrototypeOf: function() {
  zd(12);
} }, gM = {};
XM(B3, function(a, e) {
  gM[a] = function() {
    return arguments[0] = arguments[0][0], e.apply(this, arguments);
  };
}), gM.deleteProperty = function(a, e) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(e)) && zd(13), gM.set.call(this, a, e, void 0);
}, gM.set = function(a, e, t) {
  return process.env.NODE_ENV !== "production" && e !== "length" && isNaN(parseInt(e)) && zd(14), B3.set.call(this, a[0], e, t, a[0]);
};
var NX = function() {
  function a(t) {
    var r = this;
    this.g = xN, this.F = !0, this.produce = function(i, s, l) {
      if (typeof i == "function" && typeof s != "function") {
        var d = s;
        s = i;
        var p = r;
        return function(O) {
          var U = this;
          O === void 0 && (O = d);
          for (var H = arguments.length, I = Array(H > 1 ? H - 1 : 0), G = 1; G < H; G++)
            I[G - 1] = arguments[G];
          return p.produce(O, function(B) {
            var Q;
            return (Q = s).call.apply(Q, [U, B].concat(I));
          });
        };
      }
      var g;
      if (typeof s != "function" && zd(6), l !== void 0 && typeof l != "function" && zd(7), J_(i)) {
        var _ = pN(r), w = I3(r, i, void 0), T = !0;
        try {
          g = s(w), T = !1;
        } finally {
          T ? DC(_) : F3(_);
        }
        return typeof Promise < "u" && g instanceof Promise ? g.then(function(O) {
          return OD(_, l), UD(O, _);
        }, function(O) {
          throw DC(_), O;
        }) : (OD(_, l), UD(g, _));
      }
      if (!i || typeof i != "object") {
        if ((g = s(i)) === void 0 && (g = i), g === S4 && (g = void 0), r.F && UL(g, !0), l) {
          var R = [], D = [];
          py("Patches").M(i, g, R, D), l(R, D);
        }
        return g;
      }
      zd(21, i);
    }, this.produceWithPatches = function(i, s) {
      if (typeof i == "function")
        return function(g) {
          for (var _ = arguments.length, w = Array(_ > 1 ? _ - 1 : 0), T = 1; T < _; T++)
            w[T - 1] = arguments[T];
          return r.produceWithPatches(g, function(R) {
            return i.apply(void 0, [R].concat(w));
          });
        };
      var l, d, p = r.produce(i, s, function(g, _) {
        l = g, d = _;
      });
      return typeof Promise < "u" && p instanceof Promise ? p.then(function(g) {
        return [g, l, d];
      }) : [p, l, d];
    }, typeof (t == null ? void 0 : t.useProxies) == "boolean" && this.setUseProxies(t.useProxies), typeof (t == null ? void 0 : t.autoFreeze) == "boolean" && this.setAutoFreeze(t.autoFreeze);
  }
  var e = a.prototype;
  return e.createDraft = function(t) {
    J_(t) || zd(8), fb(t) && (t = AX(t));
    var r = pN(this), i = I3(this, t, void 0);
    return i[Mm].C = !0, F3(r), i;
  }, e.finishDraft = function(t, r) {
    var i = t && t[Mm];
    process.env.NODE_ENV !== "production" && (i && i.C || zd(9), i.I && zd(10));
    var s = i.A;
    return OD(s, r), UD(void 0, s);
  }, e.setAutoFreeze = function(t) {
    this.F = t;
  }, e.setUseProxies = function(t) {
    t && !xN && zd(20), this.g = t;
  }, e.applyPatches = function(t, r) {
    var i;
    for (i = r.length - 1; i >= 0; i--) {
      var s = r[i];
      if (s.path.length === 0 && s.op === "replace") {
        t = s.value;
        break;
      }
    }
    i > -1 && (r = r.slice(i + 1));
    var l = py("Patches").$;
    return fb(t) ? l(t, r) : this.produce(t, function(d) {
      return l(d, r);
    });
  }, a;
}(), Tm = new NX(), FX = Tm.produce;
Tm.produceWithPatches.bind(Tm);
Tm.setAutoFreeze.bind(Tm);
Tm.setUseProxies.bind(Tm);
Tm.applyPatches.bind(Tm);
Tm.createDraft.bind(Tm);
Tm.finishDraft.bind(Tm);
const kX = (a) => (e, t, r) => (r.setState = (i, s, ...l) => {
  const d = typeof i == "function" ? FX(i) : i;
  return e(d, s, ...l);
}, a(r.setState, t, r)), IX = kX;
class BX {
  constructor() {
    this._previousTime = 0, this._currentTime = 0, this._delta = 0, this._elapsed = 0, this._timescale = 1, this._useFixedDelta = !1, this._fixedDelta = 16.67, this._usePageVisibilityAPI = typeof document < "u" && document.hidden !== void 0, this._usePageVisibilityAPI === !0 && (this._pageVisibilityHandler = HX.bind(this), document.addEventListener("visibilitychange", this._pageVisibilityHandler, !1));
  }
  disableFixedDelta() {
    return this._useFixedDelta = !1, this;
  }
  dispose() {
    return this._usePageVisibilityAPI === !0 && document.removeEventListener("visibilitychange", this._pageVisibilityHandler), this;
  }
  enableFixedDelta() {
    return this._useFixedDelta = !0, this;
  }
  getDelta() {
    return this._delta / 1e3;
  }
  getElapsed() {
    return this._elapsed / 1e3;
  }
  getFixedDelta() {
    return this._fixedDelta / 1e3;
  }
  getTimescale() {
    return this._timescale;
  }
  reset() {
    return this._currentTime = this._now(), this;
  }
  setFixedDelta(e) {
    return this._fixedDelta = e * 1e3, this;
  }
  setTimescale(e) {
    return this._timescale = e, this;
  }
  update() {
    return this._useFixedDelta === !0 ? this._delta = this._fixedDelta : (this._previousTime = this._currentTime, this._currentTime = this._now(), this._delta = this._currentTime - this._previousTime), this._delta *= this._timescale, this._elapsed += this._delta, this;
  }
  _now() {
    return (typeof performance > "u" ? Date : performance).now();
  }
}
function HX() {
  document.hidden === !1 && this.reset();
}
var Sv = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
(function(a, e) {
  (function() {
    var t, r = "4.17.21", i = 200, s = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", l = "Expected a function", d = "Invalid `variable` option passed into `_.template`", p = "__lodash_hash_undefined__", g = 500, _ = "__lodash_placeholder__", w = 1, T = 2, R = 4, D = 1, O = 2, U = 1, H = 2, I = 4, G = 8, B = 16, Q = 32, K = 64, te = 128, Y = 256, re = 512, se = 30, ce = "...", ue = 800, Me = 16, me = 1, De = 2, Re = 3, He = 1 / 0, ve = 9007199254740991, fe = 17976931348623157e292, he = 0 / 0, ye = 4294967295, Ee = ye - 1, Ve = ye >>> 1, Je = [
      ["ary", te],
      ["bind", U],
      ["bindKey", H],
      ["curry", G],
      ["curryRight", B],
      ["flip", re],
      ["partial", Q],
      ["partialRight", K],
      ["rearg", Y]
    ], rt = "[object Arguments]", Ne = "[object Array]", ct = "[object AsyncFunction]", tt = "[object Boolean]", Tt = "[object Date]", gt = "[object DOMException]", ft = "[object Error]", Ie = "[object Function]", qe = "[object GeneratorFunction]", dt = "[object Map]", ht = "[object Number]", xt = "[object Null]", Vt = "[object Object]", yt = "[object Promise]", Nt = "[object Proxy]", Zt = "[object RegExp]", Rt = "[object Set]", we = "[object String]", oe = "[object Symbol]", Qe = "[object Undefined]", ut = "[object WeakMap]", Ft = "[object WeakSet]", Ot = "[object ArrayBuffer]", Wt = "[object DataView]", it = "[object Float32Array]", an = "[object Float64Array]", Be = "[object Int8Array]", pe = "[object Int16Array]", Fe = "[object Int32Array]", at = "[object Uint8Array]", st = "[object Uint8ClampedArray]", dn = "[object Uint16Array]", ze = "[object Uint32Array]", wt = /\b__p \+= '';/g, Pe = /\b(__p \+=) '' \+/g, Gt = /(__e\(.*?\)|\b__t\)) \+\n'';/g, At = /&(?:amp|lt|gt|quot|#39);/g, cn = /[&<>"']/g, ki = RegExp(At.source), Or = RegExp(cn.source), Ii = /<%-([\s\S]+?)%>/g, Ir = /<%([\s\S]+?)%>/g, Bn = /<%=([\s\S]+?)%>/g, Mi = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, yi = /^\w*$/, ii = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Bi = /[\\^$.*+?()[\]{}|]/g, xi = RegExp(Bi.source), $r = /^\s+/, ai = /\s/, Te = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, ot = /\{\n\/\* \[wrapped with (.+)\] \*/, de = /,? & /, Le = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, Ye = /[()=,{}\[\]\/\s]/, $t = /\\(\\)?/g, mn = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Rn = /\w*$/, gn = /^[-+]0x[0-9a-f]+$/i, yn = /^0b[01]+$/i, Jn = /^\[object .+?Constructor\]$/, rr = /^0o[0-7]+$/i, wr = /^(?:0|[1-9]\d*)$/, Yi = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, La = /($^)/, qs = /['\n\r\u2028\u2029\\]/g, en = "\\ud800-\\udfff", Xr = "\\u0300-\\u036f", us = "\\ufe20-\\ufe2f", qn = "\\u20d0-\\u20ff", qa = Xr + us + qn, mo = "\\u2700-\\u27bf", Ls = "a-z\\xdf-\\xf6\\xf8-\\xff", cs = "\\xac\\xb1\\xd7\\xf7", mr = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", di = "\\u2000-\\u206f", Ea = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", Si = "A-Z\\xc0-\\xd6\\xd8-\\xde", Ti = "\\ufe0e\\ufe0f", Uo = cs + mr + di + Ea, zo = "['\u2019]", Pa = "[" + en + "]", Dl = "[" + Uo + "]", vo = "[" + qa + "]", Yf = "\\d+", Ll = "[" + mo + "]", Nd = "[" + Ls + "]", Ps = "[^" + en + Uo + Yf + mo + Ls + Si + "]", Ju = "\\ud83c[\\udffb-\\udfff]", ou = "(?:" + vo + "|" + Ju + ")", Jh = "[^" + en + "]", Pl = "(?:\\ud83c[\\udde6-\\uddff]){2}", ei = "[\\ud800-\\udbff][\\udc00-\\udfff]", go = "[" + Si + "]", Xf = "\\u200d", No = "(?:" + Nd + "|" + Ps + ")", Ci = "(?:" + go + "|" + Ps + ")", fs = "(?:" + zo + "(?:d|ll|m|re|s|t|ve))?", qf = "(?:" + zo + "(?:D|LL|M|RE|S|T|VE))?", xr = ou + "?", Tu = "[" + Ti + "]?", ua = "(?:" + Xf + "(?:" + [Jh, Pl, ei].join("|") + ")" + Tu + xr + ")*", Cr = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", dl = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", yo = Tu + xr + ua, Ka = "(?:" + [Ll, Pl, ei].join("|") + ")" + yo, Xi = "(?:" + [Jh + vo + "?", vo, Pl, ei, Pa].join("|") + ")", Lm = RegExp(zo, "g"), hi = RegExp(vo, "g"), Qa = RegExp(Ju + "(?=" + Ju + ")|" + Xi + yo, "g"), Sc = RegExp([
      go + "?" + Nd + "+" + fs + "(?=" + [Dl, go, "$"].join("|") + ")",
      Ci + "+" + qf + "(?=" + [Dl, go + No, "$"].join("|") + ")",
      go + "?" + No + "+" + fs,
      go + "+" + qf,
      dl,
      Cr,
      Yf,
      Ka
    ].join("|"), "g"), hl = RegExp("[" + Xf + en + qa + Ti + "]"), pf = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, mf = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ], lu = -1, Hi = {};
    Hi[it] = Hi[an] = Hi[Be] = Hi[pe] = Hi[Fe] = Hi[at] = Hi[st] = Hi[dn] = Hi[ze] = !0, Hi[rt] = Hi[Ne] = Hi[Ot] = Hi[tt] = Hi[Wt] = Hi[Tt] = Hi[ft] = Hi[Ie] = Hi[dt] = Hi[ht] = Hi[Vt] = Hi[Zt] = Hi[Rt] = Hi[we] = Hi[ut] = !1;
    var Ri = {};
    Ri[rt] = Ri[Ne] = Ri[Ot] = Ri[Wt] = Ri[tt] = Ri[Tt] = Ri[it] = Ri[an] = Ri[Be] = Ri[pe] = Ri[Fe] = Ri[dt] = Ri[ht] = Ri[Vt] = Ri[Zt] = Ri[Rt] = Ri[we] = Ri[oe] = Ri[at] = Ri[st] = Ri[dn] = Ri[ze] = !0, Ri[ft] = Ri[Ie] = Ri[ut] = !1;
    var Fo = {
      \u00C0: "A",
      \u00C1: "A",
      \u00C2: "A",
      \u00C3: "A",
      \u00C4: "A",
      \u00C5: "A",
      \u00E0: "a",
      \u00E1: "a",
      \u00E2: "a",
      \u00E3: "a",
      \u00E4: "a",
      \u00E5: "a",
      \u00C7: "C",
      \u00E7: "c",
      \u00D0: "D",
      \u00F0: "d",
      \u00C8: "E",
      \u00C9: "E",
      \u00CA: "E",
      \u00CB: "E",
      \u00E8: "e",
      \u00E9: "e",
      \u00EA: "e",
      \u00EB: "e",
      \u00CC: "I",
      \u00CD: "I",
      \u00CE: "I",
      \u00CF: "I",
      \u00EC: "i",
      \u00ED: "i",
      \u00EE: "i",
      \u00EF: "i",
      \u00D1: "N",
      \u00F1: "n",
      \u00D2: "O",
      \u00D3: "O",
      \u00D4: "O",
      \u00D5: "O",
      \u00D6: "O",
      \u00D8: "O",
      \u00F2: "o",
      \u00F3: "o",
      \u00F4: "o",
      \u00F5: "o",
      \u00F6: "o",
      \u00F8: "o",
      \u00D9: "U",
      \u00DA: "U",
      \u00DB: "U",
      \u00DC: "U",
      \u00F9: "u",
      \u00FA: "u",
      \u00FB: "u",
      \u00FC: "u",
      \u00DD: "Y",
      \u00FD: "y",
      \u00FF: "y",
      \u00C6: "Ae",
      \u00E6: "ae",
      \u00DE: "Th",
      \u00FE: "th",
      \u00DF: "ss",
      \u0100: "A",
      \u0102: "A",
      \u0104: "A",
      \u0101: "a",
      \u0103: "a",
      \u0105: "a",
      \u0106: "C",
      \u0108: "C",
      \u010A: "C",
      \u010C: "C",
      \u0107: "c",
      \u0109: "c",
      \u010B: "c",
      \u010D: "c",
      \u010E: "D",
      \u0110: "D",
      \u010F: "d",
      \u0111: "d",
      \u0112: "E",
      \u0114: "E",
      \u0116: "E",
      \u0118: "E",
      \u011A: "E",
      \u0113: "e",
      \u0115: "e",
      \u0117: "e",
      \u0119: "e",
      \u011B: "e",
      \u011C: "G",
      \u011E: "G",
      \u0120: "G",
      \u0122: "G",
      \u011D: "g",
      \u011F: "g",
      \u0121: "g",
      \u0123: "g",
      \u0124: "H",
      \u0126: "H",
      \u0125: "h",
      \u0127: "h",
      \u0128: "I",
      \u012A: "I",
      \u012C: "I",
      \u012E: "I",
      \u0130: "I",
      \u0129: "i",
      \u012B: "i",
      \u012D: "i",
      \u012F: "i",
      \u0131: "i",
      \u0134: "J",
      \u0135: "j",
      \u0136: "K",
      \u0137: "k",
      \u0138: "k",
      \u0139: "L",
      \u013B: "L",
      \u013D: "L",
      \u013F: "L",
      \u0141: "L",
      \u013A: "l",
      \u013C: "l",
      \u013E: "l",
      \u0140: "l",
      \u0142: "l",
      \u0143: "N",
      \u0145: "N",
      \u0147: "N",
      \u014A: "N",
      \u0144: "n",
      \u0146: "n",
      \u0148: "n",
      \u014B: "n",
      \u014C: "O",
      \u014E: "O",
      \u0150: "O",
      \u014D: "o",
      \u014F: "o",
      \u0151: "o",
      \u0154: "R",
      \u0156: "R",
      \u0158: "R",
      \u0155: "r",
      \u0157: "r",
      \u0159: "r",
      \u015A: "S",
      \u015C: "S",
      \u015E: "S",
      \u0160: "S",
      \u015B: "s",
      \u015D: "s",
      \u015F: "s",
      \u0161: "s",
      \u0162: "T",
      \u0164: "T",
      \u0166: "T",
      \u0163: "t",
      \u0165: "t",
      \u0167: "t",
      \u0168: "U",
      \u016A: "U",
      \u016C: "U",
      \u016E: "U",
      \u0170: "U",
      \u0172: "U",
      \u0169: "u",
      \u016B: "u",
      \u016D: "u",
      \u016F: "u",
      \u0171: "u",
      \u0173: "u",
      \u0174: "W",
      \u0175: "w",
      \u0176: "Y",
      \u0177: "y",
      \u0178: "Y",
      \u0179: "Z",
      \u017B: "Z",
      \u017D: "Z",
      \u017A: "z",
      \u017C: "z",
      \u017E: "z",
      \u0132: "IJ",
      \u0133: "ij",
      \u0152: "Oe",
      \u0153: "oe",
      \u0149: "'n",
      \u017F: "s"
    }, Os = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    }, wc = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    }, Ol = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    }, Qf = parseFloat, Zf = parseInt, ko = typeof D0 == "object" && D0 && D0.Object === Object && D0, Jf = typeof self == "object" && self && self.Object === Object && self, Ki = ko || Jf || Function("return this")(), Cu = e && !e.nodeType && e, Oa = Cu && !0 && a && !a.nodeType && a, xs = Oa && Oa.exports === Cu, uu = xs && ko.process, Ua = function() {
      try {
        var Xe = Oa && Oa.require && Oa.require("util").types;
        return Xe || uu && uu.binding && uu.binding("util");
      } catch {
      }
    }(), bc = Ua && Ua.isArrayBuffer, xo = Ua && Ua.isDate, Ru = Ua && Ua.isMap, Ul = Ua && Ua.isRegExp, za = Ua && Ua.isSet, Qs = Ua && Ua.isTypedArray;
    function qr(Xe, Bt, vt) {
      switch (vt.length) {
        case 0:
          return Xe.call(Bt);
        case 1:
          return Xe.call(Bt, vt[0]);
        case 2:
          return Xe.call(Bt, vt[0], vt[1]);
        case 3:
          return Xe.call(Bt, vt[0], vt[1], vt[2]);
      }
      return Xe.apply(Bt, vt);
    }
    function _s(Xe, Bt, vt, Mn) {
      for (var $n = -1, or = Xe == null ? 0 : Xe.length; ++$n < or; ) {
        var Ta = Xe[$n];
        Bt(Mn, Ta, vt(Ta), Xe);
      }
      return Mn;
    }
    function va(Xe, Bt) {
      for (var vt = -1, Mn = Xe == null ? 0 : Xe.length; ++vt < Mn && Bt(Xe[vt], vt, Xe) !== !1; )
        ;
      return Xe;
    }
    function Zs(Xe, Bt) {
      for (var vt = Xe == null ? 0 : Xe.length; vt-- && Bt(Xe[vt], vt, Xe) !== !1; )
        ;
      return Xe;
    }
    function Kf(Xe, Bt) {
      for (var vt = -1, Mn = Xe == null ? 0 : Xe.length; ++vt < Mn; )
        if (!Bt(Xe[vt], vt, Xe))
          return !1;
      return !0;
    }
    function el(Xe, Bt) {
      for (var vt = -1, Mn = Xe == null ? 0 : Xe.length, $n = 0, or = []; ++vt < Mn; ) {
        var Ta = Xe[vt];
        Bt(Ta, vt, Xe) && (or[$n++] = Ta);
      }
      return or;
    }
    function Ku(Xe, Bt) {
      var vt = Xe == null ? 0 : Xe.length;
      return !!vt && $u(Xe, Bt, 0) > -1;
    }
    function Kh(Xe, Bt, vt) {
      for (var Mn = -1, $n = Xe == null ? 0 : Xe.length; ++Mn < $n; )
        if (vt(Bt, Xe[Mn]))
          return !0;
      return !1;
    }
    function qi(Xe, Bt) {
      for (var vt = -1, Mn = Xe == null ? 0 : Xe.length, $n = Array(Mn); ++vt < Mn; )
        $n[vt] = Bt(Xe[vt], vt, Xe);
      return $n;
    }
    function Au(Xe, Bt) {
      for (var vt = -1, Mn = Bt.length, $n = Xe.length; ++vt < Mn; )
        Xe[$n + vt] = Bt[vt];
      return Xe;
    }
    function Fp(Xe, Bt, vt, Mn) {
      var $n = -1, or = Xe == null ? 0 : Xe.length;
      for (Mn && or && (vt = Xe[++$n]); ++$n < or; )
        vt = Bt(vt, Xe[$n], $n, Xe);
      return vt;
    }
    function pg(Xe, Bt, vt, Mn) {
      var $n = Xe == null ? 0 : Xe.length;
      for (Mn && $n && (vt = Xe[--$n]); $n--; )
        vt = Bt(vt, Xe[$n], $n, Xe);
      return vt;
    }
    function $h(Xe, Bt) {
      for (var vt = -1, Mn = Xe == null ? 0 : Xe.length; ++vt < Mn; )
        if (Bt(Xe[vt], vt, Xe))
          return !0;
      return !1;
    }
    var Pm = pl("length");
    function Om(Xe) {
      return Xe.split("");
    }
    function Um(Xe) {
      return Xe.match(Le) || [];
    }
    function zm(Xe, Bt, vt) {
      var Mn;
      return vt(Xe, function($n, or, Ta) {
        if (Bt($n, or, Ta))
          return Mn = or, !1;
      }), Mn;
    }
    function gh(Xe, Bt, vt, Mn) {
      for (var $n = Xe.length, or = vt + (Mn ? 1 : -1); Mn ? or-- : ++or < $n; )
        if (Bt(Xe[or], or, Xe))
          return or;
      return -1;
    }
    function $u(Xe, Bt, vt) {
      return Bt === Bt ? Ec(Xe, Bt, vt) : gh(Xe, Du, vt);
    }
    function Fd(Xe, Bt, vt, Mn) {
      for (var $n = vt - 1, or = Xe.length; ++$n < or; )
        if (Mn(Xe[$n], Bt))
          return $n;
      return -1;
    }
    function Du(Xe) {
      return Xe !== Xe;
    }
    function kp(Xe, Bt) {
      var vt = Xe == null ? 0 : Xe.length;
      return vt ? cu(Xe, Bt) / vt : he;
    }
    function pl(Xe) {
      return function(Bt) {
        return Bt == null ? t : Bt[Xe];
      };
    }
    function tl(Xe) {
      return function(Bt) {
        return Xe == null ? t : Xe[Bt];
      };
    }
    function vf(Xe, Bt, vt, Mn, $n) {
      return $n(Xe, function(or, Ta, er) {
        vt = Mn ? (Mn = !1, or) : Bt(vt, or, Ta, er);
      }), vt;
    }
    function $f(Xe, Bt) {
      var vt = Xe.length;
      for (Xe.sort(Bt); vt--; )
        Xe[vt] = Xe[vt].value;
      return Xe;
    }
    function cu(Xe, Bt) {
      for (var vt, Mn = -1, $n = Xe.length; ++Mn < $n; ) {
        var or = Bt(Xe[Mn]);
        or !== t && (vt = vt === t ? or : vt + or);
      }
      return vt;
    }
    function gf(Xe, Bt) {
      for (var vt = -1, Mn = Array(Xe); ++vt < Xe; )
        Mn[vt] = Bt(vt);
      return Mn;
    }
    function zl(Xe, Bt) {
      return qi(Bt, function(vt) {
        return [vt, Xe[vt]];
      });
    }
    function ec(Xe) {
      return Xe && Xe.slice(0, Hd(Xe) + 1).replace($r, "");
    }
    function Oi(Xe) {
      return function(Bt) {
        return Xe(Bt);
      };
    }
    function Za(Xe, Bt) {
      return qi(Bt, function(vt) {
        return Xe[vt];
      });
    }
    function Ma(Xe, Bt) {
      return Xe.has(Bt);
    }
    function ca(Xe, Bt) {
      for (var vt = -1, Mn = Xe.length; ++vt < Mn && $u(Bt, Xe[vt], 0) > -1; )
        ;
      return vt;
    }
    function kd(Xe, Bt) {
      for (var vt = Xe.length; vt-- && $u(Bt, Xe[vt], 0) > -1; )
        ;
      return vt;
    }
    function nl(Xe, Bt) {
      for (var vt = Xe.length, Mn = 0; vt--; )
        Xe[vt] === Bt && ++Mn;
      return Mn;
    }
    var Nm = tl(Fo), Fm = tl(Os);
    function yh(Xe) {
      return "\\" + Ol[Xe];
    }
    function ed(Xe, Bt) {
      return Xe == null ? t : Xe[Bt];
    }
    function Id(Xe) {
      return hl.test(Xe);
    }
    function Ip(Xe) {
      return pf.test(Xe);
    }
    function xh(Xe) {
      for (var Bt, vt = []; !(Bt = Xe.next()).done; )
        vt.push(Bt.value);
      return vt;
    }
    function Bd(Xe) {
      var Bt = -1, vt = Array(Xe.size);
      return Xe.forEach(function(Mn, $n) {
        vt[++Bt] = [$n, Mn];
      }), vt;
    }
    function td(Xe, Bt) {
      return function(vt) {
        return Xe(Bt(vt));
      };
    }
    function Ss(Xe, Bt) {
      for (var vt = -1, Mn = Xe.length, $n = 0, or = []; ++vt < Mn; ) {
        var Ta = Xe[vt];
        (Ta === Bt || Ta === _) && (Xe[vt] = _, or[$n++] = vt);
      }
      return or;
    }
    function tc(Xe) {
      var Bt = -1, vt = Array(Xe.size);
      return Xe.forEach(function(Mn) {
        vt[++Bt] = Mn;
      }), vt;
    }
    function yf(Xe) {
      var Bt = -1, vt = Array(Xe.size);
      return Xe.forEach(function(Mn) {
        vt[++Bt] = [Mn, Mn];
      }), vt;
    }
    function Ec(Xe, Bt, vt) {
      for (var Mn = vt - 1, $n = Xe.length; ++Mn < $n; )
        if (Xe[Mn] === Bt)
          return Mn;
      return -1;
    }
    function Bp(Xe, Bt, vt) {
      for (var Mn = vt + 1; Mn--; )
        if (Xe[Mn] === Bt)
          return Mn;
      return Mn;
    }
    function nc(Xe) {
      return Id(Xe) ? rc(Xe) : Pm(Xe);
    }
    function Na(Xe) {
      return Id(Xe) ? Hp(Xe) : Om(Xe);
    }
    function Hd(Xe) {
      for (var Bt = Xe.length; Bt-- && ai.test(Xe.charAt(Bt)); )
        ;
      return Bt;
    }
    var nd = tl(wc);
    function rc(Xe) {
      for (var Bt = Qa.lastIndex = 0; Qa.test(Xe); )
        ++Bt;
      return Bt;
    }
    function Hp(Xe) {
      return Xe.match(Qa) || [];
    }
    function _h(Xe) {
      return Xe.match(Sc) || [];
    }
    var Vp = function Xe(Bt) {
      Bt = Bt == null ? Ki : Io.defaults(Ki.Object(), Bt, Io.pick(Ki, mf));
      var vt = Bt.Array, Mn = Bt.Date, $n = Bt.Error, or = Bt.Function, Ta = Bt.Math, er = Bt.Object, Ui = Bt.RegExp, ia = Bt.String, Bo = Bt.TypeError, ds = vt.prototype, Vd = or.prototype, Nl = er.prototype, $a = Bt["__core-js_shared__"], ml = Vd.toString, _i = Nl.hasOwnProperty, Mc = 0, Lu = function() {
        var v = /[^.]+$/.exec($a && $a.keys && $a.keys.IE_PROTO || "");
        return v ? "Symbol(src)_1." + v : "";
      }(), vl = Nl.toString, Ca = ml.call(er), Sh = Ki._, Gp = Ui(
        "^" + ml.call(_i).replace(Bi, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      ), Tc = xs ? Bt.Buffer : t, Cc = Bt.Symbol, Mr = Bt.Uint8Array, $i = Tc ? Tc.allocUnsafe : t, Br = td(er.getPrototypeOf, er), Fa = er.create, _o = Nl.propertyIsEnumerable, rd = ds.splice, wh = Cc ? Cc.isConcatSpreadable : t, ic = Cc ? Cc.iterator : t, xf = Cc ? Cc.toStringTag : t, id = function() {
        try {
          var v = zf(er, "defineProperty");
          return v({}, "", {}), v;
        } catch {
        }
      }(), sn = Bt.clearTimeout !== Ki.clearTimeout && Bt.clearTimeout, kr = Mn && Mn.now !== Ki.Date.now && Mn.now, Hr = Bt.setTimeout !== Ki.setTimeout && Bt.setTimeout, Ho = Ta.ceil, rl = Ta.floor, ac = er.getOwnPropertySymbols, Pu = Tc ? Tc.isBuffer : t, Rc = Bt.isFinite, _f = ds.join, sc = td(er.keys, er), hs = Ta.max, Js = Ta.min, km = Mn.now, ep = Bt.parseInt, Gd = Ta.random, bh = ds.reverse, Sf = zf(Bt, "DataView"), Ou = zf(Bt, "Map"), ad = zf(Bt, "Promise"), fu = zf(Bt, "Set"), wf = zf(Bt, "WeakMap"), Ac = zf(er, "create"), Wd = wf && new wf(), sd = {}, Dc = gd(Sf), Fl = gd(Ou), Lc = gd(ad), Pc = gd(fu), Us = gd(wf), Uu = Cc ? Cc.prototype : t, So = Uu ? Uu.valueOf : t, od = Uu ? Uu.toString : t;
      function xe(v) {
        if (so(v) && !Jr(v) && !(v instanceof Gn)) {
          if (v instanceof ka)
            return v;
          if (_i.call(v, "__wrapped__"))
            return Mv(v);
        }
        return new ka(v);
      }
      var oc = function() {
        function v() {
        }
        return function(b) {
          if (!Vs(b))
            return {};
          if (Fa)
            return Fa(b);
          v.prototype = b;
          var N = new v();
          return v.prototype = t, N;
        };
      }();
      function Ks() {
      }
      function ka(v, b) {
        this.__wrapped__ = v, this.__actions__ = [], this.__chain__ = !!b, this.__index__ = 0, this.__values__ = t;
      }
      xe.templateSettings = {
        escape: Ii,
        evaluate: Ir,
        interpolate: Bn,
        variable: "",
        imports: {
          _: xe
        }
      }, xe.prototype = Ks.prototype, xe.prototype.constructor = xe, ka.prototype = oc(Ks.prototype), ka.prototype.constructor = ka;
      function Gn(v) {
        this.__wrapped__ = v, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = ye, this.__views__ = [];
      }
      function vr() {
        var v = new Gn(this.__wrapped__);
        return v.__actions__ = Ts(this.__actions__), v.__dir__ = this.__dir__, v.__filtered__ = this.__filtered__, v.__iteratees__ = Ts(this.__iteratees__), v.__takeCount__ = this.__takeCount__, v.__views__ = Ts(this.__views__), v;
      }
      function Vi() {
        if (this.__filtered__) {
          var v = new Gn(this);
          v.__dir__ = -1, v.__filtered__ = !0;
        } else
          v = this.clone(), v.__dir__ *= -1;
        return v;
      }
      function si() {
        var v = this.__wrapped__.value(), b = this.__dir__, N = Jr(v), Z = b < 0, ie = N ? v.length : 0, be = Xp(0, ie, this.__views__), ke = be.start, je = be.end, lt = je - ke, nn = Z ? je : ke - 1, Kt = this.__iteratees__, on = Kt.length, Cn = 0, On = Js(lt, this.__takeCount__);
        if (!N || !Z && ie == lt && On == lt)
          return ql(v, this.__actions__);
        var dr = [];
        e:
          for (; lt-- && Cn < On; ) {
            nn += b;
            for (var mi = -1, Fr = v[nn]; ++mi < on; ) {
              var Fi = Kt[mi], Ji = Fi.iteratee, Gu = Fi.type, Gs = Ji(Fr);
              if (Gu == De)
                Fr = Gs;
              else if (!Gs) {
                if (Gu == me)
                  continue e;
                break e;
              }
            }
            dr[Cn++] = Fr;
          }
        return dr;
      }
      Gn.prototype = oc(Ks.prototype), Gn.prototype.constructor = Gn;
      function Wn(v) {
        var b = -1, N = v == null ? 0 : v.length;
        for (this.clear(); ++b < N; ) {
          var Z = v[b];
          this.set(Z[0], Z[1]);
        }
      }
      function wi() {
        this.__data__ = Ac ? Ac(null) : {}, this.size = 0;
      }
      function zi(v) {
        var b = this.has(v) && delete this.__data__[v];
        return this.size -= b ? 1 : 0, b;
      }
      function Oc(v) {
        var b = this.__data__;
        if (Ac) {
          var N = b[v];
          return N === p ? t : N;
        }
        return _i.call(b, v) ? b[v] : t;
      }
      function Rr(v) {
        var b = this.__data__;
        return Ac ? b[v] !== t : _i.call(b, v);
      }
      function ps(v, b) {
        var N = this.__data__;
        return this.size += this.has(v) ? 0 : 1, N[v] = Ac && b === t ? p : b, this;
      }
      Wn.prototype.clear = wi, Wn.prototype.delete = zi, Wn.prototype.get = Oc, Wn.prototype.has = Rr, Wn.prototype.set = ps;
      function es(v) {
        var b = -1, N = v == null ? 0 : v.length;
        for (this.clear(); ++b < N; ) {
          var Z = v[b];
          this.set(Z[0], Z[1]);
        }
      }
      function kl() {
        this.__data__ = [], this.size = 0;
      }
      function Ia(v) {
        var b = this.__data__, N = bs(b, v);
        if (N < 0)
          return !1;
        var Z = b.length - 1;
        return N == Z ? b.pop() : rd.call(b, N, 1), --this.size, !0;
      }
      function Il(v) {
        var b = this.__data__, N = bs(b, v);
        return N < 0 ? t : b[N][1];
      }
      function bf(v) {
        return bs(this.__data__, v) > -1;
      }
      function jd(v, b) {
        var N = this.__data__, Z = bs(N, v);
        return Z < 0 ? (++this.size, N.push([v, b])) : N[Z][1] = b, this;
      }
      es.prototype.clear = kl, es.prototype.delete = Ia, es.prototype.get = Il, es.prototype.has = bf, es.prototype.set = jd;
      function Vo(v) {
        var b = -1, N = v == null ? 0 : v.length;
        for (this.clear(); ++b < N; ) {
          var Z = v[b];
          this.set(Z[0], Z[1]);
        }
      }
      function bv() {
        this.size = 0, this.__data__ = {
          hash: new Wn(),
          map: new (Ou || es)(),
          string: new Wn()
        };
      }
      function gl(v) {
        var b = Yp(this, v).delete(v);
        return this.size -= b ? 1 : 0, b;
      }
      function wo(v) {
        return Yp(this, v).get(v);
      }
      function tp(v) {
        return Yp(this, v).has(v);
      }
      function lc(v, b) {
        var N = Yp(this, v), Z = N.size;
        return N.set(v, b), this.size += N.size == Z ? 0 : 1, this;
      }
      Vo.prototype.clear = bv, Vo.prototype.delete = gl, Vo.prototype.get = wo, Vo.prototype.has = tp, Vo.prototype.set = lc;
      function du(v) {
        var b = -1, N = v == null ? 0 : v.length;
        for (this.__data__ = new Vo(); ++b < N; )
          this.add(v[b]);
      }
      function ws(v) {
        return this.__data__.set(v, p), this;
      }
      function Uc(v) {
        return this.__data__.has(v);
      }
      du.prototype.add = du.prototype.push = ws, du.prototype.has = Uc;
      function Vr(v) {
        var b = this.__data__ = new es(v);
        this.size = b.size;
      }
      function uc() {
        this.__data__ = new es(), this.size = 0;
      }
      function Ur(v) {
        var b = this.__data__, N = b.delete(v);
        return this.size = b.size, N;
      }
      function $s(v) {
        return this.__data__.get(v);
      }
      function ms(v) {
        return this.__data__.has(v);
      }
      function zc(v, b) {
        var N = this.__data__;
        if (N instanceof es) {
          var Z = N.__data__;
          if (!Ou || Z.length < i - 1)
            return Z.push([v, b]), this.size = ++N.size, this;
          N = this.__data__ = new Vo(Z);
        }
        return N.set(v, b), this.size = N.size, this;
      }
      Vr.prototype.clear = uc, Vr.prototype.delete = Ur, Vr.prototype.get = $s, Vr.prototype.has = ms, Vr.prototype.set = zc;
      function vn(v, b) {
        var N = Jr(v), Z = !N && rm(v), ie = !N && !Z && Sd(v), be = !N && !Z && !ie && am(v), ke = N || Z || ie || be, je = ke ? gf(v.length, ia) : [], lt = je.length;
        for (var nn in v)
          (b || _i.call(v, nn)) && !(ke && (nn == "length" || ie && (nn == "offset" || nn == "parent") || be && (nn == "buffer" || nn == "byteLength" || nn == "byteOffset") || Iu(nn, lt))) && je.push(nn);
        return je;
      }
      function Bl(v) {
        var b = v.length;
        return b ? v[Fs(0, b - 1)] : t;
      }
      function bo(v, b) {
        return sl(Ts(v), Hl(b, 0, v.length));
      }
      function Im(v) {
        return sl(Ts(v));
      }
      function Eh(v, b, N) {
        (N !== t && !Vu(v[b], N) || N === t && !(b in v)) && zs(v, b, N);
      }
      function zu(v, b, N) {
        var Z = v[b];
        (!(_i.call(v, b) && Vu(Z, N)) || N === t && !(b in v)) && zs(v, b, N);
      }
      function bs(v, b) {
        for (var N = v.length; N--; )
          if (Vu(v[N][0], b))
            return N;
        return -1;
      }
      function yl(v, b, N, Z) {
        return Nu(v, function(ie, be, ke) {
          b(Z, ie, N(ie), ke);
        }), Z;
      }
      function ga(v, b) {
        return v && Is(b, Jl(b), v);
      }
      function hu(v, b) {
        return v && Is(b, qc(b), v);
      }
      function zs(v, b, N) {
        b == "__proto__" && id ? id(v, b, {
          configurable: !0,
          enumerable: !0,
          value: N,
          writable: !0
        }) : v[b] = N;
      }
      function ld(v, b) {
        for (var N = -1, Z = b.length, ie = vt(Z), be = v == null; ++N < Z; )
          ie[N] = be ? t : m1(v, b[N]);
        return ie;
      }
      function Hl(v, b, N) {
        return v === v && (N !== t && (v = v <= N ? v : N), b !== t && (v = v >= b ? v : b)), v;
      }
      function Go(v, b, N, Z, ie, be) {
        var ke, je = b & w, lt = b & T, nn = b & R;
        if (N && (ke = ie ? N(v, Z, ie, be) : N(v)), ke !== t)
          return ke;
        if (!Vs(v))
          return v;
        var Kt = Jr(v);
        if (Kt) {
          if (ke = ro(v), !je)
            return Ts(v, ke);
        } else {
          var on = rs(v), Cn = on == Ie || on == qe;
          if (Sd(v))
            return Pf(v, je);
          if (on == Vt || on == rt || Cn && !ie) {
            if (ke = lt || Cn ? {} : sp(v), !je)
              return lt ? mg(v, hu(ke, v)) : yu(v, ga(ke, v));
          } else {
            if (!Ri[on])
              return ie ? v : {};
            ke = xl(v, on, je);
          }
        }
        be || (be = new Vr());
        var On = be.get(v);
        if (On)
          return On;
        be.set(v, ke), q0(v) ? v.forEach(function(Fr) {
          ke.add(Go(Fr, b, N, Fr, v, be));
        }) : d1(v) && v.forEach(function(Fr, Fi) {
          ke.set(Fi, Go(Fr, b, N, Fi, v, be));
        });
        var dr = nn ? lt ? Zr : Va : lt ? qc : Jl, mi = Kt ? t : dr(v);
        return va(mi || v, function(Fr, Fi) {
          mi && (Fi = Fr, Fr = v[Fi]), zu(ke, Fi, Go(Fr, b, N, Fi, v, be));
        }), ke;
      }
      function Yd(v) {
        var b = Jl(v);
        return function(N) {
          return il(N, v, b);
        };
      }
      function il(v, b, N) {
        var Z = N.length;
        if (v == null)
          return !Z;
        for (v = er(v); Z--; ) {
          var ie = N[Z], be = b[ie], ke = v[ie];
          if (ke === t && !(ie in v) || !be(ke))
            return !1;
        }
        return !0;
      }
      function Ns(v, b, N) {
        if (typeof v != "function")
          throw new Bo(l);
        return _l(function() {
          v.apply(t, N);
        }, b);
      }
      function fa(v, b, N, Z) {
        var ie = -1, be = Ku, ke = !0, je = v.length, lt = [], nn = b.length;
        if (!je)
          return lt;
        N && (b = qi(b, Oi(N))), Z ? (be = Kh, ke = !1) : b.length >= i && (be = Ma, ke = !1, b = new du(b));
        e:
          for (; ++ie < je; ) {
            var Kt = v[ie], on = N == null ? Kt : N(Kt);
            if (Kt = Z || Kt !== 0 ? Kt : 0, ke && on === on) {
              for (var Cn = nn; Cn--; )
                if (b[Cn] === on)
                  continue e;
              lt.push(Kt);
            } else
              be(b, on, Z) || lt.push(Kt);
          }
        return lt;
      }
      var Nu = Of(Gi), Wp = Of(bn, !0);
      function pu(v, b) {
        var N = !0;
        return Nu(v, function(Z, ie, be) {
          return N = !!b(Z, ie, be), N;
        }), N;
      }
      function Vl(v, b, N) {
        for (var Z = -1, ie = v.length; ++Z < ie; ) {
          var be = v[Z], ke = b(be);
          if (ke != null && (je === t ? ke === ke && !Ni(ke) : N(ke, je)))
            var je = ke, lt = be;
        }
        return lt;
      }
      function np(v, b, N, Z) {
        var ie = v.length;
        for (N = jr(N), N < 0 && (N = -N > ie ? 0 : ie + N), Z = Z === t || Z > ie ? ie : jr(Z), Z < 0 && (Z += ie), Z = N > Z ? 0 : Uh(Z); N < Z; )
          v[N++] = b;
        return v;
      }
      function Ef(v, b) {
        var N = [];
        return Nu(v, function(Z, ie, be) {
          b(Z, ie, be) && N.push(Z);
        }), N;
      }
      function eo(v, b, N, Z, ie) {
        var be = -1, ke = v.length;
        for (N || (N = gg), ie || (ie = []); ++be < ke; ) {
          var je = v[be];
          b > 0 && N(je) ? b > 1 ? eo(je, b - 1, N, Z, ie) : Au(ie, je) : Z || (ie[ie.length] = je);
        }
        return ie;
      }
      var Xd = dc(), da = dc(!0);
      function Gi(v, b) {
        return v && Xd(v, b, Jl);
      }
      function bn(v, b) {
        return v && da(v, b, Jl);
      }
      function Qi(v, b) {
        return el(b, function(N) {
          return Sp(v[N]);
        });
      }
      function ya(v, b) {
        b = no(b, v);
        for (var N = 0, Z = b.length; v != null && N < Z; )
          v = v[Zl(b[N++])];
        return N && N == Z ? v : t;
      }
      function rp(v, b, N) {
        var Z = b(v);
        return Jr(v) ? Z : Au(Z, N(v));
      }
      function Wo(v) {
        return v == null ? v === t ? Qe : xt : xf && xf in er(v) ? vg(v) : Zp(v);
      }
      function jo(v, b) {
        return v > b;
      }
      function ts(v, b) {
        return v != null && _i.call(v, b);
      }
      function An(v, b) {
        return v != null && b in er(v);
      }
      function xa(v, b, N) {
        return v >= Js(b, N) && v < hs(b, N);
      }
      function ns(v, b, N) {
        for (var Z = N ? Kh : Ku, ie = v[0].length, be = v.length, ke = be, je = vt(be), lt = 1 / 0, nn = []; ke--; ) {
          var Kt = v[ke];
          ke && b && (Kt = qi(Kt, Oi(b))), lt = Js(Kt.length, lt), je[ke] = !N && (b || ie >= 120 && Kt.length >= 120) ? new du(ke && Kt) : t;
        }
        Kt = v[0];
        var on = -1, Cn = je[0];
        e:
          for (; ++on < ie && nn.length < lt; ) {
            var On = Kt[on], dr = b ? b(On) : On;
            if (On = N || On !== 0 ? On : 0, !(Cn ? Ma(Cn, dr) : Z(nn, dr, N))) {
              for (ke = be; --ke; ) {
                var mi = je[ke];
                if (!(mi ? Ma(mi, dr) : Z(v[ke], dr, N)))
                  continue e;
              }
              Cn && Cn.push(dr), nn.push(On);
            }
          }
        return nn;
      }
      function Mf(v, b, N, Z) {
        return Gi(v, function(ie, be, ke) {
          b(Z, N(ie), be, ke);
        }), Z;
      }
      function _a(v, b, N) {
        b = no(b, v), v = io(v, b);
        var Z = v == null ? v : v[Zl(Zo(b))];
        return Z == null ? t : qr(Z, v, N);
      }
      function Qr(v) {
        return so(v) && Wo(v) == rt;
      }
      function Ra(v) {
        return so(v) && Wo(v) == Ot;
      }
      function Ba(v) {
        return so(v) && Wo(v) == Tt;
      }
      function li(v, b, N, Z, ie) {
        return v === b ? !0 : v == null || b == null || !so(v) && !so(b) ? v !== v && b !== b : Gl(v, b, N, Z, li, ie);
      }
      function Gl(v, b, N, Z, ie, be) {
        var ke = Jr(v), je = Jr(b), lt = ke ? Ne : rs(v), nn = je ? Ne : rs(b);
        lt = lt == rt ? Vt : lt, nn = nn == rt ? Vt : nn;
        var Kt = lt == Vt, on = nn == Vt, Cn = lt == nn;
        if (Cn && Sd(v)) {
          if (!Sd(b))
            return !1;
          ke = !0, Kt = !1;
        }
        if (Cn && !Kt)
          return be || (be = new Vr()), ke || am(v) ? jn(v, b, N, Z, ie, be) : Wr(v, b, lt, N, Z, ie, be);
        if (!(N & D)) {
          var On = Kt && _i.call(v, "__wrapped__"), dr = on && _i.call(b, "__wrapped__");
          if (On || dr) {
            var mi = On ? v.value() : v, Fr = dr ? b.value() : b;
            return be || (be = new Vr()), ie(mi, Fr, N, Z, be);
          }
        }
        return Cn ? (be || (be = new Vr()), Er(v, b, N, Z, ie, be)) : !1;
      }
      function ud(v) {
        return so(v) && rs(v) == dt;
      }
      function Es(v, b, N, Z) {
        var ie = N.length, be = ie, ke = !Z;
        if (v == null)
          return !be;
        for (v = er(v); ie--; ) {
          var je = N[ie];
          if (ke && je[2] ? je[1] !== v[je[0]] : !(je[0] in v))
            return !1;
        }
        for (; ++ie < be; ) {
          je = N[ie];
          var lt = je[0], nn = v[lt], Kt = je[1];
          if (ke && je[2]) {
            if (nn === t && !(lt in v))
              return !1;
          } else {
            var on = new Vr();
            if (Z)
              var Cn = Z(nn, Kt, lt, v, b, on);
            if (!(Cn === t ? li(Kt, nn, D | O, Z, on) : Cn))
              return !1;
          }
        }
        return !0;
      }
      function qd(v) {
        if (!Vs(v) || Vm(v))
          return !1;
        var b = Sp(v) ? Gp : Jn;
        return b.test(gd(v));
      }
      function Nc(v) {
        return so(v) && Wo(v) == Zt;
      }
      function cc(v) {
        return so(v) && rs(v) == Rt;
      }
      function Qd(v) {
        return so(v) && Lg(v.length) && !!Hi[Wo(v)];
      }
      function cd(v) {
        return typeof v == "function" ? v : v == null ? Vf : typeof v == "object" ? Jr(v) ? Wl(v[0], v[1]) : Cf(v) : Bg(v);
      }
      function al(v) {
        if (!qp(v))
          return sc(v);
        var b = [];
        for (var N in er(v))
          _i.call(v, N) && N != "constructor" && b.push(N);
        return b;
      }
      function Bm(v) {
        if (!Vs(v))
          return Qp(v);
        var b = qp(v), N = [];
        for (var Z in v)
          Z == "constructor" && (b || !_i.call(v, Z)) || N.push(Z);
        return N;
      }
      function Tf(v, b) {
        return v < b;
      }
      function Zd(v, b) {
        var N = -1, Z = ul(v) ? vt(v.length) : [];
        return Nu(v, function(ie, be, ke) {
          Z[++N] = b(ie, be, ke);
        }), Z;
      }
      function Cf(v) {
        var b = Hm(v);
        return b.length == 1 && b[0][2] ? Gm(b[0][0], b[0][1]) : function(N) {
          return N === v || Es(N, v, b);
        };
      }
      function Wl(v, b) {
        return Ev(v) && op(b) ? Gm(Zl(v), b) : function(N) {
          var Z = m1(N, v);
          return Z === t && Z === b ? tv(N, v) : li(b, Z, D | O);
        };
      }
      function jl(v, b, N, Z, ie) {
        v !== b && Xd(b, function(be, ke) {
          if (ie || (ie = new Vr()), Vs(be))
            fd(v, b, ke, N, jl, Z, ie);
          else {
            var je = Z ? Z(is(v, ke), be, ke + "", v, b, ie) : t;
            je === t && (je = be), Eh(v, ke, je);
          }
        }, qc);
      }
      function fd(v, b, N, Z, ie, be, ke) {
        var je = is(v, N), lt = is(b, N), nn = ke.get(lt);
        if (nn) {
          Eh(v, N, nn);
          return;
        }
        var Kt = be ? be(je, lt, N + "", v, b, ke) : t, on = Kt === t;
        if (on) {
          var Cn = Jr(lt), On = !Cn && Sd(lt), dr = !Cn && !On && am(lt);
          Kt = lt, Cn || On || dr ? Jr(je) ? Kt = je : As(je) ? Kt = Ts(je) : On ? (on = !1, Kt = Pf(lt, !0)) : dr ? (on = !1, Kt = dd(lt, !0)) : Kt = [] : $m(lt) || rm(lt) ? (Kt = je, rm(je) ? Kt = Ny(je) : (!Vs(je) || Sp(je)) && (Kt = sp(lt))) : on = !1;
        }
        on && (ke.set(lt, Kt), ie(Kt, lt, Z, be, ke), ke.delete(lt)), Eh(v, N, Kt);
      }
      function Yl(v, b) {
        var N = v.length;
        if (!!N)
          return b += b < 0 ? N : 0, Iu(b, N) ? v[b] : t;
      }
      function Mh(v, b, N) {
        b.length ? b = qi(b, function(be) {
          return Jr(be) ? function(ke) {
            return ya(ke, be.length === 1 ? be[0] : be);
          } : be;
        }) : b = [Vf];
        var Z = -1;
        b = qi(b, Oi(gr()));
        var ie = Zd(v, function(be, ke, je) {
          var lt = qi(b, function(nn) {
            return nn(be);
          });
          return { criteria: lt, index: ++Z, value: be };
        });
        return $f(ie, function(be, ke) {
          return hd(be, ke, N);
        });
      }
      function fc(v, b) {
        return hr(v, b, function(N, Z) {
          return tv(v, Z);
        });
      }
      function hr(v, b, N) {
        for (var Z = -1, ie = b.length, be = {}; ++Z < ie; ) {
          var ke = b[Z], je = ya(v, ke);
          N(je, ke) && Ht(be, no(ke, v), je);
        }
        return be;
      }
      function Gr(v) {
        return function(b) {
          return ya(b, v);
        };
      }
      function fr(v, b, N, Z) {
        var ie = Z ? Fd : $u, be = -1, ke = b.length, je = v;
        for (v === b && (b = Ts(b)), N && (je = qi(v, Oi(N))); ++be < ke; )
          for (var lt = 0, nn = b[be], Kt = N ? N(nn) : nn; (lt = ie(je, Kt, lt, Z)) > -1; )
            je !== v && rd.call(je, lt, 1), rd.call(v, lt, 1);
        return v;
      }
      function ui(v, b) {
        for (var N = v ? b.length : 0, Z = N - 1; N--; ) {
          var ie = b[N];
          if (N == Z || ie !== be) {
            var be = ie;
            Iu(ie) ? rd.call(v, ie, 1) : Lf(v, ie);
          }
        }
        return v;
      }
      function Fs(v, b) {
        return v + rl(Gd() * (b - v + 1));
      }
      function Xl(v, b, N, Z) {
        for (var ie = -1, be = hs(Ho((b - v) / (N || 1)), 0), ke = vt(be); be--; )
          ke[Z ? be : ++ie] = v, v += N;
        return ke;
      }
      function Fc(v, b) {
        var N = "";
        if (!v || b < 1 || b > ve)
          return N;
        do
          b % 2 && (N += v), b = rl(b / 2), b && (v += v);
        while (b);
        return N;
      }
      function _r(v, b) {
        return vd(Kd(v, b, Vf), v + "");
      }
      function Eo(v) {
        return Bl(nv(v));
      }
      function Ai(v, b) {
        var N = nv(v);
        return sl(N, Hl(b, 0, N.length));
      }
      function Ht(v, b, N, Z) {
        if (!Vs(v))
          return v;
        b = no(b, v);
        for (var ie = -1, be = b.length, ke = be - 1, je = v; je != null && ++ie < be; ) {
          var lt = Zl(b[ie]), nn = N;
          if (lt === "__proto__" || lt === "constructor" || lt === "prototype")
            return v;
          if (ie != ke) {
            var Kt = je[lt];
            nn = Z ? Z(Kt, lt, je) : t, nn === t && (nn = Vs(Kt) ? Kt : Iu(b[ie + 1]) ? [] : {});
          }
          zu(je, lt, nn), je = je[lt];
        }
        return v;
      }
      var pi = Wd ? function(v, b) {
        return Wd.set(v, b), v;
      } : Vf, lr = id ? function(v, b) {
        return id(v, "toString", {
          configurable: !0,
          enumerable: !1,
          value: nx(b),
          writable: !0
        });
      } : Vf;
      function kc(v) {
        return sl(nv(v));
      }
      function Ha(v, b, N) {
        var Z = -1, ie = v.length;
        b < 0 && (b = -b > ie ? 0 : ie + b), N = N > ie ? ie : N, N < 0 && (N += ie), ie = b > N ? 0 : N - b >>> 0, b >>>= 0;
        for (var be = vt(ie); ++Z < ie; )
          be[Z] = v[Z + b];
        return be;
      }
      function Yo(v, b) {
        var N;
        return Nu(v, function(Z, ie, be) {
          return N = b(Z, ie, be), !N;
        }), !!N;
      }
      function Di(v, b, N) {
        var Z = 0, ie = v == null ? Z : v.length;
        if (typeof b == "number" && b === b && ie <= Ve) {
          for (; Z < ie; ) {
            var be = Z + ie >>> 1, ke = v[be];
            ke !== null && !Ni(ke) && (N ? ke <= b : ke < b) ? Z = be + 1 : ie = be;
          }
          return ie;
        }
        return Rf(v, b, Vf, N);
      }
      function Rf(v, b, N, Z) {
        var ie = 0, be = v == null ? 0 : v.length;
        if (be === 0)
          return 0;
        b = N(b);
        for (var ke = b !== b, je = b === null, lt = Ni(b), nn = b === t; ie < be; ) {
          var Kt = rl((ie + be) / 2), on = N(v[Kt]), Cn = on !== t, On = on === null, dr = on === on, mi = Ni(on);
          if (ke)
            var Fr = Z || dr;
          else
            nn ? Fr = dr && (Z || Cn) : je ? Fr = dr && Cn && (Z || !On) : lt ? Fr = dr && Cn && !On && (Z || !mi) : On || mi ? Fr = !1 : Fr = Z ? on <= b : on < b;
          Fr ? ie = Kt + 1 : be = Kt;
        }
        return Js(be, Ee);
      }
      function Af(v, b) {
        for (var N = -1, Z = v.length, ie = 0, be = []; ++N < Z; ) {
          var ke = v[N], je = b ? b(ke) : ke;
          if (!N || !Vu(je, lt)) {
            var lt = je;
            be[ie++] = ke === 0 ? 0 : ke;
          }
        }
        return be;
      }
      function Df(v) {
        return typeof v == "number" ? v : Ni(v) ? he : +v;
      }
      function aa(v) {
        if (typeof v == "string")
          return v;
        if (Jr(v))
          return qi(v, aa) + "";
        if (Ni(v))
          return od ? od.call(v) : "";
        var b = v + "";
        return b == "0" && 1 / v == -He ? "-0" : b;
      }
      function ks(v, b, N) {
        var Z = -1, ie = Ku, be = v.length, ke = !0, je = [], lt = je;
        if (N)
          ke = !1, ie = Kh;
        else if (be >= i) {
          var nn = b ? null : Li(v);
          if (nn)
            return tc(nn);
          ke = !1, ie = Ma, lt = new du();
        } else
          lt = b ? [] : je;
        e:
          for (; ++Z < be; ) {
            var Kt = v[Z], on = b ? b(Kt) : Kt;
            if (Kt = N || Kt !== 0 ? Kt : 0, ke && on === on) {
              for (var Cn = lt.length; Cn--; )
                if (lt[Cn] === on)
                  continue e;
              b && lt.push(on), je.push(Kt);
            } else
              ie(lt, on, N) || (lt !== je && lt.push(on), je.push(Kt));
          }
        return je;
      }
      function Lf(v, b) {
        return b = no(b, v), v = io(v, b), v == null || delete v[Zl(Zo(b))];
      }
      function Jd(v, b, N, Z) {
        return Ht(v, b, N(ya(v, b)), Z);
      }
      function to(v, b, N, Z) {
        for (var ie = v.length, be = Z ? ie : -1; (Z ? be-- : ++be < ie) && b(v[be], be, v); )
          ;
        return N ? Ha(v, Z ? 0 : be, Z ? be + 1 : ie) : Ha(v, Z ? be + 1 : 0, Z ? ie : be);
      }
      function ql(v, b) {
        var N = v;
        return N instanceof Gn && (N = N.value()), Fp(b, function(Z, ie) {
          return ie.func.apply(ie.thisArg, Au([Z], ie.args));
        }, N);
      }
      function ip(v, b, N) {
        var Z = v.length;
        if (Z < 2)
          return Z ? ks(v[0]) : [];
        for (var ie = -1, be = vt(Z); ++ie < Z; )
          for (var ke = v[ie], je = -1; ++je < Z; )
            je != ie && (be[ie] = fa(be[ie] || ke, v[je], b, N));
        return ks(eo(be, 1), b, N);
      }
      function Ic(v, b, N) {
        for (var Z = -1, ie = v.length, be = b.length, ke = {}; ++Z < ie; ) {
          var je = Z < be ? b[Z] : t;
          N(ke, v[Z], je);
        }
        return ke;
      }
      function Ms(v) {
        return As(v) ? v : [];
      }
      function bi(v) {
        return typeof v == "function" ? v : Vf;
      }
      function no(v, b) {
        return Jr(v) ? v : Ev(v, b) ? [v] : yg(Da(v));
      }
      var Ql = _r;
      function Bc(v, b, N) {
        var Z = v.length;
        return N = N === t ? Z : N, !b && N >= Z ? v : Ha(v, b, N);
      }
      var mu = sn || function(v) {
        return Ki.clearTimeout(v);
      };
      function Pf(v, b) {
        if (b)
          return v.slice();
        var N = v.length, Z = $i ? $i(N) : new v.constructor(N);
        return v.copy(Z), Z;
      }
      function vu(v) {
        var b = new v.constructor(v.byteLength);
        return new Mr(b).set(new Mr(v)), b;
      }
      function Fu(v, b) {
        var N = b ? vu(v.buffer) : v.buffer;
        return new v.constructor(N, v.byteOffset, v.byteLength);
      }
      function Mo(v) {
        var b = new v.constructor(v.source, Rn.exec(v));
        return b.lastIndex = v.lastIndex, b;
      }
      function Hc(v) {
        return So ? er(So.call(v)) : {};
      }
      function dd(v, b) {
        var N = b ? vu(v.buffer) : v.buffer;
        return new v.constructor(N, v.byteOffset, v.length);
      }
      function Xo(v, b) {
        if (v !== b) {
          var N = v !== t, Z = v === null, ie = v === v, be = Ni(v), ke = b !== t, je = b === null, lt = b === b, nn = Ni(b);
          if (!je && !nn && !be && v > b || be && ke && lt && !je && !nn || Z && ke && lt || !N && lt || !ie)
            return 1;
          if (!Z && !be && !nn && v < b || nn && N && ie && !Z && !be || je && N && ie || !ke && ie || !lt)
            return -1;
        }
        return 0;
      }
      function hd(v, b, N) {
        for (var Z = -1, ie = v.criteria, be = b.criteria, ke = ie.length, je = N.length; ++Z < ke; ) {
          var lt = Xo(ie[Z], be[Z]);
          if (lt) {
            if (Z >= je)
              return lt;
            var nn = N[Z];
            return lt * (nn == "desc" ? -1 : 1);
          }
        }
        return v.index - b.index;
      }
      function gu(v, b, N, Z) {
        for (var ie = -1, be = v.length, ke = N.length, je = -1, lt = b.length, nn = hs(be - ke, 0), Kt = vt(lt + nn), on = !Z; ++je < lt; )
          Kt[je] = b[je];
        for (; ++ie < ke; )
          (on || ie < be) && (Kt[N[ie]] = v[ie]);
        for (; nn--; )
          Kt[je++] = v[ie++];
        return Kt;
      }
      function pd(v, b, N, Z) {
        for (var ie = -1, be = v.length, ke = -1, je = N.length, lt = -1, nn = b.length, Kt = hs(be - je, 0), on = vt(Kt + nn), Cn = !Z; ++ie < Kt; )
          on[ie] = v[ie];
        for (var On = ie; ++lt < nn; )
          on[On + lt] = b[lt];
        for (; ++ke < je; )
          (Cn || ie < be) && (on[On + N[ke]] = v[ie++]);
        return on;
      }
      function Ts(v, b) {
        var N = -1, Z = v.length;
        for (b || (b = vt(Z)); ++N < Z; )
          b[N] = v[N];
        return b;
      }
      function Is(v, b, N, Z) {
        var ie = !N;
        N || (N = {});
        for (var be = -1, ke = b.length; ++be < ke; ) {
          var je = b[be], lt = Z ? Z(N[je], v[je], je, N, v) : t;
          lt === t && (lt = v[je]), ie ? zs(N, je, lt) : zu(N, je, lt);
        }
        return N;
      }
      function yu(v, b) {
        return Is(v, qo(v), b);
      }
      function mg(v, b) {
        return Is(v, Qo(v), b);
      }
      function ti(v, b) {
        return function(N, Z) {
          var ie = Jr(N) ? _s : yl, be = b ? b() : {};
          return ie(N, v, gr(Z, 2), be);
        };
      }
      function ku(v) {
        return _r(function(b, N) {
          var Z = -1, ie = N.length, be = ie > 1 ? N[ie - 1] : t, ke = ie > 2 ? N[2] : t;
          for (be = v.length > 3 && typeof be == "function" ? (ie--, be) : t, ke && Wi(N[0], N[1], ke) && (be = ie < 3 ? t : be, ie = 1), b = er(b); ++Z < ie; ) {
            var je = N[Z];
            je && v(b, je, Z, be);
          }
          return b;
        });
      }
      function Of(v, b) {
        return function(N, Z) {
          if (N == null)
            return N;
          if (!ul(N))
            return v(N, Z);
          for (var ie = N.length, be = b ? ie : -1, ke = er(N); (b ? be-- : ++be < ie) && Z(ke[be], be, ke) !== !1; )
            ;
          return N;
        };
      }
      function dc(v) {
        return function(b, N, Z) {
          for (var ie = -1, be = er(b), ke = Z(b), je = ke.length; je--; ) {
            var lt = ke[v ? je : ++ie];
            if (N(be[lt], lt, be) === !1)
              break;
          }
          return b;
        };
      }
      function Uf(v, b, N) {
        var Z = b & U, ie = x(v);
        function be() {
          var ke = this && this !== Ki && this instanceof be ? ie : v;
          return ke.apply(Z ? N : this, arguments);
        }
        return be;
      }
      function jp(v) {
        return function(b) {
          b = Da(b);
          var N = Id(b) ? Na(b) : t, Z = N ? N[0] : b.charAt(0), ie = N ? Bc(N, 1).join("") : b.slice(1);
          return Z[v]() + ie;
        };
      }
      function y(v) {
        return function(b) {
          return Fp(Yy(Gy(b).replace(Lm, "")), v, "");
        };
      }
      function x(v) {
        return function() {
          var b = arguments;
          switch (b.length) {
            case 0:
              return new v();
            case 1:
              return new v(b[0]);
            case 2:
              return new v(b[0], b[1]);
            case 3:
              return new v(b[0], b[1], b[2]);
            case 4:
              return new v(b[0], b[1], b[2], b[3]);
            case 5:
              return new v(b[0], b[1], b[2], b[3], b[4]);
            case 6:
              return new v(b[0], b[1], b[2], b[3], b[4], b[5]);
            case 7:
              return new v(b[0], b[1], b[2], b[3], b[4], b[5], b[6]);
          }
          var N = oc(v.prototype), Z = v.apply(N, b);
          return Vs(Z) ? Z : N;
        };
      }
      function L(v, b, N) {
        var Z = x(v);
        function ie() {
          for (var be = arguments.length, ke = vt(be), je = be, lt = ap(ie); je--; )
            ke[je] = arguments[je];
          var nn = be < 3 && ke[0] !== lt && ke[be - 1] !== lt ? [] : Ss(ke, lt);
          if (be -= nn.length, be < N)
            return Sa(
              v,
              b,
              $,
              ie.placeholder,
              t,
              ke,
              nn,
              t,
              t,
              N - be
            );
          var Kt = this && this !== Ki && this instanceof ie ? Z : v;
          return qr(Kt, this, ke);
        }
        return ie;
      }
      function k(v) {
        return function(b, N, Z) {
          var ie = er(b);
          if (!ul(b)) {
            var be = gr(N, 3);
            b = Jl(b), N = function(je) {
              return be(ie[je], je, ie);
            };
          }
          var ke = v(b, N, Z);
          return ke > -1 ? ie[be ? b[ke] : ke] : t;
        };
      }
      function X(v) {
        return Ar(function(b) {
          var N = b.length, Z = N, ie = ka.prototype.thru;
          for (v && b.reverse(); Z--; ) {
            var be = b[Z];
            if (typeof be != "function")
              throw new Bo(l);
            if (ie && !ke && md(be) == "wrapper")
              var ke = new ka([], !0);
          }
          for (Z = ke ? Z : N; ++Z < N; ) {
            be = b[Z];
            var je = md(be), lt = je == "wrapper" ? hc(be) : t;
            lt && Ch(lt[0]) && lt[1] == (te | G | Q | Y) && !lt[4].length && lt[9] == 1 ? ke = ke[md(lt[0])].apply(ke, lt[3]) : ke = be.length == 1 && Ch(be) ? ke[je]() : ke.thru(be);
          }
          return function() {
            var nn = arguments, Kt = nn[0];
            if (ke && nn.length == 1 && Jr(Kt))
              return ke.plant(Kt).value();
            for (var on = 0, Cn = N ? b[on].apply(this, nn) : Kt; ++on < N; )
              Cn = b[on].call(this, Cn);
            return Cn;
          };
        });
      }
      function $(v, b, N, Z, ie, be, ke, je, lt, nn) {
        var Kt = b & te, on = b & U, Cn = b & H, On = b & (G | B), dr = b & re, mi = Cn ? t : x(v);
        function Fr() {
          for (var Fi = arguments.length, Ji = vt(Fi), Gu = Fi; Gu--; )
            Ji[Gu] = arguments[Gu];
          if (On)
            var Gs = ap(Fr), gc = nl(Ji, Gs);
          if (Z && (Ji = gu(Ji, Z, ie, On)), be && (Ji = pd(Ji, be, ke, On)), Fi -= gc, On && Fi < nn) {
            var Ws = Ss(Ji, Gs);
            return Sa(
              v,
              b,
              $,
              Fr.placeholder,
              N,
              Ji,
              Ws,
              je,
              lt,
              nn - Fi
            );
          }
          var $l = on ? N : this, Wu = Cn ? $l[v] : v;
          return Fi = Ji.length, je ? Ji = ji(Ji, je) : dr && Fi > 1 && Ji.reverse(), Kt && lt < Fi && (Ji.length = lt), this && this !== Ki && this instanceof Fr && (Wu = mi || x(Wu)), Wu.apply($l, Ji);
        }
        return Fr;
      }
      function Ae(v, b) {
        return function(N, Z) {
          return Mf(N, v, b(Z), {});
        };
      }
      function $e(v, b) {
        return function(N, Z) {
          var ie;
          if (N === t && Z === t)
            return b;
          if (N !== t && (ie = N), Z !== t) {
            if (ie === t)
              return Z;
            typeof N == "string" || typeof Z == "string" ? (N = aa(N), Z = aa(Z)) : (N = Df(N), Z = Df(Z)), ie = v(N, Z);
          }
          return ie;
        };
      }
      function kt(v) {
        return Ar(function(b) {
          return b = qi(b, Oi(gr())), _r(function(N) {
            var Z = this;
            return v(b, function(ie) {
              return qr(ie, Z, N);
            });
          });
        });
      }
      function hn(v, b) {
        b = b === t ? " " : aa(b);
        var N = b.length;
        if (N < 2)
          return N ? Fc(b, v) : b;
        var Z = Fc(b, Ho(v / nc(b)));
        return Id(b) ? Bc(Na(Z), 0, v).join("") : Z.slice(0, v);
      }
      function wn(v, b, N, Z) {
        var ie = b & U, be = x(v);
        function ke() {
          for (var je = -1, lt = arguments.length, nn = -1, Kt = Z.length, on = vt(Kt + lt), Cn = this && this !== Ki && this instanceof ke ? be : v; ++nn < Kt; )
            on[nn] = Z[nn];
          for (; lt--; )
            on[nn++] = arguments[++je];
          return qr(Cn, ie ? N : this, on);
        }
        return ke;
      }
      function br(v) {
        return function(b, N, Z) {
          return Z && typeof Z != "number" && Wi(b, N, Z) && (N = Z = t), b = wp(b), N === t ? (N = b, b = 0) : N = wp(N), Z = Z === t ? b < N ? 1 : -1 : wp(Z), Xl(b, N, Z, v);
        };
      }
      function ur(v) {
        return function(b, N) {
          return typeof b == "string" && typeof N == "string" || (b = Xc(b), N = Xc(N)), v(b, N);
        };
      }
      function Sa(v, b, N, Z, ie, be, ke, je, lt, nn) {
        var Kt = b & G, on = Kt ? ke : t, Cn = Kt ? t : ke, On = Kt ? be : t, dr = Kt ? t : be;
        b |= Kt ? Q : K, b &= ~(Kt ? K : Q), b & I || (b &= ~(U | H));
        var mi = [
          v,
          b,
          ie,
          On,
          on,
          dr,
          Cn,
          je,
          lt,
          nn
        ], Fr = N.apply(t, mi);
        return Ch(v) && To(Fr, mi), Fr.placeholder = Z, Nf(Fr, v, b);
      }
      function Tn(v) {
        var b = Ta[v];
        return function(N, Z) {
          if (N = Xc(N), Z = Z == null ? 0 : Js(jr(Z), 292), Z && Rc(N)) {
            var ie = (Da(N) + "e").split("e"), be = b(ie[0] + "e" + (+ie[1] + Z));
            return ie = (Da(be) + "e").split("e"), +(ie[0] + "e" + (+ie[1] - Z));
          }
          return b(N);
        };
      }
      var Li = fu && 1 / tc(new fu([, -0]))[1] == He ? function(v) {
        return new fu(v);
      } : Xy;
      function vs(v) {
        return function(b) {
          var N = rs(b);
          return N == dt ? Bd(b) : N == Rt ? yf(b) : zl(b, v(b));
        };
      }
      function pt(v, b, N, Z, ie, be, ke, je) {
        var lt = b & H;
        if (!lt && typeof v != "function")
          throw new Bo(l);
        var nn = Z ? Z.length : 0;
        if (nn || (b &= ~(Q | K), Z = ie = t), ke = ke === t ? ke : hs(jr(ke), 0), je = je === t ? je : jr(je), nn -= ie ? ie.length : 0, b & K) {
          var Kt = Z, on = ie;
          Z = ie = t;
        }
        var Cn = lt ? t : hc(v), On = [
          v,
          b,
          N,
          Z,
          ie,
          Kt,
          on,
          be,
          ke,
          je
        ];
        if (Cn && lp(On, Cn), v = On[0], b = On[1], N = On[2], Z = On[3], ie = On[4], je = On[9] = On[9] === t ? lt ? 0 : v.length : hs(On[9] - nn, 0), !je && b & (G | B) && (b &= ~(G | B)), !b || b == U)
          var dr = Uf(v, b, N);
        else
          b == G || b == B ? dr = L(v, b, je) : (b == Q || b == (U | Q)) && !ie.length ? dr = wn(v, b, N, Z) : dr = $.apply(t, On);
        var mi = Cn ? pi : To;
        return Nf(mi(dr, On), v, b);
      }
      function Ze(v, b, N, Z) {
        return v === t || Vu(v, Nl[N]) && !_i.call(Z, N) ? b : v;
      }
      function Lt(v, b, N, Z, ie, be) {
        return Vs(v) && Vs(b) && (be.set(b, v), jl(v, b, t, Lt, be), be.delete(b)), v;
      }
      function Qt(v) {
        return $m(v) ? t : v;
      }
      function jn(v, b, N, Z, ie, be) {
        var ke = N & D, je = v.length, lt = b.length;
        if (je != lt && !(ke && lt > je))
          return !1;
        var nn = be.get(v), Kt = be.get(b);
        if (nn && Kt)
          return nn == b && Kt == v;
        var on = -1, Cn = !0, On = N & O ? new du() : t;
        for (be.set(v, b), be.set(b, v); ++on < je; ) {
          var dr = v[on], mi = b[on];
          if (Z)
            var Fr = ke ? Z(mi, dr, on, b, v, be) : Z(dr, mi, on, v, b, be);
          if (Fr !== t) {
            if (Fr)
              continue;
            Cn = !1;
            break;
          }
          if (On) {
            if (!$h(b, function(Fi, Ji) {
              if (!Ma(On, Ji) && (dr === Fi || ie(dr, Fi, N, Z, be)))
                return On.push(Ji);
            })) {
              Cn = !1;
              break;
            }
          } else if (!(dr === mi || ie(dr, mi, N, Z, be))) {
            Cn = !1;
            break;
          }
        }
        return be.delete(v), be.delete(b), Cn;
      }
      function Wr(v, b, N, Z, ie, be, ke) {
        switch (N) {
          case Wt:
            if (v.byteLength != b.byteLength || v.byteOffset != b.byteOffset)
              return !1;
            v = v.buffer, b = b.buffer;
          case Ot:
            return !(v.byteLength != b.byteLength || !be(new Mr(v), new Mr(b)));
          case tt:
          case Tt:
          case ht:
            return Vu(+v, +b);
          case ft:
            return v.name == b.name && v.message == b.message;
          case Zt:
          case we:
            return v == b + "";
          case dt:
            var je = Bd;
          case Rt:
            var lt = Z & D;
            if (je || (je = tc), v.size != b.size && !lt)
              return !1;
            var nn = ke.get(v);
            if (nn)
              return nn == b;
            Z |= O, ke.set(v, b);
            var Kt = jn(je(v), je(b), Z, ie, be, ke);
            return ke.delete(v), Kt;
          case oe:
            if (So)
              return So.call(v) == So.call(b);
        }
        return !1;
      }
      function Er(v, b, N, Z, ie, be) {
        var ke = N & D, je = Va(v), lt = je.length, nn = Va(b), Kt = nn.length;
        if (lt != Kt && !ke)
          return !1;
        for (var on = lt; on--; ) {
          var Cn = je[on];
          if (!(ke ? Cn in b : _i.call(b, Cn)))
            return !1;
        }
        var On = be.get(v), dr = be.get(b);
        if (On && dr)
          return On == b && dr == v;
        var mi = !0;
        be.set(v, b), be.set(b, v);
        for (var Fr = ke; ++on < lt; ) {
          Cn = je[on];
          var Fi = v[Cn], Ji = b[Cn];
          if (Z)
            var Gu = ke ? Z(Ji, Fi, Cn, b, v, be) : Z(Fi, Ji, Cn, v, b, be);
          if (!(Gu === t ? Fi === Ji || ie(Fi, Ji, N, Z, be) : Gu)) {
            mi = !1;
            break;
          }
          Fr || (Fr = Cn == "constructor");
        }
        if (mi && !Fr) {
          var Gs = v.constructor, gc = b.constructor;
          Gs != gc && "constructor" in v && "constructor" in b && !(typeof Gs == "function" && Gs instanceof Gs && typeof gc == "function" && gc instanceof gc) && (mi = !1);
        }
        return be.delete(v), be.delete(b), mi;
      }
      function Ar(v) {
        return vd(Kd(v, t, Ym), v + "");
      }
      function Va(v) {
        return rp(v, Jl, qo);
      }
      function Zr(v) {
        return rp(v, qc, Qo);
      }
      var hc = Wd ? function(v) {
        return Wd.get(v);
      } : Xy;
      function md(v) {
        for (var b = v.name + "", N = sd[b], Z = _i.call(sd, b) ? N.length : 0; Z--; ) {
          var ie = N[Z], be = ie.func;
          if (be == null || be == v)
            return ie.name;
        }
        return b;
      }
      function ap(v) {
        var b = _i.call(xe, "placeholder") ? xe : v;
        return b.placeholder;
      }
      function gr() {
        var v = xe.iteratee || ix;
        return v = v === ix ? cd : v, arguments.length ? v(arguments[0], arguments[1]) : v;
      }
      function Yp(v, b) {
        var N = v.__data__;
        return Kn(b) ? N[typeof b == "string" ? "string" : "hash"] : N.map;
      }
      function Hm(v) {
        for (var b = Jl(v), N = b.length; N--; ) {
          var Z = b[N], ie = v[Z];
          b[N] = [Z, ie, op(ie)];
        }
        return b;
      }
      function zf(v, b) {
        var N = ed(v, b);
        return qd(N) ? N : t;
      }
      function vg(v) {
        var b = _i.call(v, xf), N = v[xf];
        try {
          v[xf] = t;
          var Z = !0;
        } catch {
        }
        var ie = vl.call(v);
        return Z && (b ? v[xf] = N : delete v[xf]), ie;
      }
      var qo = ac ? function(v) {
        return v == null ? [] : (v = er(v), el(ac(v), function(b) {
          return _o.call(v, b);
        }));
      } : P1, Qo = ac ? function(v) {
        for (var b = []; v; )
          Au(b, qo(v)), v = Br(v);
        return b;
      } : P1, rs = Wo;
      (Sf && rs(new Sf(new ArrayBuffer(1))) != Wt || Ou && rs(new Ou()) != dt || ad && rs(ad.resolve()) != yt || fu && rs(new fu()) != Rt || wf && rs(new wf()) != ut) && (rs = function(v) {
        var b = Wo(v), N = b == Vt ? v.constructor : t, Z = N ? gd(N) : "";
        if (Z)
          switch (Z) {
            case Dc:
              return Wt;
            case Fl:
              return dt;
            case Lc:
              return yt;
            case Pc:
              return Rt;
            case Us:
              return ut;
          }
        return b;
      });
      function Xp(v, b, N) {
        for (var Z = -1, ie = N.length; ++Z < ie; ) {
          var be = N[Z], ke = be.size;
          switch (be.type) {
            case "drop":
              v += ke;
              break;
            case "dropRight":
              b -= ke;
              break;
            case "take":
              b = Js(b, v + ke);
              break;
            case "takeRight":
              v = hs(v, b - ke);
              break;
          }
        }
        return { start: v, end: b };
      }
      function Th(v) {
        var b = v.match(ot);
        return b ? b[1].split(de) : [];
      }
      function pc(v, b, N) {
        b = no(b, v);
        for (var Z = -1, ie = b.length, be = !1; ++Z < ie; ) {
          var ke = Zl(b[Z]);
          if (!(be = v != null && N(v, ke)))
            break;
          v = v[ke];
        }
        return be || ++Z != ie ? be : (ie = v == null ? 0 : v.length, !!ie && Lg(ie) && Iu(ke, ie) && (Jr(v) || rm(v)));
      }
      function ro(v) {
        var b = v.length, N = new v.constructor(b);
        return b && typeof v[0] == "string" && _i.call(v, "index") && (N.index = v.index, N.input = v.input), N;
      }
      function sp(v) {
        return typeof v.constructor == "function" && !qp(v) ? oc(Br(v)) : {};
      }
      function xl(v, b, N) {
        var Z = v.constructor;
        switch (b) {
          case Ot:
            return vu(v);
          case tt:
          case Tt:
            return new Z(+v);
          case Wt:
            return Fu(v, N);
          case it:
          case an:
          case Be:
          case pe:
          case Fe:
          case at:
          case st:
          case dn:
          case ze:
            return dd(v, N);
          case dt:
            return new Z();
          case ht:
          case we:
            return new Z(v);
          case Zt:
            return Mo(v);
          case Rt:
            return new Z();
          case oe:
            return Hc(v);
        }
      }
      function _y(v, b) {
        var N = b.length;
        if (!N)
          return v;
        var Z = N - 1;
        return b[Z] = (N > 1 ? "& " : "") + b[Z], b = b.join(N > 2 ? ", " : " "), v.replace(Te, `{
/* [wrapped with ` + b + `] */
`);
      }
      function gg(v) {
        return Jr(v) || rm(v) || !!(wh && v && v[wh]);
      }
      function Iu(v, b) {
        var N = typeof v;
        return b = b == null ? ve : b, !!b && (N == "number" || N != "symbol" && wr.test(v)) && v > -1 && v % 1 == 0 && v < b;
      }
      function Wi(v, b, N) {
        if (!Vs(N))
          return !1;
        var Z = typeof b;
        return (Z == "number" ? ul(N) && Iu(b, N.length) : Z == "string" && b in N) ? Vu(N[b], v) : !1;
      }
      function Ev(v, b) {
        if (Jr(v))
          return !1;
        var N = typeof v;
        return N == "number" || N == "symbol" || N == "boolean" || v == null || Ni(v) ? !0 : yi.test(v) || !Mi.test(v) || b != null && v in er(b);
      }
      function Kn(v) {
        var b = typeof v;
        return b == "string" || b == "number" || b == "symbol" || b == "boolean" ? v !== "__proto__" : v === null;
      }
      function Ch(v) {
        var b = md(v), N = xe[b];
        if (typeof N != "function" || !(b in Gn.prototype))
          return !1;
        if (v === N)
          return !0;
        var Z = hc(N);
        return !!Z && v === Z[0];
      }
      function Vm(v) {
        return !!Lu && Lu in v;
      }
      var z0 = $a ? Sp : Qy;
      function qp(v) {
        var b = v && v.constructor, N = typeof b == "function" && b.prototype || Nl;
        return v === N;
      }
      function op(v) {
        return v === v && !Vs(v);
      }
      function Gm(v, b) {
        return function(N) {
          return N == null ? !1 : N[v] === b && (b !== t || v in er(N));
        };
      }
      function Sy(v) {
        var b = Ke(v, function(Z) {
          return N.size === g && N.clear(), Z;
        }), N = b.cache;
        return b;
      }
      function lp(v, b) {
        var N = v[1], Z = b[1], ie = N | Z, be = ie < (U | H | te), ke = Z == te && N == G || Z == te && N == Y && v[7].length <= b[8] || Z == (te | Y) && b[7].length <= b[8] && N == G;
        if (!(be || ke))
          return v;
        Z & U && (v[2] = b[2], ie |= N & U ? 0 : I);
        var je = b[3];
        if (je) {
          var lt = v[3];
          v[3] = lt ? gu(lt, je, b[4]) : je, v[4] = lt ? Ss(v[3], _) : b[4];
        }
        return je = b[5], je && (lt = v[5], v[5] = lt ? pd(lt, je, b[6]) : je, v[6] = lt ? Ss(v[5], _) : b[6]), je = b[7], je && (v[7] = je), Z & te && (v[8] = v[8] == null ? b[8] : Js(v[8], b[8])), v[9] == null && (v[9] = b[9]), v[0] = b[0], v[1] = ie, v;
      }
      function Qp(v) {
        var b = [];
        if (v != null)
          for (var N in er(v))
            b.push(N);
        return b;
      }
      function Zp(v) {
        return vl.call(v);
      }
      function Kd(v, b, N) {
        return b = hs(b === t ? v.length - 1 : b, 0), function() {
          for (var Z = arguments, ie = -1, be = hs(Z.length - b, 0), ke = vt(be); ++ie < be; )
            ke[ie] = Z[b + ie];
          ie = -1;
          for (var je = vt(b + 1); ++ie < b; )
            je[ie] = Z[ie];
          return je[b] = N(ke), qr(v, this, je);
        };
      }
      function io(v, b) {
        return b.length < 2 ? v : ya(v, Ha(b, 0, -1));
      }
      function ji(v, b) {
        for (var N = v.length, Z = Js(b.length, N), ie = Ts(v); Z--; ) {
          var be = b[Z];
          v[Z] = Iu(be, N) ? ie[be] : t;
        }
        return v;
      }
      function is(v, b) {
        if (!(b === "constructor" && typeof v[b] == "function") && b != "__proto__")
          return v[b];
      }
      var To = wy(pi), _l = Hr || function(v, b) {
        return Ki.setTimeout(v, b);
      }, vd = wy(lr);
      function Nf(v, b, N) {
        var Z = b + "";
        return vd(v, _y(Z, by(Th(Z), N)));
      }
      function wy(v) {
        var b = 0, N = 0;
        return function() {
          var Z = km(), ie = Me - (Z - N);
          if (N = Z, ie > 0) {
            if (++b >= ue)
              return arguments[0];
          } else
            b = 0;
          return v.apply(t, arguments);
        };
      }
      function sl(v, b) {
        var N = -1, Z = v.length, ie = Z - 1;
        for (b = b === t ? Z : b; ++N < b; ) {
          var be = Fs(N, ie), ke = v[be];
          v[be] = v[N], v[N] = ke;
        }
        return v.length = b, v;
      }
      var yg = Sy(function(v) {
        var b = [];
        return v.charCodeAt(0) === 46 && b.push(""), v.replace(ii, function(N, Z, ie, be) {
          b.push(ie ? be.replace($t, "$1") : Z || N);
        }), b;
      });
      function Zl(v) {
        if (typeof v == "string" || Ni(v))
          return v;
        var b = v + "";
        return b == "0" && 1 / v == -He ? "-0" : b;
      }
      function gd(v) {
        if (v != null) {
          try {
            return ml.call(v);
          } catch {
          }
          try {
            return v + "";
          } catch {
          }
        }
        return "";
      }
      function by(v, b) {
        return va(Je, function(N) {
          var Z = "_." + N[0];
          b & N[1] && !Ku(v, Z) && v.push(Z);
        }), v.sort();
      }
      function Mv(v) {
        if (v instanceof Gn)
          return v.clone();
        var b = new ka(v.__wrapped__, v.__chain__);
        return b.__actions__ = Ts(v.__actions__), b.__index__ = v.__index__, b.__values__ = v.__values__, b;
      }
      function xg(v, b, N) {
        (N ? Wi(v, b, N) : b === t) ? b = 1 : b = hs(jr(b), 0);
        var Z = v == null ? 0 : v.length;
        if (!Z || b < 1)
          return [];
        for (var ie = 0, be = 0, ke = vt(Ho(Z / b)); ie < Z; )
          ke[be++] = Ha(v, ie, ie += b);
        return ke;
      }
      function Tv(v) {
        for (var b = -1, N = v == null ? 0 : v.length, Z = 0, ie = []; ++b < N; ) {
          var be = v[b];
          be && (ie[Z++] = be);
        }
        return ie;
      }
      function Rh() {
        var v = arguments.length;
        if (!v)
          return [];
        for (var b = vt(v - 1), N = arguments[0], Z = v; Z--; )
          b[Z - 1] = arguments[Z];
        return Au(Jr(N) ? Ts(N) : [N], eo(b, 1));
      }
      var sa = _r(function(v, b) {
        return As(v) ? fa(v, eo(b, 1, As, !0)) : [];
      }), zr = _r(function(v, b) {
        var N = Zo(b);
        return As(N) && (N = t), As(v) ? fa(v, eo(b, 1, As, !0), gr(N, 2)) : [];
      }), ea = _r(function(v, b) {
        var N = Zo(b);
        return As(N) && (N = t), As(v) ? fa(v, eo(b, 1, As, !0), t, N) : [];
      });
      function Ga(v, b, N) {
        var Z = v == null ? 0 : v.length;
        return Z ? (b = N || b === t ? 1 : jr(b), Ha(v, b < 0 ? 0 : b, Z)) : [];
      }
      function gs(v, b, N) {
        var Z = v == null ? 0 : v.length;
        return Z ? (b = N || b === t ? 1 : jr(b), b = Z - b, Ha(v, 0, b < 0 ? 0 : b)) : [];
      }
      function Vc(v, b) {
        return v && v.length ? to(v, gr(b, 3), !0, !0) : [];
      }
      function Wm(v, b) {
        return v && v.length ? to(v, gr(b, 3), !0) : [];
      }
      function ol(v, b, N, Z) {
        var ie = v == null ? 0 : v.length;
        return ie ? (N && typeof N != "number" && Wi(v, b, N) && (N = 0, Z = ie), np(v, b, N, Z)) : [];
      }
      function jm(v, b, N) {
        var Z = v == null ? 0 : v.length;
        if (!Z)
          return -1;
        var ie = N == null ? 0 : jr(N);
        return ie < 0 && (ie = hs(Z + ie, 0)), gh(v, gr(b, 3), ie);
      }
      function yd(v, b, N) {
        var Z = v == null ? 0 : v.length;
        if (!Z)
          return -1;
        var ie = Z - 1;
        return N !== t && (ie = jr(N), ie = N < 0 ? hs(Z + ie, 0) : Js(ie, Z - 1)), gh(v, gr(b, 3), ie, !0);
      }
      function Ym(v) {
        var b = v == null ? 0 : v.length;
        return b ? eo(v, 1) : [];
      }
      function up(v) {
        var b = v == null ? 0 : v.length;
        return b ? eo(v, He) : [];
      }
      function cp(v, b) {
        var N = v == null ? 0 : v.length;
        return N ? (b = b === t ? 1 : jr(b), eo(v, b)) : [];
      }
      function xu(v) {
        for (var b = -1, N = v == null ? 0 : v.length, Z = {}; ++b < N; ) {
          var ie = v[b];
          Z[ie[0]] = ie[1];
        }
        return Z;
      }
      function Xm(v) {
        return v && v.length ? v[0] : t;
      }
      function fp(v, b, N) {
        var Z = v == null ? 0 : v.length;
        if (!Z)
          return -1;
        var ie = N == null ? 0 : jr(N);
        return ie < 0 && (ie = hs(Z + ie, 0)), $u(v, b, ie);
      }
      function xd(v) {
        var b = v == null ? 0 : v.length;
        return b ? Ha(v, 0, -1) : [];
      }
      var _g = _r(function(v) {
        var b = qi(v, Ms);
        return b.length && b[0] === v[0] ? ns(b) : [];
      }), Jp = _r(function(v) {
        var b = Zo(v), N = qi(v, Ms);
        return b === Zo(N) ? b = t : N.pop(), N.length && N[0] === v[0] ? ns(N, gr(b, 2)) : [];
      }), $d = _r(function(v) {
        var b = Zo(v), N = qi(v, Ms);
        return b = typeof b == "function" ? b : t, b && N.pop(), N.length && N[0] === v[0] ? ns(N, t, b) : [];
      });
      function dp(v, b) {
        return v == null ? "" : _f.call(v, b);
      }
      function Zo(v) {
        var b = v == null ? 0 : v.length;
        return b ? v[b - 1] : t;
      }
      function hp(v, b, N) {
        var Z = v == null ? 0 : v.length;
        if (!Z)
          return -1;
        var ie = Z;
        return N !== t && (ie = jr(N), ie = ie < 0 ? hs(Z + ie, 0) : Js(ie, Z - 1)), b === b ? Bp(v, b, ie) : gh(v, Du, ie, !0);
      }
      function qm(v, b) {
        return v && v.length ? Yl(v, jr(b)) : t;
      }
      var Cv = _r(Gc);
      function Gc(v, b) {
        return v && v.length && b && b.length ? fr(v, b) : v;
      }
      function pp(v, b, N) {
        return v && v.length && b && b.length ? fr(v, b, gr(N, 2)) : v;
      }
      function ha(v, b, N) {
        return v && v.length && b && b.length ? fr(v, b, t, N) : v;
      }
      var ao = Ar(function(v, b) {
        var N = v == null ? 0 : v.length, Z = ld(v, b);
        return ui(v, qi(b, function(ie) {
          return Iu(ie, N) ? +ie : ie;
        }).sort(Xo)), Z;
      });
      function Sl(v, b) {
        var N = [];
        if (!(v && v.length))
          return N;
        var Z = -1, ie = [], be = v.length;
        for (b = gr(b, 3); ++Z < be; ) {
          var ke = v[Z];
          b(ke, Z, v) && (N.push(ke), ie.push(Z));
        }
        return ui(v, ie), N;
      }
      function Jo(v) {
        return v == null ? v : bh.call(v);
      }
      function mp(v, b, N) {
        var Z = v == null ? 0 : v.length;
        return Z ? (N && typeof N != "number" && Wi(v, b, N) ? (b = 0, N = Z) : (b = b == null ? 0 : jr(b), N = N === t ? Z : jr(N)), Ha(v, b, N)) : [];
      }
      function Rv(v, b) {
        return Di(v, b);
      }
      function Kp(v, b, N) {
        return Rf(v, b, gr(N, 2));
      }
      function Sg(v, b) {
        var N = v == null ? 0 : v.length;
        if (N) {
          var Z = Di(v, b);
          if (Z < N && Vu(v[Z], b))
            return Z;
        }
        return -1;
      }
      function _u(v, b) {
        return Di(v, b, !0);
      }
      function Av(v, b, N) {
        return Rf(v, b, gr(N, 2), !0);
      }
      function Ah(v, b) {
        var N = v == null ? 0 : v.length;
        if (N) {
          var Z = Di(v, b, !0) - 1;
          if (Vu(v[Z], b))
            return Z;
        }
        return -1;
      }
      function Dh(v) {
        return v && v.length ? Af(v) : [];
      }
      function wg(v, b) {
        return v && v.length ? Af(v, gr(b, 2)) : [];
      }
      function Ff(v) {
        var b = v == null ? 0 : v.length;
        return b ? Ha(v, 1, b) : [];
      }
      function Ey(v, b, N) {
        return v && v.length ? (b = N || b === t ? 1 : jr(b), Ha(v, 0, b < 0 ? 0 : b)) : [];
      }
      function bg(v, b, N) {
        var Z = v == null ? 0 : v.length;
        return Z ? (b = N || b === t ? 1 : jr(b), b = Z - b, Ha(v, b < 0 ? 0 : b, Z)) : [];
      }
      function My(v, b) {
        return v && v.length ? to(v, gr(b, 3), !1, !0) : [];
      }
      function vp(v, b) {
        return v && v.length ? to(v, gr(b, 3)) : [];
      }
      var gp = _r(function(v) {
        return ks(eo(v, 1, As, !0));
      }), Dv = _r(function(v) {
        var b = Zo(v);
        return As(b) && (b = t), ks(eo(v, 1, As, !0), gr(b, 2));
      }), Lv = _r(function(v) {
        var b = Zo(v);
        return b = typeof b == "function" ? b : t, ks(eo(v, 1, As, !0), t, b);
      });
      function Qm(v) {
        return v && v.length ? ks(v) : [];
      }
      function Lh(v, b) {
        return v && v.length ? ks(v, gr(b, 2)) : [];
      }
      function Ty(v, b) {
        return b = typeof b == "function" ? b : t, v && v.length ? ks(v, t, b) : [];
      }
      function Wc(v) {
        if (!(v && v.length))
          return [];
        var b = 0;
        return v = el(v, function(N) {
          if (As(N))
            return b = hs(N.length, b), !0;
        }), gf(b, function(N) {
          return qi(v, pl(N));
        });
      }
      function $p(v, b) {
        if (!(v && v.length))
          return [];
        var N = Wc(v);
        return b == null ? N : qi(N, function(Z) {
          return qr(b, t, Z);
        });
      }
      var Bs = _r(function(v, b) {
        return As(v) ? fa(v, b) : [];
      }), Cy = _r(function(v) {
        return ip(el(v, As));
      }), Eg = _r(function(v) {
        var b = Zo(v);
        return As(b) && (b = t), ip(el(v, As), gr(b, 2));
      }), N0 = _r(function(v) {
        var b = Zo(v);
        return b = typeof b == "function" ? b : t, ip(el(v, As), t, b);
      }), F0 = _r(Wc);
      function Zm(v, b) {
        return Ic(v || [], b || [], zu);
      }
      function jc(v, b) {
        return Ic(v || [], b || [], Ht);
      }
      var Ry = _r(function(v) {
        var b = v.length, N = b > 1 ? v[b - 1] : t;
        return N = typeof N == "function" ? (v.pop(), N) : t, $p(v, N);
      });
      function wl(v) {
        var b = xe(v);
        return b.__chain__ = !0, b;
      }
      function Pv(v, b) {
        return b(v), v;
      }
      function Mg(v, b) {
        return b(v);
      }
      var Bu = Ar(function(v) {
        var b = v.length, N = b ? v[0] : 0, Z = this.__wrapped__, ie = function(be) {
          return ld(be, v);
        };
        return b > 1 || this.__actions__.length || !(Z instanceof Gn) || !Iu(N) ? this.thru(ie) : (Z = Z.slice(N, +N + (b ? 1 : 0)), Z.__actions__.push({
          func: Mg,
          args: [ie],
          thisArg: t
        }), new ka(Z, this.__chain__).thru(function(be) {
          return b && !be.length && be.push(t), be;
        }));
      });
      function Ph() {
        return wl(this);
      }
      function em() {
        return new ka(this.value(), this.__chain__);
      }
      function yp() {
        this.__values__ === t && (this.__values__ = bd(this.value()));
        var v = this.__index__ >= this.__values__.length, b = v ? t : this.__values__[this.__index__++];
        return { done: v, value: b };
      }
      function mc() {
        return this;
      }
      function Aa(v) {
        for (var b, N = this; N instanceof Ks; ) {
          var Z = Mv(N);
          Z.__index__ = 0, Z.__values__ = t, b ? ie.__wrapped__ = Z : b = Z;
          var ie = Z;
          N = N.__wrapped__;
        }
        return ie.__wrapped__ = v, b;
      }
      function xp() {
        var v = this.__wrapped__;
        if (v instanceof Gn) {
          var b = v;
          return this.__actions__.length && (b = new Gn(this)), b = b.reverse(), b.__actions__.push({
            func: Mg,
            args: [Jo],
            thisArg: t
          }), new ka(b, this.__chain__);
        }
        return this.thru(Jo);
      }
      function Cs() {
        return ql(this.__wrapped__, this.__actions__);
      }
      var bl = ti(function(v, b, N) {
        _i.call(v, N) ? ++v[N] : zs(v, N, 1);
      });
      function Ov(v, b, N) {
        var Z = Jr(v) ? Kf : pu;
        return N && Wi(v, b, N) && (b = t), Z(v, gr(b, 3));
      }
      function Tg(v, b) {
        var N = Jr(v) ? el : Ef;
        return N(v, gr(b, 3));
      }
      var Uv = k(jm), zn = k(yd);
      function Hu(v, b) {
        return eo(_p(v, b), 1);
      }
      function zv(v, b) {
        return eo(_p(v, b), He);
      }
      function tm(v, b, N) {
        return N = N === t ? 1 : jr(N), eo(_p(v, b), N);
      }
      function Oh(v, b) {
        var N = Jr(v) ? va : Nu;
        return N(v, gr(b, 3));
      }
      function oa(v, b) {
        var N = Jr(v) ? Zs : Wp;
        return N(v, gr(b, 3));
      }
      var Rs = ti(function(v, b, N) {
        _i.call(v, N) ? v[N].push(b) : zs(v, N, [b]);
      });
      function Co(v, b, N, Z) {
        v = ul(v) ? v : nv(v), N = N && !Z ? jr(N) : 0;
        var ie = v.length;
        return N < 0 && (N = hs(ie + N, 0)), Uy(v) ? N <= ie && v.indexOf(b, N) > -1 : !!ie && $u(v, b, N) > -1;
      }
      var nm = _r(function(v, b, N) {
        var Z = -1, ie = typeof b == "function", be = ul(v) ? vt(v.length) : [];
        return Nu(v, function(ke) {
          be[++Z] = ie ? qr(b, ke, N) : _a(ke, b, N);
        }), be;
      }), Jm = ti(function(v, b, N) {
        zs(v, N, b);
      });
      function _p(v, b) {
        var N = Jr(v) ? qi : Zd;
        return N(v, gr(b, 3));
      }
      function Cg(v, b, N, Z) {
        return v == null ? [] : (Jr(b) || (b = b == null ? [] : [b]), N = Z ? t : N, Jr(N) || (N = N == null ? [] : [N]), Mh(v, b, N));
      }
      var u1 = ti(function(v, b, N) {
        v[N ? 0 : 1].push(b);
      }, function() {
        return [[], []];
      });
      function jt(v, b, N) {
        var Z = Jr(v) ? Fp : vf, ie = arguments.length < 3;
        return Z(v, gr(b, 4), N, ie, Nu);
      }
      function kf(v, b, N) {
        var Z = Jr(v) ? pg : vf, ie = arguments.length < 3;
        return Z(v, gr(b, 4), N, ie, Wp);
      }
      function _d(v, b) {
        var N = Jr(v) ? el : Ef;
        return N(v, _t(gr(b, 3)));
      }
      function c(v) {
        var b = Jr(v) ? Bl : Eo;
        return b(v);
      }
      function h(v, b, N) {
        (N ? Wi(v, b, N) : b === t) ? b = 1 : b = jr(b);
        var Z = Jr(v) ? bo : Ai;
        return Z(v, b);
      }
      function E(v) {
        var b = Jr(v) ? Im : kc;
        return b(v);
      }
      function P(v) {
        if (v == null)
          return 0;
        if (ul(v))
          return Uy(v) ? nc(v) : v.length;
        var b = rs(v);
        return b == dt || b == Rt ? v.size : al(v).length;
      }
      function V(v, b, N) {
        var Z = Jr(v) ? $h : Yo;
        return N && Wi(v, b, N) && (b = t), Z(v, gr(b, 3));
      }
      var q = _r(function(v, b) {
        if (v == null)
          return [];
        var N = b.length;
        return N > 1 && Wi(v, b[0], b[1]) ? b = [] : N > 2 && Wi(b[0], b[1], b[2]) && (b = [b[0]]), Mh(v, eo(b, 1), []);
      }), le = kr || function() {
        return Ki.Date.now();
      };
      function Oe(v, b) {
        if (typeof b != "function")
          throw new Bo(l);
        return v = jr(v), function() {
          if (--v < 1)
            return b.apply(this, arguments);
        };
      }
      function Ge(v, b, N) {
        return b = N ? t : b, b = v && b == null ? v.length : b, pt(v, te, t, t, t, t, b);
      }
      function Dt(v, b) {
        var N;
        if (typeof b != "function")
          throw new Bo(l);
        return v = jr(v), function() {
          return --v > 0 && (N = b.apply(this, arguments)), v <= 1 && (b = t), N;
        };
      }
      var fn = _r(function(v, b, N) {
        var Z = U;
        if (N.length) {
          var ie = Ss(N, ap(fn));
          Z |= Q;
        }
        return pt(v, Z, b, N, ie);
      }), un = _r(function(v, b, N) {
        var Z = U | H;
        if (N.length) {
          var ie = Ss(N, ap(un));
          Z |= Q;
        }
        return pt(b, Z, v, N, ie);
      });
      function rn(v, b, N) {
        b = N ? t : b;
        var Z = pt(v, G, t, t, t, t, t, b);
        return Z.placeholder = rn.placeholder, Z;
      }
      function Hn(v, b, N) {
        b = N ? t : b;
        var Z = pt(v, B, t, t, t, t, t, b);
        return Z.placeholder = Hn.placeholder, Z;
      }
      function Qn(v, b, N) {
        var Z, ie, be, ke, je, lt, nn = 0, Kt = !1, on = !1, Cn = !0;
        if (typeof v != "function")
          throw new Bo(l);
        b = Xc(b) || 0, Vs(N) && (Kt = !!N.leading, on = "maxWait" in N, be = on ? hs(Xc(N.maxWait) || 0, b) : be, Cn = "trailing" in N ? !!N.trailing : Cn);
        function On(Ws) {
          var $l = Z, Wu = ie;
          return Z = ie = t, nn = Ws, ke = v.apply(Wu, $l), ke;
        }
        function dr(Ws) {
          return nn = Ws, je = _l(Fi, b), Kt ? On(Ws) : ke;
        }
        function mi(Ws) {
          var $l = Ws - lt, Wu = Ws - nn, ju = b - $l;
          return on ? Js(ju, be - Wu) : ju;
        }
        function Fr(Ws) {
          var $l = Ws - lt, Wu = Ws - nn;
          return lt === t || $l >= b || $l < 0 || on && Wu >= be;
        }
        function Fi() {
          var Ws = le();
          if (Fr(Ws))
            return Ji(Ws);
          je = _l(Fi, mi(Ws));
        }
        function Ji(Ws) {
          return je = t, Cn && Z ? On(Ws) : (Z = ie = t, ke);
        }
        function Gu() {
          je !== t && mu(je), nn = 0, Z = lt = ie = je = t;
        }
        function Gs() {
          return je === t ? ke : Ji(le());
        }
        function gc() {
          var Ws = le(), $l = Fr(Ws);
          if (Z = arguments, ie = this, lt = Ws, $l) {
            if (je === t)
              return dr(lt);
            if (on)
              return mu(je), je = _l(Fi, b), On(lt);
          }
          return je === t && (je = _l(Fi, b)), ke;
        }
        return gc.cancel = Gu, gc.flush = Gs, gc;
      }
      var ir = _r(function(v, b) {
        return Ns(v, 1, b);
      }), Hs = _r(function(v, b, N) {
        return Ns(v, Xc(b) || 0, N);
      });
      function mt(v) {
        return pt(v, re);
      }
      function Ke(v, b) {
        if (typeof v != "function" || b != null && typeof b != "function")
          throw new Bo(l);
        var N = function() {
          var Z = arguments, ie = b ? b.apply(this, Z) : Z[0], be = N.cache;
          if (be.has(ie))
            return be.get(ie);
          var ke = v.apply(this, Z);
          return N.cache = be.set(ie, ke) || be, ke;
        };
        return N.cache = new (Ke.Cache || Vo)(), N;
      }
      Ke.Cache = Vo;
      function _t(v) {
        if (typeof v != "function")
          throw new Bo(l);
        return function() {
          var b = arguments;
          switch (b.length) {
            case 0:
              return !v.call(this);
            case 1:
              return !v.call(this, b[0]);
            case 2:
              return !v.call(this, b[0], b[1]);
            case 3:
              return !v.call(this, b[0], b[1], b[2]);
          }
          return !v.apply(this, b);
        };
      }
      function _n(v) {
        return Dt(2, v);
      }
      var ar = Ql(function(v, b) {
        b = b.length == 1 && Jr(b[0]) ? qi(b[0], Oi(gr())) : qi(eo(b, 1), Oi(gr()));
        var N = b.length;
        return _r(function(Z) {
          for (var ie = -1, be = Js(Z.length, N); ++ie < be; )
            Z[ie] = b[ie].call(this, Z[ie]);
          return qr(v, this, Z);
        });
      }), Zn = _r(function(v, b) {
        var N = Ss(b, ap(Zn));
        return pt(v, Q, t, b, N);
      }), pr = _r(function(v, b) {
        var N = Ss(b, ap(pr));
        return pt(v, K, t, b, N);
      }), Lr = Ar(function(v, b) {
        return pt(v, Y, t, t, t, b);
      });
      function ll(v, b) {
        if (typeof v != "function")
          throw new Bo(l);
        return b = b === t ? b : jr(b), _r(v, b);
      }
      function Zi(v, b) {
        if (typeof v != "function")
          throw new Bo(l);
        return b = b == null ? 0 : hs(jr(b), 0), _r(function(N) {
          var Z = N[b], ie = Bc(N, 0, b);
          return Z && Au(ie, Z), qr(v, this, ie);
        });
      }
      function If(v, b, N) {
        var Z = !0, ie = !0;
        if (typeof v != "function")
          throw new Bo(l);
        return Vs(N) && (Z = "leading" in N ? !!N.leading : Z, ie = "trailing" in N ? !!N.trailing : ie), Qn(v, b, {
          leading: Z,
          maxWait: b,
          trailing: ie
        });
      }
      function Rg(v) {
        return Ge(v, 1);
      }
      function k0(v, b) {
        return Zn(bi(b), v);
      }
      function Ag() {
        if (!arguments.length)
          return [];
        var v = arguments[0];
        return Jr(v) ? v : [v];
      }
      function I0(v) {
        return Go(v, R);
      }
      function B0(v, b) {
        return b = typeof b == "function" ? b : t, Go(v, R, b);
      }
      function Ay(v) {
        return Go(v, w | R);
      }
      function Dy(v, b) {
        return b = typeof b == "function" ? b : t, Go(v, w | R, b);
      }
      function Nv(v, b) {
        return b == null || il(v, b, Jl(b));
      }
      function Vu(v, b) {
        return v === b || v !== v && b !== b;
      }
      var c1 = ur(jo), H0 = ur(function(v, b) {
        return v >= b;
      }), rm = Qr(function() {
        return arguments;
      }()) ? Qr : function(v) {
        return so(v) && _i.call(v, "callee") && !_o.call(v, "callee");
      }, Jr = vt.isArray, rS = bc ? Oi(bc) : Ra;
      function ul(v) {
        return v != null && Lg(v.length) && !Sp(v);
      }
      function As(v) {
        return so(v) && ul(v);
      }
      function Ly(v) {
        return v === !0 || v === !1 || so(v) && Wo(v) == tt;
      }
      var Sd = Pu || Qy, f1 = xo ? Oi(xo) : Ba;
      function V0(v) {
        return so(v) && v.nodeType === 1 && !$m(v);
      }
      function G0(v) {
        if (v == null)
          return !0;
        if (ul(v) && (Jr(v) || typeof v == "string" || typeof v.splice == "function" || Sd(v) || am(v) || rm(v)))
          return !v.length;
        var b = rs(v);
        if (b == dt || b == Rt)
          return !v.size;
        if (qp(v))
          return !al(v).length;
        for (var N in v)
          if (_i.call(v, N))
            return !1;
        return !0;
      }
      function W0(v, b) {
        return li(v, b);
      }
      function Dg(v, b, N) {
        N = typeof N == "function" ? N : t;
        var Z = N ? N(v, b) : t;
        return Z === t ? li(v, b, t, N) : !!Z;
      }
      function im(v) {
        if (!so(v))
          return !1;
        var b = Wo(v);
        return b == ft || b == gt || typeof v.message == "string" && typeof v.name == "string" && !$m(v);
      }
      function j0(v) {
        return typeof v == "number" && Rc(v);
      }
      function Sp(v) {
        if (!Vs(v))
          return !1;
        var b = Wo(v);
        return b == Ie || b == qe || b == ct || b == Nt;
      }
      function Fv(v) {
        return typeof v == "number" && v == jr(v);
      }
      function Lg(v) {
        return typeof v == "number" && v > -1 && v % 1 == 0 && v <= ve;
      }
      function Vs(v) {
        var b = typeof v;
        return v != null && (b == "object" || b == "function");
      }
      function so(v) {
        return v != null && typeof v == "object";
      }
      var d1 = Ru ? Oi(Ru) : ud;
      function Y0(v, b) {
        return v === b || Es(v, b, Hm(b));
      }
      function Py(v, b, N) {
        return N = typeof N == "function" ? N : t, Es(v, b, Hm(b), N);
      }
      function Km(v) {
        return kv(v) && v != +v;
      }
      function xb(v) {
        if (z0(v))
          throw new $n(s);
        return qd(v);
      }
      function iS(v) {
        return v === null;
      }
      function aS(v) {
        return v == null;
      }
      function kv(v) {
        return typeof v == "number" || so(v) && Wo(v) == ht;
      }
      function $m(v) {
        if (!so(v) || Wo(v) != Vt)
          return !1;
        var b = Br(v);
        if (b === null)
          return !0;
        var N = _i.call(b, "constructor") && b.constructor;
        return typeof N == "function" && N instanceof N && ml.call(N) == Ca;
      }
      var Oy = Ul ? Oi(Ul) : Nc;
      function X0(v) {
        return Fv(v) && v >= -ve && v <= ve;
      }
      var q0 = za ? Oi(za) : cc;
      function Uy(v) {
        return typeof v == "string" || !Jr(v) && so(v) && Wo(v) == we;
      }
      function Ni(v) {
        return typeof v == "symbol" || so(v) && Wo(v) == oe;
      }
      var am = Qs ? Oi(Qs) : Qd;
      function wd(v) {
        return v === t;
      }
      function Yc(v) {
        return so(v) && rs(v) == ut;
      }
      function zy(v) {
        return so(v) && Wo(v) == Ft;
      }
      var Q0 = ur(Tf), Nr = ur(function(v, b) {
        return v <= b;
      });
      function bd(v) {
        if (!v)
          return [];
        if (ul(v))
          return Uy(v) ? Na(v) : Ts(v);
        if (ic && v[ic])
          return xh(v[ic]());
        var b = rs(v), N = b == dt ? Bd : b == Rt ? tc : nv;
        return N(v);
      }
      function wp(v) {
        if (!v)
          return v === 0 ? v : 0;
        if (v = Xc(v), v === He || v === -He) {
          var b = v < 0 ? -1 : 1;
          return b * fe;
        }
        return v === v ? v : 0;
      }
      function jr(v) {
        var b = wp(v), N = b % 1;
        return b === b ? N ? b - N : b : 0;
      }
      function Uh(v) {
        return v ? Hl(jr(v), 0, ye) : 0;
      }
      function Xc(v) {
        if (typeof v == "number")
          return v;
        if (Ni(v))
          return he;
        if (Vs(v)) {
          var b = typeof v.valueOf == "function" ? v.valueOf() : v;
          v = Vs(b) ? b + "" : b;
        }
        if (typeof v != "string")
          return v === 0 ? v : +v;
        v = ec(v);
        var N = yn.test(v);
        return N || rr.test(v) ? Zf(v.slice(2), N ? 2 : 8) : gn.test(v) ? he : +v;
      }
      function Ny(v) {
        return Is(v, qc(v));
      }
      function Z0(v) {
        return v ? Hl(jr(v), -ve, ve) : v === 0 ? v : 0;
      }
      function Da(v) {
        return v == null ? "" : aa(v);
      }
      var Bf = ku(function(v, b) {
        if (qp(b) || ul(b)) {
          Is(b, Jl(b), v);
          return;
        }
        for (var N in b)
          _i.call(b, N) && zu(v, N, b[N]);
      }), Pg = ku(function(v, b) {
        Is(b, qc(b), v);
      }), Iv = ku(function(v, b, N, Z) {
        Is(b, qc(b), v, Z);
      }), sm = ku(function(v, b, N, Z) {
        Is(b, Jl(b), v, Z);
      }), h1 = Ar(ld);
      function om(v, b) {
        var N = oc(v);
        return b == null ? N : ga(N, b);
      }
      var ev = _r(function(v, b) {
        v = er(v);
        var N = -1, Z = b.length, ie = Z > 2 ? b[2] : t;
        for (ie && Wi(b[0], b[1], ie) && (Z = 1); ++N < Z; )
          for (var be = b[N], ke = qc(be), je = -1, lt = ke.length; ++je < lt; ) {
            var nn = ke[je], Kt = v[nn];
            (Kt === t || Vu(Kt, Nl[nn]) && !_i.call(v, nn)) && (v[nn] = be[nn]);
          }
        return v;
      }), Bv = _r(function(v) {
        return v.push(t, Lt), qr(g1, t, v);
      });
      function Hf(v, b) {
        return zm(v, gr(b, 3), Gi);
      }
      function Og(v, b) {
        return zm(v, gr(b, 3), bn);
      }
      function vc(v, b) {
        return v == null ? v : Xd(v, gr(b, 3), qc);
      }
      function J0(v, b) {
        return v == null ? v : da(v, gr(b, 3), qc);
      }
      function Ug(v, b) {
        return v && Gi(v, gr(b, 3));
      }
      function Fy(v, b) {
        return v && bn(v, gr(b, 3));
      }
      function sS(v) {
        return v == null ? [] : Qi(v, Jl(v));
      }
      function p1(v) {
        return v == null ? [] : Qi(v, qc(v));
      }
      function m1(v, b, N) {
        var Z = v == null ? t : ya(v, b);
        return Z === t ? N : Z;
      }
      function ky(v, b) {
        return v != null && pc(v, b, ts);
      }
      function tv(v, b) {
        return v != null && pc(v, b, An);
      }
      var v1 = Ae(function(v, b, N) {
        b != null && typeof b.toString != "function" && (b = vl.call(b)), v[b] = N;
      }, nx(Vf)), _b = Ae(function(v, b, N) {
        b != null && typeof b.toString != "function" && (b = vl.call(b)), _i.call(v, b) ? v[b].push(N) : v[b] = [N];
      }, gr), K0 = _r(_a);
      function Jl(v) {
        return ul(v) ? vn(v) : al(v);
      }
      function qc(v) {
        return ul(v) ? vn(v, !0) : Bm(v);
      }
      function Sb(v, b) {
        var N = {};
        return b = gr(b, 3), Gi(v, function(Z, ie, be) {
          zs(N, b(Z, ie, be), Z);
        }), N;
      }
      function wb(v, b) {
        var N = {};
        return b = gr(b, 3), Gi(v, function(Z, ie, be) {
          zs(N, ie, b(Z, ie, be));
        }), N;
      }
      var bp = ku(function(v, b, N) {
        jl(v, b, N);
      }), g1 = ku(function(v, b, N, Z) {
        jl(v, b, N, Z);
      }), oS = Ar(function(v, b) {
        var N = {};
        if (v == null)
          return N;
        var Z = !1;
        b = qi(b, function(be) {
          return be = no(be, v), Z || (Z = be.length > 1), be;
        }), Is(v, Zr(v), N), Z && (N = Go(N, w | T | R, Qt));
        for (var ie = b.length; ie--; )
          Lf(N, b[ie]);
        return N;
      });
      function Iy(v, b) {
        return Hy(v, _t(gr(b)));
      }
      var By = Ar(function(v, b) {
        return v == null ? {} : fc(v, b);
      });
      function Hy(v, b) {
        if (v == null)
          return {};
        var N = qi(Zr(v), function(Z) {
          return [Z];
        });
        return b = gr(b), hr(v, N, function(Z, ie) {
          return b(Z, ie[0]);
        });
      }
      function zg(v, b, N) {
        b = no(b, v);
        var Z = -1, ie = b.length;
        for (ie || (ie = 1, v = t); ++Z < ie; ) {
          var be = v == null ? t : v[Zl(b[Z])];
          be === t && (Z = ie, be = N), v = Sp(be) ? be.call(v) : be;
        }
        return v;
      }
      function $0(v, b, N) {
        return v == null ? v : Ht(v, b, N);
      }
      function Hv(v, b, N, Z) {
        return Z = typeof Z == "function" ? Z : t, v == null ? v : Ht(v, b, N, Z);
      }
      var El = vs(Jl), y1 = vs(qc);
      function lm(v, b, N) {
        var Z = Jr(v), ie = Z || Sd(v) || am(v);
        if (b = gr(b, 4), N == null) {
          var be = v && v.constructor;
          ie ? N = Z ? new be() : [] : Vs(v) ? N = Sp(be) ? oc(Br(v)) : {} : N = {};
        }
        return (ie ? va : Gi)(v, function(ke, je, lt) {
          return b(N, ke, je, lt);
        }), N;
      }
      function Qc(v, b) {
        return v == null ? !0 : Lf(v, b);
      }
      function x1(v, b, N) {
        return v == null ? v : Jd(v, b, bi(N));
      }
      function Ng(v, b, N, Z) {
        return Z = typeof Z == "function" ? Z : t, v == null ? v : Jd(v, b, bi(N), Z);
      }
      function nv(v) {
        return v == null ? [] : Za(v, Jl(v));
      }
      function _1(v) {
        return v == null ? [] : Za(v, qc(v));
      }
      function ex(v, b, N) {
        return N === t && (N = b, b = t), N !== t && (N = Xc(N), N = N === N ? N : 0), b !== t && (b = Xc(b), b = b === b ? b : 0), Hl(Xc(v), b, N);
      }
      function Vv(v, b, N) {
        return b = wp(b), N === t ? (N = b, b = 0) : N = wp(N), v = Xc(v), xa(v, b, N);
      }
      function S1(v, b, N) {
        if (N && typeof N != "boolean" && Wi(v, b, N) && (b = N = t), N === t && (typeof b == "boolean" ? (N = b, b = t) : typeof v == "boolean" && (N = v, v = t)), v === t && b === t ? (v = 0, b = 1) : (v = wp(v), b === t ? (b = v, v = 0) : b = wp(b)), v > b) {
          var Z = v;
          v = b, b = Z;
        }
        if (N || v % 1 || b % 1) {
          var ie = Gd();
          return Js(v + ie * (b - v + Qf("1e-" + ((ie + "").length - 1))), b);
        }
        return Fs(v, b);
      }
      var Vy = y(function(v, b, N) {
        return b = b.toLowerCase(), v + (N ? Kl(b) : b);
      });
      function Kl(v) {
        return tx(Da(v).toLowerCase());
      }
      function Gy(v) {
        return v = Da(v), v && v.replace(Yi, Nm).replace(hi, "");
      }
      function Wy(v, b, N) {
        v = Da(v), b = aa(b);
        var Z = v.length;
        N = N === t ? Z : Hl(jr(N), 0, Z);
        var ie = N;
        return N -= b.length, N >= 0 && v.slice(N, ie) == b;
      }
      function Fg(v) {
        return v = Da(v), v && Or.test(v) ? v.replace(cn, Fm) : v;
      }
      function kg(v) {
        return v = Da(v), v && xi.test(v) ? v.replace(Bi, "\\$&") : v;
      }
      var lS = y(function(v, b, N) {
        return v + (N ? "-" : "") + b.toLowerCase();
      }), w1 = y(function(v, b, N) {
        return v + (N ? " " : "") + b.toLowerCase();
      }), b1 = jp("toLowerCase");
      function bb(v, b, N) {
        v = Da(v), b = jr(b);
        var Z = b ? nc(v) : 0;
        if (!b || Z >= b)
          return v;
        var ie = (b - Z) / 2;
        return hn(rl(ie), N) + v + hn(Ho(ie), N);
      }
      function uS(v, b, N) {
        v = Da(v), b = jr(b);
        var Z = b ? nc(v) : 0;
        return b && Z < b ? v + hn(b - Z, N) : v;
      }
      function cS(v, b, N) {
        v = Da(v), b = jr(b);
        var Z = b ? nc(v) : 0;
        return b && Z < b ? hn(b - Z, N) + v : v;
      }
      function fS(v, b, N) {
        return N || b == null ? b = 0 : b && (b = +b), ep(Da(v).replace($r, ""), b || 0);
      }
      function E1(v, b, N) {
        return (N ? Wi(v, b, N) : b === t) ? b = 1 : b = jr(b), Fc(Da(v), b);
      }
      function dS() {
        var v = arguments, b = Da(v[0]);
        return v.length < 3 ? b : b.replace(v[1], v[2]);
      }
      var Eb = y(function(v, b, N) {
        return v + (N ? "_" : "") + b.toLowerCase();
      });
      function hS(v, b, N) {
        return N && typeof N != "number" && Wi(v, b, N) && (b = N = t), N = N === t ? ye : N >>> 0, N ? (v = Da(v), v && (typeof b == "string" || b != null && !Oy(b)) && (b = aa(b), !b && Id(v)) ? Bc(Na(v), 0, N) : v.split(b, N)) : [];
      }
      var Mb = y(function(v, b, N) {
        return v + (N ? " " : "") + tx(b);
      });
      function M1(v, b, N) {
        return v = Da(v), N = N == null ? 0 : Hl(jr(N), 0, v.length), b = aa(b), v.slice(N, N + b.length) == b;
      }
      function Tb(v, b, N) {
        var Z = xe.templateSettings;
        N && Wi(v, b, N) && (b = t), v = Da(v), b = Iv({}, b, Z, Ze);
        var ie = Iv({}, b.imports, Z.imports, Ze), be = Jl(ie), ke = Za(ie, be), je, lt, nn = 0, Kt = b.interpolate || La, on = "__p += '", Cn = Ui(
          (b.escape || La).source + "|" + Kt.source + "|" + (Kt === Bn ? mn : La).source + "|" + (b.evaluate || La).source + "|$",
          "g"
        ), On = "//# sourceURL=" + (_i.call(b, "sourceURL") ? (b.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++lu + "]") + `
`;
        v.replace(Cn, function(Fr, Fi, Ji, Gu, Gs, gc) {
          return Ji || (Ji = Gu), on += v.slice(nn, gc).replace(qs, yh), Fi && (je = !0, on += `' +
__e(` + Fi + `) +
'`), Gs && (lt = !0, on += `';
` + Gs + `;
__p += '`), Ji && (on += `' +
((__t = (` + Ji + `)) == null ? '' : __t) +
'`), nn = gc + Fr.length, Fr;
        }), on += `';
`;
        var dr = _i.call(b, "variable") && b.variable;
        if (!dr)
          on = `with (obj) {
` + on + `
}
`;
        else if (Ye.test(dr))
          throw new $n(d);
        on = (lt ? on.replace(wt, "") : on).replace(Pe, "$1").replace(Gt, "$1;"), on = "function(" + (dr || "obj") + `) {
` + (dr ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (je ? ", __e = _.escape" : "") + (lt ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + on + `return __p
}`;
        var mi = vS(function() {
          return or(be, On + "return " + on).apply(t, ke);
        });
        if (mi.source = on, im(mi))
          throw mi;
        return mi;
      }
      function Cb(v) {
        return Da(v).toLowerCase();
      }
      function T1(v) {
        return Da(v).toUpperCase();
      }
      function C1(v, b, N) {
        if (v = Da(v), v && (N || b === t))
          return ec(v);
        if (!v || !(b = aa(b)))
          return v;
        var Z = Na(v), ie = Na(b), be = ca(Z, ie), ke = kd(Z, ie) + 1;
        return Bc(Z, be, ke).join("");
      }
      function Ig(v, b, N) {
        if (v = Da(v), v && (N || b === t))
          return v.slice(0, Hd(v) + 1);
        if (!v || !(b = aa(b)))
          return v;
        var Z = Na(v), ie = kd(Z, Na(b)) + 1;
        return Bc(Z, 0, ie).join("");
      }
      function jy(v, b, N) {
        if (v = Da(v), v && (N || b === t))
          return v.replace($r, "");
        if (!v || !(b = aa(b)))
          return v;
        var Z = Na(v), ie = ca(Z, Na(b));
        return Bc(Z, ie).join("");
      }
      function pS(v, b) {
        var N = se, Z = ce;
        if (Vs(b)) {
          var ie = "separator" in b ? b.separator : ie;
          N = "length" in b ? jr(b.length) : N, Z = "omission" in b ? aa(b.omission) : Z;
        }
        v = Da(v);
        var be = v.length;
        if (Id(v)) {
          var ke = Na(v);
          be = ke.length;
        }
        if (N >= be)
          return v;
        var je = N - nc(Z);
        if (je < 1)
          return Z;
        var lt = ke ? Bc(ke, 0, je).join("") : v.slice(0, je);
        if (ie === t)
          return lt + Z;
        if (ke && (je += lt.length - je), Oy(ie)) {
          if (v.slice(je).search(ie)) {
            var nn, Kt = lt;
            for (ie.global || (ie = Ui(ie.source, Da(Rn.exec(ie)) + "g")), ie.lastIndex = 0; nn = ie.exec(Kt); )
              var on = nn.index;
            lt = lt.slice(0, on === t ? je : on);
          }
        } else if (v.indexOf(aa(ie), je) != je) {
          var Cn = lt.lastIndexOf(ie);
          Cn > -1 && (lt = lt.slice(0, Cn));
        }
        return lt + Z;
      }
      function Rb(v) {
        return v = Da(v), v && ki.test(v) ? v.replace(At, nd) : v;
      }
      var mS = y(function(v, b, N) {
        return v + (N ? " " : "") + b.toUpperCase();
      }), tx = jp("toUpperCase");
      function Yy(v, b, N) {
        return v = Da(v), b = N ? t : b, b === t ? Ip(v) ? _h(v) : Um(v) : v.match(b) || [];
      }
      var vS = _r(function(v, b) {
        try {
          return qr(v, t, b);
        } catch (N) {
          return im(N) ? N : new $n(N);
        }
      }), R1 = Ar(function(v, b) {
        return va(b, function(N) {
          N = Zl(N), zs(v, N, fn(v[N], v));
        }), v;
      });
      function gS(v) {
        var b = v == null ? 0 : v.length, N = gr();
        return v = b ? qi(v, function(Z) {
          if (typeof Z[1] != "function")
            throw new Bo(l);
          return [N(Z[0]), Z[1]];
        }) : [], _r(function(Z) {
          for (var ie = -1; ++ie < b; ) {
            var be = v[ie];
            if (qr(be[0], this, Z))
              return qr(be[1], this, Z);
          }
        });
      }
      function yS(v) {
        return Yd(Go(v, w));
      }
      function nx(v) {
        return function() {
          return v;
        };
      }
      function rx(v, b) {
        return v == null || v !== v ? b : v;
      }
      var Ab = X(), A1 = X(!0);
      function Vf(v) {
        return v;
      }
      function ix(v) {
        return cd(typeof v == "function" ? v : Go(v, w));
      }
      function Db(v) {
        return Cf(Go(v, w));
      }
      function Lb(v, b) {
        return Wl(v, Go(b, w));
      }
      var Pb = _r(function(v, b) {
        return function(N) {
          return _a(N, v, b);
        };
      }), Ob = _r(function(v, b) {
        return function(N) {
          return _a(v, N, b);
        };
      });
      function ax(v, b, N) {
        var Z = Jl(b), ie = Qi(b, Z);
        N == null && !(Vs(b) && (ie.length || !Z.length)) && (N = b, b = v, v = this, ie = Qi(b, Jl(b)));
        var be = !(Vs(N) && "chain" in N) || !!N.chain, ke = Sp(v);
        return va(ie, function(je) {
          var lt = b[je];
          v[je] = lt, ke && (v.prototype[je] = function() {
            var nn = this.__chain__;
            if (be || nn) {
              var Kt = v(this.__wrapped__), on = Kt.__actions__ = Ts(this.__actions__);
              return on.push({ func: lt, args: arguments, thisArg: v }), Kt.__chain__ = nn, Kt;
            }
            return lt.apply(v, Au([this.value()], arguments));
          });
        }), v;
      }
      function Ub() {
        return Ki._ === this && (Ki._ = Sh), this;
      }
      function Xy() {
      }
      function D1(v) {
        return v = jr(v), _r(function(b) {
          return Yl(b, v);
        });
      }
      var L1 = kt(qi), xS = kt(Kf), zb = kt($h);
      function Bg(v) {
        return Ev(v) ? pl(Zl(v)) : Gr(v);
      }
      function qy(v) {
        return function(b) {
          return v == null ? t : ya(v, b);
        };
      }
      var sx = br(), um = br(!0);
      function P1() {
        return [];
      }
      function Qy() {
        return !1;
      }
      function Nb() {
        return {};
      }
      function _S() {
        return "";
      }
      function Fb() {
        return !0;
      }
      function O1(v, b) {
        if (v = jr(v), v < 1 || v > ve)
          return [];
        var N = ye, Z = Js(v, ye);
        b = gr(b), v -= ye;
        for (var ie = gf(Z, b); ++N < v; )
          b(N);
        return ie;
      }
      function SS(v) {
        return Jr(v) ? qi(v, Zl) : Ni(v) ? [v] : Ts(yg(Da(v)));
      }
      function wS(v) {
        var b = ++Mc;
        return Da(v) + b;
      }
      var U1 = $e(function(v, b) {
        return v + b;
      }, 0), kb = Tn("ceil"), Zy = $e(function(v, b) {
        return v / b;
      }, 1), ox = Tn("floor");
      function Ib(v) {
        return v && v.length ? Vl(v, Vf, jo) : t;
      }
      function bS(v, b) {
        return v && v.length ? Vl(v, gr(b, 2), jo) : t;
      }
      function Bb(v) {
        return kp(v, Vf);
      }
      function ES(v, b) {
        return kp(v, gr(b, 2));
      }
      function MS(v) {
        return v && v.length ? Vl(v, Vf, Tf) : t;
      }
      function lx(v, b) {
        return v && v.length ? Vl(v, gr(b, 2), Tf) : t;
      }
      var rv = $e(function(v, b) {
        return v * b;
      }, 1), Hb = Tn("round"), Vn = $e(function(v, b) {
        return v - b;
      }, 0);
      function Hg(v) {
        return v && v.length ? cu(v, Vf) : 0;
      }
      function zh(v, b) {
        return v && v.length ? cu(v, gr(b, 2)) : 0;
      }
      return xe.after = Oe, xe.ary = Ge, xe.assign = Bf, xe.assignIn = Pg, xe.assignInWith = Iv, xe.assignWith = sm, xe.at = h1, xe.before = Dt, xe.bind = fn, xe.bindAll = R1, xe.bindKey = un, xe.castArray = Ag, xe.chain = wl, xe.chunk = xg, xe.compact = Tv, xe.concat = Rh, xe.cond = gS, xe.conforms = yS, xe.constant = nx, xe.countBy = bl, xe.create = om, xe.curry = rn, xe.curryRight = Hn, xe.debounce = Qn, xe.defaults = ev, xe.defaultsDeep = Bv, xe.defer = ir, xe.delay = Hs, xe.difference = sa, xe.differenceBy = zr, xe.differenceWith = ea, xe.drop = Ga, xe.dropRight = gs, xe.dropRightWhile = Vc, xe.dropWhile = Wm, xe.fill = ol, xe.filter = Tg, xe.flatMap = Hu, xe.flatMapDeep = zv, xe.flatMapDepth = tm, xe.flatten = Ym, xe.flattenDeep = up, xe.flattenDepth = cp, xe.flip = mt, xe.flow = Ab, xe.flowRight = A1, xe.fromPairs = xu, xe.functions = sS, xe.functionsIn = p1, xe.groupBy = Rs, xe.initial = xd, xe.intersection = _g, xe.intersectionBy = Jp, xe.intersectionWith = $d, xe.invert = v1, xe.invertBy = _b, xe.invokeMap = nm, xe.iteratee = ix, xe.keyBy = Jm, xe.keys = Jl, xe.keysIn = qc, xe.map = _p, xe.mapKeys = Sb, xe.mapValues = wb, xe.matches = Db, xe.matchesProperty = Lb, xe.memoize = Ke, xe.merge = bp, xe.mergeWith = g1, xe.method = Pb, xe.methodOf = Ob, xe.mixin = ax, xe.negate = _t, xe.nthArg = D1, xe.omit = oS, xe.omitBy = Iy, xe.once = _n, xe.orderBy = Cg, xe.over = L1, xe.overArgs = ar, xe.overEvery = xS, xe.overSome = zb, xe.partial = Zn, xe.partialRight = pr, xe.partition = u1, xe.pick = By, xe.pickBy = Hy, xe.property = Bg, xe.propertyOf = qy, xe.pull = Cv, xe.pullAll = Gc, xe.pullAllBy = pp, xe.pullAllWith = ha, xe.pullAt = ao, xe.range = sx, xe.rangeRight = um, xe.rearg = Lr, xe.reject = _d, xe.remove = Sl, xe.rest = ll, xe.reverse = Jo, xe.sampleSize = h, xe.set = $0, xe.setWith = Hv, xe.shuffle = E, xe.slice = mp, xe.sortBy = q, xe.sortedUniq = Dh, xe.sortedUniqBy = wg, xe.split = hS, xe.spread = Zi, xe.tail = Ff, xe.take = Ey, xe.takeRight = bg, xe.takeRightWhile = My, xe.takeWhile = vp, xe.tap = Pv, xe.throttle = If, xe.thru = Mg, xe.toArray = bd, xe.toPairs = El, xe.toPairsIn = y1, xe.toPath = SS, xe.toPlainObject = Ny, xe.transform = lm, xe.unary = Rg, xe.union = gp, xe.unionBy = Dv, xe.unionWith = Lv, xe.uniq = Qm, xe.uniqBy = Lh, xe.uniqWith = Ty, xe.unset = Qc, xe.unzip = Wc, xe.unzipWith = $p, xe.update = x1, xe.updateWith = Ng, xe.values = nv, xe.valuesIn = _1, xe.without = Bs, xe.words = Yy, xe.wrap = k0, xe.xor = Cy, xe.xorBy = Eg, xe.xorWith = N0, xe.zip = F0, xe.zipObject = Zm, xe.zipObjectDeep = jc, xe.zipWith = Ry, xe.entries = El, xe.entriesIn = y1, xe.extend = Pg, xe.extendWith = Iv, ax(xe, xe), xe.add = U1, xe.attempt = vS, xe.camelCase = Vy, xe.capitalize = Kl, xe.ceil = kb, xe.clamp = ex, xe.clone = I0, xe.cloneDeep = Ay, xe.cloneDeepWith = Dy, xe.cloneWith = B0, xe.conformsTo = Nv, xe.deburr = Gy, xe.defaultTo = rx, xe.divide = Zy, xe.endsWith = Wy, xe.eq = Vu, xe.escape = Fg, xe.escapeRegExp = kg, xe.every = Ov, xe.find = Uv, xe.findIndex = jm, xe.findKey = Hf, xe.findLast = zn, xe.findLastIndex = yd, xe.findLastKey = Og, xe.floor = ox, xe.forEach = Oh, xe.forEachRight = oa, xe.forIn = vc, xe.forInRight = J0, xe.forOwn = Ug, xe.forOwnRight = Fy, xe.get = m1, xe.gt = c1, xe.gte = H0, xe.has = ky, xe.hasIn = tv, xe.head = Xm, xe.identity = Vf, xe.includes = Co, xe.indexOf = fp, xe.inRange = Vv, xe.invoke = K0, xe.isArguments = rm, xe.isArray = Jr, xe.isArrayBuffer = rS, xe.isArrayLike = ul, xe.isArrayLikeObject = As, xe.isBoolean = Ly, xe.isBuffer = Sd, xe.isDate = f1, xe.isElement = V0, xe.isEmpty = G0, xe.isEqual = W0, xe.isEqualWith = Dg, xe.isError = im, xe.isFinite = j0, xe.isFunction = Sp, xe.isInteger = Fv, xe.isLength = Lg, xe.isMap = d1, xe.isMatch = Y0, xe.isMatchWith = Py, xe.isNaN = Km, xe.isNative = xb, xe.isNil = aS, xe.isNull = iS, xe.isNumber = kv, xe.isObject = Vs, xe.isObjectLike = so, xe.isPlainObject = $m, xe.isRegExp = Oy, xe.isSafeInteger = X0, xe.isSet = q0, xe.isString = Uy, xe.isSymbol = Ni, xe.isTypedArray = am, xe.isUndefined = wd, xe.isWeakMap = Yc, xe.isWeakSet = zy, xe.join = dp, xe.kebabCase = lS, xe.last = Zo, xe.lastIndexOf = hp, xe.lowerCase = w1, xe.lowerFirst = b1, xe.lt = Q0, xe.lte = Nr, xe.max = Ib, xe.maxBy = bS, xe.mean = Bb, xe.meanBy = ES, xe.min = MS, xe.minBy = lx, xe.stubArray = P1, xe.stubFalse = Qy, xe.stubObject = Nb, xe.stubString = _S, xe.stubTrue = Fb, xe.multiply = rv, xe.nth = qm, xe.noConflict = Ub, xe.noop = Xy, xe.now = le, xe.pad = bb, xe.padEnd = uS, xe.padStart = cS, xe.parseInt = fS, xe.random = S1, xe.reduce = jt, xe.reduceRight = kf, xe.repeat = E1, xe.replace = dS, xe.result = zg, xe.round = Hb, xe.runInContext = Xe, xe.sample = c, xe.size = P, xe.snakeCase = Eb, xe.some = V, xe.sortedIndex = Rv, xe.sortedIndexBy = Kp, xe.sortedIndexOf = Sg, xe.sortedLastIndex = _u, xe.sortedLastIndexBy = Av, xe.sortedLastIndexOf = Ah, xe.startCase = Mb, xe.startsWith = M1, xe.subtract = Vn, xe.sum = Hg, xe.sumBy = zh, xe.template = Tb, xe.times = O1, xe.toFinite = wp, xe.toInteger = jr, xe.toLength = Uh, xe.toLower = Cb, xe.toNumber = Xc, xe.toSafeInteger = Z0, xe.toString = Da, xe.toUpper = T1, xe.trim = C1, xe.trimEnd = Ig, xe.trimStart = jy, xe.truncate = pS, xe.unescape = Rb, xe.uniqueId = wS, xe.upperCase = mS, xe.upperFirst = tx, xe.each = Oh, xe.eachRight = oa, xe.first = Xm, ax(xe, function() {
        var v = {};
        return Gi(xe, function(b, N) {
          _i.call(xe.prototype, N) || (v[N] = b);
        }), v;
      }(), { chain: !1 }), xe.VERSION = r, va(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(v) {
        xe[v].placeholder = xe;
      }), va(["drop", "take"], function(v, b) {
        Gn.prototype[v] = function(N) {
          N = N === t ? 1 : hs(jr(N), 0);
          var Z = this.__filtered__ && !b ? new Gn(this) : this.clone();
          return Z.__filtered__ ? Z.__takeCount__ = Js(N, Z.__takeCount__) : Z.__views__.push({
            size: Js(N, ye),
            type: v + (Z.__dir__ < 0 ? "Right" : "")
          }), Z;
        }, Gn.prototype[v + "Right"] = function(N) {
          return this.reverse()[v](N).reverse();
        };
      }), va(["filter", "map", "takeWhile"], function(v, b) {
        var N = b + 1, Z = N == me || N == Re;
        Gn.prototype[v] = function(ie) {
          var be = this.clone();
          return be.__iteratees__.push({
            iteratee: gr(ie, 3),
            type: N
          }), be.__filtered__ = be.__filtered__ || Z, be;
        };
      }), va(["head", "last"], function(v, b) {
        var N = "take" + (b ? "Right" : "");
        Gn.prototype[v] = function() {
          return this[N](1).value()[0];
        };
      }), va(["initial", "tail"], function(v, b) {
        var N = "drop" + (b ? "" : "Right");
        Gn.prototype[v] = function() {
          return this.__filtered__ ? new Gn(this) : this[N](1);
        };
      }), Gn.prototype.compact = function() {
        return this.filter(Vf);
      }, Gn.prototype.find = function(v) {
        return this.filter(v).head();
      }, Gn.prototype.findLast = function(v) {
        return this.reverse().find(v);
      }, Gn.prototype.invokeMap = _r(function(v, b) {
        return typeof v == "function" ? new Gn(this) : this.map(function(N) {
          return _a(N, v, b);
        });
      }), Gn.prototype.reject = function(v) {
        return this.filter(_t(gr(v)));
      }, Gn.prototype.slice = function(v, b) {
        v = jr(v);
        var N = this;
        return N.__filtered__ && (v > 0 || b < 0) ? new Gn(N) : (v < 0 ? N = N.takeRight(-v) : v && (N = N.drop(v)), b !== t && (b = jr(b), N = b < 0 ? N.dropRight(-b) : N.take(b - v)), N);
      }, Gn.prototype.takeRightWhile = function(v) {
        return this.reverse().takeWhile(v).reverse();
      }, Gn.prototype.toArray = function() {
        return this.take(ye);
      }, Gi(Gn.prototype, function(v, b) {
        var N = /^(?:filter|find|map|reject)|While$/.test(b), Z = /^(?:head|last)$/.test(b), ie = xe[Z ? "take" + (b == "last" ? "Right" : "") : b], be = Z || /^find/.test(b);
        !ie || (xe.prototype[b] = function() {
          var ke = this.__wrapped__, je = Z ? [1] : arguments, lt = ke instanceof Gn, nn = je[0], Kt = lt || Jr(ke), on = function(Fi) {
            var Ji = ie.apply(xe, Au([Fi], je));
            return Z && Cn ? Ji[0] : Ji;
          };
          Kt && N && typeof nn == "function" && nn.length != 1 && (lt = Kt = !1);
          var Cn = this.__chain__, On = !!this.__actions__.length, dr = be && !Cn, mi = lt && !On;
          if (!be && Kt) {
            ke = mi ? ke : new Gn(this);
            var Fr = v.apply(ke, je);
            return Fr.__actions__.push({ func: Mg, args: [on], thisArg: t }), new ka(Fr, Cn);
          }
          return dr && mi ? v.apply(this, je) : (Fr = this.thru(on), dr ? Z ? Fr.value()[0] : Fr.value() : Fr);
        });
      }), va(["pop", "push", "shift", "sort", "splice", "unshift"], function(v) {
        var b = ds[v], N = /^(?:push|sort|unshift)$/.test(v) ? "tap" : "thru", Z = /^(?:pop|shift)$/.test(v);
        xe.prototype[v] = function() {
          var ie = arguments;
          if (Z && !this.__chain__) {
            var be = this.value();
            return b.apply(Jr(be) ? be : [], ie);
          }
          return this[N](function(ke) {
            return b.apply(Jr(ke) ? ke : [], ie);
          });
        };
      }), Gi(Gn.prototype, function(v, b) {
        var N = xe[b];
        if (N) {
          var Z = N.name + "";
          _i.call(sd, Z) || (sd[Z] = []), sd[Z].push({ name: b, func: N });
        }
      }), sd[$(t, H).name] = [{
        name: "wrapper",
        func: t
      }], Gn.prototype.clone = vr, Gn.prototype.reverse = Vi, Gn.prototype.value = si, xe.prototype.at = Bu, xe.prototype.chain = Ph, xe.prototype.commit = em, xe.prototype.next = yp, xe.prototype.plant = Aa, xe.prototype.reverse = xp, xe.prototype.toJSON = xe.prototype.valueOf = xe.prototype.value = Cs, xe.prototype.first = xe.prototype.head, ic && (xe.prototype[ic] = mc), xe;
    }, Io = Vp();
    Oa ? ((Oa.exports = Io)._ = Io, Cu._ = Io) : Ki._ = Io;
  }).call(D0);
})(Sv, Sv.exports);
const VX = Sv.exports, GX = (a, e) => ({
  clock: new BX(),
  items: {},
  tfs: {},
  hulls: {},
  lines: {},
  texts: {},
  points: {},
  widgets: {},
  onMove: (t, r, i, s) => a((l) => {
    console.log(s), l[r][t].position = { ...s.position }, l[r][t].rotation = s.quaternion, l[r][t].rotation.x = s.quaternion.x, l[r][t].rotation.y = s.quaternion.y, l[r][t].rotation.z = s.quaternion.z, l[r][t].rotation.w = s.quaternion.w, l[r][t].scale = { ...s.scale };
  }),
  onClick: (t, r, i, s) => {
    r || console.log(`id: ${t} clicked!`, i), e().items[t] && !r && s.stopPropagation();
  },
  onPointerOver: (t, r, i) => {
  },
  onPointerOut: (t, r, i) => {
  },
  pause: () => a((t) => {
    t.clock.setTimescale(0);
  }),
  play: (t) => a((r) => {
    r.clock.setTimescale(t || 1);
  }),
  reset: (t) => a((r) => {
    console.log(`setting time to ${t}`), r.clock._elapsed = t ? t * 1e3 : 0;
  }),
  clearItems: () => a((t) => ({ items: {} })),
  clearLines: () => a((t) => ({ lines: {} })),
  clearTfs: () => a((t) => ({ tfs: {} })),
  clearHulls: () => a((t) => ({ hulls: {} })),
  clearTexts: () => a((t) => ({ texts: {} })),
  clearPoints: () => a((t) => ({ points: {} })),
  setItems: (t) => a((r) => ({ items: t })),
  setLines: (t) => a((r) => ({ lines: t })),
  setTfs: (t) => a((r) => ({ tfs: t })),
  setHulls: (t) => a((r) => ({ hulls: t })),
  setTexts: (t) => a((r) => ({ texts: t })),
  setPoints: (t) => a((r) => ({ points: t })),
  removeItem: (t) => a((r) => {
    delete r.items[t];
  }),
  removeLine: (t) => a((r) => {
    delete r.lines[t];
  }),
  removeTf: (t) => a((r) => {
    delete r.tfs[t];
  }),
  removeHull: (t) => a((r) => {
    delete r.hulls[t];
  }),
  removeText: (t) => a((r) => {
    delete r.texts[t];
  }),
  removePoint: (t) => a((r) => {
    delete r.points[t];
  }),
  setItem: (t, r) => a((i) => {
    i.items[t] = r;
  }),
  setLine: (t, r) => a((i) => {
    i.lines[t] = r;
  }),
  setTf: (t, r) => a((i) => {
    i.tfs[t] = r;
  }),
  setHull: (t, r) => a((i) => {
    i.hulls[t] = r;
  }),
  setText: (t, r) => a((i) => {
    i.texts[t] = r;
  }),
  setPoint: (t, r) => a((i) => {
    i.points[t] = r;
  }),
  setProperty: (t, r) => a((i) => {
    VX.set(i, t, r);
  })
}), WX = IX(EX(GX)), jX = wX(WX), w4 = OC(), os = (a, e) => {
  const t = TM(w4);
  return x4(t, a, e);
}, YX = ({
  store: a,
  children: e,
  debug: t = !1
}) => (t && console.log("SceneProvider regenerated"), /* @__PURE__ */ ln(w4.Provider, {
  value: a || jX,
  children: e
})), XX = ph.forwardRef((a, e) => /* @__PURE__ */ ln("ambientLight", {
  ref: e,
  ...a
}));
ph.forwardRef((a, e) => /* @__PURE__ */ ln("pointLight", {
  ref: e,
  ...a
}));
const qX = ph.forwardRef((a, e) => /* @__PURE__ */ ln("directionalLight", {
  ref: e,
  ...a
})), my = (a, e, t, r) => {
  var i = new Un();
  return i.setRGB(a / 255, e / 255, t / 255), r <= 0.99 ? new HM({
    color: i.getHex(),
    opacity: r + 0.1,
    transparent: !0,
    depthWrite: !0,
    blendSrc: zC,
    blendDst: NC,
    blendEquation: V3,
    blending: P0
  }) : new HM({
    color: i.getHex(),
    opacity: r,
    blending: P0
  });
}, _C = Sv.exports.memoize((a) => {
  var e = new Un(a), t = `
		varying vec3	vVertexWorldPosition;
		varying vec3	vVertexNormal;

		// varying vec4	vFragColor;

		void main(){
			vVertexNormal	= normalize(normalMatrix * normal);

			vVertexWorldPosition	= (modelMatrix * vec4(position, 1.0)).xyz;

			// set gl_Position
			gl_Position	= projectionMatrix * modelViewMatrix * vec4(position, 1.0);
		}`, r = `
		uniform vec3	glowColor;
		uniform float	coeficient;
		uniform float	power;

		varying vec3	vVertexNormal;
		varying vec3	vVertexWorldPosition;

		// varying vec4	vFragColor;

		void main(){
			vec3 worldCameraToVertex= vVertexWorldPosition - cameraPosition;
			vec3 viewCameraToVertex	= (viewMatrix * vec4(worldCameraToVertex, 0.0)).xyz;
			viewCameraToVertex	= normalize(viewCameraToVertex);
			float intensity		= pow(coeficient + dot(vVertexNormal, viewCameraToVertex), power);
			gl_FragColor		= vec4(glowColor, intensity);
		}`, i = new Mu({
    uniforms: {
      coeficient: {
        type: "f",
        value: 1.2
      },
      power: {
        type: "f",
        value: 4
      },
      glowColor: {
        type: "c",
        value: e
      }
    },
    vertexShader: t,
    fragmentShader: r,
    blending: wC,
    transparent: !0,
    depthWrite: !1,
    depthTest: !1
  });
  return i;
});
function QX(a) {
  var e = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
  a = a.replace(e, function(r, i, s, l) {
    return i + i + s + s + l + l;
  });
  var t = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(a);
  return t ? {
    r: parseInt(t[1], 16),
    g: parseInt(t[2], 16),
    b: parseInt(t[3], 16)
  } : null;
}
const E_ = new _L(), Up = new ge(), qx = new ge(), Rl = new Po(), SN = {
  X: new ge(1, 0, 0),
  Y: new ge(0, 1, 0),
  Z: new ge(0, 0, 1)
}, FD = { type: "change" }, wN = { type: "mouseDown" }, bN = { type: "mouseUp", mode: null }, EN = { type: "objectChange" };
class ZX extends Xa {
  constructor(e, t) {
    super(), t === void 0 && (console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'), t = document), this.isTransformControls = !0, this.visible = !1, this.domElement = t, this.domElement.style.touchAction = "none";
    const r = new nq();
    this._gizmo = r, this.add(r);
    const i = new rq();
    this._plane = i, this.add(i);
    const s = this;
    function l(I, G) {
      let B = G;
      Object.defineProperty(s, I, {
        get: function() {
          return B !== void 0 ? B : G;
        },
        set: function(Q) {
          B !== Q && (B = Q, i[I] = Q, r[I] = Q, s.dispatchEvent({ type: I + "-changed", value: Q }), s.dispatchEvent(FD));
        }
      }), s[I] = G, i[I] = G, r[I] = G;
    }
    l("camera", e), l("object", void 0), l("enabled", !0), l("axis", null), l("mode", "translate"), l("translationSnap", null), l("rotationSnap", null), l("scaleSnap", null), l("space", "world"), l("size", 1), l("dragging", !1), l("showX", !0), l("showY", !0), l("showZ", !0);
    const d = new ge(), p = new ge(), g = new Po(), _ = new Po(), w = new ge(), T = new Po(), R = new ge(), D = new ge(), O = new ge(), U = 0, H = new ge();
    l("worldPosition", d), l("worldPositionStart", p), l("worldQuaternion", g), l("worldQuaternionStart", _), l("cameraPosition", w), l("cameraQuaternion", T), l("pointStart", R), l("pointEnd", D), l("rotationAxis", O), l("rotationAngle", U), l("eye", H), this._offset = new ge(), this._startNorm = new ge(), this._endNorm = new ge(), this._cameraScale = new ge(), this._parentPosition = new ge(), this._parentQuaternion = new Po(), this._parentQuaternionInv = new Po(), this._parentScale = new ge(), this._worldScaleStart = new ge(), this._worldQuaternionInv = new Po(), this._worldScale = new ge(), this._positionStart = new ge(), this._quaternionStart = new Po(), this._scaleStart = new ge(), this._getPointer = JX.bind(this), this._onPointerDown = $X.bind(this), this._onPointerHover = KX.bind(this), this._onPointerMove = eq.bind(this), this._onPointerUp = tq.bind(this), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointermove", this._onPointerHover), this.domElement.addEventListener("pointerup", this._onPointerUp);
  }
  updateMatrixWorld() {
    this.object !== void 0 && (this.object.updateMatrixWorld(), this.object.parent === null ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : this.object.parent.matrixWorld.decompose(this._parentPosition, this._parentQuaternion, this._parentScale), this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this._worldScale), this._parentQuaternionInv.copy(this._parentQuaternion).invert(), this._worldQuaternionInv.copy(this.worldQuaternion).invert()), this.camera.updateMatrixWorld(), this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this._cameraScale), this.camera.isOrthographicCamera ? this.camera.getWorldDirection(this.eye) : this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(), super.updateMatrixWorld(this);
  }
  pointerHover(e) {
    if (this.object === void 0 || this.dragging === !0)
      return;
    E_.setFromCamera(e, this.camera);
    const t = kD(this._gizmo.picker[this.mode], E_);
    t ? this.axis = t.object.name : this.axis = null;
  }
  pointerDown(e) {
    if (!(this.object === void 0 || this.dragging === !0 || e.button !== 0) && this.axis !== null) {
      E_.setFromCamera(e, this.camera);
      const t = kD(this._plane, E_, !0);
      t && (this.object.updateMatrixWorld(), this.object.parent.updateMatrixWorld(), this._positionStart.copy(this.object.position), this._quaternionStart.copy(this.object.quaternion), this._scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart), this.pointStart.copy(t.point).sub(this.worldPositionStart)), this.dragging = !0, wN.mode = this.mode, this.dispatchEvent(wN);
    }
  }
  pointerMove(e) {
    const t = this.axis, r = this.mode, i = this.object;
    let s = this.space;
    if (r === "scale" ? s = "local" : (t === "E" || t === "XYZE" || t === "XYZ") && (s = "world"), i === void 0 || t === null || this.dragging === !1 || e.button !== -1)
      return;
    E_.setFromCamera(e, this.camera);
    const l = kD(this._plane, E_, !0);
    if (!!l) {
      if (this.pointEnd.copy(l.point).sub(this.worldPositionStart), r === "translate")
        this._offset.copy(this.pointEnd).sub(this.pointStart), s === "local" && t !== "XYZ" && this._offset.applyQuaternion(this._worldQuaternionInv), t.indexOf("X") === -1 && (this._offset.x = 0), t.indexOf("Y") === -1 && (this._offset.y = 0), t.indexOf("Z") === -1 && (this._offset.z = 0), s === "local" && t !== "XYZ" ? this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale) : this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale), i.position.copy(this._offset).add(this._positionStart), this.translationSnap && (s === "local" && (i.position.applyQuaternion(Rl.copy(this._quaternionStart).invert()), t.search("X") !== -1 && (i.position.x = Math.round(i.position.x / this.translationSnap) * this.translationSnap), t.search("Y") !== -1 && (i.position.y = Math.round(i.position.y / this.translationSnap) * this.translationSnap), t.search("Z") !== -1 && (i.position.z = Math.round(i.position.z / this.translationSnap) * this.translationSnap), i.position.applyQuaternion(this._quaternionStart)), s === "world" && (i.parent && i.position.add(Up.setFromMatrixPosition(i.parent.matrixWorld)), t.search("X") !== -1 && (i.position.x = Math.round(i.position.x / this.translationSnap) * this.translationSnap), t.search("Y") !== -1 && (i.position.y = Math.round(i.position.y / this.translationSnap) * this.translationSnap), t.search("Z") !== -1 && (i.position.z = Math.round(i.position.z / this.translationSnap) * this.translationSnap), i.parent && i.position.sub(Up.setFromMatrixPosition(i.parent.matrixWorld))));
      else if (r === "scale") {
        if (t.search("XYZ") !== -1) {
          let d = this.pointEnd.length() / this.pointStart.length();
          this.pointEnd.dot(this.pointStart) < 0 && (d *= -1), qx.set(d, d, d);
        } else
          Up.copy(this.pointStart), qx.copy(this.pointEnd), Up.applyQuaternion(this._worldQuaternionInv), qx.applyQuaternion(this._worldQuaternionInv), qx.divide(Up), t.search("X") === -1 && (qx.x = 1), t.search("Y") === -1 && (qx.y = 1), t.search("Z") === -1 && (qx.z = 1);
        i.scale.copy(this._scaleStart).multiply(qx), this.scaleSnap && (t.search("X") !== -1 && (i.scale.x = Math.round(i.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), t.search("Y") !== -1 && (i.scale.y = Math.round(i.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), t.search("Z") !== -1 && (i.scale.z = Math.round(i.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
      } else if (r === "rotate") {
        this._offset.copy(this.pointEnd).sub(this.pointStart);
        const d = 20 / this.worldPosition.distanceTo(Up.setFromMatrixPosition(this.camera.matrixWorld));
        t === "E" ? (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this._startNorm.copy(this.pointStart).normalize(), this._endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1) : t === "XYZE" ? (this.rotationAxis.copy(this._offset).cross(this.eye).normalize(), this.rotationAngle = this._offset.dot(Up.copy(this.rotationAxis).cross(this.eye)) * d) : (t === "X" || t === "Y" || t === "Z") && (this.rotationAxis.copy(SN[t]), Up.copy(SN[t]), s === "local" && Up.applyQuaternion(this.worldQuaternion), this.rotationAngle = this._offset.dot(Up.cross(this.eye).normalize()) * d), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), s === "local" && t !== "E" && t !== "XYZE" ? (i.quaternion.copy(this._quaternionStart), i.quaternion.multiply(Rl.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this._parentQuaternionInv), i.quaternion.copy(Rl.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), i.quaternion.multiply(this._quaternionStart).normalize());
      }
      this.dispatchEvent(FD), this.dispatchEvent(EN);
    }
  }
  pointerUp(e) {
    e.button === 0 && (this.dragging && this.axis !== null && (bN.mode = this.mode, this.dispatchEvent(bN)), this.dragging = !1, this.axis = null);
  }
  dispose() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerHover), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.traverse(function(e) {
      e.geometry && e.geometry.dispose(), e.material && e.material.dispose();
    });
  }
  attach(e) {
    return this.object = e, this.visible = !0, this;
  }
  detach() {
    return this.object = void 0, this.visible = !1, this.axis = null, this;
  }
  reset() {
    !this.enabled || this.dragging && (this.object.position.copy(this._positionStart), this.object.quaternion.copy(this._quaternionStart), this.object.scale.copy(this._scaleStart), this.dispatchEvent(FD), this.dispatchEvent(EN), this.pointStart.copy(this.pointEnd));
  }
  getRaycaster() {
    return E_;
  }
  getMode() {
    return this.mode;
  }
  setMode(e) {
    this.mode = e;
  }
  setTranslationSnap(e) {
    this.translationSnap = e;
  }
  setRotationSnap(e) {
    this.rotationSnap = e;
  }
  setScaleSnap(e) {
    this.scaleSnap = e;
  }
  setSize(e) {
    this.size = e;
  }
  setSpace(e) {
    this.space = e;
  }
  update() {
    console.warn("THREE.TransformControls: update function has no more functionality and therefore has been deprecated.");
  }
}
function JX(a) {
  if (this.domElement.ownerDocument.pointerLockElement)
    return {
      x: 0,
      y: 0,
      button: a.button
    };
  {
    const e = this.domElement.getBoundingClientRect();
    return {
      x: (a.clientX - e.left) / e.width * 2 - 1,
      y: -(a.clientY - e.top) / e.height * 2 + 1,
      button: a.button
    };
  }
}
function KX(a) {
  if (!!this.enabled)
    switch (a.pointerType) {
      case "mouse":
      case "pen":
        this.pointerHover(this._getPointer(a));
        break;
    }
}
function $X(a) {
  !this.enabled || (document.pointerLockElement || this.domElement.setPointerCapture(a.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.pointerHover(this._getPointer(a)), this.pointerDown(this._getPointer(a)));
}
function eq(a) {
  !this.enabled || this.pointerMove(this._getPointer(a));
}
function tq(a) {
  !this.enabled || (this.domElement.releasePointerCapture(a.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.pointerUp(this._getPointer(a)));
}
function kD(a, e, t) {
  const r = e.intersectObject(a, !0);
  for (let i = 0; i < r.length; i++)
    if (r[i].object.visible || t)
      return r[i];
  return !1;
}
const aC = new $_(), Lo = new ge(0, 1, 0), MN = new ge(0, 0, 0), TN = new Kr(), sC = new Po(), SC = new Po(), ly = new ge(), CN = new Kr(), yM = new ge(1, 0, 0), D_ = new ge(0, 1, 0), xM = new ge(0, 0, 1), oC = new ge(), dM = new ge(), hM = new ge();
class nq extends Xa {
  constructor() {
    super(), this.isTransformControlsGizmo = !0, this.type = "TransformControlsGizmo";
    const e = new fg({
      depthTest: !1,
      depthWrite: !1,
      fog: !1,
      toneMapped: !1,
      transparent: !0
    }), t = new mh({
      depthTest: !1,
      depthWrite: !1,
      fog: !1,
      toneMapped: !1,
      transparent: !0
    }), r = e.clone();
    r.opacity = 0.15;
    const i = t.clone();
    i.opacity = 0.5;
    const s = e.clone();
    s.color.setHex(16711680);
    const l = e.clone();
    l.color.setHex(65280);
    const d = e.clone();
    d.color.setHex(255);
    const p = e.clone();
    p.color.setHex(16711680), p.opacity = 0.5;
    const g = e.clone();
    g.color.setHex(65280), g.opacity = 0.5;
    const _ = e.clone();
    _.color.setHex(255), _.opacity = 0.5;
    const w = e.clone();
    w.opacity = 0.25;
    const T = e.clone();
    T.color.setHex(16776960), T.opacity = 0.25, e.clone().color.setHex(16776960);
    const D = e.clone();
    D.color.setHex(7895160);
    const O = new Ko(0, 0.04, 0.1, 12);
    O.translate(0, 0.05, 0);
    const U = new fl(0.08, 0.08, 0.08);
    U.translate(0, 0.04, 0);
    const H = new oi();
    H.setAttribute("position", new sr([0, 0, 0, 1, 0, 0], 3));
    const I = new Ko(75e-4, 75e-4, 0.5, 3);
    I.translate(0, 0.25, 0);
    function G(De, Re) {
      const He = new ag(De, 75e-4, 3, 64, Re * Math.PI * 2);
      return He.rotateY(Math.PI / 2), He.rotateX(Math.PI / 2), He;
    }
    function B() {
      const De = new oi();
      return De.setAttribute("position", new sr([0, 0, 0, 1, 1, 1], 3)), De;
    }
    const Q = {
      X: [
        [new Fn(O, s), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Fn(O, s), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
        [new Fn(I, s), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      Y: [
        [new Fn(O, l), [0, 0.5, 0]],
        [new Fn(O, l), [0, -0.5, 0], [Math.PI, 0, 0]],
        [new Fn(I, l)]
      ],
      Z: [
        [new Fn(O, d), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Fn(O, d), [0, 0, -0.5], [-Math.PI / 2, 0, 0]],
        [new Fn(I, d), null, [Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Fn(new sg(0.1, 0), w.clone()), [0, 0, 0]]
      ],
      XY: [
        [new Fn(new fl(0.15, 0.15, 0.01), _.clone()), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Fn(new fl(0.15, 0.15, 0.01), p.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Fn(new fl(0.15, 0.15, 0.01), g.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, K = {
      X: [
        [new Fn(new Ko(0.2, 0, 0.6, 4), r), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Fn(new Ko(0.2, 0, 0.6, 4), r), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Fn(new Ko(0.2, 0, 0.6, 4), r), [0, 0.3, 0]],
        [new Fn(new Ko(0.2, 0, 0.6, 4), r), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Fn(new Ko(0.2, 0, 0.6, 4), r), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Fn(new Ko(0.2, 0, 0.6, 4), r), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Fn(new sg(0.2, 0), r)]
      ],
      XY: [
        [new Fn(new fl(0.2, 0.2, 0.01), r), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Fn(new fl(0.2, 0.2, 0.01), r), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Fn(new fl(0.2, 0.2, 0.01), r), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, te = {
      START: [
        [new Fn(new sg(0.01, 2), i), null, null, null, "helper"]
      ],
      END: [
        [new Fn(new sg(0.01, 2), i), null, null, null, "helper"]
      ],
      DELTA: [
        [new fh(B(), i), null, null, null, "helper"]
      ],
      X: [
        [new fh(H, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new fh(H, i.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new fh(H, i.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    }, Y = {
      XYZE: [
        [new Fn(G(0.5, 1), D), null, [0, Math.PI / 2, 0]]
      ],
      X: [
        [new Fn(G(0.5, 0.5), s)]
      ],
      Y: [
        [new Fn(G(0.5, 0.5), l), null, [0, 0, -Math.PI / 2]]
      ],
      Z: [
        [new Fn(G(0.5, 0.5), d), null, [0, Math.PI / 2, 0]]
      ],
      E: [
        [new Fn(G(0.75, 1), T), null, [0, Math.PI / 2, 0]]
      ]
    }, re = {
      AXIS: [
        [new fh(H, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ]
    }, se = {
      XYZE: [
        [new Fn(new ug(0.25, 10, 8), r)]
      ],
      X: [
        [new Fn(new ag(0.5, 0.1, 4, 24), r), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]
      ],
      Y: [
        [new Fn(new ag(0.5, 0.1, 4, 24), r), [0, 0, 0], [Math.PI / 2, 0, 0]]
      ],
      Z: [
        [new Fn(new ag(0.5, 0.1, 4, 24), r), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      E: [
        [new Fn(new ag(0.75, 0.1, 2, 24), r)]
      ]
    }, ce = {
      X: [
        [new Fn(U, s), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Fn(I, s), [0, 0, 0], [0, 0, -Math.PI / 2]],
        [new Fn(U, s), [-0.5, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Fn(U, l), [0, 0.5, 0]],
        [new Fn(I, l)],
        [new Fn(U, l), [0, -0.5, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Fn(U, d), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Fn(I, d), [0, 0, 0], [Math.PI / 2, 0, 0]],
        [new Fn(U, d), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Fn(new fl(0.15, 0.15, 0.01), _), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Fn(new fl(0.15, 0.15, 0.01), p), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Fn(new fl(0.15, 0.15, 0.01), g), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Fn(new fl(0.1, 0.1, 0.1), w.clone())]
      ]
    }, ue = {
      X: [
        [new Fn(new Ko(0.2, 0, 0.6, 4), r), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Fn(new Ko(0.2, 0, 0.6, 4), r), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Fn(new Ko(0.2, 0, 0.6, 4), r), [0, 0.3, 0]],
        [new Fn(new Ko(0.2, 0, 0.6, 4), r), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Fn(new Ko(0.2, 0, 0.6, 4), r), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Fn(new Ko(0.2, 0, 0.6, 4), r), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Fn(new fl(0.2, 0.2, 0.01), r), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Fn(new fl(0.2, 0.2, 0.01), r), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Fn(new fl(0.2, 0.2, 0.01), r), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Fn(new fl(0.2, 0.2, 0.2), r), [0, 0, 0]]
      ]
    }, Me = {
      X: [
        [new fh(H, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new fh(H, i.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new fh(H, i.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    function me(De) {
      const Re = new Xa();
      for (const He in De)
        for (let ve = De[He].length; ve--; ) {
          const fe = De[He][ve][0].clone(), he = De[He][ve][1], ye = De[He][ve][2], Ee = De[He][ve][3], Ve = De[He][ve][4];
          fe.name = He, fe.tag = Ve, he && fe.position.set(he[0], he[1], he[2]), ye && fe.rotation.set(ye[0], ye[1], ye[2]), Ee && fe.scale.set(Ee[0], Ee[1], Ee[2]), fe.updateMatrix();
          const Je = fe.geometry.clone();
          Je.applyMatrix4(fe.matrix), fe.geometry = Je, fe.renderOrder = 1 / 0, fe.position.set(0, 0, 0), fe.rotation.set(0, 0, 0), fe.scale.set(1, 1, 1), Re.add(fe);
        }
      return Re;
    }
    this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = me(Q)), this.add(this.gizmo.rotate = me(Y)), this.add(this.gizmo.scale = me(ce)), this.add(this.picker.translate = me(K)), this.add(this.picker.rotate = me(se)), this.add(this.picker.scale = me(ue)), this.add(this.helper.translate = me(te)), this.add(this.helper.rotate = me(re)), this.add(this.helper.scale = me(Me)), this.picker.translate.visible = !1, this.picker.rotate.visible = !1, this.picker.scale.visible = !1;
  }
  updateMatrixWorld(e) {
    const r = (this.mode === "scale" ? "local" : this.space) === "local" ? this.worldQuaternion : SC;
    this.gizmo.translate.visible = this.mode === "translate", this.gizmo.rotate.visible = this.mode === "rotate", this.gizmo.scale.visible = this.mode === "scale", this.helper.translate.visible = this.mode === "translate", this.helper.rotate.visible = this.mode === "rotate", this.helper.scale.visible = this.mode === "scale";
    let i = [];
    i = i.concat(this.picker[this.mode].children), i = i.concat(this.gizmo[this.mode].children), i = i.concat(this.helper[this.mode].children);
    for (let s = 0; s < i.length; s++) {
      const l = i[s];
      l.visible = !0, l.rotation.set(0, 0, 0), l.position.copy(this.worldPosition);
      let d;
      if (this.camera.isOrthographicCamera ? d = (this.camera.top - this.camera.bottom) / this.camera.zoom : d = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), l.scale.set(1, 1, 1).multiplyScalar(d * this.size / 4), l.tag === "helper") {
        l.visible = !1, l.name === "AXIS" ? (l.position.copy(this.worldPositionStart), l.visible = !!this.axis, this.axis === "X" && (Rl.setFromEuler(aC.set(0, 0, 0)), l.quaternion.copy(r).multiply(Rl), Math.abs(Lo.copy(yM).applyQuaternion(r).dot(this.eye)) > 0.9 && (l.visible = !1)), this.axis === "Y" && (Rl.setFromEuler(aC.set(0, 0, Math.PI / 2)), l.quaternion.copy(r).multiply(Rl), Math.abs(Lo.copy(D_).applyQuaternion(r).dot(this.eye)) > 0.9 && (l.visible = !1)), this.axis === "Z" && (Rl.setFromEuler(aC.set(0, Math.PI / 2, 0)), l.quaternion.copy(r).multiply(Rl), Math.abs(Lo.copy(xM).applyQuaternion(r).dot(this.eye)) > 0.9 && (l.visible = !1)), this.axis === "XYZE" && (Rl.setFromEuler(aC.set(0, Math.PI / 2, 0)), Lo.copy(this.rotationAxis), l.quaternion.setFromRotationMatrix(TN.lookAt(MN, Lo, D_)), l.quaternion.multiply(Rl), l.visible = this.dragging), this.axis === "E" && (l.visible = !1)) : l.name === "START" ? (l.position.copy(this.worldPositionStart), l.visible = this.dragging) : l.name === "END" ? (l.position.copy(this.worldPosition), l.visible = this.dragging) : l.name === "DELTA" ? (l.position.copy(this.worldPositionStart), l.quaternion.copy(this.worldQuaternionStart), Up.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), Up.applyQuaternion(this.worldQuaternionStart.clone().invert()), l.scale.copy(Up), l.visible = this.dragging) : (l.quaternion.copy(r), this.dragging ? l.position.copy(this.worldPositionStart) : l.position.copy(this.worldPosition), this.axis && (l.visible = this.axis.search(l.name) !== -1));
        continue;
      }
      l.quaternion.copy(r), this.mode === "translate" || this.mode === "scale" ? (l.name === "X" && Math.abs(Lo.copy(yM).applyQuaternion(r).dot(this.eye)) > 0.99 && (l.scale.set(1e-10, 1e-10, 1e-10), l.visible = !1), l.name === "Y" && Math.abs(Lo.copy(D_).applyQuaternion(r).dot(this.eye)) > 0.99 && (l.scale.set(1e-10, 1e-10, 1e-10), l.visible = !1), l.name === "Z" && Math.abs(Lo.copy(xM).applyQuaternion(r).dot(this.eye)) > 0.99 && (l.scale.set(1e-10, 1e-10, 1e-10), l.visible = !1), l.name === "XY" && Math.abs(Lo.copy(xM).applyQuaternion(r).dot(this.eye)) < 0.2 && (l.scale.set(1e-10, 1e-10, 1e-10), l.visible = !1), l.name === "YZ" && Math.abs(Lo.copy(yM).applyQuaternion(r).dot(this.eye)) < 0.2 && (l.scale.set(1e-10, 1e-10, 1e-10), l.visible = !1), l.name === "XZ" && Math.abs(Lo.copy(D_).applyQuaternion(r).dot(this.eye)) < 0.2 && (l.scale.set(1e-10, 1e-10, 1e-10), l.visible = !1)) : this.mode === "rotate" && (sC.copy(r), Lo.copy(this.eye).applyQuaternion(Rl.copy(r).invert()), l.name.search("E") !== -1 && l.quaternion.setFromRotationMatrix(TN.lookAt(this.eye, MN, D_)), l.name === "X" && (Rl.setFromAxisAngle(yM, Math.atan2(-Lo.y, Lo.z)), Rl.multiplyQuaternions(sC, Rl), l.quaternion.copy(Rl)), l.name === "Y" && (Rl.setFromAxisAngle(D_, Math.atan2(Lo.x, Lo.z)), Rl.multiplyQuaternions(sC, Rl), l.quaternion.copy(Rl)), l.name === "Z" && (Rl.setFromAxisAngle(xM, Math.atan2(Lo.y, Lo.x)), Rl.multiplyQuaternions(sC, Rl), l.quaternion.copy(Rl))), l.visible = l.visible && (l.name.indexOf("X") === -1 || this.showX), l.visible = l.visible && (l.name.indexOf("Y") === -1 || this.showY), l.visible = l.visible && (l.name.indexOf("Z") === -1 || this.showZ), l.visible = l.visible && (l.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ), l.material._color = l.material._color || l.material.color.clone(), l.material._opacity = l.material._opacity || l.material.opacity, l.material.color.copy(l.material._color), l.material.opacity = l.material._opacity, this.enabled && this.axis && (l.name === this.axis || this.axis.split("").some(function(p) {
        return l.name === p;
      })) && (l.material.color.setHex(16776960), l.material.opacity = 1);
    }
    super.updateMatrixWorld(e);
  }
}
class rq extends Fn {
  constructor() {
    super(
      new lg(1e5, 1e5, 2, 2),
      new fg({ visible: !1, wireframe: !0, side: Yh, transparent: !0, opacity: 0.1, toneMapped: !1 })
    ), this.isTransformControlsPlane = !0, this.type = "TransformControlsPlane";
  }
  updateMatrixWorld(e) {
    let t = this.space;
    switch (this.position.copy(this.worldPosition), this.mode === "scale" && (t = "local"), oC.copy(yM).applyQuaternion(t === "local" ? this.worldQuaternion : SC), dM.copy(D_).applyQuaternion(t === "local" ? this.worldQuaternion : SC), hM.copy(xM).applyQuaternion(t === "local" ? this.worldQuaternion : SC), Lo.copy(dM), this.mode) {
      case "translate":
      case "scale":
        switch (this.axis) {
          case "X":
            Lo.copy(this.eye).cross(oC), ly.copy(oC).cross(Lo);
            break;
          case "Y":
            Lo.copy(this.eye).cross(dM), ly.copy(dM).cross(Lo);
            break;
          case "Z":
            Lo.copy(this.eye).cross(hM), ly.copy(hM).cross(Lo);
            break;
          case "XY":
            ly.copy(hM);
            break;
          case "YZ":
            ly.copy(oC);
            break;
          case "XZ":
            Lo.copy(hM), ly.copy(dM);
            break;
          case "XYZ":
          case "E":
            ly.set(0, 0, 0);
            break;
        }
        break;
      case "rotate":
      default:
        ly.set(0, 0, 0);
    }
    ly.length() === 0 ? this.quaternion.copy(this.cameraQuaternion) : (CN.lookAt(Up.set(0, 0, 0), ly, Lo), this.quaternion.setFromRotationMatrix(CN)), super.updateMatrixWorld(e);
  }
}
const ID = 1, iq = (a) => {
  let { x: e, y: t, z: r } = a === void 0 ? {} : a;
  return e = e === void 0 ? ID : e, t = t === void 0 ? ID : t, r = r === void 0 ? ID : r, new Pj(e, t, r, 2, 0.05);
}, aq = 0.5, sq = (a) => {
  let { radius: e } = a === void 0 ? {} : a;
  return e = e === void 0 ? aq : e, new ug(e, 32, 32);
}, b4 = 0.5, E4 = 1, oq = (a) => {
  let { radius: e, height: t } = a === void 0 ? {} : a;
  return e = e === void 0 ? b4 : e, t = t === void 0 ? E4 : t, new Ko(e, e, t, 32, 1, !1);
}, lq = 0.4, uq = 0.05, cq = 0.2, fq = 0.6, nR = (a) => {
  let { length: e, radius: t } = a === void 0 ? {} : a;
  e = e === void 0 ? 1 : e, t = t === void 0 ? 1 : t;
  const r = lq * e, i = cq * 0.5 * t, s = new Ko(
    0,
    i,
    r,
    32,
    1
  ), l = fq * e, d = uq * 0.5 * t, p = new Ko(
    d,
    d,
    l,
    32,
    1
  );
  var g = new Kr();
  return g.setPosition(new ge(0, l * 0.5, 0)), p.applyMatrix4(g), g.setPosition(new ge(0, l + r * 0.5, 0)), s.applyMatrix4(g), e4([
    s,
    p
  ]);
}, dq = (a) => {
  let { radius: e, height: t } = a === void 0 ? {} : a;
  e = e === void 0 ? b4 : e, t = t === void 0 ? E4 : t;
  const r = new Ko(e, e, t, 32, 1, !0), i = new ug(e, 32, 32, Math.PI, Math.PI), s = new ug(e, 32, 32, Math.PI, Math.PI);
  var l = new Kr();
  l.makeRotationX(Math.PI / 2), l.setPosition(0, t / 2, 0);
  var d = new Kr();
  return d.makeRotationX(-Math.PI / 2), d.setPosition(0, -t / 2, 0), i.applyMatrix4(l), s.applyMatrix4(d), e4([
    r,
    i,
    s
  ]);
}, qM = (a, e, t) => {
  if (a.current && e) {
    const r = typeof e.r == "function" ? e.r(t) / 255 : e.r / 255, i = typeof e.g == "function" ? e.g(t) / 255 : e.g / 255, s = typeof e.b == "function" ? e.b(t) / 255 : e.b / 255, l = typeof e.a == "function" ? e.a(t) : e.a;
    a.current.material.color.setRGB(r, i, s), a.current.material.opacity = l, a.current.material.transparent = l !== 1;
  }
}, hq = (a) => {
  let e = null;
  if (a.shape)
    a.shape === "cube" ? e = iq(a.shapeParams) : a.shape === "cylinder" ? e = oq(a.shapeParams) : a.shape === "sphere" ? e = sq(a.shapeParams) : a.shape === "capsule" ? e = dq(a.shapeParams) : a.shape === "arrow" && (e = nR(a.shapeParams));
  else
    return [];
  return [{ geometry: e, type: "part" }];
};
function yb(...a) {
  const e = Xs();
  return hh(() => {
    a.forEach((t) => {
      !t || (typeof t == "function" ? t(e.current) : t.current = e.current);
    });
  }, [a]), e;
}
function dh(a, e) {
  if (Object.is(a, e))
    return !0;
  if (typeof a != "object" || a === null || typeof e != "object" || e === null)
    return !1;
  if (a instanceof Map && e instanceof Map) {
    if (a.size !== e.size)
      return !1;
    for (const [r, i] of a)
      if (!Object.is(i, e.get(r)))
        return !1;
    return !0;
  }
  if (a instanceof Set && e instanceof Set) {
    if (a.size !== e.size)
      return !1;
    for (const r of a)
      if (!e.has(r))
        return !1;
    return !0;
  }
  const t = Object.keys(a);
  if (t.length !== Object.keys(e).length)
    return !1;
  for (let r = 0; r < t.length; r++)
    if (!Object.prototype.hasOwnProperty.call(e, t[r]) || !Object.is(a[t[r]], e[t[r]]))
      return !1;
  return !0;
}
const pq = U0(({
  objectKey: a,
  displayTfs: e,
  position: t,
  rotation: r,
  scale: i,
  ghost: s,
  highlightColor: l,
  children: d
}, p) => {
  const g = Xs(null), _ = yb(p, g), w = os(qh((D) => D.tfs[a], [a]), dh), T = os((D) => D.clock);
  Am(qh(() => {
    const D = T.getElapsed() * 1e3;
    _.current && (_.current.position.set(t ? t.x : typeof w.position.x == "function" ? w.position.x(D) : w.position.x, t ? t.y : typeof w.position.y == "function" ? w.position.y(D) : w.position.y, t ? t.z : typeof w.position.z == "function" ? w.position.z(D) : w.position.z), _.current.quaternion.set(r ? r.x : typeof w.rotation.x == "function" ? w.rotation.x(D) : w.rotation.x, r ? r.y : typeof w.rotation.y == "function" ? w.rotation.y(D) : w.rotation.y, r ? r.z : typeof w.rotation.z == "function" ? w.rotation.z(D) : w.rotation.z, r ? r.w : typeof w.rotation.w == "function" ? w.rotation.w(D) : w.rotation.w), _.current.scale.set(i ? i.x : w.scale ? typeof w.scale.x == "function" ? w.scale.x(D) : w.scale.x : 0, i ? i.y : w.scale ? typeof w.scale.y == "function" ? w.scale.y(D) : w.scale.y : 0, i ? i.z : w.scale ? typeof w.scale.z == "function" ? w.scale.z(D) : w.scale.z : 0));
  }, [w, t, r, i, _, T]));
  const R = nR();
  return /* @__PURE__ */ _c("group", {
    ref: _,
    dispose: null,
    up: [0, 0, 1],
    children: [e && /* @__PURE__ */ _c(rT, {
      children: [/* @__PURE__ */ ln("axesHelper", {
        size: 1
      }), /* @__PURE__ */ ln("mesh", {
        geometry: R,
        material: s ? _C(l) : my(255, 0, 0, 1),
        scale: [0.2, 0.5, 0.2],
        rotation: [0, 0, -Math.PI / 2]
      }, `${a}ArrowX`), /* @__PURE__ */ ln("mesh", {
        geometry: R,
        material: s ? _C(l) : my(0, 255, 0, 1),
        scale: [0.2, 0.5, 0.2],
        rotation: [0, Math.PI / 2, 0]
      }, `${a}ArrowY`), /* @__PURE__ */ ln("mesh", {
        geometry: R,
        material: s ? _C(l) : my(0, 0, 255, 1),
        scale: [0.2, 0.5, 0.2],
        rotation: [Math.PI / 2, 0, 0]
      }, `${a}ArrowZ`)]
    }), d]
  });
});
function mq({
  displayTfs: a,
  children: e
}) {
  const t = nR();
  return /* @__PURE__ */ _c("group", {
    dispose: null,
    up: [0, 0, 1],
    children: [a && /* @__PURE__ */ _c(rT, {
      children: [/* @__PURE__ */ ln("axesHelper", {
        size: 1
      }), /* @__PURE__ */ ln("mesh", {
        geometry: t,
        material: my(255, 0, 0, 1),
        scale: [0.2, 0.5, 0.2],
        rotation: [0, 0, -Math.PI / 2]
      }, "$WorldArrowX"), /* @__PURE__ */ ln("mesh", {
        geometry: t,
        material: my(0, 255, 0, 1),
        scale: [0.2, 0.5, 0.2],
        rotation: [0, Math.PI / 2, 0]
      }, "$WorldArrowY"), /* @__PURE__ */ ln("mesh", {
        geometry: t,
        material: my(0, 0, 255, 1),
        scale: [0.2, 0.5, 0.2],
        rotation: [Math.PI / 2, 0, 0]
      }, "$WorldArrowZ")]
    }), e]
  });
}
function vq({
  displayTfs: a,
  children: e
}) {
  const t = nR();
  return /* @__PURE__ */ _c("group", {
    dispose: null,
    up: [0, 0, 1],
    children: [a && /* @__PURE__ */ _c(rT, {
      children: [/* @__PURE__ */ ln("axesHelper", {
        size: 1
      }), /* @__PURE__ */ ln("mesh", {
        geometry: t,
        material: my(255, 0, 0, 1),
        scale: [0.2, 0.5, 0.2],
        rotation: [0, 0, -Math.PI / 2]
      }, "$WorldArrowX"), /* @__PURE__ */ ln("mesh", {
        geometry: t,
        material: my(0, 255, 0, 1),
        scale: [0.2, 0.5, 0.2],
        rotation: [0, Math.PI / 2, 0]
      }, "$WorldArrowY"), /* @__PURE__ */ ln("mesh", {
        geometry: t,
        material: my(0, 0, 255, 1),
        scale: [0.2, 0.5, 0.2],
        rotation: [Math.PI / 2, 0, 0]
      }, "$WorldArrowZ")]
    }), e]
  });
}
/**
 * postprocessing v6.30.1 build Fri Feb 24 2023
 * https://github.com/pmndrs/postprocessing
 * Copyright 2015-2023 Raoul van Rschen
 * @license Zlib
 */
var gq = `#include <packing>
#define packFloatToRGBA(v) packDepthToRGBA(v)
#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)
uniform lowp sampler2D luminanceBuffer0;uniform lowp sampler2D luminanceBuffer1;uniform float minLuminance;uniform float deltaTime;uniform float tau;varying vec2 vUv;void main(){float l0=unpackRGBAToFloat(texture2D(luminanceBuffer0,vUv));
#if __VERSION__ < 300
float l1=texture2DLodEXT(luminanceBuffer1,vUv,MIP_LEVEL_1X1).r;
#else
float l1=textureLod(luminanceBuffer1,vUv,MIP_LEVEL_1X1).r;
#endif
l0=max(minLuminance,l0);l1=max(minLuminance,l1);float adaptedLum=l0+(l1-l0)*(1.0-exp(-deltaTime*tau));gl_FragColor=(adaptedLum==1.0)?vec4(1.0):packFloatToRGBA(adaptedLum);}`, kL = "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}", yq = class extends Mu {
  constructor() {
    super({
      name: "AdaptiveLuminanceMaterial",
      defines: {
        THREE_REVISION: a1.replace(/\D+/g, ""),
        MIP_LEVEL_1X1: "0.0"
      },
      uniforms: {
        luminanceBuffer0: new Pn(null),
        luminanceBuffer1: new Pn(null),
        minLuminance: new Pn(0.01),
        deltaTime: new Pn(0),
        tau: new Pn(1)
      },
      extensions: {
        shaderTextureLOD: !0
      },
      blending: ff,
      depthWrite: !1,
      depthTest: !1,
      fragmentShader: gq,
      vertexShader: kL
    }), this.toneMapped = !1;
  }
  set luminanceBuffer0(a) {
    this.uniforms.luminanceBuffer0.value = a;
  }
  setLuminanceBuffer0(a) {
    this.uniforms.luminanceBuffer0.value = a;
  }
  set luminanceBuffer1(a) {
    this.uniforms.luminanceBuffer1.value = a;
  }
  setLuminanceBuffer1(a) {
    this.uniforms.luminanceBuffer1.value = a;
  }
  set mipLevel1x1(a) {
    this.defines.MIP_LEVEL_1X1 = a.toFixed(1), this.needsUpdate = !0;
  }
  setMipLevel1x1(a) {
    this.mipLevel1x1 = a;
  }
  set deltaTime(a) {
    this.uniforms.deltaTime.value = a;
  }
  setDeltaTime(a) {
    this.uniforms.deltaTime.value = a;
  }
  get minLuminance() {
    return this.uniforms.minLuminance.value;
  }
  set minLuminance(a) {
    this.uniforms.minLuminance.value = a;
  }
  getMinLuminance() {
    return this.uniforms.minLuminance.value;
  }
  setMinLuminance(a) {
    this.uniforms.minLuminance.value = a;
  }
  get adaptationRate() {
    return this.uniforms.tau.value;
  }
  set adaptationRate(a) {
    this.uniforms.tau.value = a;
  }
  getAdaptationRate() {
    return this.uniforms.tau.value;
  }
  setAdaptationRate(a) {
    this.uniforms.tau.value = a;
  }
};
function RN(a, e) {
  let t = "texel";
  if (a !== null) {
    const r = Number.parseInt(a1);
    if (!(e && r >= 133 && r !== 135 && a.format === zp && a.type === df && a.encoding === gi))
      switch (a.encoding) {
        case gi:
          t = "sRGBToLinear(texel)";
          break;
        case wv:
          t = "texel";
          break;
        default:
          throw new Error(`Unsupported encoding: ${a.encoding}`);
      }
  }
  return t;
}
var ri = {
  SKIP: 9,
  SET: 30,
  ADD: 0,
  ALPHA: 1,
  AVERAGE: 2,
  COLOR: 3,
  COLOR_BURN: 4,
  COLOR_DODGE: 5,
  DARKEN: 6,
  DIFFERENCE: 7,
  DIVIDE: 8,
  DST: 9,
  EXCLUSION: 10,
  HARD_LIGHT: 11,
  HARD_MIX: 12,
  HUE: 13,
  INVERT: 14,
  INVERT_RGB: 15,
  LIGHTEN: 16,
  LINEAR_BURN: 17,
  LINEAR_DODGE: 18,
  LINEAR_LIGHT: 19,
  LUMINOSITY: 20,
  MULTIPLY: 21,
  NEGATION: 22,
  NORMAL: 23,
  OVERLAY: 24,
  PIN_LIGHT: 25,
  REFLECT: 26,
  SATURATION: 27,
  SCREEN: 28,
  SOFT_LIGHT: 29,
  SRC: 30,
  SUBTRACT: 31,
  VIVID_LIGHT: 32
}, e1 = {
  NONE: 0,
  DEPTH: 1,
  CONVOLUTION: 2
}, ss = {
  FRAGMENT_HEAD: "FRAGMENT_HEAD",
  FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV",
  FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE",
  VERTEX_HEAD: "VERTEX_HEAD",
  VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT"
}, nS = {
  VERY_SMALL: 0,
  SMALL: 1,
  MEDIUM: 2,
  LARGE: 3,
  VERY_LARGE: 4,
  HUGE: 5
}, C0 = {
  REINHARD: 0,
  REINHARD2: 1,
  REINHARD2_ADAPTIVE: 2,
  OPTIMIZED_CINEON: 3,
  ACES_FILMIC: 4
}, lC = {
  DEFAULT: 0,
  ESKIL: 1
}, xq = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;
#include <encodings_fragment>
}`, _q = "uniform vec4 texelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}", Sq = [
  new Float32Array([0, 0]),
  new Float32Array([0, 1, 1]),
  new Float32Array([0, 1, 1, 2]),
  new Float32Array([0, 1, 2, 2, 3]),
  new Float32Array([0, 1, 2, 3, 4, 4, 5]),
  new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10])
], M4 = class extends Mu {
  constructor(a = new ra()) {
    super({
      name: "KawaseBlurMaterial",
      uniforms: {
        inputBuffer: new Pn(null),
        texelSize: new Pn(new ra()),
        scale: new Pn(1),
        kernel: new Pn(0)
      },
      blending: ff,
      depthWrite: !1,
      depthTest: !1,
      fragmentShader: xq,
      vertexShader: _q
    }), this.toneMapped = !1, this.setTexelSize(a.x, a.y), this.kernelSize = nS.MEDIUM;
  }
  set inputBuffer(a) {
    this.uniforms.inputBuffer.value = a;
  }
  setInputBuffer(a) {
    this.inputBuffer = a;
  }
  get kernelSequence() {
    return Sq[this.kernelSize];
  }
  get scale() {
    return this.uniforms.scale.value;
  }
  set scale(a) {
    this.uniforms.scale.value = a;
  }
  getScale() {
    return this.uniforms.scale.value;
  }
  setScale(a) {
    this.uniforms.scale.value = a;
  }
  getKernel() {
    return null;
  }
  get kernel() {
    return this.uniforms.kernel.value;
  }
  set kernel(a) {
    this.uniforms.kernel.value = a;
  }
  setKernel(a) {
    this.kernel = a;
  }
  setTexelSize(a, e) {
    this.uniforms.texelSize.value.set(a, e, a * 0.5, e * 0.5);
  }
  setSize(a, e) {
    const t = 1 / a, r = 1 / e;
    this.uniforms.texelSize.value.set(t, r, t * 0.5, r * 0.5);
  }
}, wq = `#include <common>
#include <dithering_pars_fragment>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;
#include <encodings_fragment>
#include <dithering_fragment>
}`, T4 = class extends Mu {
  constructor() {
    super({
      name: "CopyMaterial",
      uniforms: {
        inputBuffer: new Pn(null),
        opacity: new Pn(1)
      },
      blending: ff,
      depthWrite: !1,
      depthTest: !1,
      fragmentShader: wq,
      vertexShader: kL
    }), this.toneMapped = !1;
  }
  set inputBuffer(a) {
    this.uniforms.inputBuffer.value = a;
  }
  setInputBuffer(a) {
    this.uniforms.inputBuffer.value = a;
  }
  getOpacity(a) {
    return this.uniforms.opacity.value;
  }
  setOpacity(a) {
    this.uniforms.opacity.value = a;
  }
}, bq = `#include <packing>
#include <clipping_planes_pars_fragment>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform float cameraNear;uniform float cameraFar;varying float vViewZ;varying vec4 vProjTexCoord;void main(){
#include <clipping_planes_fragment>
vec2 projTexCoord=(vProjTexCoord.xy/vProjTexCoord.w)*0.5+0.5;projTexCoord=clamp(projTexCoord,0.002,0.998);
#if DEPTH_PACKING == 3201
float fragCoordZ=unpackRGBAToDepth(texture2D(depthBuffer,projTexCoord));
#else
float fragCoordZ=texture2D(depthBuffer,projTexCoord).r;
#endif
#ifdef PERSPECTIVE_CAMERA
float viewZ=perspectiveDepthToViewZ(fragCoordZ,cameraNear,cameraFar);
#else
float viewZ=orthographicDepthToViewZ(fragCoordZ,cameraNear,cameraFar);
#endif
float depthTest=(-vViewZ>-viewZ)?1.0:0.0;gl_FragColor.rg=vec2(0.0,depthTest);}`, Eq = `#include <common>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
varying float vViewZ;varying vec4 vProjTexCoord;void main(){
#include <skinbase_vertex>
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <project_vertex>
vViewZ=mvPosition.z;vProjTexCoord=gl_Position;
#include <clipping_planes_vertex>
}`, Mq = class extends Mu {
  constructor(a = null, e) {
    super({
      name: "DepthComparisonMaterial",
      defines: {
        DEPTH_PACKING: "0"
      },
      uniforms: {
        depthBuffer: new Pn(null),
        cameraNear: new Pn(0.3),
        cameraFar: new Pn(1e3)
      },
      blending: ff,
      depthWrite: !1,
      depthTest: !1,
      fragmentShader: bq,
      vertexShader: Eq
    }), this.toneMapped = !1, this.depthBuffer = a, this.depthPacking = Jw, this.copyCameraSettings(e);
  }
  set depthBuffer(a) {
    this.uniforms.depthBuffer.value = a;
  }
  set depthPacking(a) {
    this.defines.DEPTH_PACKING = a.toFixed(0), this.needsUpdate = !0;
  }
  setDepthBuffer(a, e = Jw) {
    this.depthBuffer = a, this.depthPacking = e;
  }
  adoptCameraSettings(a) {
    this.copyCameraSettings(a);
  }
  copyCameraSettings(a) {
    a && (this.uniforms.cameraNear.value = a.near, this.uniforms.cameraFar.value = a.far, a instanceof ho ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0);
  }
}, Tq = `#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
#ifdef DOWNSAMPLE_NORMALS
uniform lowp sampler2D normalBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}int findBestDepth(const in float samples[4]){float c=(samples[0]+samples[1]+samples[2]+samples[3])*0.25;float distances[]=float[4](abs(c-samples[0]),abs(c-samples[1]),abs(c-samples[2]),abs(c-samples[3]));float maxDistance=max(max(distances[0],distances[1]),max(distances[2],distances[3]));int remaining[3];int rejected[3];int i,j,k;for(i=0,j=0,k=0;i<4;++i){if(distances[i]<maxDistance){remaining[j++]=i;}else{rejected[k++]=i;}}for(;j<3;++j){remaining[j]=rejected[--k];}vec3 s=vec3(samples[remaining[0]],samples[remaining[1]],samples[remaining[2]]);c=(s.x+s.y+s.z)/3.0;distances[0]=abs(c-s.x);distances[1]=abs(c-s.y);distances[2]=abs(c-s.z);float minDistance=min(distances[0],min(distances[1],distances[2]));for(i=0;i<3;++i){if(distances[i]==minDistance){break;}}return remaining[i];}void main(){float d[]=float[4](readDepth(vUv0),readDepth(vUv1),readDepth(vUv2),readDepth(vUv3));int index=findBestDepth(d);
#ifdef DOWNSAMPLE_NORMALS
vec3 n[]=vec3[4](texture2D(normalBuffer,vUv0).rgb,texture2D(normalBuffer,vUv1).rgb,texture2D(normalBuffer,vUv2).rgb,texture2D(normalBuffer,vUv3).rgb);
#else
vec3 n[]=vec3[4](vec3(0.0),vec3(0.0),vec3(0.0),vec3(0.0));
#endif
gl_FragColor=vec4(n[index],d[index]);}`, Cq = "uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=uv;vUv1=vec2(uv.x,uv.y+texelSize.y);vUv2=vec2(uv.x+texelSize.x,uv.y);vUv3=uv+texelSize;gl_Position=vec4(position.xy,1.0,1.0);}", Rq = class extends Mu {
  constructor() {
    super({
      name: "DepthDownsamplingMaterial",
      defines: {
        DEPTH_PACKING: "0"
      },
      uniforms: {
        depthBuffer: new Pn(null),
        normalBuffer: new Pn(null),
        texelSize: new Pn(new zt())
      },
      blending: ff,
      depthWrite: !1,
      depthTest: !1,
      fragmentShader: Tq,
      vertexShader: Cq
    }), this.toneMapped = !1;
  }
  set depthBuffer(a) {
    this.uniforms.depthBuffer.value = a;
  }
  set depthPacking(a) {
    this.defines.DEPTH_PACKING = a.toFixed(0), this.needsUpdate = !0;
  }
  setDepthBuffer(a, e = o1) {
    this.depthBuffer = a, this.depthPacking = e;
  }
  set normalBuffer(a) {
    this.uniforms.normalBuffer.value = a, a !== null ? this.defines.DOWNSAMPLE_NORMALS = "1" : delete this.defines.DOWNSAMPLE_NORMALS, this.needsUpdate = !0;
  }
  setNormalBuffer(a) {
    this.normalBuffer = a;
  }
  setTexelSize(a, e) {
    this.uniforms.texelSize.value.set(a, e);
  }
  setSize(a, e) {
    this.uniforms.texelSize.value.set(1 / a, 1 / e);
  }
}, Aq = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#define WEIGHT_INNER 0.125
#define WEIGHT_OUTER 0.0555555
varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;float clampToBorder(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void main(){vec4 c=vec4(0.0);vec4 w=WEIGHT_INNER*vec4(clampToBorder(vUv00),clampToBorder(vUv01),clampToBorder(vUv02),clampToBorder(vUv03));c+=w.x*texture2D(inputBuffer,vUv00);c+=w.y*texture2D(inputBuffer,vUv01);c+=w.z*texture2D(inputBuffer,vUv02);c+=w.w*texture2D(inputBuffer,vUv03);w=WEIGHT_OUTER*vec4(clampToBorder(vUv04),clampToBorder(vUv05),clampToBorder(vUv06),clampToBorder(vUv07));c+=w.x*texture2D(inputBuffer,vUv04);c+=w.y*texture2D(inputBuffer,vUv05);c+=w.z*texture2D(inputBuffer,vUv06);c+=w.w*texture2D(inputBuffer,vUv07);w=WEIGHT_OUTER*vec4(clampToBorder(vUv08),clampToBorder(vUv09),clampToBorder(vUv10),clampToBorder(vUv11));c+=w.x*texture2D(inputBuffer,vUv08);c+=w.y*texture2D(inputBuffer,vUv09);c+=w.z*texture2D(inputBuffer,vUv10);c+=w.w*texture2D(inputBuffer,vUv11);c+=WEIGHT_OUTER*texture2D(inputBuffer,vUv);gl_FragColor=c;
#include <encodings_fragment>
}`, Dq = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;void main(){vUv=position.xy*0.5+0.5;vUv00=vUv+texelSize*vec2(-1.0,1.0);vUv01=vUv+texelSize*vec2(1.0,1.0);vUv02=vUv+texelSize*vec2(-1.0,-1.0);vUv03=vUv+texelSize*vec2(1.0,-1.0);vUv04=vUv+texelSize*vec2(-2.0,2.0);vUv05=vUv+texelSize*vec2(0.0,2.0);vUv06=vUv+texelSize*vec2(2.0,2.0);vUv07=vUv+texelSize*vec2(-2.0,0.0);vUv08=vUv+texelSize*vec2(2.0,0.0);vUv09=vUv+texelSize*vec2(-2.0,-2.0);vUv10=vUv+texelSize*vec2(0.0,-2.0);vUv11=vUv+texelSize*vec2(2.0,-2.0);gl_Position=vec4(position.xy,1.0,1.0);}", Lq = class extends Mu {
  constructor() {
    super({
      name: "DownsamplingMaterial",
      uniforms: {
        inputBuffer: new Pn(null),
        texelSize: new Pn(new zt())
      },
      blending: ff,
      depthWrite: !1,
      depthTest: !1,
      fragmentShader: Aq,
      vertexShader: Dq
    }), this.toneMapped = !1;
  }
  set inputBuffer(a) {
    this.uniforms.inputBuffer.value = a;
  }
  setSize(a, e) {
    this.uniforms.texelSize.value.set(1 / a, 1 / e);
  }
}, Pq = `#include <common>
#include <packing>
#include <dithering_pars_fragment>
#define packFloatToRGBA(v) packDepthToRGBA(v)
#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#if DEPTH_PACKING == 3201
uniform lowp sampler2D depthBuffer;
#elif defined(GL_FRAGMENT_PRECISION_HIGH)
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;
#if THREE_REVISION < 143
#define luminance(v) linearToRelativeLuminance(v)
#endif
#if THREE_REVISION >= 137
vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}
#endif
float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNear,cameraFar);
#else
return orthographicDepthToViewZ(depth,cameraNear,cameraFar);
#endif
}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEADvoid main(){FRAGMENT_MAIN_UVvec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGEgl_FragColor=color0;
#ifdef ENCODE_OUTPUT
#include <encodings_fragment>
#endif
#include <dithering_fragment>
}`, Oq = "uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEADvoid main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORTgl_Position=vec4(position.xy,1.0,1.0);}", Uq = class extends Mu {
  constructor(a, e, t, r, i = !1) {
    super({
      name: "EffectMaterial",
      defines: {
        THREE_REVISION: a1.replace(/\D+/g, ""),
        DEPTH_PACKING: "0",
        ENCODE_OUTPUT: "1"
      },
      uniforms: {
        inputBuffer: new Pn(null),
        depthBuffer: new Pn(null),
        resolution: new Pn(new zt()),
        texelSize: new Pn(new zt()),
        cameraNear: new Pn(0.3),
        cameraFar: new Pn(1e3),
        aspect: new Pn(1),
        time: new Pn(0)
      },
      blending: ff,
      depthWrite: !1,
      depthTest: !1,
      dithering: i
    }), this.toneMapped = !1, a && this.setShaderParts(a), e && this.setDefines(e), t && this.setUniforms(t), this.copyCameraSettings(r);
  }
  set inputBuffer(a) {
    this.uniforms.inputBuffer.value = a;
  }
  setInputBuffer(a) {
    this.uniforms.inputBuffer.value = a;
  }
  get depthBuffer() {
    return this.uniforms.depthBuffer.value;
  }
  set depthBuffer(a) {
    this.uniforms.depthBuffer.value = a;
  }
  get depthPacking() {
    return Number(this.defines.DEPTH_PACKING);
  }
  set depthPacking(a) {
    this.defines.DEPTH_PACKING = a.toFixed(0), this.needsUpdate = !0;
  }
  setDepthBuffer(a, e = o1) {
    this.depthBuffer = a, this.depthPacking = e;
  }
  setShaderData(a) {
    this.setShaderParts(a.shaderParts), this.setDefines(a.defines), this.setUniforms(a.uniforms), this.setExtensions(a.extensions);
  }
  setShaderParts(a) {
    var e, t, r, i, s;
    return this.fragmentShader = Pq.replace(ss.FRAGMENT_HEAD, (e = a.get(ss.FRAGMENT_HEAD)) != null ? e : "").replace(ss.FRAGMENT_MAIN_UV, (t = a.get(ss.FRAGMENT_MAIN_UV)) != null ? t : "").replace(ss.FRAGMENT_MAIN_IMAGE, (r = a.get(ss.FRAGMENT_MAIN_IMAGE)) != null ? r : ""), this.vertexShader = Oq.replace(ss.VERTEX_HEAD, (i = a.get(ss.VERTEX_HEAD)) != null ? i : "").replace(ss.VERTEX_MAIN_SUPPORT, (s = a.get(ss.VERTEX_MAIN_SUPPORT)) != null ? s : ""), this.needsUpdate = !0, this;
  }
  setDefines(a) {
    for (const e of a.entries())
      this.defines[e[0]] = e[1];
    return this.needsUpdate = !0, this;
  }
  setUniforms(a) {
    for (const e of a.entries())
      this.uniforms[e[0]] = e[1];
    return this;
  }
  setExtensions(a) {
    this.extensions = {};
    for (const e of a)
      this.extensions[e] = !0;
    return this;
  }
  get encodeOutput() {
    return this.defines.ENCODE_OUTPUT !== void 0;
  }
  set encodeOutput(a) {
    this.encodeOutput !== a && (a ? this.defines.ENCODE_OUTPUT = "1" : delete this.defines.ENCODE_OUTPUT, this.needsUpdate = !0);
  }
  isOutputEncodingEnabled(a) {
    return this.encodeOutput;
  }
  setOutputEncodingEnabled(a) {
    this.encodeOutput = a;
  }
  get time() {
    return this.uniforms.time.value;
  }
  set time(a) {
    this.uniforms.time.value = a;
  }
  setDeltaTime(a) {
    this.uniforms.time.value += a;
  }
  adoptCameraSettings(a) {
    this.copyCameraSettings(a);
  }
  copyCameraSettings(a) {
    a && (this.uniforms.cameraNear.value = a.near, this.uniforms.cameraFar.value = a.far, a instanceof ho ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0);
  }
  setSize(a, e) {
    const t = this.uniforms;
    t.resolution.value.set(a, e), t.texelSize.value.set(1 / a, 1 / e), t.aspect.value = a / e;
  }
  static get Section() {
    return ss;
  }
}, zq = `#include <common>
#if THREE_REVISION < 143
#define luminance(v) linearToRelativeLuminance(v)
#endif
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef RANGE
uniform vec2 range;
#elif defined(THRESHOLD)
uniform float threshold;uniform float smoothing;
#endif
varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);
#ifdef RANGE
float low=step(range.x,l);float high=step(l,range.y);l*=low*high;
#elif defined(THRESHOLD)
l=smoothstep(threshold,threshold+smoothing,l);
#endif
#ifdef COLOR
gl_FragColor=vec4(texel.rgb*l,l);
#else
gl_FragColor=vec4(l);
#endif
}`, Nq = class extends Mu {
  constructor(a = !1, e = null) {
    super({
      name: "LuminanceMaterial",
      defines: {
        THREE_REVISION: a1.replace(/\D+/g, "")
      },
      uniforms: {
        inputBuffer: new Pn(null),
        threshold: new Pn(0),
        smoothing: new Pn(1),
        range: new Pn(null)
      },
      blending: ff,
      depthWrite: !1,
      depthTest: !1,
      fragmentShader: zq,
      vertexShader: kL
    }), this.toneMapped = !1, this.colorOutput = a, this.luminanceRange = e;
  }
  set inputBuffer(a) {
    this.uniforms.inputBuffer.value = a;
  }
  setInputBuffer(a) {
    this.uniforms.inputBuffer.value = a;
  }
  get threshold() {
    return this.uniforms.threshold.value;
  }
  set threshold(a) {
    this.smoothing > 0 || a > 0 ? this.defines.THRESHOLD = "1" : delete this.defines.THRESHOLD, this.uniforms.threshold.value = a;
  }
  getThreshold() {
    return this.threshold;
  }
  setThreshold(a) {
    this.threshold = a;
  }
  get smoothing() {
    return this.uniforms.smoothing.value;
  }
  set smoothing(a) {
    this.threshold > 0 || a > 0 ? this.defines.THRESHOLD = "1" : delete this.defines.THRESHOLD, this.uniforms.smoothing.value = a;
  }
  getSmoothingFactor() {
    return this.smoothing;
  }
  setSmoothingFactor(a) {
    this.smoothing = a;
  }
  get useThreshold() {
    return this.threshold > 0 || this.smoothing > 0;
  }
  set useThreshold(a) {
  }
  get colorOutput() {
    return this.defines.COLOR !== void 0;
  }
  set colorOutput(a) {
    a ? this.defines.COLOR = "1" : delete this.defines.COLOR, this.needsUpdate = !0;
  }
  isColorOutputEnabled(a) {
    return this.colorOutput;
  }
  setColorOutputEnabled(a) {
    this.colorOutput = a;
  }
  get useRange() {
    return this.luminanceRange !== null;
  }
  set useRange(a) {
    this.luminanceRange = null;
  }
  get luminanceRange() {
    return this.uniforms.range.value;
  }
  set luminanceRange(a) {
    a !== null ? this.defines.RANGE = "1" : delete this.defines.RANGE, this.uniforms.range.value = a, this.needsUpdate = !0;
  }
  getLuminanceRange() {
    return this.luminanceRange;
  }
  setLuminanceRange(a) {
    this.luminanceRange = a;
  }
}, Fq = "uniform lowp sampler2D inputBuffer;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 c0=texture2D(inputBuffer,vUv0).rg;vec2 c1=texture2D(inputBuffer,vUv1).rg;vec2 c2=texture2D(inputBuffer,vUv2).rg;vec2 c3=texture2D(inputBuffer,vUv3).rg;float d0=(c0.x-c1.x)*0.5;float d1=(c2.x-c3.x)*0.5;float d=length(vec2(d0,d1));float a0=min(c0.y,c1.y);float a1=min(c2.y,c3.y);float visibilityFactor=min(a0,a1);gl_FragColor.rg=(1.0-visibilityFactor>0.001)?vec2(d,0.0):vec2(0.0,d);}", kq = "uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=vec2(uv.x+texelSize.x,uv.y);vUv1=vec2(uv.x-texelSize.x,uv.y);vUv2=vec2(uv.x,uv.y+texelSize.y);vUv3=vec2(uv.x,uv.y-texelSize.y);gl_Position=vec4(position.xy,1.0,1.0);}", Iq = class extends Mu {
  constructor(a = new zt()) {
    super({
      name: "OutlineMaterial",
      uniforms: {
        inputBuffer: new Pn(null),
        texelSize: new Pn(new zt())
      },
      blending: ff,
      depthWrite: !1,
      depthTest: !1,
      fragmentShader: Fq,
      vertexShader: kq
    }), this.toneMapped = !1, this.uniforms.texelSize.value.set(a.x, a.y), this.uniforms.maskTexture = this.uniforms.inputBuffer;
  }
  set inputBuffer(a) {
    this.uniforms.inputBuffer.value = a;
  }
  setInputBuffer(a) {
    this.uniforms.inputBuffer.value = a;
  }
  setTexelSize(a, e) {
    this.uniforms.texelSize.value.set(a, e);
  }
  setSize(a, e) {
    this.uniforms.texelSize.value.set(1 / a, 1 / e);
  }
}, Bq = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform vec4 maskParams;varying vec2 vUv;varying vec2 vUv2;varying vec2 vOffset;float linearGradientMask(const in float x){return smoothstep(maskParams.x,maskParams.y,x)-smoothstep(maskParams.w,maskParams.z,x);}void main(){vec2 dUv=vOffset*(1.0-linearGradientMask(vUv2.y));vec4 sum=texture2D(inputBuffer,vec2(vUv.x-dUv.x,vUv.y+dUv.y));sum+=texture2D(inputBuffer,vec2(vUv.x+dUv.x,vUv.y+dUv.y));sum+=texture2D(inputBuffer,vec2(vUv.x+dUv.x,vUv.y-dUv.y));sum+=texture2D(inputBuffer,vec2(vUv.x-dUv.x,vUv.y-dUv.y));gl_FragColor=sum*0.25;
#include <encodings_fragment>
}`, Hq = "uniform vec4 texelSize;uniform float kernel;uniform float scale;uniform float aspect;uniform vec2 rotation;varying vec2 vUv;varying vec2 vUv2;varying vec2 vOffset;void main(){vec2 uv=position.xy*0.5+0.5;vUv=uv;vUv2=(uv-0.5)*2.0*vec2(aspect,1.0);vUv2=vec2(dot(rotation,vUv2),dot(rotation,vec2(vUv2.y,-vUv2.x)));vOffset=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;gl_Position=vec4(position.xy,1.0,1.0);}", Vq = class extends M4 {
  constructor({
    kernelSize: a = nS.MEDIUM,
    offset: e = 0,
    rotation: t = 0,
    focusArea: r = 0.4,
    feather: i = 0.3
  } = {}) {
    super(), this.fragmentShader = Bq, this.vertexShader = Hq, this.kernelSize = a, this.uniforms.aspect = new Pn(1), this.uniforms.rotation = new Pn(new zt()), this.uniforms.maskParams = new Pn(new ra()), this._offset = e, this._focusArea = r, this._feather = i, this.rotation = t, this.updateParams();
  }
  updateParams() {
    const a = this.uniforms.maskParams.value, e = Math.max(this.focusArea, 0), t = Math.max(e - this.feather, 0);
    a.set(
      this.offset - e,
      this.offset - t,
      this.offset + e,
      this.offset + t
    );
  }
  get rotation() {
    return Math.acos(this.uniforms.rotation.value.x);
  }
  set rotation(a) {
    this.uniforms.rotation.value.set(Math.cos(a), Math.sin(a));
  }
  get offset() {
    return this._offset;
  }
  set offset(a) {
    this._offset = a, this.updateParams();
  }
  get focusArea() {
    return this._focusArea;
  }
  set focusArea(a) {
    this._focusArea = a, this.updateParams();
  }
  get feather() {
    return this._feather;
  }
  set feather(a) {
    this._feather = a, this.updateParams();
  }
  setSize(a, e) {
    super.setSize(a, e), this.uniforms.aspect.value = a / e;
  }
}, Gq = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;uniform mediump sampler2D supportBuffer;
#else
uniform lowp sampler2D inputBuffer;uniform lowp sampler2D supportBuffer;
#endif
uniform float radius;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vec4 c=vec4(0.0);c+=texture2D(inputBuffer,vUv0)*0.0625;c+=texture2D(inputBuffer,vUv1)*0.125;c+=texture2D(inputBuffer,vUv2)*0.0625;c+=texture2D(inputBuffer,vUv3)*0.125;c+=texture2D(inputBuffer,vUv)*0.25;c+=texture2D(inputBuffer,vUv4)*0.125;c+=texture2D(inputBuffer,vUv5)*0.0625;c+=texture2D(inputBuffer,vUv6)*0.125;c+=texture2D(inputBuffer,vUv7)*0.0625;vec4 baseColor=texture2D(supportBuffer,vUv);gl_FragColor=mix(baseColor,c,radius);
#include <encodings_fragment>
}`, Wq = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,1.0);vUv1=vUv+texelSize*vec2(0.0,1.0);vUv2=vUv+texelSize*vec2(1.0,1.0);vUv3=vUv+texelSize*vec2(-1.0,0.0);vUv4=vUv+texelSize*vec2(1.0,0.0);vUv5=vUv+texelSize*vec2(-1.0,-1.0);vUv6=vUv+texelSize*vec2(0.0,-1.0);vUv7=vUv+texelSize*vec2(1.0,-1.0);gl_Position=vec4(position.xy,1.0,1.0);}", jq = class extends Mu {
  constructor() {
    super({
      name: "UpsamplingMaterial",
      uniforms: {
        inputBuffer: new Pn(null),
        supportBuffer: new Pn(null),
        texelSize: new Pn(new zt()),
        radius: new Pn(0.85)
      },
      blending: ff,
      depthWrite: !1,
      depthTest: !1,
      fragmentShader: Gq,
      vertexShader: Wq
    }), this.toneMapped = !1;
  }
  set inputBuffer(a) {
    this.uniforms.inputBuffer.value = a;
  }
  set supportBuffer(a) {
    this.uniforms.supportBuffer.value = a;
  }
  get radius() {
    return this.uniforms.radius.value;
  }
  set radius(a) {
    this.uniforms.radius.value = a;
  }
  setSize(a, e) {
    this.uniforms.texelSize.value.set(1 / a, 1 / e);
  }
}, Yq = new pb(), Qx = null;
function Xq() {
  if (Qx === null) {
    const a = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]), e = new Float32Array([0, 0, 2, 0, 0, 2]);
    Qx = new oi(), Qx.setAttribute !== void 0 ? (Qx.setAttribute("position", new ls(a, 3)), Qx.setAttribute("uv", new ls(e, 2))) : (Qx.addAttribute("position", new ls(a, 3)), Qx.addAttribute("uv", new ls(e, 2)));
  }
  return Qx;
}
var vh = class {
  constructor(a = "Pass", e = new NM(), t = Yq) {
    this.name = a, this.renderer = null, this.scene = e, this.camera = t, this.screen = null, this.rtt = !0, this.needsSwap = !0, this.needsDepthTexture = !1, this.enabled = !0;
  }
  get renderToScreen() {
    return !this.rtt;
  }
  set renderToScreen(a) {
    if (this.rtt === a) {
      const e = this.fullscreenMaterial;
      e !== null && (e.needsUpdate = !0), this.rtt = !a;
    }
  }
  set mainScene(a) {
  }
  set mainCamera(a) {
  }
  setRenderer(a) {
    this.renderer = a;
  }
  isEnabled() {
    return this.enabled;
  }
  setEnabled(a) {
    this.enabled = a;
  }
  get fullscreenMaterial() {
    return this.screen !== null ? this.screen.material : null;
  }
  set fullscreenMaterial(a) {
    let e = this.screen;
    e !== null ? e.material = a : (e = new Fn(Xq(), a), e.frustumCulled = !1, this.scene === null && (this.scene = new NM()), this.scene.add(e), this.screen = e);
  }
  getFullscreenMaterial() {
    return this.fullscreenMaterial;
  }
  setFullscreenMaterial(a) {
    this.fullscreenMaterial = a;
  }
  getDepthTexture() {
    return null;
  }
  setDepthTexture(a, e = o1) {
  }
  render(a, e, t, r, i) {
    throw new Error("Render method not implemented!");
  }
  setSize(a, e) {
  }
  initialize(a, e, t) {
  }
  dispose() {
    for (const a of Object.keys(this)) {
      const e = this[a];
      (e instanceof po || e instanceof hf || e instanceof su || e instanceof vh) && this[a].dispose();
    }
  }
}, C4 = class extends vh {
  constructor(a, e = !0) {
    super("CopyPass"), this.fullscreenMaterial = new T4(), this.needsSwap = !1, this.renderTarget = a, a === void 0 && (this.renderTarget = new po(1, 1, {
      minFilter: Oo,
      magFilter: Oo,
      stencilBuffer: !1,
      depthBuffer: !1
    }), this.renderTarget.texture.name = "CopyPass.Target"), this.autoResize = e;
  }
  get resize() {
    return this.autoResize;
  }
  set resize(a) {
    this.autoResize = a;
  }
  get texture() {
    return this.renderTarget.texture;
  }
  getTexture() {
    return this.renderTarget.texture;
  }
  setAutoResizeEnabled(a) {
    this.autoResize = a;
  }
  render(a, e, t, r, i) {
    this.fullscreenMaterial.inputBuffer = e.texture, a.setRenderTarget(this.renderToScreen ? null : this.renderTarget), a.render(this.scene, this.camera);
  }
  setSize(a, e) {
    this.autoResize && this.renderTarget.setSize(a, e);
  }
  initialize(a, e, t) {
    t !== void 0 && (this.renderTarget.texture.type = t, t !== df ? this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1" : a.outputEncoding === gi && (this.renderTarget.texture.encoding = gi));
  }
}, qq = class extends vh {
  constructor(a, { minLuminance: e = 0.01, adaptationRate: t = 1 } = {}) {
    super("AdaptiveLuminancePass"), this.fullscreenMaterial = new yq(), this.needsSwap = !1, this.renderTargetPrevious = new po(1, 1, {
      minFilter: fo,
      magFilter: fo,
      depthBuffer: !1
    }), this.renderTargetPrevious.texture.name = "Luminance.Previous";
    const r = this.fullscreenMaterial;
    r.luminanceBuffer0 = this.renderTargetPrevious.texture, r.luminanceBuffer1 = a, r.minLuminance = e, r.adaptationRate = t, this.renderTargetAdapted = this.renderTargetPrevious.clone(), this.renderTargetAdapted.texture.name = "Luminance.Adapted", this.copyPass = new C4(this.renderTargetPrevious, !1);
  }
  get texture() {
    return this.renderTargetAdapted.texture;
  }
  getTexture() {
    return this.renderTargetAdapted.texture;
  }
  set mipLevel1x1(a) {
    this.fullscreenMaterial.mipLevel1x1 = a;
  }
  get adaptationRate() {
    return this.fullscreenMaterial.adaptationRate;
  }
  set adaptationRate(a) {
    this.fullscreenMaterial.adaptationRate = a;
  }
  render(a, e, t, r, i) {
    this.fullscreenMaterial.deltaTime = r, a.setRenderTarget(this.renderToScreen ? null : this.renderTargetAdapted), a.render(this.scene, this.camera), this.copyPass.render(a, this.renderTargetAdapted);
  }
}, Qq = class extends vh {
  constructor() {
    super("ClearMaskPass", null, null), this.needsSwap = !1;
  }
  render(a, e, t, r, i) {
    const s = a.state.buffers.stencil;
    s.setLocked(!1), s.setTest(!1);
  }
}, AN = new Un(), IL = class extends vh {
  constructor(a = !0, e = !0, t = !1) {
    super("ClearPass", null, null), this.needsSwap = !1, this.color = a, this.depth = e, this.stencil = t, this.overrideClearColor = null, this.overrideClearAlpha = -1;
  }
  setClearFlags(a, e, t) {
    this.color = a, this.depth = e, this.stencil = t;
  }
  getOverrideClearColor() {
    return this.overrideClearColor;
  }
  setOverrideClearColor(a) {
    this.overrideClearColor = a;
  }
  getOverrideClearAlpha() {
    return this.overrideClearAlpha;
  }
  setOverrideClearAlpha(a) {
    this.overrideClearAlpha = a;
  }
  render(a, e, t, r, i) {
    const s = this.overrideClearColor, l = this.overrideClearAlpha, d = a.getClearAlpha(), p = s !== null, g = l >= 0;
    p ? (a.getClearColor(AN), a.setClearColor(s, g ? l : d)) : g && a.setClearAlpha(l), a.setRenderTarget(this.renderToScreen ? null : e), a.clear(this.color, this.depth, this.stencil), p ? a.setClearColor(AN, d) : g && a.setClearAlpha(d);
  }
}, Zx = -1, $o = class extends Cm {
  constructor(a, e = Zx, t = Zx, r = 1) {
    super(), this.resizable = a, this.baseSize = new zt(1, 1), this.preferredSize = new zt(e, t), this.target = this.preferredSize, this.s = r, this.effectiveSize = new zt(), this.addEventListener("change", () => this.updateEffectiveSize()), this.updateEffectiveSize();
  }
  updateEffectiveSize() {
    const a = this.baseSize, e = this.preferredSize, t = this.effectiveSize, r = this.scale;
    e.width !== Zx ? t.width = e.width : e.height !== Zx ? t.width = Math.round(e.height * (a.width / Math.max(a.height, 1))) : t.width = Math.round(a.width * r), e.height !== Zx ? t.height = e.height : e.width !== Zx ? t.height = Math.round(e.width / Math.max(a.width / Math.max(a.height, 1), 1)) : t.height = Math.round(a.height * r);
  }
  get width() {
    return this.effectiveSize.width;
  }
  set width(a) {
    this.preferredWidth = a;
  }
  get height() {
    return this.effectiveSize.height;
  }
  set height(a) {
    this.preferredHeight = a;
  }
  getWidth() {
    return this.width;
  }
  getHeight() {
    return this.height;
  }
  get scale() {
    return this.s;
  }
  set scale(a) {
    this.s !== a && (this.s = a, this.preferredSize.setScalar(Zx), this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height));
  }
  getScale() {
    return this.scale;
  }
  setScale(a) {
    this.scale = a;
  }
  get baseWidth() {
    return this.baseSize.width;
  }
  set baseWidth(a) {
    this.baseSize.width !== a && (this.baseSize.width = a, this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height));
  }
  getBaseWidth() {
    return this.baseWidth;
  }
  setBaseWidth(a) {
    this.baseWidth = a;
  }
  get baseHeight() {
    return this.baseSize.height;
  }
  set baseHeight(a) {
    this.baseSize.height !== a && (this.baseSize.height = a, this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height));
  }
  getBaseHeight() {
    return this.baseHeight;
  }
  setBaseHeight(a) {
    this.baseHeight = a;
  }
  setBaseSize(a, e) {
    (this.baseSize.width !== a || this.baseSize.height !== e) && (this.baseSize.set(a, e), this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height));
  }
  get preferredWidth() {
    return this.preferredSize.width;
  }
  set preferredWidth(a) {
    this.preferredSize.width !== a && (this.preferredSize.width = a, this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height));
  }
  getPreferredWidth() {
    return this.preferredWidth;
  }
  setPreferredWidth(a) {
    this.preferredWidth = a;
  }
  get preferredHeight() {
    return this.preferredSize.height;
  }
  set preferredHeight(a) {
    this.preferredSize.height !== a && (this.preferredSize.height = a, this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height));
  }
  getPreferredHeight() {
    return this.preferredHeight;
  }
  setPreferredHeight(a) {
    this.preferredHeight = a;
  }
  setPreferredSize(a, e) {
    (this.preferredSize.width !== a || this.preferredSize.height !== e) && (this.preferredSize.set(a, e), this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height));
  }
  copy(a) {
    this.s = a.scale, this.baseSize.set(a.baseWidth, a.baseHeight), this.preferredSize.set(a.preferredWidth, a.preferredHeight), this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.baseSize.width, this.baseSize.height);
  }
  static get AUTO_SIZE() {
    return Zx;
  }
}, BD = !1, DN = class {
  constructor(a = null) {
    this.originalMaterials = /* @__PURE__ */ new Map(), this.material = null, this.materials = null, this.materialsBackSide = null, this.materialsDoubleSide = null, this.materialsFlatShaded = null, this.materialsFlatShadedBackSide = null, this.materialsFlatShadedDoubleSide = null, this.setMaterial(a), this.meshCount = 0, this.replaceMaterial = (e) => {
      if (e.isMesh) {
        let t;
        if (e.material.flatShading)
          switch (e.material.side) {
            case Yh:
              t = this.materialsFlatShadedDoubleSide;
              break;
            case cf:
              t = this.materialsFlatShadedBackSide;
              break;
            default:
              t = this.materialsFlatShaded;
              break;
          }
        else
          switch (e.material.side) {
            case Yh:
              t = this.materialsDoubleSide;
              break;
            case cf:
              t = this.materialsBackSide;
              break;
            default:
              t = this.materials;
              break;
          }
        this.originalMaterials.set(e, e.material), e.isSkinnedMesh ? e.material = t[2] : e.isInstancedMesh ? e.material = t[1] : e.material = t[0], ++this.meshCount;
      }
    };
  }
  setMaterial(a) {
    if (this.disposeMaterials(), this.material = a, a !== null) {
      const e = this.materials = [
        a.clone(),
        a.clone(),
        a.clone()
      ];
      for (const t of e)
        t.uniforms = Object.assign({}, a.uniforms), t.side = vy;
      e[2].skinning = !0, this.materialsBackSide = e.map((t) => {
        const r = t.clone();
        return r.uniforms = Object.assign({}, a.uniforms), r.side = cf, r;
      }), this.materialsDoubleSide = e.map((t) => {
        const r = t.clone();
        return r.uniforms = Object.assign({}, a.uniforms), r.side = Yh, r;
      }), this.materialsFlatShaded = e.map((t) => {
        const r = t.clone();
        return r.uniforms = Object.assign({}, a.uniforms), r.flatShading = !0, r;
      }), this.materialsFlatShadedBackSide = e.map((t) => {
        const r = t.clone();
        return r.uniforms = Object.assign({}, a.uniforms), r.flatShading = !0, r.side = cf, r;
      }), this.materialsFlatShadedDoubleSide = e.map((t) => {
        const r = t.clone();
        return r.uniforms = Object.assign({}, a.uniforms), r.flatShading = !0, r.side = Yh, r;
      });
    }
  }
  render(a, e, t) {
    const r = a.shadowMap.enabled;
    if (a.shadowMap.enabled = !1, BD) {
      const i = this.originalMaterials;
      this.meshCount = 0, e.traverse(this.replaceMaterial), a.render(e, t);
      for (const s of i)
        s[0].material = s[1];
      this.meshCount !== i.size && i.clear();
    } else {
      const i = e.overrideMaterial;
      e.overrideMaterial = this.material, a.render(e, t), e.overrideMaterial = i;
    }
    a.shadowMap.enabled = r;
  }
  disposeMaterials() {
    if (this.material !== null) {
      const a = this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);
      for (const e of a)
        e.dispose();
    }
  }
  dispose() {
    this.originalMaterials.clear(), this.disposeMaterials();
  }
  static get workaroundEnabled() {
    return BD;
  }
  static set workaroundEnabled(a) {
    BD = a;
  }
}, rR = class extends vh {
  constructor(a, e, t = null) {
    super("RenderPass", a, e), this.needsSwap = !1, this.clearPass = new IL(), this.overrideMaterialManager = t === null ? null : new DN(t), this.ignoreBackground = !1, this.skipShadowMapUpdate = !1, this.selection = null;
  }
  set mainScene(a) {
    this.scene = a;
  }
  set mainCamera(a) {
    this.camera = a;
  }
  get renderToScreen() {
    return super.renderToScreen;
  }
  set renderToScreen(a) {
    super.renderToScreen = a, this.clearPass.renderToScreen = a;
  }
  get overrideMaterial() {
    const a = this.overrideMaterialManager;
    return a !== null ? a.material : null;
  }
  set overrideMaterial(a) {
    const e = this.overrideMaterialManager;
    a !== null ? e !== null ? e.setMaterial(a) : this.overrideMaterialManager = new DN(a) : e !== null && (e.dispose(), this.overrideMaterialManager = null);
  }
  getOverrideMaterial() {
    return this.overrideMaterial;
  }
  setOverrideMaterial(a) {
    this.overrideMaterial = a;
  }
  get clear() {
    return this.clearPass.enabled;
  }
  set clear(a) {
    this.clearPass.enabled = a;
  }
  getSelection() {
    return this.selection;
  }
  setSelection(a) {
    this.selection = a;
  }
  isBackgroundDisabled() {
    return this.ignoreBackground;
  }
  setBackgroundDisabled(a) {
    this.ignoreBackground = a;
  }
  isShadowMapDisabled() {
    return this.skipShadowMapUpdate;
  }
  setShadowMapDisabled(a) {
    this.skipShadowMapUpdate = a;
  }
  getClearPass() {
    return this.clearPass;
  }
  render(a, e, t, r, i) {
    const s = this.scene, l = this.camera, d = this.selection, p = l.layers.mask, g = s.background, _ = a.shadowMap.autoUpdate, w = this.renderToScreen ? null : e;
    d !== null && l.layers.set(d.getLayer()), this.skipShadowMapUpdate && (a.shadowMap.autoUpdate = !1), (this.ignoreBackground || this.clearPass.overrideClearColor !== null) && (s.background = null), this.clearPass.enabled && this.clearPass.render(a, e), a.setRenderTarget(w), this.overrideMaterialManager !== null ? this.overrideMaterialManager.render(a, s, l) : a.render(s, l), l.layers.mask = p, s.background = g, a.shadowMap.autoUpdate = _;
  }
}, Zq = class extends vh {
  constructor(a, e, {
    renderTarget: t,
    resolutionScale: r = 1,
    width: i = $o.AUTO_SIZE,
    height: s = $o.AUTO_SIZE,
    resolutionX: l = i,
    resolutionY: d = s
  } = {}) {
    super("DepthPass"), this.needsSwap = !1, this.renderPass = new rR(a, e, new tT({
      depthPacking: Jw
    }));
    const p = this.renderPass;
    p.skipShadowMapUpdate = !0, p.ignoreBackground = !0;
    const g = p.getClearPass();
    g.overrideClearColor = new Un(16777215), g.overrideClearAlpha = 1, this.renderTarget = t, this.renderTarget === void 0 && (this.renderTarget = new po(1, 1, {
      minFilter: fo,
      magFilter: fo
    }), this.renderTarget.texture.name = "DepthPass.Target");
    const _ = this.resolution = new $o(this, l, d, r);
    _.addEventListener("change", (w) => this.setSize(_.baseWidth, _.baseHeight));
  }
  set mainScene(a) {
    this.renderPass.mainScene = a;
  }
  set mainCamera(a) {
    this.renderPass.mainCamera = a;
  }
  get texture() {
    return this.renderTarget.texture;
  }
  getTexture() {
    return this.renderTarget.texture;
  }
  getResolution() {
    return this.resolution;
  }
  getResolutionScale() {
    return this.resolution.scale;
  }
  setResolutionScale(a) {
    this.resolution.scale = a;
  }
  render(a, e, t, r, i) {
    const s = this.renderToScreen ? null : this.renderTarget;
    this.renderPass.render(a, s);
  }
  setSize(a, e) {
    const t = this.resolution;
    t.setBaseSize(a, e), this.renderTarget.setSize(t.width, t.height);
  }
}, Jq = class extends vh {
  constructor({
    normalBuffer: a = null,
    resolutionScale: e = 0.5,
    width: t = $o.AUTO_SIZE,
    height: r = $o.AUTO_SIZE,
    resolutionX: i = t,
    resolutionY: s = r
  } = {}) {
    super("DepthDownsamplingPass");
    const l = new Rq();
    l.normalBuffer = a, this.fullscreenMaterial = l, this.needsDepthTexture = !0, this.needsSwap = !1, this.renderTarget = new po(1, 1, {
      minFilter: fo,
      magFilter: fo,
      depthBuffer: !1,
      type: fy
    }), this.renderTarget.texture.name = "DepthDownsamplingPass.Target", this.renderTarget.texture.generateMipmaps = !1;
    const d = this.resolution = new $o(this, i, s, e);
    d.addEventListener("change", (p) => this.setSize(d.baseWidth, d.baseHeight));
  }
  get texture() {
    return this.renderTarget.texture;
  }
  getTexture() {
    return this.renderTarget.texture;
  }
  getResolution() {
    return this.resolution;
  }
  setDepthTexture(a, e = o1) {
    this.fullscreenMaterial.depthBuffer = a, this.fullscreenMaterial.depthPacking = e;
  }
  render(a, e, t, r, i) {
    a.setRenderTarget(this.renderToScreen ? null : this.renderTarget), a.render(this.scene, this.camera);
  }
  setSize(a, e) {
    const t = this.resolution;
    t.setBaseSize(a, e), this.renderTarget.setSize(t.width, t.height), this.fullscreenMaterial.setSize(a, e);
  }
  initialize(a, e, t) {
    const r = a.getContext();
    if (!(r.getExtension("EXT_color_buffer_float") || r.getExtension("EXT_color_buffer_half_float")))
      throw new Error("Rendering to float texture is not supported.");
  }
};
function LN(a, e, t) {
  for (const r of e) {
    const i = "$1" + a + r.charAt(0).toUpperCase() + r.slice(1), s = new RegExp("([^\\.])(\\b" + r + "\\b)", "g");
    for (const l of t.entries())
      l[1] !== null && t.set(l[0], l[1].replace(s, i));
  }
}
function Kq(a, e, t) {
  var r, i, s, l, d;
  let p = e.getFragmentShader(), g = e.getVertexShader();
  const _ = p !== void 0 && /mainImage/.test(p), w = p !== void 0 && /mainUv/.test(p);
  if (t.attributes |= e.getAttributes(), p === void 0)
    throw new Error(`Missing fragment shader (${e.name})`);
  if (w && (t.attributes & e1.CONVOLUTION) !== 0)
    throw new Error(`Effects that transform UVs are incompatible with convolution effects (${e.name})`);
  if (!_ && !w)
    throw new Error(`Could not find mainImage or mainUv function (${e.name})`);
  {
    const T = /\w+\s+(\w+)\([\w\s,]*\)\s*{/g, R = t.shaderParts;
    let D = (r = R.get(ss.FRAGMENT_HEAD)) != null ? r : "", O = (i = R.get(ss.FRAGMENT_MAIN_UV)) != null ? i : "", U = (s = R.get(ss.FRAGMENT_MAIN_IMAGE)) != null ? s : "", H = (l = R.get(ss.VERTEX_HEAD)) != null ? l : "", I = (d = R.get(ss.VERTEX_MAIN_SUPPORT)) != null ? d : "";
    const G = /* @__PURE__ */ new Set(), B = /* @__PURE__ */ new Set();
    if (w && (O += `	${a}MainUv(UV);
`, t.uvTransformation = !0), g !== null && /mainSupport/.test(g)) {
      const te = /mainSupport *\([\w\s]*?uv\s*?\)/.test(g);
      I += `	${a}MainSupport(`, I += te ? `vUv);
` : `);
`;
      for (const Y of g.matchAll(/(?:varying\s+\w+\s+([\S\s]*?);)/g))
        for (const re of Y[1].split(/\s*,\s*/))
          t.varyings.add(re), G.add(re), B.add(re);
      for (const Y of g.matchAll(T))
        B.add(Y[1]);
    }
    for (const te of p.matchAll(T))
      B.add(te[1]);
    for (const te of e.defines.keys())
      B.add(te.replace(/\([\w\s,]*\)/g, ""));
    for (const te of e.uniforms.keys())
      B.add(te);
    B.delete("while"), B.delete("for"), B.delete("if"), e.uniforms.forEach((te, Y) => t.uniforms.set(a + Y.charAt(0).toUpperCase() + Y.slice(1), te)), e.defines.forEach((te, Y) => t.defines.set(a + Y.charAt(0).toUpperCase() + Y.slice(1), te));
    const Q = /* @__PURE__ */ new Map([["fragment", p], ["vertex", g]]);
    LN(a, B, t.defines), LN(a, B, Q), p = Q.get("fragment"), g = Q.get("vertex");
    const K = e.blendMode;
    if (t.blendModes.set(K.blendFunction, K), _) {
      e.inputColorSpace !== null && e.inputColorSpace !== t.colorSpace && (U += e.inputColorSpace === gi ? `color0 = LinearTosRGB(color0);
	` : `color0 = sRGBToLinear(color0);
	`), e.outputColorSpace !== null ? t.colorSpace = e.outputColorSpace : e.inputColorSpace !== null && (t.colorSpace = e.inputColorSpace);
      const te = /MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;
      U += `${a}MainImage(color0, UV, `, (t.attributes & e1.DEPTH) !== 0 && te.test(p) && (U += "depth, ", t.readDepth = !0), U += `color1);
	`;
      const Y = a + "BlendOpacity";
      t.uniforms.set(Y, K.opacity), U += `color0 = blend${K.blendFunction}(color0, color1, ${Y});

	`, D += `uniform float ${Y};

`;
    }
    if (D += p + `
`, g !== null && (H += g + `
`), R.set(ss.FRAGMENT_HEAD, D), R.set(ss.FRAGMENT_MAIN_UV, O), R.set(ss.FRAGMENT_MAIN_IMAGE, U), R.set(ss.VERTEX_HEAD, H), R.set(ss.VERTEX_MAIN_SUPPORT, I), e.extensions !== null)
      for (const te of e.extensions)
        t.extensions.add(te);
  }
}
var $q = class extends vh {
  constructor(a, ...e) {
    super("EffectPass"), this.fullscreenMaterial = new Uq(null, null, null, a), this.listener = (t) => this.handleEvent(t), this.effects = [], this.setEffects(e), this.skipRendering = !1, this.minTime = 1, this.maxTime = Number.POSITIVE_INFINITY, this.timeScale = 1;
  }
  set mainScene(a) {
    for (const e of this.effects)
      e.mainScene = a;
  }
  set mainCamera(a) {
    this.fullscreenMaterial.copyCameraSettings(a);
    for (const e of this.effects)
      e.mainCamera = a;
  }
  get encodeOutput() {
    return this.fullscreenMaterial.encodeOutput;
  }
  set encodeOutput(a) {
    this.fullscreenMaterial.encodeOutput = a;
  }
  get dithering() {
    return this.fullscreenMaterial.dithering;
  }
  set dithering(a) {
    const e = this.fullscreenMaterial;
    e.dithering = a, e.needsUpdate = !0;
  }
  setEffects(a) {
    for (const e of this.effects)
      e.removeEventListener("change", this.listener);
    this.effects = a.sort((e, t) => t.attributes - e.attributes);
    for (const e of this.effects)
      e.addEventListener("change", this.listener);
  }
  updateMaterial() {
    const a = new lQ();
    let e = 0;
    for (const l of this.effects)
      if (l.blendMode.blendFunction === ri.DST)
        a.attributes |= l.getAttributes() & e1.DEPTH;
      else {
        if ((a.attributes & l.getAttributes() & e1.CONVOLUTION) !== 0)
          throw new Error(`Convolution effects cannot be merged (${l.name})`);
        Kq("e" + e++, l, a);
      }
    let t = a.shaderParts.get(ss.FRAGMENT_HEAD), r = a.shaderParts.get(ss.FRAGMENT_MAIN_IMAGE), i = a.shaderParts.get(ss.FRAGMENT_MAIN_UV);
    const s = /\bblend\b/g;
    for (const l of a.blendModes.values())
      t += l.getShaderCode().replace(s, `blend${l.blendFunction}`) + `
`;
    (a.attributes & e1.DEPTH) !== 0 ? (a.readDepth && (r = `float depth = readDepth(UV);

	` + r), this.needsDepthTexture = this.getDepthTexture() === null) : this.needsDepthTexture = !1, a.colorSpace === gi && (r += `color0 = sRGBToLinear(color0);
	`), a.uvTransformation ? (i = `vec2 transformedUv = vUv;
` + i, a.defines.set("UV", "transformedUv")) : a.defines.set("UV", "vUv"), a.shaderParts.set(ss.FRAGMENT_HEAD, t), a.shaderParts.set(ss.FRAGMENT_MAIN_IMAGE, r), a.shaderParts.set(ss.FRAGMENT_MAIN_UV, i), a.shaderParts.forEach((l, d, p) => p.set(d, l == null ? void 0 : l.trim().replace(/^#/, `
#`))), this.skipRendering = e === 0, this.needsSwap = !this.skipRendering, this.fullscreenMaterial.setShaderData(a);
  }
  recompile() {
    this.updateMaterial();
  }
  getDepthTexture() {
    return this.fullscreenMaterial.depthBuffer;
  }
  setDepthTexture(a, e = o1) {
    this.fullscreenMaterial.depthBuffer = a, this.fullscreenMaterial.depthPacking = e;
    for (const t of this.effects)
      t.setDepthTexture(a, e);
  }
  render(a, e, t, r, i) {
    for (const s of this.effects)
      s.update(a, e, r);
    if (!this.skipRendering || this.renderToScreen) {
      const s = this.fullscreenMaterial;
      s.inputBuffer = e.texture, s.time += r * this.timeScale, a.setRenderTarget(this.renderToScreen ? null : t), a.render(this.scene, this.camera);
    }
  }
  setSize(a, e) {
    this.fullscreenMaterial.setSize(a, e);
    for (const t of this.effects)
      t.setSize(a, e);
  }
  initialize(a, e, t) {
    this.renderer = a;
    for (const r of this.effects)
      r.initialize(a, e, t);
    this.updateMaterial(), t !== void 0 && t !== df && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1");
  }
  dispose() {
    super.dispose();
    for (const a of this.effects)
      a.removeEventListener("change", this.listener), a.dispose();
  }
  handleEvent(a) {
    switch (a.type) {
      case "change":
        this.recompile();
        break;
    }
  }
}, BL = class extends vh {
  constructor({
    kernelSize: a = nS.MEDIUM,
    resolutionScale: e = 0.5,
    width: t = $o.AUTO_SIZE,
    height: r = $o.AUTO_SIZE,
    resolutionX: i = t,
    resolutionY: s = r
  } = {}) {
    super("KawaseBlurPass"), this.renderTargetA = new po(1, 1, { depthBuffer: !1 }), this.renderTargetA.texture.name = "Blur.Target.A", this.renderTargetB = this.renderTargetA.clone(), this.renderTargetB.texture.name = "Blur.Target.B";
    const l = this.resolution = new $o(this, i, s, e);
    l.addEventListener("change", (d) => this.setSize(l.baseWidth, l.baseHeight)), this._blurMaterial = new M4(), this._blurMaterial.kernelSize = a, this.copyMaterial = new T4();
  }
  getResolution() {
    return this.resolution;
  }
  get blurMaterial() {
    return this._blurMaterial;
  }
  set blurMaterial(a) {
    this._blurMaterial = a;
  }
  get dithering() {
    return this.copyMaterial.dithering;
  }
  set dithering(a) {
    this.copyMaterial.dithering = a;
  }
  get kernelSize() {
    return this.blurMaterial.kernelSize;
  }
  set kernelSize(a) {
    this.blurMaterial.kernelSize = a;
  }
  get width() {
    return this.resolution.width;
  }
  set width(a) {
    this.resolution.preferredWidth = a;
  }
  get height() {
    return this.resolution.height;
  }
  set height(a) {
    this.resolution.preferredHeight = a;
  }
  get scale() {
    return this.blurMaterial.scale;
  }
  set scale(a) {
    this.blurMaterial.scale = a;
  }
  getScale() {
    return this.blurMaterial.scale;
  }
  setScale(a) {
    this.blurMaterial.scale = a;
  }
  getKernelSize() {
    return this.kernelSize;
  }
  setKernelSize(a) {
    this.kernelSize = a;
  }
  getResolutionScale() {
    return this.resolution.scale;
  }
  setResolutionScale(a) {
    this.resolution.scale = a;
  }
  render(a, e, t, r, i) {
    const s = this.scene, l = this.camera, d = this.renderTargetA, p = this.renderTargetB, g = this.blurMaterial, _ = g.kernelSequence;
    let w = e;
    this.fullscreenMaterial = g;
    for (let T = 0, R = _.length; T < R; ++T) {
      const D = (T & 1) === 0 ? d : p;
      g.kernel = _[T], g.inputBuffer = w.texture, a.setRenderTarget(D), a.render(s, l), w = D;
    }
    this.fullscreenMaterial = this.copyMaterial, this.copyMaterial.inputBuffer = w.texture, a.setRenderTarget(this.renderToScreen ? null : t), a.render(s, l);
  }
  setSize(a, e) {
    const t = this.resolution;
    t.setBaseSize(a, e);
    const r = t.width, i = t.height;
    this.renderTargetA.setSize(r, i), this.renderTargetB.setSize(r, i), this.blurMaterial.setSize(a, e);
  }
  initialize(a, e, t) {
    t !== void 0 && (this.renderTargetA.texture.type = t, this.renderTargetB.texture.type = t, t !== df ? (this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1", this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1") : a.outputEncoding === gi && (this.renderTargetA.texture.encoding = gi, this.renderTargetB.texture.encoding = gi));
  }
  static get AUTO_SIZE() {
    return $o.AUTO_SIZE;
  }
}, R4 = class extends vh {
  constructor({
    renderTarget: a,
    luminanceRange: e,
    colorOutput: t,
    resolutionScale: r = 1,
    width: i = $o.AUTO_SIZE,
    height: s = $o.AUTO_SIZE,
    resolutionX: l = i,
    resolutionY: d = s
  } = {}) {
    super("LuminancePass"), this.fullscreenMaterial = new Nq(t, e), this.needsSwap = !1, this.renderTarget = a, this.renderTarget === void 0 && (this.renderTarget = new po(1, 1, { depthBuffer: !1 }), this.renderTarget.texture.name = "LuminancePass.Target");
    const p = this.resolution = new $o(this, l, d, r);
    p.addEventListener("change", (g) => this.setSize(p.baseWidth, p.baseHeight));
  }
  get texture() {
    return this.renderTarget.texture;
  }
  getTexture() {
    return this.renderTarget.texture;
  }
  getResolution() {
    return this.resolution;
  }
  render(a, e, t, r, i) {
    const s = this.fullscreenMaterial;
    s.inputBuffer = e.texture, a.setRenderTarget(this.renderToScreen ? null : this.renderTarget), a.render(this.scene, this.camera);
  }
  setSize(a, e) {
    const t = this.resolution;
    t.setBaseSize(a, e), this.renderTarget.setSize(t.width, t.height);
  }
  initialize(a, e, t) {
    t !== void 0 && t !== df && (this.renderTarget.texture.type = t, this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1");
  }
}, eQ = class extends vh {
  constructor(a, e) {
    super("MaskPass", a, e), this.needsSwap = !1, this.clearPass = new IL(!1, !1, !0), this.inverse = !1;
  }
  set mainScene(a) {
    this.scene = a;
  }
  set mainCamera(a) {
    this.camera = a;
  }
  get inverted() {
    return this.inverse;
  }
  set inverted(a) {
    this.inverse = a;
  }
  get clear() {
    return this.clearPass.enabled;
  }
  set clear(a) {
    this.clearPass.enabled = a;
  }
  getClearPass() {
    return this.clearPass;
  }
  isInverted() {
    return this.inverted;
  }
  setInverted(a) {
    this.inverted = a;
  }
  render(a, e, t, r, i) {
    const s = a.getContext(), l = a.state.buffers, d = this.scene, p = this.camera, g = this.clearPass, _ = this.inverted ? 0 : 1, w = 1 - _;
    l.color.setMask(!1), l.depth.setMask(!1), l.color.setLocked(!0), l.depth.setLocked(!0), l.stencil.setTest(!0), l.stencil.setOp(s.REPLACE, s.REPLACE, s.REPLACE), l.stencil.setFunc(s.ALWAYS, _, 4294967295), l.stencil.setClear(w), l.stencil.setLocked(!0), this.clearPass.enabled && (this.renderToScreen ? g.render(a, null) : (g.render(a, e), g.render(a, t))), this.renderToScreen ? (a.setRenderTarget(null), a.render(d, p)) : (a.setRenderTarget(e), a.render(d, p), a.setRenderTarget(t), a.render(d, p)), l.color.setLocked(!1), l.depth.setLocked(!1), l.stencil.setLocked(!1), l.stencil.setFunc(s.EQUAL, 1, 4294967295), l.stencil.setOp(s.KEEP, s.KEEP, s.KEEP), l.stencil.setLocked(!0);
  }
}, tQ = class extends vh {
  constructor() {
    super("MipmapBlurPass"), this.needsSwap = !1, this.renderTarget = new po(1, 1, { depthBuffer: !1 }), this.renderTarget.texture.name = "Upsampling.Mipmap0", this.downsamplingMipmaps = [], this.upsamplingMipmaps = [], this.downsamplingMaterial = new Lq(), this.upsamplingMaterial = new jq(), this.resolution = new zt();
  }
  get texture() {
    return this.renderTarget.texture;
  }
  get levels() {
    return this.downsamplingMipmaps.length;
  }
  set levels(a) {
    if (this.levels !== a) {
      const e = this.renderTarget;
      this.dispose(), this.downsamplingMipmaps = [], this.upsamplingMipmaps = [];
      for (let t = 0; t < a; ++t) {
        const r = e.clone();
        r.texture.name = "Downsampling.Mipmap" + t, this.downsamplingMipmaps.push(r);
      }
      this.upsamplingMipmaps.push(e);
      for (let t = 1, r = a - 1; t < r; ++t) {
        const i = e.clone();
        i.texture.name = "Upsampling.Mipmap" + t, this.upsamplingMipmaps.push(i);
      }
      this.setSize(this.resolution.x, this.resolution.y);
    }
  }
  get radius() {
    return this.upsamplingMaterial.radius;
  }
  set radius(a) {
    this.upsamplingMaterial.radius = a;
  }
  render(a, e, t, r, i) {
    const { scene: s, camera: l } = this, { downsamplingMaterial: d, upsamplingMaterial: p } = this, { downsamplingMipmaps: g, upsamplingMipmaps: _ } = this;
    let w = e;
    this.fullscreenMaterial = d;
    for (let T = 0, R = g.length; T < R; ++T) {
      const D = g[T];
      d.setSize(w.width, w.height), d.inputBuffer = w.texture, a.setRenderTarget(D), a.render(s, l), w = D;
    }
    this.fullscreenMaterial = p;
    for (let T = _.length - 1; T >= 0; --T) {
      const R = _[T];
      p.setSize(w.width, w.height), p.inputBuffer = w.texture, p.supportBuffer = g[T].texture, a.setRenderTarget(R), a.render(s, l), w = R;
    }
  }
  setSize(a, e) {
    const t = this.resolution;
    t.set(a, e);
    let r = t.width, i = t.height;
    for (let s = 0, l = this.downsamplingMipmaps.length; s < l; ++s)
      r = Math.round(r * 0.5), i = Math.round(i * 0.5), this.downsamplingMipmaps[s].setSize(r, i), s < this.upsamplingMipmaps.length && this.upsamplingMipmaps[s].setSize(r, i);
  }
  initialize(a, e, t) {
    if (t !== void 0) {
      const r = this.downsamplingMipmaps.concat(this.upsamplingMipmaps);
      for (const i of r)
        i.texture.type = t;
      if (t !== df)
        this.downsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1", this.upsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
      else if (a.outputEncoding === gi)
        for (const i of r)
          i.texture.encoding = gi;
    }
  }
  dispose() {
    super.dispose();
    for (const a of this.downsamplingMipmaps.concat(this.upsamplingMipmaps))
      a.dispose();
  }
}, nQ = class extends vh {
  constructor(a, e, {
    renderTarget: t,
    resolutionScale: r = 1,
    width: i = $o.AUTO_SIZE,
    height: s = $o.AUTO_SIZE,
    resolutionX: l = i,
    resolutionY: d = s
  } = {}) {
    super("NormalPass"), this.needsSwap = !1, this.renderPass = new rR(a, e, new uL());
    const p = this.renderPass;
    p.ignoreBackground = !0, p.skipShadowMapUpdate = !0;
    const g = p.getClearPass();
    g.overrideClearColor = new Un(7829503), g.overrideClearAlpha = 1, this.renderTarget = t, this.renderTarget === void 0 && (this.renderTarget = new po(1, 1, {
      minFilter: fo,
      magFilter: fo
    }), this.renderTarget.texture.name = "NormalPass.Target");
    const _ = this.resolution = new $o(this, l, d, r);
    _.addEventListener("change", (w) => this.setSize(_.baseWidth, _.baseHeight));
  }
  set mainScene(a) {
    this.renderPass.mainScene = a;
  }
  set mainCamera(a) {
    this.renderPass.mainCamera = a;
  }
  get texture() {
    return this.renderTarget.texture;
  }
  getTexture() {
    return this.renderTarget.texture;
  }
  getResolution() {
    return this.resolution;
  }
  getResolutionScale() {
    return this.resolution.scale;
  }
  setResolutionScale(a) {
    this.resolution.scale = a;
  }
  render(a, e, t, r, i) {
    const s = this.renderToScreen ? null : this.renderTarget;
    this.renderPass.render(a, s, s);
  }
  setSize(a, e) {
    const t = this.resolution;
    t.setBaseSize(a, e), this.renderTarget.setSize(t.width, t.height);
  }
}, rQ = class extends vh {
  constructor(a, e = "inputBuffer") {
    super("ShaderPass"), this.fullscreenMaterial = a, this.input = e;
  }
  setInput(a) {
    this.input = a;
  }
  render(a, e, t, r, i) {
    const s = this.fullscreenMaterial.uniforms;
    e !== null && s !== void 0 && s[this.input] !== void 0 && (s[this.input].value = e.texture), a.setRenderTarget(this.renderToScreen ? null : t), a.render(this.scene, this.camera);
  }
  initialize(a, e, t) {
    t !== void 0 && t !== df && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1");
  }
}, iQ = class extends BL {
  constructor({
    offset: a = 0,
    rotation: e = 0,
    focusArea: t = 0.4,
    feather: r = 0.3,
    kernelSize: i = nS.MEDIUM,
    resolutionScale: s = 0.5,
    resolutionX: l = $o.AUTO_SIZE,
    resolutionY: d = $o.AUTO_SIZE
  } = {}) {
    super({ kernelSize: i, resolutionScale: s, resolutionX: l, resolutionY: d }), this.blurMaterial = new Vq({ kernelSize: i, offset: a, rotation: e, focusArea: t, feather: r });
  }
}, HD = 1 / 1e3, aQ = 1e3, sQ = class {
  constructor() {
    this.previousTime = 0, this.currentTime = 0, this._delta = 0, this._elapsed = 0, this._fixedDelta = 1e3 / 60, this.timescale = 1, this.useFixedDelta = !1, this._autoReset = !1;
  }
  get autoReset() {
    return this._autoReset;
  }
  set autoReset(a) {
    typeof document < "u" && document.hidden !== void 0 && (a ? document.addEventListener("visibilitychange", this) : document.removeEventListener("visibilitychange", this), this._autoReset = a);
  }
  get delta() {
    return this._delta * HD;
  }
  get fixedDelta() {
    return this._fixedDelta * HD;
  }
  set fixedDelta(a) {
    this._fixedDelta = a * aQ;
  }
  get elapsed() {
    return this._elapsed * HD;
  }
  update(a) {
    this.useFixedDelta ? this._delta = this.fixedDelta : (this.previousTime = this.currentTime, this.currentTime = a !== void 0 ? a : performance.now(), this._delta = this.currentTime - this.previousTime), this._delta *= this.timescale, this._elapsed += this._delta;
  }
  reset() {
    this._delta = 0, this._elapsed = 0, this.currentTime = performance.now();
  }
  handleEvent(a) {
    document.hidden || (this.currentTime = performance.now());
  }
  dispose() {
    this.autoReset = !1;
  }
}, oQ = class {
  constructor(a = null, {
    depthBuffer: e = !0,
    stencilBuffer: t = !1,
    multisampling: r = 0,
    frameBufferType: i
  } = {}) {
    this.renderer = null, this.inputBuffer = this.createBuffer(e, t, i, r), this.outputBuffer = this.inputBuffer.clone(), this.copyPass = new C4(), this.depthTexture = null, this.passes = [], this.timer = new sQ(), this.autoRenderToScreen = !0, this.setRenderer(a);
  }
  get multisampling() {
    return this.inputBuffer.samples || 0;
  }
  set multisampling(a) {
    const e = this.inputBuffer, t = this.multisampling;
    t > 0 && a > 0 ? (this.inputBuffer.samples = a, this.outputBuffer.samples = a, this.inputBuffer.dispose(), this.outputBuffer.dispose()) : t !== a && (this.inputBuffer.dispose(), this.outputBuffer.dispose(), this.inputBuffer = this.createBuffer(
      e.depthBuffer,
      e.stencilBuffer,
      e.texture.type,
      a
    ), this.inputBuffer.depthTexture = this.depthTexture, this.outputBuffer = this.inputBuffer.clone());
  }
  getTimer() {
    return this.timer;
  }
  getRenderer() {
    return this.renderer;
  }
  setRenderer(a) {
    if (this.renderer = a, a !== null) {
      const e = a.getSize(new zt()), t = a.getContext().getContextAttributes().alpha, r = this.inputBuffer.texture.type;
      r === df && a.outputEncoding === gi && (this.inputBuffer.texture.encoding = gi, this.outputBuffer.texture.encoding = gi, this.inputBuffer.dispose(), this.outputBuffer.dispose()), a.autoClear = !1, this.setSize(e.width, e.height);
      for (const i of this.passes)
        i.initialize(a, t, r);
    }
  }
  replaceRenderer(a, e = !0) {
    const t = this.renderer, r = t.domElement.parentNode;
    return this.setRenderer(a), e && r !== null && (r.removeChild(t.domElement), r.appendChild(a.domElement)), t;
  }
  createDepthTexture() {
    const a = this.depthTexture = new K3();
    return this.inputBuffer.depthTexture = a, this.inputBuffer.dispose(), this.inputBuffer.stencilBuffer ? (a.format = r1, a.type = Kx) : a.type = L0, a;
  }
  deleteDepthTexture() {
    if (this.depthTexture !== null) {
      this.depthTexture.dispose(), this.depthTexture = null, this.inputBuffer.depthTexture = null, this.inputBuffer.dispose();
      for (const a of this.passes)
        a.setDepthTexture(null);
    }
  }
  createBuffer(a, e, t, r) {
    const i = this.renderer, s = i === null ? new zt() : i.getDrawingBufferSize(new zt()), l = {
      minFilter: Oo,
      magFilter: Oo,
      stencilBuffer: e,
      depthBuffer: a,
      type: t
    }, d = new po(s.width, s.height, l);
    return r > 0 && (d.ignoreDepthForMultisampleCopy = !1, d.samples = r), t === df && i !== null && i.outputEncoding === gi && (d.texture.encoding = gi), d.texture.name = "EffectComposer.Buffer", d.texture.generateMipmaps = !1, d;
  }
  setMainScene(a) {
    for (const e of this.passes)
      e.mainScene = a;
  }
  setMainCamera(a) {
    for (const e of this.passes)
      e.mainCamera = a;
  }
  addPass(a, e) {
    const t = this.passes, r = this.renderer, i = r.getDrawingBufferSize(new zt()), s = r.getContext().getContextAttributes().alpha, l = this.inputBuffer.texture.type;
    if (a.setRenderer(r), a.setSize(i.width, i.height), a.initialize(r, s, l), this.autoRenderToScreen && (t.length > 0 && (t[t.length - 1].renderToScreen = !1), a.renderToScreen && (this.autoRenderToScreen = !1)), e !== void 0 ? t.splice(e, 0, a) : t.push(a), this.autoRenderToScreen && (t[t.length - 1].renderToScreen = !0), a.needsDepthTexture || this.depthTexture !== null)
      if (this.depthTexture === null) {
        const d = this.createDepthTexture();
        for (a of t)
          a.setDepthTexture(d);
      } else
        a.setDepthTexture(this.depthTexture);
  }
  removePass(a) {
    const e = this.passes, t = e.indexOf(a);
    if (t !== -1 && e.splice(t, 1).length > 0) {
      if (this.depthTexture !== null) {
        const s = (d, p) => d || p.needsDepthTexture;
        e.reduce(s, !1) || (a.getDepthTexture() === this.depthTexture && a.setDepthTexture(null), this.deleteDepthTexture());
      }
      this.autoRenderToScreen && t === e.length && (a.renderToScreen = !1, e.length > 0 && (e[e.length - 1].renderToScreen = !0));
    }
  }
  removeAllPasses() {
    const a = this.passes;
    this.deleteDepthTexture(), a.length > 0 && (this.autoRenderToScreen && (a[a.length - 1].renderToScreen = !1), this.passes = []);
  }
  render(a) {
    const e = this.renderer, t = this.copyPass;
    let r = this.inputBuffer, i = this.outputBuffer, s = !1, l, d, p;
    a === void 0 && (this.timer.update(), a = this.timer.delta);
    for (const g of this.passes)
      g.enabled && (g.render(e, r, i, a, s), g.needsSwap && (s && (t.renderToScreen = g.renderToScreen, l = e.getContext(), d = e.state.buffers.stencil, d.setFunc(l.NOTEQUAL, 1, 4294967295), t.render(e, r, i, a, s), d.setFunc(l.EQUAL, 1, 4294967295)), p = r, r = i, i = p), g instanceof eQ ? s = !0 : g instanceof Qq && (s = !1));
  }
  setSize(a, e, t) {
    const r = this.renderer, i = r.getSize(new zt());
    (a === void 0 || e === void 0) && (a = i.width, e = i.height), (i.width !== a || i.height !== e) && r.setSize(a, e, t);
    const s = r.getDrawingBufferSize(new zt());
    this.inputBuffer.setSize(s.width, s.height), this.outputBuffer.setSize(s.width, s.height);
    for (const l of this.passes)
      l.setSize(s.width, s.height);
  }
  reset() {
    const a = this.timer.autoReset;
    this.dispose(), this.autoRenderToScreen = !0, this.timer.autoReset = a;
  }
  dispose() {
    for (const a of this.passes)
      a.dispose();
    this.passes = [], this.inputBuffer !== null && this.inputBuffer.dispose(), this.outputBuffer !== null && this.outputBuffer.dispose(), this.deleteDepthTexture(), this.copyPass.dispose(), this.timer.dispose();
  }
}, lQ = class {
  constructor() {
    this.shaderParts = /* @__PURE__ */ new Map([
      [ss.FRAGMENT_HEAD, null],
      [ss.FRAGMENT_MAIN_UV, null],
      [ss.FRAGMENT_MAIN_IMAGE, null],
      [ss.VERTEX_HEAD, null],
      [ss.VERTEX_MAIN_SUPPORT, null]
    ]), this.defines = /* @__PURE__ */ new Map(), this.uniforms = /* @__PURE__ */ new Map(), this.blendModes = /* @__PURE__ */ new Map(), this.extensions = /* @__PURE__ */ new Set(), this.attributes = e1.NONE, this.varyings = /* @__PURE__ */ new Set(), this.uvTransformation = !1, this.readDepth = !1, this.colorSpace = wv;
  }
}, uQ = class extends Set {
  constructor(a, e = 10) {
    super(), this.l = e, this.exclusive = !1, a !== void 0 && this.set(a);
  }
  get layer() {
    return this.l;
  }
  set layer(a) {
    const e = this.l;
    for (const t of this)
      t.layers.disable(e), t.layers.enable(a);
    this.l = a;
  }
  getLayer() {
    return this.layer;
  }
  setLayer(a) {
    this.layer = a;
  }
  isExclusive() {
    return this.exclusive;
  }
  setExclusive(a) {
    this.exclusive = a;
  }
  clear() {
    const a = this.layer;
    for (const e of this)
      e.layers.disable(a);
    return super.clear();
  }
  set(a) {
    this.clear();
    for (const e of a)
      this.add(e);
    return this;
  }
  indexOf(a) {
    return this.has(a) ? 0 : -1;
  }
  add(a) {
    return this.exclusive ? a.layers.set(this.layer) : a.layers.enable(this.layer), super.add(a);
  }
  delete(a) {
    return this.has(a) && a.layers.disable(this.layer), super.delete(a);
  }
  toggle(a) {
    let e;
    return this.has(a) ? (this.delete(a), e = !1) : (this.add(a), e = !0), e;
  }
  setVisible(a) {
    for (const e of this)
      a ? e.layers.enable(0) : e.layers.disable(0);
    return this;
  }
}, cQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y,opacity);}", fQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,min(y.a,opacity));}", dQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y)*0.5,opacity);}", hQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.rg,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}", pQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(step(0.0,y)*(1.0-min(vec4(1.0),(1.0-x)/y)),vec4(1.0),step(1.0,x));return mix(x,z,opacity);}", mQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=step(0.0,x)*mix(min(vec4(1.0),x/max(1.0-y,1e-9)),vec4(1.0),step(1.0,y));return mix(x,z,opacity);}", vQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x,y),opacity);}", gQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,abs(x-y),opacity);}", yQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x/max(y,1e-12),opacity);}", xQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y-2.0*x*y),opacity);}", _Q = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 a=min(x,1.0),b=min(y,1.0);vec4 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,y));return mix(x,z,opacity);}", SQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,step(1.0,x+y),opacity);}", wQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.r,xHSL.gb));return vec4(mix(x.rgb,z,opacity),y.a);}", bQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-y,opacity);}", EQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y*(1.0-x),opacity);}", MQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x,y),opacity);}", TQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(y+x-1.0,0.0,1.0),opacity);}", CQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x+y,1.0),opacity);}", RQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(2.0*y+x-1.0,0.0,1.0),opacity);}", AQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.rg,yHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}", DQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x*y,opacity);}", LQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-abs(1.0-x-y),opacity);}", PQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}", OQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(2.0*y*x,1.0-2.0*(1.0-y)*(1.0-x),step(0.5,x));return mix(x,z,opacity);}", UQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 z=mix(mix(y2,x,step(0.5*x,y)),max(vec4(0.0),y2-1.0),step(x,(y2-1.0)));return mix(x,z,opacity);}", zQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(min(x*x/max(1.0-y,1e-12),1.0),y,step(1.0,y));return mix(x,z,opacity);}", NQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.r,yHSL.g,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}", FQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y-min(x*y,1.0),opacity);}", kQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 w=step(0.5,y);vec4 z=mix(x-(1.0-y2)*x*(1.0-x),mix(x+(y2-1.0)*(sqrt(x)-x),x+(y2-1.0)*x*((16.0*x-12.0)*x+3.0),w*(1.0-step(0.25,x))),w);return mix(x,z,opacity);}", IQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}", BQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x+y-1.0,0.0),opacity);}", HQ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(max(1.0-min((1.0-x)/(2.0*y),1.0),0.0),min(x/(2.0*(1.0-y)),1.0),step(0.5,y));return mix(x,z,opacity);}", VQ = /* @__PURE__ */ new Map([
  [ri.ADD, cQ],
  [ri.ALPHA, fQ],
  [ri.AVERAGE, dQ],
  [ri.COLOR, hQ],
  [ri.COLOR_BURN, pQ],
  [ri.COLOR_DODGE, mQ],
  [ri.DARKEN, vQ],
  [ri.DIFFERENCE, gQ],
  [ri.DIVIDE, yQ],
  [ri.DST, null],
  [ri.EXCLUSION, xQ],
  [ri.HARD_LIGHT, _Q],
  [ri.HARD_MIX, SQ],
  [ri.HUE, wQ],
  [ri.INVERT, bQ],
  [ri.INVERT_RGB, EQ],
  [ri.LIGHTEN, MQ],
  [ri.LINEAR_BURN, TQ],
  [ri.LINEAR_DODGE, CQ],
  [ri.LINEAR_LIGHT, RQ],
  [ri.LUMINOSITY, AQ],
  [ri.MULTIPLY, DQ],
  [ri.NEGATION, LQ],
  [ri.NORMAL, PQ],
  [ri.OVERLAY, OQ],
  [ri.PIN_LIGHT, UQ],
  [ri.REFLECT, zQ],
  [ri.SATURATION, NQ],
  [ri.SCREEN, FQ],
  [ri.SOFT_LIGHT, kQ],
  [ri.SRC, IQ],
  [ri.SUBTRACT, BQ],
  [ri.VIVID_LIGHT, HQ]
]), GQ = class extends Cm {
  constructor(a, e = 1) {
    super(), this._blendFunction = a, this.opacity = new Pn(e);
  }
  getOpacity() {
    return this.opacity.value;
  }
  setOpacity(a) {
    this.opacity.value = a;
  }
  get blendFunction() {
    return this._blendFunction;
  }
  set blendFunction(a) {
    this._blendFunction = a, this.dispatchEvent({ type: "change" });
  }
  getBlendFunction() {
    return this.blendFunction;
  }
  setBlendFunction(a) {
    this.blendFunction = a;
  }
  getShaderCode() {
    return VQ.get(this.blendFunction);
  }
}, Np = class extends Cm {
  constructor(a, e, {
    attributes: t = e1.NONE,
    blendFunction: r = ri.NORMAL,
    defines: i = /* @__PURE__ */ new Map(),
    uniforms: s = /* @__PURE__ */ new Map(),
    extensions: l = null,
    vertexShader: d = null
  } = {}) {
    super(), this.name = a, this.renderer = null, this.attributes = t, this.fragmentShader = e, this.vertexShader = d, this.defines = i, this.uniforms = s, this.extensions = l, this.blendMode = new GQ(r), this.blendMode.addEventListener("change", (p) => this.setChanged()), this._inputColorSpace = wv, this._outputColorSpace = null;
  }
  get inputColorSpace() {
    return this._inputColorSpace;
  }
  set inputColorSpace(a) {
    this._inputColorSpace = a, this.setChanged();
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(a) {
    this._outputColorSpace = a, this.setChanged();
  }
  set mainScene(a) {
  }
  set mainCamera(a) {
  }
  getName() {
    return this.name;
  }
  setRenderer(a) {
    this.renderer = a;
  }
  getDefines() {
    return this.defines;
  }
  getUniforms() {
    return this.uniforms;
  }
  getExtensions() {
    return this.extensions;
  }
  getBlendMode() {
    return this.blendMode;
  }
  getAttributes() {
    return this.attributes;
  }
  setAttributes(a) {
    this.attributes = a, this.setChanged();
  }
  getFragmentShader() {
    return this.fragmentShader;
  }
  setFragmentShader(a) {
    this.fragmentShader = a, this.setChanged();
  }
  getVertexShader() {
    return this.vertexShader;
  }
  setVertexShader(a) {
    this.vertexShader = a, this.setChanged();
  }
  setChanged() {
    this.dispatchEvent({ type: "change" });
  }
  setDepthTexture(a, e = o1) {
  }
  update(a, e, t) {
  }
  setSize(a, e) {
  }
  initialize(a, e, t) {
  }
  dispose() {
    for (const a of Object.keys(this)) {
      const e = this[a];
      (e instanceof po || e instanceof hf || e instanceof su || e instanceof vh) && this[a].dispose();
    }
  }
}, WQ = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D map;
#else
uniform lowp sampler2D map;
#endif
uniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=texture2D(map,uv)*intensity;}`, jQ = class extends Np {
  constructor({
    blendFunction: a = ri.SCREEN,
    luminanceThreshold: e = 0.9,
    luminanceSmoothing: t = 0.025,
    mipmapBlur: r = !1,
    intensity: i = 1,
    radius: s = 0.85,
    levels: l = 8,
    kernelSize: d = nS.LARGE,
    resolutionScale: p = 0.5,
    width: g = $o.AUTO_SIZE,
    height: _ = $o.AUTO_SIZE,
    resolutionX: w = g,
    resolutionY: T = _
  } = {}) {
    super("BloomEffect", WQ, {
      blendFunction: a,
      uniforms: /* @__PURE__ */ new Map([
        ["map", new Pn(null)],
        ["intensity", new Pn(i)]
      ])
    }), this.renderTarget = new po(1, 1, { depthBuffer: !1 }), this.renderTarget.texture.name = "Bloom.Target", this.blurPass = new BL({ kernelSize: d }), this.luminancePass = new R4({ colorOutput: !0 }), this.luminanceMaterial.threshold = e, this.luminanceMaterial.smoothing = t, this.mipmapBlurPass = new tQ(), this.mipmapBlurPass.enabled = r, this.mipmapBlurPass.radius = s, this.mipmapBlurPass.levels = l, this.uniforms.get("map").value = r ? this.mipmapBlurPass.texture : this.renderTarget.texture;
    const R = this.resolution = new $o(this, w, T, p);
    R.addEventListener("change", (D) => this.setSize(R.baseWidth, R.baseHeight));
  }
  get texture() {
    return this.mipmapBlurPass.enabled ? this.mipmapBlurPass.texture : this.renderTarget.texture;
  }
  getTexture() {
    return this.texture;
  }
  getResolution() {
    return this.resolution;
  }
  getBlurPass() {
    return this.blurPass;
  }
  getLuminancePass() {
    return this.luminancePass;
  }
  get luminanceMaterial() {
    return this.luminancePass.fullscreenMaterial;
  }
  getLuminanceMaterial() {
    return this.luminancePass.fullscreenMaterial;
  }
  get width() {
    return this.resolution.width;
  }
  set width(a) {
    this.resolution.preferredWidth = a;
  }
  get height() {
    return this.resolution.height;
  }
  set height(a) {
    this.resolution.preferredHeight = a;
  }
  get dithering() {
    return this.blurPass.dithering;
  }
  set dithering(a) {
    this.blurPass.dithering = a;
  }
  get kernelSize() {
    return this.blurPass.kernelSize;
  }
  set kernelSize(a) {
    this.blurPass.kernelSize = a;
  }
  get distinction() {
    return console.warn(this.name, "distinction was removed"), 1;
  }
  set distinction(a) {
    console.warn(this.name, "distinction was removed");
  }
  get intensity() {
    return this.uniforms.get("intensity").value;
  }
  set intensity(a) {
    this.uniforms.get("intensity").value = a;
  }
  getIntensity() {
    return this.intensity;
  }
  setIntensity(a) {
    this.intensity = a;
  }
  getResolutionScale() {
    return this.resolution.scale;
  }
  setResolutionScale(a) {
    this.resolution.scale = a;
  }
  update(a, e, t) {
    const r = this.renderTarget, i = this.luminancePass;
    i.enabled ? (i.render(a, e), this.mipmapBlurPass.enabled ? this.mipmapBlurPass.render(a, i.renderTarget) : this.blurPass.render(a, i.renderTarget, r)) : this.mipmapBlurPass.enabled ? this.mipmapBlurPass.render(a, e) : this.blurPass.render(a, e, r);
  }
  setSize(a, e) {
    const t = this.resolution;
    t.setBaseSize(a, e), this.renderTarget.setSize(t.width, t.height), this.blurPass.resolution.copy(t), this.luminancePass.setSize(a, e), this.mipmapBlurPass.setSize(a, e);
  }
  initialize(a, e, t) {
    this.blurPass.initialize(a, e, t), this.luminancePass.initialize(a, e, t), this.mipmapBlurPass.initialize(a, e, t), t !== void 0 && (this.renderTarget.texture.type = t, a.outputEncoding === gi && (this.renderTarget.texture.encoding = gi));
  }
}, YQ = "uniform float brightness;uniform float contrast;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=inputColor.rgb+vec3(brightness-0.5);if(contrast>0.0){color/=vec3(1.0-contrast);}else{color*=vec3(1.0+contrast);}outputColor=vec4(color+vec3(0.5),inputColor.a);}", XQ = class extends Np {
  constructor({ blendFunction: a = ri.SRC, brightness: e = 0, contrast: t = 0 } = {}) {
    super("BrightnessContrastEffect", YQ, {
      blendFunction: a,
      uniforms: /* @__PURE__ */ new Map([
        ["brightness", new Pn(e)],
        ["contrast", new Pn(t)]
      ])
    }), this.inputColorSpace = gi;
  }
  get brightness() {
    return this.uniforms.get("brightness").value;
  }
  set brightness(a) {
    this.uniforms.get("brightness").value = a;
  }
  getBrightness(a) {
    return this.brightness;
  }
  setBrightness(a) {
    this.brightness = a;
  }
  get contrast() {
    return this.uniforms.get("contrast").value;
  }
  set contrast(a) {
    this.uniforms.get("contrast").value = a;
  }
  getContrast(a) {
    return this.contrast;
  }
  setContrast(a) {
    this.contrast = a;
  }
}, qQ = "uniform float factor;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=vec4(floor(inputColor.rgb*factor+0.5)/factor,inputColor.a);}", QQ = class extends Np {
  constructor({ blendFunction: a, bits: e = 16 } = {}) {
    super("ColorDepthEffect", qQ, {
      blendFunction: a,
      uniforms: /* @__PURE__ */ new Map([
        ["factor", new Pn(1)]
      ])
    }), this.bits = 0, this.bitDepth = e;
  }
  get bitDepth() {
    return this.bits;
  }
  set bitDepth(a) {
    this.bits = a, this.uniforms.get("factor").value = Math.pow(2, a / 3);
  }
  getBitDepth() {
    return this.bitDepth;
  }
  setBitDepth(a) {
    this.bitDepth = a;
  }
}, ZQ = `void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){
#ifdef INVERTED
vec3 color=vec3(1.0-depth);
#else
vec3 color=vec3(depth);
#endif
outputColor=vec4(color,inputColor.a);}`, JQ = class extends Np {
  constructor({ blendFunction: a = ri.SRC, inverted: e = !1 } = {}) {
    super("DepthEffect", ZQ, {
      blendFunction: a,
      attributes: e1.DEPTH
    }), this.inverted = e;
  }
  get inverted() {
    return this.defines.has("INVERTED");
  }
  set inverted(a) {
    this.inverted !== a && (a ? this.defines.set("INVERTED", "1") : this.defines.delete("INVERTED"), this.setChanged());
  }
  isInverted() {
    return this.inverted;
  }
  setInverted(a) {
    this.inverted = a;
  }
}, KQ = "uniform vec2 angle;uniform float scale;float pattern(const in vec2 uv){vec2 point=scale*vec2(dot(angle.yx,vec2(uv.x,-uv.y)),dot(angle,uv));return(sin(point.x)*sin(point.y))*4.0;}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(inputColor.rgb*10.0-5.0+pattern(uv*resolution));outputColor=vec4(color,inputColor.a);}", $Q = class extends Np {
  constructor({ blendFunction: a, angle: e = Math.PI * 0.5, scale: t = 1 } = {}) {
    super("DotScreenEffect", KQ, {
      blendFunction: a,
      uniforms: /* @__PURE__ */ new Map([
        ["angle", new Pn(new zt())],
        ["scale", new Pn(t)]
      ])
    }), this.angle = e;
  }
  get angle() {
    return Math.acos(this.uniforms.get("angle").value.y);
  }
  set angle(a) {
    this.uniforms.get("angle").value.set(Math.sin(a), Math.cos(a));
  }
  getAngle() {
    return this.angle;
  }
  setAngle(a) {
    this.angle = a;
  }
  get scale() {
    return this.uniforms.get("scale").value;
  }
  set scale(a) {
    this.uniforms.get("scale").value = a;
  }
};
new ge();
new Kr();
var eZ = "uniform vec3 hue;uniform float saturation;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,hue.xyz),dot(inputColor.rgb,hue.zxy),dot(inputColor.rgb,hue.yzx));float average=(color.r+color.g+color.b)/3.0;vec3 diff=average-color;if(saturation>0.0){color+=diff*(1.0-1.0/(1.001-saturation));}else{color+=diff*-saturation;}outputColor=vec4(min(color,1.0),inputColor.a);}", tZ = class extends Np {
  constructor({ blendFunction: a = ri.SRC, hue: e = 0, saturation: t = 0 } = {}) {
    super("HueSaturationEffect", eZ, {
      blendFunction: a,
      uniforms: /* @__PURE__ */ new Map([
        ["hue", new Pn(new ge())],
        ["saturation", new Pn(t)]
      ])
    }), this.hue = e;
  }
  get saturation() {
    return this.uniforms.get("saturation").value;
  }
  set saturation(a) {
    this.uniforms.get("saturation").value = a;
  }
  getSaturation() {
    return this.saturation;
  }
  setSaturation(a) {
    this.saturation = a;
  }
  get hue() {
    const a = this.uniforms.get("hue").value;
    return Math.acos((a.x * 3 - 1) / 2);
  }
  set hue(a) {
    const e = Math.sin(a), t = Math.cos(a);
    this.uniforms.get("hue").value.set(
      (2 * t + 1) / 3,
      (-Math.sqrt(3) * e - t + 1) / 3,
      (Math.sqrt(3) * e - t + 1) / 3
    );
  }
  getHue() {
    return this.hue;
  }
  setHue(a) {
    this.hue = a;
  }
};
new Un();
var nZ = `void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 noise=vec3(rand(uv*time));
#ifdef PREMULTIPLY
outputColor=vec4(min(inputColor.rgb*noise,vec3(1.0)),inputColor.a);
#else
outputColor=vec4(noise,inputColor.a);
#endif
}`, rZ = class extends Np {
  constructor({ blendFunction: a = ri.SCREEN, premultiply: e = !1 } = {}) {
    super("NoiseEffect", nZ, { blendFunction: a }), this.premultiply = e;
  }
  get premultiply() {
    return this.defines.has("PREMULTIPLY");
  }
  set premultiply(a) {
    this.premultiply !== a && (a ? this.defines.set("PREMULTIPLY", "1") : this.defines.delete("PREMULTIPLY"), this.setChanged());
  }
  isPremultiplied() {
    return this.premultiply;
  }
  setPremultiplied(a) {
    this.premultiply = a;
  }
}, iZ = `uniform lowp sampler2D edgeTexture;uniform lowp sampler2D maskTexture;uniform vec3 visibleEdgeColor;uniform vec3 hiddenEdgeColor;uniform float pulse;uniform float edgeStrength;
#ifdef USE_PATTERN
uniform lowp sampler2D patternTexture;varying vec2 vUvPattern;
#endif
void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec2 edge=texture2D(edgeTexture,uv).rg;vec2 mask=texture2D(maskTexture,uv).rg;
#ifndef X_RAY
edge.y=0.0;
#endif
edge*=(edgeStrength*mask.x*pulse);vec3 color=edge.x*visibleEdgeColor+edge.y*hiddenEdgeColor;float visibilityFactor=0.0;
#ifdef USE_PATTERN
vec4 patternColor=texelToLinear(texture2D(patternTexture,vUvPattern));
#ifdef X_RAY
float hiddenFactor=0.5;
#else
float hiddenFactor=0.0;
#endif
visibilityFactor=(1.0-mask.y>0.0)?1.0:hiddenFactor;visibilityFactor*=(1.0-mask.x)*patternColor.a;color+=visibilityFactor*patternColor.rgb;
#endif
float alpha=max(max(edge.x,edge.y),visibilityFactor);
#ifdef ALPHA
outputColor=vec4(color,alpha);
#else
outputColor=vec4(color,max(alpha,inputColor.a));
#endif
}`, aZ = "uniform float patternScale;varying vec2 vUvPattern;void mainSupport(const in vec2 uv){vUvPattern=uv*vec2(aspect,1.0)*patternScale;}", sZ = class extends Np {
  constructor(a, e, {
    blendFunction: t = ri.SCREEN,
    patternTexture: r = null,
    patternScale: i = 1,
    edgeStrength: s = 1,
    pulseSpeed: l = 0,
    visibleEdgeColor: d = 16777215,
    hiddenEdgeColor: p = 2230538,
    kernelSize: g = nS.VERY_SMALL,
    blur: _ = !1,
    xRay: w = !0,
    multisampling: T = 0,
    resolutionScale: R = 0.5,
    width: D = $o.AUTO_SIZE,
    height: O = $o.AUTO_SIZE,
    resolutionX: U = D,
    resolutionY: H = O
  } = {}) {
    super("OutlineEffect", iZ, {
      uniforms: /* @__PURE__ */ new Map([
        ["maskTexture", new Pn(null)],
        ["edgeTexture", new Pn(null)],
        ["edgeStrength", new Pn(s)],
        ["visibleEdgeColor", new Pn(new Un(d))],
        ["hiddenEdgeColor", new Pn(new Un(p))],
        ["pulse", new Pn(1)],
        ["patternScale", new Pn(i)],
        ["patternTexture", new Pn(null)]
      ])
    }), this.blendMode.addEventListener("change", (Q) => {
      this.blendMode.getBlendFunction() === ri.ALPHA ? this.defines.set("ALPHA", "1") : this.defines.delete("ALPHA"), this.setChanged();
    }), this.blendMode.setBlendFunction(t), this.patternTexture = r, this.xRay = w, this.scene = a, this.camera = e, this.renderTargetMask = new po(1, 1), this.renderTargetMask.samples = T, this.renderTargetMask.texture.name = "Outline.Mask", this.uniforms.get("maskTexture").value = this.renderTargetMask.texture, this.renderTargetOutline = new po(1, 1, { depthBuffer: !1 }), this.renderTargetOutline.texture.name = "Outline.Edges", this.uniforms.get("edgeTexture").value = this.renderTargetOutline.texture, this.clearPass = new IL(), this.clearPass.overrideClearColor = new Un(0), this.clearPass.overrideClearAlpha = 1, this.depthPass = new Zq(a, e), this.maskPass = new rR(a, e, new Mq(this.depthPass.texture, e));
    const I = this.maskPass.clearPass;
    I.overrideClearColor = new Un(16777215), I.overrideClearAlpha = 1, this.blurPass = new BL({ resolutionScale: R, resolutionX: U, resolutionY: H, kernelSize: g }), this.blurPass.enabled = _;
    const G = this.blurPass.resolution;
    G.addEventListener("change", (Q) => this.setSize(G.baseWidth, G.baseHeight)), this.outlinePass = new rQ(new Iq());
    const B = this.outlinePass.fullscreenMaterial;
    B.inputBuffer = this.renderTargetMask.texture, this.time = 0, this.active = !1, this.selection = new uQ(), this.selection.layer = 10, this.pulseSpeed = l;
  }
  set mainScene(a) {
    this.scene = a, this.depthPass.mainScene = a, this.maskPass.mainScene = a;
  }
  set mainCamera(a) {
    this.camera = a, this.depthPass.mainCamera = a, this.maskPass.mainCamera = a, this.maskPass.overrideMaterial.copyCameraSettings(a);
  }
  get resolution() {
    return this.blurPass.resolution;
  }
  getResolution() {
    return this.blurPass.getResolution();
  }
  get multisampling() {
    return this.renderTargetMask.samples;
  }
  set multisampling(a) {
    this.renderTargetMask.samples = a, this.renderTargetMask.dispose();
  }
  get patternScale() {
    return this.uniforms.get("patternScale").value;
  }
  set patternScale(a) {
    this.uniforms.get("patternScale").value = a;
  }
  get edgeStrength() {
    return this.uniforms.get("edgeStrength").value;
  }
  set edgeStrength(a) {
    this.uniforms.get("edgeStrength").value = a;
  }
  get visibleEdgeColor() {
    return this.uniforms.get("visibleEdgeColor").value;
  }
  set visibleEdgeColor(a) {
    this.uniforms.get("visibleEdgeColor").value = a;
  }
  get hiddenEdgeColor() {
    return this.uniforms.get("hiddenEdgeColor").value;
  }
  set hiddenEdgeColor(a) {
    this.uniforms.get("hiddenEdgeColor").value = a;
  }
  getBlurPass() {
    return this.blurPass;
  }
  getSelection() {
    return this.selection;
  }
  getPulseSpeed() {
    return this.pulseSpeed;
  }
  setPulseSpeed(a) {
    this.pulseSpeed = a;
  }
  get width() {
    return this.resolution.width;
  }
  set width(a) {
    this.resolution.preferredWidth = a;
  }
  get height() {
    return this.resolution.height;
  }
  set height(a) {
    this.resolution.preferredHeight = a;
  }
  get selectionLayer() {
    return this.selection.layer;
  }
  set selectionLayer(a) {
    this.selection.layer = a;
  }
  get dithering() {
    return this.blurPass.dithering;
  }
  set dithering(a) {
    this.blurPass.dithering = a;
  }
  get kernelSize() {
    return this.blurPass.kernelSize;
  }
  set kernelSize(a) {
    this.blurPass.kernelSize = a;
  }
  get blur() {
    return this.blurPass.enabled;
  }
  set blur(a) {
    this.blurPass.enabled = a;
  }
  get xRay() {
    return this.defines.has("X_RAY");
  }
  set xRay(a) {
    this.xRay !== a && (a ? this.defines.set("X_RAY", "1") : this.defines.delete("X_RAY"), this.setChanged());
  }
  isXRayEnabled() {
    return this.xRay;
  }
  setXRayEnabled(a) {
    this.xRay = a;
  }
  get patternTexture() {
    return this.uniforms.get("patternTexture").value;
  }
  set patternTexture(a) {
    if (a !== null ? (a.wrapS = a.wrapT = Zw, this.defines.set("USE_PATTERN", "1"), this.setVertexShader(aZ)) : (this.defines.delete("USE_PATTERN"), this.setVertexShader(null)), this.renderer !== null) {
      const e = RN(a, this.renderer.capabilities.isWebGL2);
      this.defines.set("texelToLinear(texel)", e);
    }
    this.uniforms.get("patternTexture").value = a, this.setChanged();
  }
  setPatternTexture(a) {
    this.patternTexture = a;
  }
  getResolutionScale() {
    return this.resolution.scale;
  }
  setResolutionScale(a) {
    this.resolution.scale = a;
  }
  setSelection(a) {
    return this.selection.set(a), this;
  }
  clearSelection() {
    return this.selection.clear(), this;
  }
  selectObject(a) {
    return this.selection.add(a), this;
  }
  deselectObject(a) {
    return this.selection.delete(a), this;
  }
  update(a, e, t) {
    const r = this.scene, i = this.camera, s = this.selection, d = this.uniforms.get("pulse"), p = r.background, g = i.layers.mask;
    s.size > 0 ? (r.background = null, d.value = 1, this.pulseSpeed > 0 && (d.value = Math.cos(this.time * this.pulseSpeed * 10) * 0.375 + 0.625), this.active = !0, this.time += t, s.setVisible(!1), this.depthPass.render(a), s.setVisible(!0), i.layers.set(s.layer), this.maskPass.render(a, this.renderTargetMask), i.layers.mask = g, r.background = p, this.outlinePass.render(a, null, this.renderTargetOutline), this.blurPass.enabled && this.blurPass.render(a, this.renderTargetOutline, this.renderTargetOutline)) : this.active && (this.clearPass.render(a, this.renderTargetOutline), this.active = !1);
  }
  setSize(a, e) {
    this.blurPass.setSize(a, e), this.renderTargetMask.setSize(a, e);
    const t = this.resolution;
    t.setBaseSize(a, e);
    const r = t.width, i = t.height;
    this.depthPass.setSize(r, i), this.renderTargetOutline.setSize(r, i), this.outlinePass.fullscreenMaterial.setSize(r, i);
  }
  initialize(a, e, t) {
    const r = this.patternTexture, i = RN(r, a.capabilities.isWebGL2);
    this.defines.set("texelToLinear(texel)", i), this.blurPass.initialize(a, e, df), t !== void 0 && (this.depthPass.initialize(a, e, t), this.maskPass.initialize(a, e, t), this.outlinePass.initialize(a, e, t));
  }
}, oZ = `uniform float count;
#ifdef SCROLL
uniform float scrollSpeed;
#endif
void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){float y=uv.y;
#ifdef SCROLL
y+=time*scrollSpeed;
#endif
vec2 sl=vec2(sin(y*count),cos(y*count));outputColor=vec4(sl.xyx,inputColor.a);}`, lZ = class extends Np {
  constructor({ blendFunction: a = ri.OVERLAY, density: e = 1.25, scrollSpeed: t = 0 } = {}) {
    super("ScanlineEffect", oZ, {
      blendFunction: a,
      uniforms: /* @__PURE__ */ new Map([
        ["count", new Pn(0)],
        ["scrollSpeed", new Pn(0)]
      ])
    }), this.resolution = new zt(), this.d = e, this.scrollSpeed = t;
  }
  get density() {
    return this.d;
  }
  set density(a) {
    this.d = a, this.setSize(this.resolution.width, this.resolution.height);
  }
  getDensity() {
    return this.density;
  }
  setDensity(a) {
    this.density = a;
  }
  get scrollSpeed() {
    return this.uniforms.get("scrollSpeed").value;
  }
  set scrollSpeed(a) {
    this.uniforms.get("scrollSpeed").value = a, a === 0 ? this.defines.delete("SCROLL") && this.setChanged() : this.defines.has("SCROLL") || (this.defines.set("SCROLL", "1"), this.setChanged());
  }
  setSize(a, e) {
    this.resolution.set(a, e), this.uniforms.get("count").value = Math.round(e * this.density);
  }
}, uZ = "uniform bool active;uniform vec2 center;uniform float waveSize;uniform float radius;uniform float maxRadius;uniform float amplitude;varying float vSize;void mainUv(inout vec2 uv){if(active){vec2 aspectCorrection=vec2(aspect,1.0);vec2 difference=uv*aspectCorrection-center*aspectCorrection;float distance=sqrt(dot(difference,difference))*vSize;if(distance>radius){if(distance<radius+waveSize){float angle=(distance-radius)*PI2/waveSize;float cosSin=(1.0-cos(angle))*0.5;float extent=maxRadius+waveSize;float decay=max(extent-distance*distance,0.0)/extent;uv-=((cosSin*amplitude*difference)/distance)*decay;}}}}", cZ = "uniform float size;uniform float cameraDistance;varying float vSize;void mainSupport(){vSize=(0.1*cameraDistance)/size;}", fZ = Math.PI * 0.5, pM = new ge(), PN = new ge(), dZ = class extends Np {
  constructor(a, e = new ge(), {
    speed: t = 2,
    maxRadius: r = 1,
    waveSize: i = 0.2,
    amplitude: s = 0.05
  } = {}) {
    super("ShockWaveEffect", uZ, {
      vertexShader: cZ,
      uniforms: /* @__PURE__ */ new Map([
        ["active", new Pn(!1)],
        ["center", new Pn(new zt(0.5, 0.5))],
        ["cameraDistance", new Pn(1)],
        ["size", new Pn(1)],
        ["radius", new Pn(-i)],
        ["maxRadius", new Pn(r)],
        ["waveSize", new Pn(i)],
        ["amplitude", new Pn(s)]
      ])
    }), this.position = e, this.speed = t, this.camera = a, this.screenPosition = this.uniforms.get("center").value, this.time = 0, this.active = !1;
  }
  set mainCamera(a) {
    this.camera = a;
  }
  get amplitude() {
    return this.uniforms.get("amplitude").value;
  }
  set amplitude(a) {
    this.uniforms.get("amplitude").value = a;
  }
  get waveSize() {
    return this.uniforms.get("waveSize").value;
  }
  set waveSize(a) {
    this.uniforms.get("waveSize").value = a;
  }
  get maxRadius() {
    return this.uniforms.get("maxRadius").value;
  }
  set maxRadius(a) {
    this.uniforms.get("maxRadius").value = a;
  }
  get epicenter() {
    return this.position;
  }
  set epicenter(a) {
    this.position = a;
  }
  getPosition() {
    return this.position;
  }
  setPosition(a) {
    this.position = a;
  }
  getSpeed() {
    return this.speed;
  }
  setSpeed(a) {
    this.speed = a;
  }
  explode() {
    this.time = 0, this.active = !0, this.uniforms.get("active").value = !0;
  }
  update(a, e, t) {
    const r = this.position, i = this.camera, s = this.uniforms, l = s.get("active");
    if (this.active) {
      const d = s.get("waveSize").value;
      i.getWorldDirection(pM), PN.copy(i.position).sub(r), l.value = pM.angleTo(PN) > fZ, l.value && (s.get("cameraDistance").value = i.position.distanceTo(r), pM.copy(r).project(i), this.screenPosition.set((pM.x + 1) * 0.5, (pM.y + 1) * 0.5)), this.time += t * this.speed;
      const p = this.time - d;
      s.get("radius").value = p, p >= (s.get("maxRadius").value + d) * 2 && (this.active = !1, l.value = !1);
    }
  }
}, hZ = "uniform vec3 weightsR;uniform vec3 weightsG;uniform vec3 weightsB;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,weightsR),dot(inputColor.rgb,weightsG),dot(inputColor.rgb,weightsB));outputColor=vec4(color,inputColor.a);}", pZ = class extends Np {
  constructor({ blendFunction: a, intensity: e = 1 } = {}) {
    super("SepiaEffect", hZ, {
      blendFunction: a,
      uniforms: /* @__PURE__ */ new Map([
        ["weightsR", new Pn(new ge(0.393, 0.769, 0.189))],
        ["weightsG", new Pn(new ge(0.349, 0.686, 0.168))],
        ["weightsB", new Pn(new ge(0.272, 0.534, 0.131))]
      ])
    });
  }
  get intensity() {
    return this.blendMode.opacity.value;
  }
  set intensity(a) {
    this.blendMode.opacity.value = a;
  }
  getIntensity() {
    return this.intensity;
  }
  setIntensity(a) {
    this.intensity = a;
  }
  get weightsR() {
    return this.uniforms.get("weightsR").value;
  }
  get weightsG() {
    return this.uniforms.get("weightsG").value;
  }
  get weightsB() {
    return this.uniforms.get("weightsB").value;
  }
}, mZ = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D map;
#else
uniform lowp sampler2D map;
#endif
uniform vec2 maskParams;varying vec2 vUv2;float linearGradientMask(const in float x){return step(maskParams.x,x)-step(maskParams.y,x);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){float mask=linearGradientMask(vUv2.y);vec4 texel=texture2D(map,uv);outputColor=mix(texel,inputColor,mask);}`, vZ = "uniform vec2 rotation;varying vec2 vUv2;void mainSupport(const in vec2 uv){vUv2=(uv-0.5)*2.0*vec2(aspect,1.0);vUv2=vec2(dot(rotation,vUv2),dot(rotation,vec2(vUv2.y,-vUv2.x)));}", gZ = class extends Np {
  constructor({
    blendFunction: a,
    offset: e = 0,
    rotation: t = 0,
    focusArea: r = 0.4,
    feather: i = 0.3,
    kernelSize: s = nS.MEDIUM,
    resolutionScale: l = 0.5,
    resolutionX: d = $o.AUTO_SIZE,
    resolutionY: p = $o.AUTO_SIZE
  } = {}) {
    super("TiltShiftEffect", mZ, {
      vertexShader: vZ,
      blendFunction: a,
      uniforms: /* @__PURE__ */ new Map([
        ["rotation", new Pn(new zt())],
        ["maskParams", new Pn(new zt())],
        ["map", new Pn(null)]
      ])
    }), this._offset = e, this._focusArea = r, this._feather = i, this.renderTarget = new po(1, 1, { depthBuffer: !1 }), this.renderTarget.texture.name = "TiltShift.Target", this.uniforms.get("map").value = this.renderTarget.texture, this.blurPass = new iQ({
      kernelSize: s,
      resolutionScale: l,
      resolutionX: d,
      resolutionY: p,
      offset: e,
      rotation: t,
      focusArea: r,
      feather: i
    });
    const g = this.resolution = new $o(this, d, p, l);
    g.addEventListener("change", (_) => this.setSize(g.baseWidth, g.baseHeight)), this.rotation = t, this.updateParams();
  }
  updateParams() {
    const a = this.uniforms.get("maskParams").value, e = Math.max(this.focusArea - this.feather, 0);
    a.set(this.offset - e, this.offset + e);
  }
  get rotation() {
    return Math.acos(this.uniforms.get("rotation").value.x);
  }
  set rotation(a) {
    this.uniforms.get("rotation").value.set(Math.cos(a), Math.sin(a)), this.blurPass.blurMaterial.rotation = a;
  }
  get offset() {
    return this._offset;
  }
  set offset(a) {
    this._offset = a, this.blurPass.blurMaterial.offset = a, this.updateParams();
  }
  get focusArea() {
    return this._focusArea;
  }
  set focusArea(a) {
    this._focusArea = a, this.blurPass.blurMaterial.focusArea = a, this.updateParams();
  }
  get feather() {
    return this._feather;
  }
  set feather(a) {
    this._feather = a, this.blurPass.blurMaterial.feather = a, this.updateParams();
  }
  get bias() {
    return 0;
  }
  set bias(a) {
  }
  update(a, e, t) {
    this.blurPass.render(a, e, this.renderTarget);
  }
  setSize(a, e) {
    const t = this.resolution;
    t.setBaseSize(a, e), this.renderTarget.setSize(t.width, t.height), this.blurPass.resolution.copy(t);
  }
  initialize(a, e, t) {
    this.blurPass.initialize(a, e, t), t !== void 0 && (this.renderTarget.texture.type = t, a.outputEncoding === gi && (this.renderTarget.texture.encoding = gi));
  }
}, yZ = `#include <tonemapping_pars_fragment>
#if THREE_REVISION < 143
#define luminance(v) linearToRelativeLuminance(v)
#endif
uniform lowp sampler2D luminanceBuffer;uniform float whitePoint;uniform float middleGrey;
#if TONE_MAPPING_MODE != 2
uniform float averageLuminance;
#endif
vec3 Reinhard2ToneMapping(vec3 color){color*=toneMappingExposure;float l=luminance(color);
#if TONE_MAPPING_MODE == 2
float lumAvg=unpackRGBAToFloat(texture2D(luminanceBuffer,vec2(0.5)));
#else
float lumAvg=averageLuminance;
#endif
float lumScaled=(l*middleGrey)/max(lumAvg,1e-6);float lumCompressed=lumScaled*(1.0+lumScaled/(whitePoint*whitePoint));lumCompressed/=(1.0+lumScaled);return clamp(lumCompressed*color,0.0,1.0);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){
#if TONE_MAPPING_MODE == 1 || TONE_MAPPING_MODE == 2
outputColor=vec4(Reinhard2ToneMapping(inputColor.rgb),inputColor.a);
#else
outputColor=vec4(toneMapping(inputColor.rgb),inputColor.a);
#endif
}`, xZ = class extends Np {
  constructor({
    blendFunction: a = ri.SRC,
    adaptive: e = !0,
    mode: t = e ? C0.REINHARD2_ADAPTIVE : C0.REINHARD2,
    resolution: r = 256,
    maxLuminance: i = 16,
    whitePoint: s = i,
    middleGrey: l = 0.6,
    minLuminance: d = 0.01,
    averageLuminance: p = 1,
    adaptationRate: g = 1
  } = {}) {
    super("ToneMappingEffect", yZ, {
      blendFunction: a,
      uniforms: /* @__PURE__ */ new Map([
        ["luminanceBuffer", new Pn(null)],
        ["maxLuminance", new Pn(i)],
        ["whitePoint", new Pn(s)],
        ["middleGrey", new Pn(l)],
        ["averageLuminance", new Pn(p)]
      ])
    }), this.renderTargetLuminance = new po(1, 1, {
      minFilter: s1,
      depthBuffer: !1
    }), this.renderTargetLuminance.texture.generateMipmaps = !0, this.renderTargetLuminance.texture.name = "Luminance", this.luminancePass = new R4({
      renderTarget: this.renderTargetLuminance
    }), this.adaptiveLuminancePass = new qq(this.luminancePass.texture, {
      minLuminance: d,
      adaptationRate: g
    }), this.uniforms.get("luminanceBuffer").value = this.adaptiveLuminancePass.texture, this.resolution = r, this.mode = t;
  }
  get mode() {
    return Number(this.defines.get("TONE_MAPPING_MODE"));
  }
  set mode(a) {
    if (this.mode !== a) {
      switch (this.defines.clear(), this.defines.set("TONE_MAPPING_MODE", a.toFixed(0)), a) {
        case C0.REINHARD:
          this.defines.set("toneMapping(texel)", "ReinhardToneMapping(texel)");
          break;
        case C0.OPTIMIZED_CINEON:
          this.defines.set("toneMapping(texel)", "OptimizedCineonToneMapping(texel)");
          break;
        case C0.ACES_FILMIC:
          this.defines.set("toneMapping(texel)", "ACESFilmicToneMapping(texel)");
          break;
        default:
          this.defines.set("toneMapping(texel)", "texel");
          break;
      }
      this.adaptiveLuminancePass.enabled = a === C0.REINHARD2_ADAPTIVE, this.setChanged();
    }
  }
  getMode() {
    return this.mode;
  }
  setMode(a) {
    this.mode = a;
  }
  get whitePoint() {
    return this.uniforms.get("whitePoint").value;
  }
  set whitePoint(a) {
    this.uniforms.get("whitePoint").value = a;
  }
  get middleGrey() {
    return this.uniforms.get("middleGrey").value;
  }
  set middleGrey(a) {
    this.uniforms.get("middleGrey").value = a;
  }
  get averageLuminance() {
    return this.uniforms.get("averageLuminance").value;
  }
  set averageLuminance(a) {
    this.uniforms.get("averageLuminance").value = a;
  }
  get adaptiveLuminanceMaterial() {
    return this.adaptiveLuminancePass.fullscreenMaterial;
  }
  getAdaptiveLuminanceMaterial() {
    return this.adaptiveLuminanceMaterial;
  }
  get resolution() {
    return this.luminancePass.resolution.width;
  }
  set resolution(a) {
    const e = Math.max(0, Math.ceil(Math.log2(a))), t = Math.pow(2, e);
    this.luminancePass.resolution.setPreferredSize(t, t), this.adaptiveLuminanceMaterial.mipLevel1x1 = e;
  }
  getResolution() {
    return this.resolution;
  }
  setResolution(a) {
    this.resolution = a;
  }
  get adaptive() {
    return this.mode === C0.REINHARD2_ADAPTIVE;
  }
  set adaptive(a) {
    this.mode = a ? C0.REINHARD2_ADAPTIVE : C0.REINHARD2;
  }
  get adaptationRate() {
    return this.adaptiveLuminanceMaterial.adaptationRate;
  }
  set adaptationRate(a) {
    this.adaptiveLuminanceMaterial.adaptationRate = a;
  }
  get distinction() {
    return console.warn(this.name, "distinction was removed."), 1;
  }
  set distinction(a) {
    console.warn(this.name, "distinction was removed.");
  }
  update(a, e, t) {
    this.adaptiveLuminancePass.enabled && (this.luminancePass.render(a, e), this.adaptiveLuminancePass.render(a, null, null, t));
  }
  initialize(a, e, t) {
    this.adaptiveLuminancePass.initialize(a, e, t);
  }
}, _Z = `uniform float offset;uniform float darkness;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){const vec2 center=vec2(0.5);vec3 color=inputColor.rgb;
#if VIGNETTE_TECHNIQUE == 0
float d=distance(uv,center);color*=smoothstep(0.8,offset*0.799,d*(darkness+offset));
#else
vec2 coord=(uv-center)*vec2(offset);color=mix(color,vec3(1.0-darkness),dot(coord,coord));
#endif
outputColor=vec4(color,inputColor.a);}`, SZ = class extends Np {
  constructor({
    blendFunction: a,
    technique: e = lC.DEFAULT,
    eskil: t = !1,
    offset: r = 0.5,
    darkness: i = 0.5
  } = {}) {
    super("VignetteEffect", _Z, {
      blendFunction: a,
      defines: /* @__PURE__ */ new Map([
        ["VIGNETTE_TECHNIQUE", e.toFixed(0)]
      ]),
      uniforms: /* @__PURE__ */ new Map([
        ["offset", new Pn(r)],
        ["darkness", new Pn(i)]
      ])
    });
  }
  get technique() {
    return Number(this.defines.get("VIGNETTE_TECHNIQUE"));
  }
  set technique(a) {
    this.technique !== a && (this.defines.set("VIGNETTE_TECHNIQUE", a.toFixed(0)), this.setChanged());
  }
  get eskil() {
    return this.technique === lC.ESKIL;
  }
  set eskil(a) {
    this.technique = a ? lC.ESKIL : lC.DEFAULT;
  }
  getTechnique() {
    return this.technique;
  }
  setTechnique(a) {
    this.technique = a;
  }
  get offset() {
    return this.uniforms.get("offset").value;
  }
  set offset(a) {
    this.uniforms.get("offset").value = a;
  }
  getOffset() {
    return this.offset;
  }
  setOffset(a) {
    this.offset = a;
  }
  get darkness() {
    return this.uniforms.get("darkness").value;
  }
  set darkness(a) {
    this.uniforms.get("darkness").value = a;
  }
  getDarkness() {
    return this.darkness;
  }
  setDarkness(a) {
    this.darkness = a;
  }
};
let mM;
function wZ() {
  if (mM !== void 0)
    return mM;
  try {
    var a;
    let e;
    const t = document.createElement("canvas");
    return mM = !!(window.WebGL2RenderingContext && (e = t.getContext("webgl2"))), e && ((a = e.getExtension("WEBGL_lose_context")) === null || a === void 0 || a.loseContext()), mM;
  } catch {
    return mM = !1;
  }
}
const bZ = (a) => !!a.current, ON = (a) => bZ(a) ? a.current : a, Dm = function(a, e) {
  return e === void 0 && (e = ri.NORMAL), /* @__PURE__ */ U0(function(r, i) {
    let {
      blendFunction: s,
      opacity: l,
      ...d
    } = r;
    const p = jf((_) => _.invalidate), g = Qw(() => new a(d), [d]);
    return H3(() => {
      g.blendMode.blendFunction = !s && s !== 0 ? e : s, l !== void 0 && (g.blendMode.opacity.value = l), p();
    }, [s, g.blendMode, l]), /* @__PURE__ */ ln("primitive", {
      ref: i,
      object: g,
      dispose: null
    });
  });
};
Dm(jQ, ri.ADD);
Dm(XQ);
Dm(QQ);
Dm(JQ);
const A4 = /* @__PURE__ */ OC(null), EZ = /* @__PURE__ */ ph.memo(/* @__PURE__ */ U0((a, e) => {
  let {
    children: t,
    camera: r,
    scene: i,
    resolutionScale: s,
    enabled: l = !0,
    renderPriority: d = 1,
    autoClear: p = !0,
    depthBuffer: g,
    disableNormalPass: _,
    stencilBuffer: w,
    multisampling: T = 8,
    frameBufferType: R = X_
  } = a;
  const {
    gl: D,
    scene: O,
    camera: U,
    size: H
  } = jf();
  i = i || O, r = r || U;
  const [I, G, B] = Qw(() => {
    const te = wZ(), Y = new oQ(D, {
      depthBuffer: g,
      stencilBuffer: w,
      multisampling: T > 0 && te ? T : 0,
      frameBufferType: R
    });
    Y.addPass(new rR(i, r));
    let re = null, se = null;
    return _ || (se = new nQ(i, r), se.enabled = !1, Y.addPass(se), s !== void 0 && te && (re = new Jq({
      normalBuffer: se.texture,
      resolutionScale: s
    }), re.enabled = !1, Y.addPass(re))), [Y, se, re];
  }, [r, D, g, w, T, R, i, _, s]);
  hh(() => I == null ? void 0 : I.setSize(H.width, H.height), [I, H]), Am((te, Y) => {
    l && (D.autoClear = p, I.render(Y));
  }, l ? d : 0);
  const Q = Xs(null);
  H3(() => {
    let te;
    return Q.current && Q.current.__r3f && I && (te = new $q(r, ...Q.current.__r3f.objects), te.renderToScreen = !0, I.addPass(te), G && (G.enabled = !0), B && (B.enabled = !0)), () => {
      te && (I == null || I.removePass(te)), G && (G.enabled = !1), B && (B.enabled = !1);
    };
  }, [I, t, r, G, B]);
  const K = Qw(() => ({
    composer: I,
    normalPass: G,
    downSamplingPass: B,
    resolutionScale: s,
    camera: r,
    scene: i
  }), [I, G, B, s, r, i]);
  return L5(e, () => I, [I]), /* @__PURE__ */ ln(A4.Provider, {
    value: K,
    children: /* @__PURE__ */ ln("group", {
      ref: Q,
      children: t
    })
  });
}));
Dm($Q);
Dm(tZ);
Dm(rZ, ri.COLOR_DODGE);
const HL = /* @__PURE__ */ OC(null);
function MZ(a) {
  let {
    children: e,
    enabled: t = !0
  } = a;
  const [r, i] = O_([]), s = Qw(() => ({
    selected: r,
    select: i,
    enabled: t
  }), [r, i, t]);
  return /* @__PURE__ */ ph.createElement(HL.Provider, {
    value: s
  }, e);
}
function D4(a) {
  let {
    enabled: e = !1,
    children: t,
    ...r
  } = a;
  const i = Xs(null), s = TM(HL);
  return hh(() => {
    if (s && e) {
      let l = !1;
      const d = [];
      if (i.current.traverse((p) => {
        p.type === "Mesh" && d.push(p), s.selected.indexOf(p) === -1 && (l = !0);
      }), l)
        return s.select((p) => [...p, ...d]), () => {
          s.select((p) => p.filter((g) => !d.includes(g)));
        };
    }
  }, [e, t]), /* @__PURE__ */ ln("group", {
    ref: i,
    ...r,
    children: t
  });
}
const TZ = /* @__PURE__ */ U0(function(e, t) {
  let {
    selection: r = [],
    selectionLayer: i = 10,
    blendFunction: s,
    patternTexture: l,
    edgeStrength: d,
    pulseSpeed: p,
    visibleEdgeColor: g,
    hiddenEdgeColor: _,
    width: w,
    height: T,
    kernelSize: R,
    blur: D,
    xRay: O,
    ...U
  } = e;
  const H = jf((K) => K.invalidate), {
    scene: I,
    camera: G
  } = TM(A4), B = Qw(() => new sZ(I, G, {
    blendFunction: s,
    patternTexture: l,
    edgeStrength: d,
    pulseSpeed: p,
    visibleEdgeColor: g,
    hiddenEdgeColor: _,
    width: w,
    height: T,
    kernelSize: R,
    blur: D,
    xRay: O,
    ...U
  }), [s, D, G, d, T, _, R, l, p, I, g, w, O]), Q = TM(HL);
  return hh(() => {
    if (!Q && r)
      return B.selection.set(Array.isArray(r) ? r.map(ON) : [ON(r)]), H(), () => {
        B.selection.clear(), H();
      };
  }, [B, r, Q]), hh(() => {
    B.selectionLayer = i, H();
  }, [B, i]), Xs(), hh(() => {
    if (Q && Q.enabled) {
      var K;
      if ((K = Q.selected) != null && K.length)
        return B.selection.set(Q.selected), H(), () => {
          B.selection.clear(), H();
        };
    }
  }, [Q]), /* @__PURE__ */ ln("primitive", {
    ref: t,
    object: B
  });
});
Dm(lZ, ri.OVERLAY);
Dm(pZ);
Dm(xZ);
Dm(SZ);
Dm(dZ);
Dm(gZ, ri.ADD);
const CZ = ["cube", "cylinder", "sphere", "capsule", "arrow"], L4 = OC(), RZ = (a) => {
  const t = TM(L4)[a.shape];
  return CZ.includes(a.shape) ? hq(a) : t && typeof t == "function" ? t() : (console.warn(`Shape not loaded: ${a.shape} (reading property 'shape' of item)`, a), []);
}, AZ = ({
  meshes: a,
  children: e
}) => /* @__PURE__ */ ln(L4.Provider, {
  value: a,
  children: e
}), DZ = QM(U0(({
  objectKey: a,
  highlightColor: e,
  position: t,
  rotation: r,
  scale: i,
  ghost: s
}, l) => {
  const d = Xs(null), p = yb(l, d), g = os((O) => O.onClick, dh), _ = os((O) => O.onPointerOver, dh), w = os((O) => O.onPointerOut, dh), T = os((O) => O.clock), R = os(qh((O) => O.items[a], [a]), dh), D = RZ(R);
  return Am(qh(() => {
    const O = T.getElapsed() * 1e3;
    p.current && (p.current.position.set(t ? t.x : typeof R.position.x == "function" ? R.position.x(O) : R.position.x, t ? t.y : typeof R.position.y == "function" ? R.position.y(O) : R.position.y, t ? t.z : typeof R.position.z == "function" ? R.position.z(O) : R.position.z), p.current.quaternion.set(r ? r.x : typeof R.rotation.x == "function" ? R.rotation.x(O) : R.rotation.x, r ? r.y : typeof R.rotation.y == "function" ? R.rotation.y(O) : R.rotation.y, r ? r.z : typeof R.rotation.z == "function" ? R.rotation.z(O) : R.rotation.z, r ? r.w : typeof R.rotation.w == "function" ? R.rotation.w(O) : R.rotation.w), p.current.scale.set(i ? i.x : typeof R.scale.x == "function" ? R.scale.x(O) : R.scale.x, i ? i.y : typeof R.scale.y == "function" ? R.scale.y(O) : R.scale.y, i ? i.z : typeof R.scale.z == "function" ? R.scale.z(O) : R.scale.z), p.current.visible = typeof R.hidden == "function" ? !R.hidden(O) : !R.hidden);
  }, [R, t, r, i, p, T])), /* @__PURE__ */ ln(D4, {
    enabled: R.highlighted,
    children: /* @__PURE__ */ _c("group", {
      ref: p,
      up: [0, 0, 1],
      children: [/* @__PURE__ */ ln("group", {
        up: [0, 0, 1],
        rotation: [Math.PI / 2, 0, 0],
        onPointerDown: (O) => {
          g(a, !p.current.visible, {
            local: {
              position: p.current.position,
              rotation: p.current.quaternion
            },
            world: {
              position: p.current.getWorldPosition(new ge()),
              rotation: p.current.getWorldQuaternion(new Po())
            }
          }, O);
        },
        onPointerOver: (O) => {
          _(a, !p.current.visible, O);
        },
        onPointerOut: (O) => {
          w(a, !p.current.visible, O);
        },
        children: D.map((O, U) => /* @__PURE__ */ ln(P4, {
          idx: U,
          groupOrPart: O,
          objectKey: a,
          ghost: s,
          highlightColor: e
        }, U))
      }), R.showName && /* @__PURE__ */ ln($k, {
        distanceFactor: 3,
        position: [0, 0, 0.2],
        children: /* @__PURE__ */ ln("div", {
          style: {
            opacity: 0.75,
            borderRadius: 2,
            backgroundColor: "lightgrey",
            padding: 5,
            userSelect: "none"
          },
          children: R.name
        })
      })]
    })
  });
})), LZ = QM(({
  part: a,
  objectKey: e,
  ghost: t,
  highlightColor: r
}) => {
  const i = os(qh((_) => _.items[e].wireframe, [e])), s = os(qh((_) => _.items[e].color, [e])), l = s !== void 0, d = Xs(), p = Xs(), g = os((_) => _.clock);
  return Am(qh(() => {
    const _ = g.getElapsed() * 1e3;
    t || (qM(p, s, _), qM(d, s, _));
  }, [t, d, p, g, s])), t ? /* @__PURE__ */ ln("mesh", {
    ref: p,
    geometry: a.geometry,
    material: _C(r),
    scale: a.scale,
    castShadow: !1,
    receiveShadow: !1
  }, "B") : l ? /* @__PURE__ */ _c("group", {
    up: [0, 0, 1],
    children: [/* @__PURE__ */ ln("mesh", {
      ref: p,
      geometry: a.geometry,
      scale: a.scale,
      castShadow: !1,
      receiveShadow: !1,
      children: /* @__PURE__ */ ln("meshLambertMaterial", {
        transparent: !0,
        wireframe: i,
        attach: "material",
        opacity: 1,
        side: cf
      })
    }, "B"), /* @__PURE__ */ ln("mesh", {
      ref: d,
      geometry: a.geometry,
      scale: a.scale,
      castShadow: !1,
      receiveShadow: !1,
      children: /* @__PURE__ */ ln("meshLambertMaterial", {
        transparent: !0,
        attach: "material",
        wireframe: i,
        opacity: 1,
        side: vy
      })
    }, "F")]
  }) : /* @__PURE__ */ ln(rT, {
    children: /* @__PURE__ */ ln("mesh", {
      ref: d,
      geometry: a.geometry,
      material: a.material,
      scale: a.scale,
      castShadow: !0,
      receiveShadow: !0,
      wireframe: i
    }, "I")
  });
}), P4 = QM(({
  idx: a,
  groupOrPart: e,
  ghost: t,
  objectKey: r,
  highlightColor: i
}) => e.type === "group" ? /* @__PURE__ */ ln("group", {
  up: [0, 0, 1],
  position: e.position,
  rotation: e.rotation,
  scale: e.scale,
  children: e.children.map((s, l) => /* @__PURE__ */ ln(P4, {
    idx: l,
    groupOrPart: s,
    objectKey: r,
    ghost: t,
    highlightColor: i
  }, l))
}, a) : /* @__PURE__ */ ln(LZ, {
  part: e,
  objectKey: r,
  highlightColor: i,
  ghost: t
}, a)), PZ = U0(({
  objectKey: a
}, e) => {
  const t = Xs(null), r = yb(e, t), {
    vertices: i,
    width: s,
    hidden: l
  } = os(qh((d) => ({
    vertices: d.lines[a].vertices,
    width: d.lines[a].width,
    hidden: d.lines[a].hidden
  }), [a]), dh);
  return i.length <= 1 ? null : /* @__PURE__ */ ln(Fj, {
    ref: r,
    visible: !l,
    points: i.map((d) => [d.position.x, d.position.y, d.position.z]),
    color: "white",
    vertexColors: i.map((d) => [d.color.r / 255, d.color.g / 255, d.color.b / 255]),
    lineWidth: s
  });
}), OZ = U0(({
  objectKey: a
}, e) => {
  const t = Xs(null), r = yb(e, t), i = os((D) => D.onClick, dh), s = os((D) => D.onPointerOver, dh), l = os((D) => D.onPointerOut, dh), d = os(qh((D) => D.hulls[a], [a]), dh), p = os(qh((D) => D.hulls[a].vertices, [a]), dh), g = os((D) => D.clock), _ = Xs(), w = Xs(), T = typeof p == "function" ? p(0) : p, R = new Oz(T.map((D) => new ge(D.x, D.y, D.z)));
  return Am(qh(() => {
    const D = g.getElapsed() * 1e3;
    qM(w, d.color, D), qM(_, d.color, D);
    const O = typeof p == "function" ? p(D) : p;
    if (O !== T) {
      const H = new Oz(O.map((I) => new ge(I.x, I.y, I.z)));
      _.current.geometry = H, w.current.geometry = H;
    }
    const U = typeof d.hidden == "function" ? !d.hidden(D) : !d.hidden;
    _.current.visible = U, w.current.visible = U;
  }, [_, w, T, d, g, p])), /* @__PURE__ */ ln(D4, {
    enabled: d.highlighted,
    children: /* @__PURE__ */ _c("group", {
      ref: r,
      up: [0, 0, 1],
      children: [/* @__PURE__ */ _c("group", {
        up: [0, 0, 1],
        onPointerDown: (D) => {
          i(a, _.current.visible, D);
        },
        onPointerOver: (D) => {
          s(a, _.current.visible, D);
        },
        onPointerOut: (D) => {
          l(a, _.current.visible, D);
        },
        children: [/* @__PURE__ */ ln("mesh", {
          ref: w,
          geometry: R,
          castShadow: !1,
          receiveShadow: !1,
          children: /* @__PURE__ */ ln("meshLambertMaterial", {
            transparent: !0,
            wireframe: d.wireframe,
            attach: "material",
            side: cf
          })
        }, `${a}B`), /* @__PURE__ */ ln("mesh", {
          ref: _,
          geometry: R,
          castShadow: !1,
          receiveShadow: !1,
          children: /* @__PURE__ */ ln("meshLambertMaterial", {
            transparent: !0,
            attach: "material",
            wireframe: d.wireframe,
            side: vy
          })
        }, `${a}F`)]
      }), d.showName && /* @__PURE__ */ ln($k, {
        distanceFactor: 2,
        position: [0, 0, 0.5],
        children: /* @__PURE__ */ ln("div", {
          style: {
            opacity: 0.75,
            borderRadius: 2,
            backgroundColor: "lightgrey"
          },
          className: "disable-text-selection",
          children: d.name
        })
      })]
    })
  });
}), UZ = U0(({
  objectKey: a
}, e) => {
  const t = Xs(null), r = yb(e, t), i = Xs(), s = os((d) => d.clock), l = os(qh((d) => d.texts[a], [a]));
  return Am(qh(() => {
    const d = s.getElapsed() * 1e3;
    r.current && (r.current.position.set(typeof l.position.x == "function" ? l.position.x(d) : l.position.x, typeof l.position.y == "function" ? l.position.y(d) : l.position.y, typeof l.position.z == "function" ? l.position.z(d) : l.position.z), r.current.visible = typeof l.hidden == "function" ? !l.hidden(d) : !l.hidden), i.current && qM(i, l.color, d);
  }, [l, r, s])), /* @__PURE__ */ ln("group", {
    ref: r,
    children: /* @__PURE__ */ ln(Nj, {
      follow: !0,
      children: /* @__PURE__ */ ln(LY, {
        ref: i,
        depthOffset: 2,
        scale: [0.2, 0.2, 0.2],
        children: l.value
      })
    })
  });
}), zZ = U0(({
  objectKey: a
}, e) => {
  const t = Xs(null), r = yb(e, t), i = os((_) => _.clock), {
    points: s,
    scale: l,
    hidden: d
  } = os(qh((_) => ({
    points: _.points[a].points,
    scale: _.points[a].scale,
    hidden: _.points[a].hidden
  }), [a]), dh), [{
    positions: p,
    colors: g
  }] = O_(() => ({
    positions: new Float32Array(s.length * 3),
    colors: new Float32Array(s.length * 3)
  }));
  return Am(() => {
    const _ = i.getElapsed() * 1e3;
    if (r.current)
      for (let w = 0; w < s.length; w++) {
        let T = w * 3;
        p[T] = typeof s[w].position.x == "function" ? s[w].position.x(_) : s[w].position.x, p[T + 1] = typeof s[w].position.y == "function" ? s[w].position.y(_) : s[w].position.y, p[T + 2] = typeof s[w].position.z == "function" ? s[w].position.z(_) : s[w].position.z, g[T] = typeof s[w].color.r == "function" ? s[w].color.r(_) / 255 : s[w].color.r / 255, g[T + 1] = typeof s[w].color.g == "function" ? s[w].color.g(_) / 255 : s[w].color.g / 255, g[T + 2] = typeof s[w].color.b == "function" ? s[w].color.b(_) / 255 : s[w].color.b / 255;
      }
  }), s.length <= 1 ? null : /* @__PURE__ */ ln(pX, {
    ref: r,
    hidden: d,
    positions: p,
    colors: g,
    children: /* @__PURE__ */ ln(lX, {
      transparent: !0,
      vertexColors: !0,
      sizeAttenuation: !0,
      depthWrite: !0,
      size: l * 0.1
    })
  });
}), VL = QM(({
  activeTf: a,
  displayTfs: e,
  allTfs: t,
  allItems: r,
  allLines: i,
  allHulls: s,
  allTexts: l,
  allPoints: d,
  highlightColor: p,
  ghosts: g,
  targetRef: _,
  targetId: w,
  targetSource: T,
  filterActive: R,
  tfFilter: D,
  customProps: O
}) => {
  const U = a === "world" ? mq : a === "gizmo" ? vq : pq, H = a === w ? O : {}, I = R ? t.filter((B) => D.includes(B.key)) : t, G = R && a !== _;
  return /* @__PURE__ */ _c(U, {
    objectKey: a,
    displayTfs: e,
    ref: w === a ? _ : null,
    ...H,
    ghost: g,
    highlightColor: p,
    children: [I.filter((B) => B.frame === a || a === "world" && !B.frame).map((B) => /* @__PURE__ */ ln(VL, {
      activeTf: B.key,
      displayTfs: e,
      allTfs: t,
      allItems: r,
      allLines: i,
      allHulls: s,
      allTexts: l,
      allPoints: d,
      highlightColor: p,
      ghosts: g,
      targetRef: _,
      targetSource: T,
      targetId: w,
      filterActive: G,
      tfFilter: D,
      customProps: O
    }, B.key)), r.filter((B) => B.frame === a || a === "world" && !B.frame).map((B) => {
      const Q = B.key === w && T === "items" ? O : {};
      return !R || B.key === w || a === w ? /* @__PURE__ */ ln(DZ, {
        objectKey: B.key,
        highlightColor: p,
        ghost: g,
        ref: B.key === w ? _ : null,
        ...Q
      }, B.key) : null;
    }), i.filter((B) => B.frame === a || a === "world" && !B.frame).map((B) => {
      const Q = B.key === w && T === "lines" ? O : {};
      return !R || B.key === w || a === w ? /* @__PURE__ */ ln(PZ, {
        objectKey: B.key,
        ref: B.lineKey === w ? _ : null,
        ...Q
      }, B.key) : null;
    }), s.filter((B) => B.frame === a || a === "world" && !B.frame).map((B) => {
      const Q = B.key === w && T === "hulls" ? O : {};
      return !R || B.key === w || a === w ? /* @__PURE__ */ ln(OZ, {
        objectKey: B.key,
        highlightColor: p,
        ghost: g,
        ref: B.key === w ? _ : null,
        ...Q
      }, B.key) : null;
    }), l.filter((B) => B.frame === a || a === "world" && !B.frame).map((B) => {
      const Q = B.key === w && T === "texts" ? O : {};
      return !R || B.key === w || a === w ? /* @__PURE__ */ ln(UZ, {
        objectKey: B.key,
        highlightColor: p,
        ref: B.key === w ? _ : null,
        ...Q
      }, B.key) : null;
    }), d.filter((B) => B.frame === a || a === "world" && !B.frame).map((B) => {
      const Q = B.key === w && T === "points" ? O : {};
      return !R || B.key === w || a === w ? /* @__PURE__ */ ln(zZ, {
        objectKey: B.key,
        highlightColor: p,
        ref: B.key === w ? _ : null,
        ...Q
      }, B.key) : null;
    })]
  });
}), NZ = ["enabled", "axis", "translationSnap", "rotationSnap", "scaleSnap", "space", "size"], FZ = ["displayTfs", "allTfs", "allItems", "allLines", "allHulls", "allTexts", "allPoints", "highlightColor"], kZ = QM(({
  camera: a,
  objectInfo: e,
  highlightColor: t,
  translateSnap: r,
  rotateSnap: i,
  scaleSnap: s,
  onDragStart: l,
  onDragEnd: d,
  mode: p,
  ...g
}) => {
  const _ = CD(g, NZ), w = CD(g, FZ), T = os(qh((ue) => {
    let Me = [];
    e.source === "tfs" && Me.push(e.key);
    let me = ue[e.source][e.key].frame;
    for (; me && me !== "world" && me !== "gizmo"; ) {
      let De = ue.tfs[me];
      Me.push(me), me = De.frame;
    }
    return Me;
  }, [e]), dh), R = Xs(), D = Xs(), O = os((ue) => CD(ue[e.source][e.key], ["position", "rotation", "scale"]), dh), U = jf(({
    gl: ue
  }) => ue), H = jf(({
    camera: ue
  }) => ue), I = jf(({
    invalidate: ue
  }) => ue), G = a || H, [B] = O_(() => new ZX(G, U.domElement));
  B.translationSnap = r, B.rotationSnap = i, B.scaleSnap = s, p != null && p.includes("translate") ? B.mode = "translate" : p != null && p.includes("rotate") ? B.mode = "rotate" : p != null && p.includes("scale") && (B.mode = "scale"), p != null && p.includes("-x") ? (B.showY = !1, B.showZ = !1) : p != null && p.includes("-y") ? (B.showX = !1, B.showZ = !1) : p != null && p.includes("-z") && (B.showX = !1, B.showY = !1);
  const [Q, K] = O_(!1), [te, Y] = O_(O), [re, se] = O_(!1);
  hh(() => {
    console.log("refreshing transform"), Y(O);
  }, [O, re]);
  const ce = os((ue) => ue.onMove, dh);
  return hh(() => {
    const ue = (Me) => {
      var He, ve, fe;
      const me = (He = D == null ? void 0 : D.current) == null ? void 0 : He.position, De = (ve = D == null ? void 0 : D.current) == null ? void 0 : ve.quaternion, Re = (fe = D == null ? void 0 : D.current) == null ? void 0 : fe.scale;
      Me.value && !Q ? (console.log("starting transform"), K(!0), Y({
        position: me,
        rotation: De,
        scale: Re
      }), l && l()) : !Me.value && Q && (console.log("stopping transform"), K(!1), d && d(), ce(e.key, e.source, {
        position: B.worldPosition,
        quaternion: B.worldQuaternion,
        scale: B._worldScale
      }, {
        position: me ? {
          x: me.x,
          y: me.y,
          z: me.z
        } : null,
        quaternion: De ? {
          x: De.x,
          y: De.y,
          z: De.z,
          w: De.w
        } : null,
        scale: Re ? {
          x: Re.x,
          y: Re.y,
          z: Re.z
        } : null
      }), se(!re));
    };
    return B && B.addEventListener("dragging-changed", ue), () => {
      B.removeEventListener("dragging-changed", ue);
    };
  }, [O, Q, e]), hh(() => void (B == null ? void 0 : B.attach(D.current)), [D, B]), hh(() => (B && B.addEventListener("change", I), () => {
    var ue;
    return (ue = B == null ? void 0 : B.removeEventListener) == null ? void 0 : ue.call(B, "change", I);
  }), [B, I]), B ? /* @__PURE__ */ _c(rT, {
    children: [/* @__PURE__ */ ln("primitive", {
      ref: R,
      object: B,
      ..._
    }), /* @__PURE__ */ ln(VL, {
      ...w,
      activeTf: "world",
      tfFilter: T,
      ghosts: !0,
      targetRef: D,
      targetSource: e.source,
      targetId: e.key,
      filterActive: !0,
      customProps: {
        ...te
      }
    })]
  }) : null;
}), M_ = (a, e) => a.length !== e.length ? !1 : !a.some((t, r) => !Sv.exports.isEqual(e[r], t));
function IZ({
  displayTfs: a = !1,
  displayGrid: e = !0,
  isPolar: t = !1,
  backgroundColor: r = "#d0d0d0",
  planeColor: i = "#a8a8a8",
  highlightColor: s = "#00ffff",
  plane: l = 0,
  translateSnap: d = 0,
  rotateSnap: p = 0,
  scaleSnap: g = 0,
  debug: _ = !1
}) {
  _ && console.log("content rerender");
  const w = jf((ce) => ce.camera), T = os((ce) => ce.clock, dh);
  Am(() => {
    T.update();
  });
  const R = os((ce) => Sv.exports.sortBy(Object.entries(ce.tfs).map(([ue, Me]) => ({
    key: ue,
    frame: Me.frame,
    transformMode: Me.transformMode,
    source: "tfs"
  })), (ue) => ue.key), M_), D = os((ce) => Sv.exports.sortBy(Object.entries(ce.items).map(([ue, Me]) => ({
    key: ue,
    frame: Me.frame,
    transformMode: Me.transformMode,
    source: "items"
  })), (ue) => ue.key), M_), O = os((ce) => Sv.exports.sortBy(Object.entries(ce.lines).map(([ue, Me]) => ({
    key: ue,
    frame: Me.frame,
    source: "lines"
  })), (ue) => ue.key), M_), U = os((ce) => Sv.exports.sortBy(Object.entries(ce.hulls).map(([ue, Me]) => ({
    key: ue,
    frame: Me.frame,
    source: "hulls"
  })), (ue) => ue.key), M_), H = os((ce) => Sv.exports.sortBy(Object.entries(ce.texts).map(([ue, Me]) => ({
    key: ue,
    frame: Me.frame,
    source: "texts"
  })), (ue) => ue.key), M_), I = os((ce) => Sv.exports.sortBy(Object.entries(ce.points).map(([ue, Me]) => ({
    key: ue,
    frame: Me.frame,
    source: "points"
  })), (ue) => ue.key), M_), G = os((ce) => Sv.exports.sortBy(Object.entries(ce.widgets).map(([ue, Me]) => ({
    key: ue,
    frame: Me.frame,
    source: "widgets"
  })), (ue) => ue.key), M_), B = [...D, ...R].filter((ce) => ["translate", "rotate", "scale", "translate-x", "translate-y", "translate-z", "rotate-x", "rotate-y", "rotate-z", "scale-x", "scale-y", "scale-z"].includes(ce.transformMode)), Q = Xs(), K = Xs(), te = Xs(), Y = Xs(), re = QX(i), se = [re.r, re.g, re.b, 0.5];
  return /* @__PURE__ */ _c(ph.Fragment, {
    children: [/* @__PURE__ */ ln(sX, {
      ref: Y,
      makeDefault: !0,
      camera: w
    }), /* @__PURE__ */ ln("pointLight", {
      ref: K,
      intensity: 0.5,
      position: [-1, -3, 3],
      color: "#FFFAEE"
    }), /* @__PURE__ */ ln(XX, {
      ref: Q,
      intensity: 0.7,
      color: "white"
    }), /* @__PURE__ */ ln(qX, {
      ref: te,
      castShadow: !0,
      position: [5, 15, 15],
      intensity: 0.6,
      color: "#FFFAEE"
    }), /* @__PURE__ */ ln("spotLight", {
      penumbra: 1,
      position: [-1, -1, 4],
      intensity: 0.3,
      castShadow: !0,
      color: "#FFFAEE"
    }), /* @__PURE__ */ ln("color", {
      attach: "background",
      args: [r]
    }), /* @__PURE__ */ ln("fogExp2", {
      attach: "fog",
      args: [r, 0.01]
    }), /* @__PURE__ */ ln(cX, {
      receiveShadow: !0,
      scale: 1e3,
      position: [0, 0, l - 0.01],
      material: my(...se)
    }), /* @__PURE__ */ _c(MZ, {
      children: [/* @__PURE__ */ ln(EZ, {
        autoClear: !1,
        children: /* @__PURE__ */ ln(TZ, {
          visibleEdgeColor: s,
          hiddenEdgeColor: s,
          blur: !0,
          kernelSize: 1,
          edgeStrength: 50,
          pulseSpeed: 0.25,
          xRay: !0
        })
      }), /* @__PURE__ */ ln(VL, {
        activeTf: "world",
        displayTfs: a,
        allTfs: R,
        allItems: D,
        allLines: O,
        allHulls: U,
        allTexts: H,
        allPoints: I,
        allWidgets: G,
        highlightColor: s
      })]
    }), /* @__PURE__ */ ln("group", {
      position: [0, 0, l],
      rotation: [Math.PI / 2, 0, 0],
      up: [0, 0, 1],
      children: e && (t ? /* @__PURE__ */ ln("polarGridHelper", {
        args: [10, 16, 8, 64, "white", "gray"]
      }) : /* @__PURE__ */ ln("gridHelper", {
        args: [20, 20, "white", "gray"]
      }))
    }), B.map((ce) => /* @__PURE__ */ ln(kZ, {
      objectInfo: ce,
      mode: ce.transformMode,
      displayTfs: a,
      allTfs: R,
      allItems: D,
      allLines: O,
      allHulls: U,
      allTexts: H,
      allPoints: I,
      allWidgets: G,
      translateSnap: d,
      rotateSnap: p,
      scaleSnap: g,
      highlightColor: s,
      onDragEnd: () => {
        Y.current && (Y.current.enabled = !0);
      },
      onDragStart: () => {
        Y.current && (Y.current.enabled = !1);
      }
    }, `movableObjectTransform-${ce.key}`))]
  });
}
Xa.DefaultUp.set(0, 0, 1);
const VZ = ({
  onPointerMissed: a = () => {
  },
  backgroundColor: e = "#d0d0d0",
  fov: t = 60,
  children: r
}) => /* @__PURE__ */ ln(Qk, {
  camera: {
    up: [0, 0, 1],
    fov: t,
    position: [0, -3, 3]
  },
  shadows: !0,
  style: {
    background: e
  },
  onPointerMissed: a,
  children: r
});
function GZ({
  backgroundColor: a = "#d0d0d0",
  store: e,
  fov: t = 60,
  onPointerMissed: r = () => {
  },
  meshLookup: i = {},
  debug: s = !1,
  ...l
}) {
  return s && console.log("Scene rerender"), /* @__PURE__ */ ln(Qk, {
    camera: {
      up: [0, 0, 1],
      fov: t,
      position: [0, -3, 3]
    },
    shadows: !0,
    style: {
      background: a || "#d0d0d0"
    },
    onPointerMissed: r || (() => {
    }),
    children: /* @__PURE__ */ ln(YX, {
      store: e,
      debug: s,
      children: /* @__PURE__ */ ln(AZ, {
        meshes: i,
        children: /* @__PURE__ */ ln(P5, {
          children: /* @__PURE__ */ ln(IZ, {
            ...l,
            backgroundColor: a,
            debug: s
          })
        })
      })
    })
  });
}
export {
  IZ as Content,
  WX as ImmerSceneSlice,
  AZ as MeshProvider,
  VZ as RobotCanvas,
  GZ as Scene,
  YX as SceneProvider,
  GX as SceneSlice,
  BX as Timer,
  os as innerUseSceneStore,
  jX as useSceneStore
};
